update article_info_true set article_content = REPLACE(article_content,'ok9ci9ckr.bkt.clouddn.com','localhost:8033/neuedublog/images') where article_content like '%ok9ci9ckr.bkt.clouddn.com%'
MySQL max_allowed_packet设置及问题
可以通过csv文件导入导出的方式进行备份还原
/*
Navicat MySQL Data Transfer

Source Server         : byl
Source Server Version : 50538
Source Host           : localhost:3306
Source Database       : neusoft_system

Target Server Type    : MYSQL
Target Server Version : 50538
File Encoding         : 65001

Date: 2017-01-25 14:49:11
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article_info
-- ----------------------------
DROP TABLE IF EXISTS `article_info`;
CREATE TABLE `article_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `text` varchar(30) NOT NULL DEFAULT '',
  `article_content` text,
  `parent` varchar(30) NOT NULL DEFAULT '0',
  `tagid` int(11) unsigned zerofill NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=128 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_info
-- ----------------------------
INSERT INTO `article_info` VALUES ('10', 'python', '1', '#', '00000000004');
INSERT INTO `article_info` VALUES ('12', 'python简介', '2', '10', '00000000004');
INSERT INTO `article_info` VALUES ('13', 'python解释器', '3', '12', '00000000004');
INSERT INTO `article_info` VALUES ('14', 'Python框架', '3', '12', '00000000004');
INSERT INTO `article_info` VALUES ('15', '安装python', '2', '10', '00000000004');
INSERT INTO `article_info` VALUES ('16', 'linux安装', '3', '15', '00000000004');
INSERT INTO `article_info` VALUES ('17', 'python基础', '2', '10', '00000000004');
INSERT INTO `article_info` VALUES ('18', 'python_markdown', '2', '10', '00000000004');
INSERT INTO `article_info` VALUES ('19', 'php', '0', '#', '00000000007');
INSERT INTO `article_info` VALUES ('21', 'php简介', '2', '19', '00000000007');
INSERT INTO `article_info` VALUES ('22', 'php安装', '2', '19', '00000000007');
INSERT INTO `article_info` VALUES ('23', 'c', '0', '#', '00000000008');
INSERT INTO `article_info` VALUES ('24', 'c语言简介', '2', '23', '00000000008');
INSERT INTO `article_info` VALUES ('25', 'oracle', '0', '#', '00000000009');
INSERT INTO `article_info` VALUES ('26', 'oracle hello', '2', '25', '00000000009');
INSERT INTO `article_info` VALUES ('27', 'oracle anzhuang', '3', '26', '00000000009');
INSERT INTO `article_info` VALUES ('28', 'java基础', '0', '#', '00000000010');
INSERT INTO `article_info` VALUES ('29', 'java基础语法', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('30', 'java高级', '0', '#', '00000000011');
INSERT INTO `article_info` VALUES ('32', '文件，目录操作', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('33', '字节流', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('34', '字符流', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('35', '序列流', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('36', '对象的序列化', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('37', '打印流', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('38', '编码和解码', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('39', '转换流', '3', '46', '00000000011');
INSERT INTO `article_info` VALUES ('40', '集合类', '2', '30', '00000000011');
INSERT INTO `article_info` VALUES ('41', '概述', '3', '40', '00000000011');
INSERT INTO `article_info` VALUES ('42', '单列集合', '3', '40', '00000000011');
INSERT INTO `article_info` VALUES ('43', '双列集合', '3', '40', '00000000011');
INSERT INTO `article_info` VALUES ('44', 'COLLECTIONS和ARRAYS常用方法', '3', '40', '00000000011');
INSERT INTO `article_info` VALUES ('46', '文件操作', '2', '30', '00000000011');
INSERT INTO `article_info` VALUES ('47', '变量和数据类型', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('48', '运算操作符', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('49', '字符串', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('50', '流程控制', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('51', '输入输出', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('52', '类和对象', '3', '61', '00000000010');
INSERT INTO `article_info` VALUES ('53', '变量、方法以及静态和非静态', '3', '61', '00000000010');
INSERT INTO `article_info` VALUES ('54', '封装', '3', '61', '00000000010');
INSERT INTO `article_info` VALUES ('55', '神奇的MAIN方法详解', '3', '61', '00000000010');
INSERT INTO `article_info` VALUES ('59', 'Java开发环境搭建', '2', '28', '00000000010');
INSERT INTO `article_info` VALUES ('60', '初识java编程', '2', '28', '00000000010');
INSERT INTO `article_info` VALUES ('61', '面向对象', '2', '28', '00000000010');
INSERT INTO `article_info` VALUES ('62', 'javascript', '0', '#', '00000000012');
INSERT INTO `article_info` VALUES ('63', '初识javascript', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('66', 'js数据类型和运算符', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('67', 'js分支选择结构', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('68', 'js循环结构', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('69', 'js函数', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('70', 'js数组', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('71', '数组', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('72', 'eclipse工具使用', '0', '#', '00000000013');
INSERT INTO `article_info` VALUES ('73', '基本设置', '2', '72', '00000000013');
INSERT INTO `article_info` VALUES ('74', 'html/css', '0', '#', '00000000014');
INSERT INTO `article_info` VALUES ('75', '数据库', '0', '#', '00000000015');
INSERT INTO `article_info` VALUES ('76', 'jquery', '0', '#', '00000000016');
INSERT INTO `article_info` VALUES ('77', 'servlet/jsp', '0', '#', '00000000017');
INSERT INTO `article_info` VALUES ('78', 'spring', '0', '#', '00000000018');
INSERT INTO `article_info` VALUES ('79', 'springmvc', '0', '#', '00000000019');
INSERT INTO `article_info` VALUES ('80', 'mybatis简介', '0', '#', '00000000020');
INSERT INTO `article_info` VALUES ('81', 'js字符串操作和数学函数', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('82', 'js BOM操作', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('83', 'js DOM操作', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('84', 'js事件', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('85', 'js事件对象', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('86', 'js日期和时间', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('87', 'js正则表达式', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('88', 'js面向对象', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('89', 'js原型', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('90', 'ES2015新特性', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('91', 'ES2015新特性2', '2', '62', '00000000012');
INSERT INTO `article_info` VALUES ('92', '初识JQuery', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('93', 'JQuery选择器', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('94', 'JQuery dom操作', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('95', 'JQuery事件', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('96', 'JQuery动画', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('97', 'JQuery表单操作', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('99', 'JQuery表格操作', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('100', '综合案列', '2', '76', '00000000016');
INSERT INTO `article_info` VALUES ('101', 'mybatis基本增删改查', '2', '80', '00000000020');
INSERT INTO `article_info` VALUES ('102', 'mybatis开发dao层', '2', '80', '00000000020');
INSERT INTO `article_info` VALUES ('103', 'mybatis查询结果映射', '2', '80', '00000000020');
INSERT INTO `article_info` VALUES ('104', 'mybatis高级主题', '2', '80', '00000000020');
INSERT INTO `article_info` VALUES ('105', 'springmvc框架原理', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('106', '非注解的处理器映射器和适配器', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('107', '注解的处理器映射器和适配器', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('108', 'springmvc前端控制器', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('109', 'springmvc小结', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('110', 'springmvc整合mybatis', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('111', 'springmvc整合mybatis之mapper', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('112', 'springmvc整合mybatis之service', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('113', 'springmvc整合mybatis之controller', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('114', 'springmvc注解开发之商品修改功能', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('115', 'springmvc注解开发之简单参数绑定', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('116', 'springmvc注解开发之包装类型参数绑定', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('117', 'springmvc注解开发之集合类型参数绑定', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('118', '搭建Java开发环境(一)', '3', '59', '00000000010');
INSERT INTO `article_info` VALUES ('119', '搭建Java开发环境(二)', '3', '59', '00000000010');
INSERT INTO `article_info` VALUES ('121', '方法', '3', '60', '00000000010');
INSERT INTO `article_info` VALUES ('122', 'springmvc数据回显', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('123', 'springmvc图片上传', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('124', 'springmvc json数据交互', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('125', 'springmvc restful支持', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('126', 'springmvc拦截器', '2', '79', '00000000019');
INSERT INTO `article_info` VALUES ('127', '框架基础', '2', '78', '00000000018');

-- ----------------------------
-- Table structure for article_info_true
-- ----------------------------
DROP TABLE IF EXISTS `article_info_true`;
CREATE TABLE `article_info_true` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_title` varchar(30) NOT NULL DEFAULT '',
  `article_content` text,
  `nodeid` int(11) NOT NULL DEFAULT '0',
  `mark_content` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=107 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article_info_true
-- ----------------------------
INSERT INTO `article_info_true` VALUES ('1', 'python基础', '<h1 id=\"h1-u6B22u8FCEu4F7Fu7528u9A6Cu514Bu98DEu8C61\"><a name=\"欢迎使用马克飞象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>\r\n<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>\r\n<ul>\r\n<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li><li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href=\"http://maxiang.info/client_zh\">桌面客户端</a>以及<a href=\"https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop\">离线Chrome App</a>，支持移动端 Web；</li><li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li></ul>\r\n<hr>\r\n<div class=\"markdown-toc editormd-markdown-toc\">[TOC]</div><h2 id=\"h2-markdown-\"><a name=\"Markdown简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Markdown简介</h2><blockquote>\r\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\">维基百科</a></p>\r\n</blockquote>\r\n<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href=\"http://www.example.com\">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p>\r\n<h3 id=\"h3-u4EE3u7801u5757\"><a name=\"代码块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码块</h3><pre><code>    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\r\n    {\r\n        String strID = request.getParameter(&quot;id&quot;);\r\n        ArticleDao ad  = new ArticleDao();\r\n        Tab_article_info tai = ad.GetArticleInfobyID(Integer.parseInt(strID));\r\n        response.getWriter().println(tai.getContent());\r\n    }\r\n</code></pre><pre><code class=\"lang-python\">@requires_authorization\r\ndef somefunc(param1=&#39;&#39;, param2=0):\r\n    &#39;&#39;&#39;A docstring&#39;&#39;&#39;\r\n    if param1 &gt; param2: # interesting\r\n        print &#39;Greater&#39;\r\n    return (param2 - param1 + 1) or None\r\nclass SomeClass:\r\n    pass\r\n&gt;&gt;&gt; message = &#39;&#39;&#39;interpreter\r\n... prompt&#39;&#39;&#39;\r\n</code></pre>\r\n<h3 id=\"h3-latex-\"><a name=\"LaTeX 公式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>LaTeX 公式</h3><p>可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式：</p>\r\n<p class=\"editormd-tex\">    x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} </p>\r\n<h3 id=\"h3-u8868u683C\"><a name=\"表格\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>表格</h3><table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:left\">Item</th>\r\n<th style=\"text-align:right\">Value</th>\r\n<th style=\"text-align:center\">Qty</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:left\">Computer</td>\r\n<td style=\"text-align:right\">1600 USD</td>\r\n<td style=\"text-align:center\">5</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">Phone</td>\r\n<td style=\"text-align:right\">12 USD</td>\r\n<td style=\"text-align:center\">12</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">Pipe</td>\r\n<td style=\"text-align:right\">1 USD</td>\r\n<td style=\"text-align:center\">234</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"h3-u6D41u7A0Bu56FE\"><a name=\"流程图\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>流程图</h3><div class=\"flowchart\">st=>start: Start\r\ne=>end\r\nop=>operation: My Operation\r\ncond=>condition: Yes or No?\r\n\r\nst->op->cond\r\ncond(yes)->e\r\ncond(no)->op</div><p>以及时序图:</p>\r\n<div class=\"sequence-diagram\">Alice->Bob: Hello Bob, how are you?\r\nNote right of Bob: Bob thinks\r\nBob-->Alice: I am good thanks!</div><blockquote>\r\n<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href=\"http://adrai.github.io/flowchart.js/\">语法</a>以及<strong>时序图</strong><a href=\"http://bramp.github.io/js-sequence-diagrams/\">语法</a>。</p>\r\n</blockquote>\r\n<h3 id=\"h3-u590Du9009u6846\"><a name=\"复选框\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>\r\n<ul>\r\n<li style=\"list-style: none;\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" checked disabled /> 已完成事项</li><li style=\"list-style: none;\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" /> 待办事项1</li><li style=\"list-style: none;\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" /> 待办事项2</li></ul>\r\n<blockquote>\r\n<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>\r\n</blockquote>\r\n<h2 id=\"h2-u5370u8C61u7B14u8BB0u76F8u5173\"><a name=\"印象笔记相关\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>印象笔记相关</h2><h3 id=\"h3-u7B14u8BB0u672Cu548Cu6807u7B7E\"><a name=\"笔记本和标签\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>\r\n<h3 id=\"h3-u7B14u8BB0u6807u9898\"><a name=\"笔记标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>\r\n<h3 id=\"h3-u5FEBu6377u7F16u8F91\"><a name=\"快捷编辑\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>\r\n<blockquote>\r\n<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>\r\n</blockquote>\r\n<h3 id=\"h3-u6570u636Eu540Cu6B65\"><a name=\"数据同步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>\r\n<blockquote>\r\n<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>\r\n</blockquote>\r\n<h3 id=\"h3-u79BBu7EBFu5B58u50A8\"><a name=\"离线存储\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>\r\n<blockquote>\r\n<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>\r\n</blockquote>\r\n<h2 id=\"h2-u7F16u8F91u5668u76F8u5173\"><a name=\"编辑器相关\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>编辑器相关</h2><h3 id=\"h3-u8BBEu7F6E\"><a name=\"设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>\r\n<h3 id=\"h3-u5FEBu6377u952E\"><a name=\"快捷键\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code> </p>\r\n<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>\r\n<h2 id=\"h2-u5173u4E8Eu6536u8D39\"><a name=\"关于收费\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href=\"maxiang.info/vip.html\">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>\r\n<h2 id=\"h2-u53CDu9988u4E0Eu5EFAu8BAE\"><a name=\"反馈与建议\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>反馈与建议</h2><ul>\r\n<li>微博：<a href=\"http://weibo.com/u/2788354117\">@马克飞象</a>，<a href=\"http://weibo.com/ggock\" title=\"开发者个人账号\">&#64;GGock</a></li><li>邮箱：<a href=\"&#x6d;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#x68;&#x75;&#x73;&#116;&#x67;&#111;&#x63;&#x6b;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;\">&#x68;&#x75;&#x73;&#116;&#x67;&#111;&#x63;&#x6b;&#x40;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a></li></ul>\r\n<hr>\r\n<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>\r\n<p>[^demo]: 这是一个示例脚注。请查阅 <a href=\"https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes\">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href=\"https://dev.yinxiang.com/doc/articles/enml.php\">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>\r\n', '17', '# 欢迎使用马克飞象\r\n\r\n@(示例笔记本)[马克飞象|帮助|Markdown]\r\n\r\n**马克飞象**是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：\r\n \r\n- **功能丰富** ：支持高亮代码块、*LaTeX* 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；\r\n- **得心应手** ：简洁高效的编辑器，提供[桌面客户端][1]以及[离线Chrome App][2]，支持移动端 Web；\r\n- **深度整合** ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。\r\n\r\n-------------------\r\n\r\n[TOC]\r\n\r\n## Markdown简介\r\n\r\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— [维基百科](https://zh.wikipedia.org/wiki/Markdown)\r\n\r\n正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.example.com)或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按`Ctrl + /`查看帮助。 \r\n\r\n### 代码块\r\n```\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\r\n    {\r\n        String strID = request.getParameter(\"id\");\r\n        ArticleDao ad  = new ArticleDao();\r\n        Tab_article_info tai = ad.GetArticleInfobyID(Integer.parseInt(strID));\r\n        response.getWriter().println(tai.getContent());\r\n    }\r\n```\r\n    \r\n``` python\r\n@requires_authorization\r\ndef somefunc(param1=\'\', param2=0):\r\n    \'\'\'A docstring\'\'\'\r\n    if param1 > param2: # interesting\r\n        print \'Greater\'\r\n    return (param2 - param1 + 1) or None\r\nclass SomeClass:\r\n    pass\r\n>>> message = \'\'\'interpreter\r\n... prompt\'\'\'\r\n```\r\n### LaTeX 公式\r\n\r\n可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式：\r\n\r\n$$	x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\r\n\r\n### 表格\r\n| Item      |    Value | Qty  |\r\n| :-------- | --------:| :--: |\r\n| Computer  | 1600 USD |  5   |\r\n| Phone     |   12 USD |  12  |\r\n| Pipe      |    1 USD | 234  |\r\n\r\n### 流程图\r\n```flow\r\nst=>start: Start\r\ne=>end\r\nop=>operation: My Operation\r\ncond=>condition: Yes or No?\r\n\r\nst->op->cond\r\ncond(yes)->e\r\ncond(no)->op\r\n```\r\n\r\n以及时序图:\r\n\r\n```sequence\r\nAlice->Bob: Hello Bob, how are you?\r\nNote right of Bob: Bob thinks\r\nBob-->Alice: I am good thanks!\r\n```\r\n\r\n> **提示：**想了解更多，请查看**流程图**[语法][3]以及**时序图**[语法][4]。\r\n\r\n### 复选框\r\n\r\n使用 `- [ ]` 和 `- [x]` 语法可以创建复选框，实现 todo-list 等功能。例如：\r\n\r\n- [x] 已完成事项\r\n- [ ] 待办事项1\r\n- [ ] 待办事项2\r\n\r\n> **注意：**目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在**马克飞象**中修改 Markdown 原文才可生效。下个版本将会全面支持。\r\n\r\n\r\n## 印象笔记相关\r\n\r\n### 笔记本和标签\r\n**马克飞象**增加了`@(笔记本)[标签A|标签B]`语法, 以选择笔记本和添加标签。 **绑定账号后**， 输入`(`自动会出现笔记本列表，请从中选择。\r\n\r\n### 笔记标题\r\n**马克飞象**会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 `欢迎使用马克飞象`。\r\n\r\n### 快捷编辑\r\n保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到**马克飞象**中打开并编辑该笔记。\r\n>**注意：**目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。\r\n\r\n### 数据同步\r\n**马克飞象**通过**将Markdown原文以隐藏内容保存在笔记中**的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。\r\n\r\n >**隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。**\r\n\r\n### 离线存储\r\n**马克飞象**使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过`文档管理`打开。\r\n\r\n> **注意：**虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，**请务必经常及时同步到印象笔记**。\r\n\r\n## 编辑器相关\r\n### 设置\r\n右侧系统菜单（快捷键`Ctrl + M`）的`设置`中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。\r\n\r\n### 快捷键\r\n\r\n帮助    `Ctrl + /`\r\n同步文档    `Ctrl + S`\r\n创建文档    `Ctrl + Alt + N`\r\n最大化编辑器    `Ctrl + Enter`\r\n预览文档 `Ctrl + Alt + Enter`\r\n文档管理    `Ctrl + O`\r\n系统菜单    `Ctrl + M` \r\n\r\n加粗    `Ctrl + B`\r\n插入图片    `Ctrl + G`\r\n插入链接    `Ctrl + L`\r\n提升标题    `Ctrl + H`\r\n\r\n## 关于收费\r\n\r\n**马克飞象**为新用户提供 10 天的试用期，试用期过后需要[续费](maxiang.info/vip.html)才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。\r\n\r\n\r\n## 反馈与建议\r\n- 微博：[@马克飞象](http://weibo.com/u/2788354117)，[@GGock](http://weibo.com/ggock \"开发者个人账号\")\r\n- 邮箱：<hustgock@gmail.com>\r\n\r\n---------\r\n感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。\r\n\r\n\r\n\r\n\r\n[^demo]: 这是一个示例脚注。请查阅 [MultiMarkdown 文档](https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes) 关于脚注的说明。 **限制：** 印象笔记的笔记内容使用 [ENML][5] 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致`脚注`和`TOC`无法正常点击。\r\n\r\n\r\n  [1]: http://maxiang.info/client_zh\r\n  [2]: https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop\r\n  [3]: http://adrai.github.io/flowchart.js/\r\n  [4]: http://bramp.github.io/js-sequence-diagrams/\r\n  [5]: https://dev.yinxiang.com/doc/articles/enml.php\r\n\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('2', '安装python', '### 范德萨范德萨888999烦烦烦发生的\r\n发的啥地方士大夫\r\n范德萨范德萨', '15', '### 5555');
INSERT INTO `article_info_true` VALUES ('3', '', '### 范德萨范德萨888999烦烦烦发生的\r\n发的啥地方士大夫\r\n范德萨范德萨', '12', '### 哦哦');
INSERT INTO `article_info_true` VALUES ('4', 'Python框架', '<h3 id=\"h3-u9632u8F90u5C04u670Du89D2u5EA6u770B\"><a name=\"防辐射服角度看\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>防辐射服角度看</h3>', '14', '### 防辐射服角度看');
INSERT INTO `article_info_true` VALUES ('5', 'linux安装', '<h3 id=\"h3--\"><a name=\"放假；可是大家看；\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>放假；可是大家看；</h3>', '16', '### 放假；可是大家看； ');
INSERT INTO `article_info_true` VALUES ('6', 'python', '<h3 id=\"h3-u7684u65B9u5F0Fu5730u65B9\"><a name=\"的方式地方\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>的方式地方</h3><p>发生地方都是</p>\r\n', '10', '### 的方式地方\r\n\r\n发生地方都是');
INSERT INTO `article_info_true` VALUES ('7', 'python_markdown', '<h3 id=\"h3-goodmarkdown\"><a name=\"goodmarkdown\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>goodmarkdown</h3>', '18', '### goodmarkdown');
INSERT INTO `article_info_true` VALUES ('8', 'python解释器', '<h3 id=\"h3-python-\"><a name=\"python解释器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>python解释器</h3>', '13', '### python解释器');
INSERT INTO `article_info_true` VALUES ('9', 'php简介', '<h3 id=\"h3-php-\"><a name=\"php简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>php简介</h3>', '21', '### php简介');
INSERT INTO `article_info_true` VALUES ('10', 'php', '<h3 id=\"h3-php-\"><a name=\"php叫姐姐\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>php叫姐姐</h3>', '19', '### php叫姐姐');
INSERT INTO `article_info_true` VALUES ('11', 'php安装', '<h3 id=\"h3-php-\"><a name=\"php安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>php安装</h3>', '22', '### php安装');
INSERT INTO `article_info_true` VALUES ('12', 'c', '<h3 id=\"h3-c-\"><a name=\"c语言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>c语言</h3><p><img src=\"http://images2015.cnblogs.com/blog/78241/201701/78241-20170108192345347-555400478.png\" alt=\"Alt text\"></p>\r\n', '23', '### c语言\r\n![Alt text](http://images2015.cnblogs.com/blog/78241/201701/78241-20170108192345347-555400478.png)');
INSERT INTO `article_info_true` VALUES ('13', 'c语言简介', '<h3 id=\"h3-c-\"><a name=\"c语言简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>c语言简介</h3>', '24', '### c语言简介');
INSERT INTO `article_info_true` VALUES ('14', 'oracle', '<h3 id=\"h3-hello-oralcle\"><a name=\"hello oralcle\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>hello oralcle</h3>', '25', '### hello oralcle');
INSERT INTO `article_info_true` VALUES ('15', 'oracle hello', '<p>fds </p>\r\n', '26', 'fds ');
INSERT INTO `article_info_true` VALUES ('16', 'java基础语法', '<p><img src=\"http://ww2.sinaimg.cn/large/006pQ25sgw1f2n7r5fumlj30bo08r74e.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1. 复习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 复习</h3><p>编写Java程序的基本步骤，如下图所示</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_Process.png\" alt=\"JavaBasics_Process.png\"></p>\r\n<p>步骤1：使用文本编辑器或IDE来编写源码。<br>步骤2：使用JDK编译命令”javac”来编译源码生成可移植的二进制代码。<br>步骤3：使用”java”运行二进制代码，根据输入产生相应的输出。</p>\r\n<p>下面的程序展示了编程中涉及的主要结构：顺序执行、循环和条件。</p>\r\n<pre><code>/*\r\n* 分别计算从最小值到最大值的奇数和偶数和\r\n*/\r\npublic class OddEvenSum { // 另存为&quot;OddEvenSum.java&quot;\r\n    public static void main(String[] args) {\r\n    int lowerbound = 1, upperbound = 1000;  // 最小值, 最大值\r\n    int sumOdd  = 0;                        // 奇数累加和, 初始化为0\r\n    int sumEven = 0;                        // 偶数累加和, 初始化为0\r\n    int number = lowerbound;\r\n\r\n    while (number &lt;= upperbound) {\r\n        if (number % 2 == 0) {              // 偶数\r\n            sumEven += number;              // 等价于sumEven = sumEven + number\r\n        } else {                            // 奇数\r\n            sumOdd += number;               // 等价于sumOdd = sumOdd + number\r\n        }\r\n\r\n        ++number;                           // 下个数值\r\n    }\r\n\r\n    // 打印输出结果\r\n    System.out.println(&quot;奇数和从&quot; + lowerbound + &quot;到&quot; + upperbound + &quot;为&quot; + sumOdd);\r\n    System.out.println(&quot;偶数和从&quot; + lowerbound + &quot;到&quot; + upperbound + &quot;为&quot; + sumEven);\r\n    System.out.println(&quot;两者之差为&quot; + (sumOdd - sumEven));\r\n    }\r\n}\r\n\r\n奇数和从1到1000为250000\r\n偶数和从1到1000为250500\r\n两者之差为-500\r\n</code></pre><h3 id=\"h3-2-\"><a name=\"2. 注释\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 注释</h3><p>注释主要用来解释你的代码逻辑，注释不是编程语句，注释会被编译器忽略不会被执行，即便这样，注释还是非常重要的，它为别人理解你的程序提供了文档似的说明（也许是3天后的自己）。</p>\r\n<p>在Java有两种注释方式：</p>\r\n<ul>\r\n<li>多行注释：以/<em>开头，以</em>/结尾，中间可以跨越多行。</li><li>单行注释：以//开头直到行尾</li></ul>\r\n<h3 id=\"h3-3-\"><a name=\"3. 语句和块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 语句和块</h3><p>语句：程序中的最小单元以分号结尾，它执行了程序的一个动作。</p>\r\n<pre><code>// 每行都是一条语句，都以分号结尾\r\nint number1 = 10;\r\nint number2, number3=99;\r\nint product;\r\nproduct = number1 * number2 * number3;\r\nSystem.out.println(&quot;Hello&quot;);\r\n</code></pre><p>块：块是由一对大括号包围的一组语句，所有块中的语句被视为一个完整的单元。块被用来表示类、方法、条件和循环的主体，包含着多条语句的一个单元，不必在括号末尾添加分号，不包含任何语句的空块是合法的。例如：</p>\r\n<pre><code>if (mark &gt;= 50) {\r\n    System.out.println(&quot;PASS&quot;);\r\n    System.out.println(&quot;Well Done!&quot;);\r\n    System.out.println(&quot;Keep it Up!&quot;);\r\n}\r\n\r\nif (number == 88) {\r\n    System.out.println(&quot;Got it!&quot;);\r\n} else {\r\n    System.out.println(&quot;Try Again!&quot;);\r\n}\r\n\r\ni = 1;\r\nwhile (i &lt; 8) {\r\n    System.out.print(i + &quot; &quot;);\r\n    ++i;\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    ...statements...\r\n}\r\n</code></pre><h3 id=\"h3-4-\"><a name=\"4. 空白和代码格式化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 空白和代码格式化</h3><p>空白：空格、制表符和换行符被统称为空白。Java和大多数的语言一样忽略多余的空白，也就是说连续的空白会被视为一个空白。</p>\r\n<pre><code>// 你需要使用空白来分隔关键字来避免混淆，例如：\r\nint sum=0;       // 不能写成：intsum=0, 在&quot;int&quot;和&quot;sum&quot;之间至少保留一个空白\r\ndouble average;  // 同样, 在&quot;double&quot;和&quot;average&quot;之间至少保留一个空白\r\n\r\n// 多余的空格和行会被忽略\r\nint  sum\r\n    =  0      ;\r\n\r\ndouble  average  ;\r\n</code></pre><p>代码格式化：正如前面提到的，额外的空白会被忽略，没有计算意义。但是，适当的缩进和额外的空行大大提高了程序的可读性，是别人更容易理解你的程序。<br>举个例子，下面是只有一行的Hello world程序，虽然能正常运行，但是你看的头不晕吗？</p>\r\n<pre><code>public class Hello{public static void main(String[] args){System.out.println(&quot;Hello, world!&quot;);}}\r\n</code></pre><p>括号：Java习惯上把开始括号放置于行尾，结束括号放置于行首。<br>缩进：根据语句块级别的不同，使用适当的空格来进行缩进，每次缩进建议使用4个空格。</p>\r\n<pre><code>/*\r\n * 推荐的Java编程风格\r\n */\r\npublic class ClassName {\r\n    public static void main(String[] args) {\r\n\r\n        // 使用空白行提高程序可读性\r\n        // 顺序执行的操作语句\r\n        statement;\r\n        statement;\r\n\r\n        // 条件语句\r\n        if ( test ) {\r\n            statements;\r\n        } else {\r\n            statements;\r\n        }\r\n\r\n        // 循环语句\r\n        init;\r\n        while ( test ) {\r\n            statements;\r\n            update;\r\n        }\r\n    }\r\n}\r\n</code></pre>', '29', '![](http://ww2.sinaimg.cn/large/006pQ25sgw1f2n7r5fumlj30bo08r74e.jpg)\r\n### 1\\. 复习\r\n\r\n编写Java程序的基本步骤，如下图所示\r\n\r\n![JavaBasics_Process.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_Process.png)\r\n\r\n步骤1：使用文本编辑器或IDE来编写源码。\r\n步骤2：使用JDK编译命令\"javac\"来编译源码生成可移植的二进制代码。\r\n步骤3：使用\"java\"运行二进制代码，根据输入产生相应的输出。\r\n\r\n下面的程序展示了编程中涉及的主要结构：顺序执行、循环和条件。\r\n\r\n```\r\n/*\r\n* 分别计算从最小值到最大值的奇数和偶数和\r\n*/\r\npublic class OddEvenSum { // 另存为\"OddEvenSum.java\"\r\n    public static void main(String[] args) {\r\n    int lowerbound = 1, upperbound = 1000;  // 最小值, 最大值\r\n    int sumOdd  = 0;                        // 奇数累加和, 初始化为0\r\n    int sumEven = 0;                        // 偶数累加和, 初始化为0\r\n    int number = lowerbound;\r\n\r\n    while (number <= upperbound) {\r\n        if (number % 2 == 0) {              // 偶数\r\n            sumEven += number;              // 等价于sumEven = sumEven + number\r\n        } else {                            // 奇数\r\n            sumOdd += number;               // 等价于sumOdd = sumOdd + number\r\n        }\r\n\r\n        ++number;                           // 下个数值\r\n    }\r\n\r\n    // 打印输出结果\r\n    System.out.println(\"奇数和从\" + lowerbound + \"到\" + upperbound + \"为\" + sumOdd);\r\n    System.out.println(\"偶数和从\" + lowerbound + \"到\" + upperbound + \"为\" + sumEven);\r\n    System.out.println(\"两者之差为\" + (sumOdd - sumEven));\r\n    }\r\n}\r\n\r\n奇数和从1到1000为250000\r\n偶数和从1到1000为250500\r\n两者之差为-500\r\n```\r\n\r\n### 2\\. 注释\r\n\r\n注释主要用来解释你的代码逻辑，注释不是编程语句，注释会被编译器忽略不会被执行，即便这样，注释还是非常重要的，它为别人理解你的程序提供了文档似的说明（也许是3天后的自己）。\r\n\r\n在Java有两种注释方式：\r\n\r\n*   多行注释：以/*开头，以*/结尾，中间可以跨越多行。\r\n*   单行注释：以//开头直到行尾\r\n\r\n### 3\\. 语句和块\r\n\r\n语句：程序中的最小单元以分号结尾，它执行了程序的一个动作。\r\n\r\n```\r\n// 每行都是一条语句，都以分号结尾\r\nint number1 = 10;\r\nint number2, number3=99;\r\nint product;\r\nproduct = number1 * number2 * number3;\r\nSystem.out.println(\"Hello\");\r\n```\r\n\r\n块：块是由一对大括号包围的一组语句，所有块中的语句被视为一个完整的单元。块被用来表示类、方法、条件和循环的主体，包含着多条语句的一个单元，不必在括号末尾添加分号，不包含任何语句的空块是合法的。例如：\r\n\r\n```\r\nif (mark >= 50) {\r\n    System.out.println(\"PASS\");\r\n    System.out.println(\"Well Done!\");\r\n    System.out.println(\"Keep it Up!\");\r\n}\r\n\r\nif (number == 88) {\r\n    System.out.println(\"Got it!\");\r\n} else {\r\n    System.out.println(\"Try Again!\");\r\n}\r\n\r\ni = 1;\r\nwhile (i < 8) {\r\n    System.out.print(i + \" \");\r\n    ++i;\r\n}\r\n\r\npublic static void main(String[] args) {\r\n    ...statements...\r\n}\r\n```\r\n\r\n### 4\\. 空白和代码格式化\r\n\r\n空白：空格、制表符和换行符被统称为空白。Java和大多数的语言一样忽略多余的空白，也就是说连续的空白会被视为一个空白。\r\n\r\n```\r\n// 你需要使用空白来分隔关键字来避免混淆，例如：\r\nint sum=0;       // 不能写成：intsum=0, 在\"int\"和\"sum\"之间至少保留一个空白\r\ndouble average;  // 同样, 在\"double\"和\"average\"之间至少保留一个空白\r\n\r\n// 多余的空格和行会被忽略\r\nint  sum\r\n    =  0      ;\r\n\r\ndouble  average  ;\r\n\r\n```\r\n\r\n代码格式化：正如前面提到的，额外的空白会被忽略，没有计算意义。但是，适当的缩进和额外的空行大大提高了程序的可读性，是别人更容易理解你的程序。\r\n举个例子，下面是只有一行的Hello world程序，虽然能正常运行，但是你看的头不晕吗？\r\n\r\n```\r\npublic class Hello{public static void main(String[] args){System.out.println(\"Hello, world!\");}}\r\n```\r\n\r\n括号：Java习惯上把开始括号放置于行尾，结束括号放置于行首。\r\n缩进：根据语句块级别的不同，使用适当的空格来进行缩进，每次缩进建议使用4个空格。\r\n\r\n```\r\n/*\r\n * 推荐的Java编程风格\r\n */\r\npublic class ClassName {\r\n    public static void main(String[] args) {\r\n\r\n        // 使用空白行提高程序可读性\r\n        // 顺序执行的操作语句\r\n        statement;\r\n        statement;\r\n\r\n        // 条件语句\r\n        if ( test ) {\r\n            statements;\r\n        } else {\r\n            statements;\r\n        }\r\n\r\n        // 循环语句\r\n        init;\r\n        while ( test ) {\r\n            statements;\r\n            update;\r\n        }\r\n    }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('17', '文件，目录操作', '<p>FILE类</p>\r\n<p>　　存储在变量,数组和对象中的数据是暂时的,当程序终止时他们就会丢失.为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们需要学习一个和文件有密切关系的类,叫做File类,将要掌握获取文件的属性以及删除和重命名文件.最终如何向文件中写入数据和从文件中读取数据.</p>\r\n<p>　　那么File类关心的是在磁盘上文件的存储.</p>\r\n<p>　　File类描述的是一个文件或文件夹。（文件夹也可以称为目录）</p>\r\n<p>　　该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。可以通过对象的思想来操作文件以及文件夹。可以用面向对象的处理问题，通过该对象的方法，可以得到文件或文件夹的信息方便了对文件与文件夹的属性信息进行操作。</p>\r\n<p>　　文件包含很多的信息:如文件名、创建修改时间、大小、可读可写属性等。</p>\r\n<p>路径分隔符</p>\r\n<p>　　 在windows机器上 的目录分隔符是 \\  ,在linux机器上的目录分隔符是/ 。</p>\r\n<p>注意：  在windows上面\\ 与 / 都可以使用作为目录分隔符。 而且，如果写/ 的时候只需要写一个即可。</p>\r\n<p>java的File类中提供了一个与系统有关的路径分隔符的常量：static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</p>\r\n<p>决定路径和相对路径</p>\r\n<p>对于UNIX平台，绝对路径名的前缀是”/“。相对路径名没有前缀。</p>\r\n<p>对于Windows平台，绝对路径名的前缀由驱动器号和一个”:”组成，例”c:\\…”。相对路径没有盘符前缀。</p>\r\n<p>相对路径：</p>\r\n<pre><code>相对路径是指相对于某位置的路径，是指相对于当前目录。\r\n\r\n在执行Java程序时，相对路径为执行java命令时当前所在的目录。\r\n</code></pre><p>. 代表当前路径<br> .. 代表上一级路径<br>注意： 如果程序当前所在的路径与资源文件不是在同一个盘下面，是没法写相对路径 的。</p>\r\n<p>File类常用方法</p>\r\n<p>构造方法：</p>\r\n<p>File(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。</p>\r\n<p>File(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。</p>\r\n<p>File(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.File;\r\n\r\npublic class DemoFile {\r\n    //构造方法\r\n    public static void main(String[] args) {\r\n        //根据全路径来创建File对象\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        System.out.println(&quot;是否存在文件：&quot;+file.exists());\r\n        //根据父路径和子路径字符串创建file\r\n        File file2 = new File(&quot;E:\\\\&quot;,&quot;nick.txt&quot;);\r\n        System.out.println(&quot;是否存在文件：&quot;+file2.exists());\r\n        //根据父File对象和子路径字符串创建File对象\r\n        File prarentFile = new File(&quot;E:\\\\&quot;);\r\n        File file3 = new File(prarentFile, &quot;nick.txt&quot;);\r\n        System.out.println(&quot;是否存在文件：&quot;+file3.exists());\r\n    }\r\n}\r\n</code></pre><p>相对路径和决定路径测试：</p>\r\n<pre><code>import java.io.File;\r\n\r\npublic class DemoFile {\r\n    //相对路径和决定路径\r\n    public static void main(String[] args) {\r\n        File file= new File(&quot;.&quot;);\r\n        System.out.println(&quot;当前路径：&quot;+file.getAbsolutePath());\r\n        File file2 = new File(&quot;..\\\\..\\\\nick.txt&quot;);\r\n        System.out.println(&quot;是否存在文件：&quot;+file2.exists());\r\n    }\r\n}\r\n</code></pre><p>创建文件或文件夹的常用方法：</p>\r\n<p>boolean createNewFile() 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</p>\r\n<p>boolean mkdir()  创建此抽象路径名指定的目录。</p>\r\n<p>boolean mkdirs()  创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</p>\r\n<p>boolean renameTo(File dest) 重新命名此抽象路径名表示的文件。如果dest文件路径和源文件路径一致，为重命名。如果不一致，则为剪切。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class DemoFile {\r\n    //创建\r\n    public static void main(String[] args) throws IOException {\r\n        //创建文件\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        boolean isSuccess = file.createNewFile(); //抛出异常\r\n        System.out.println(&quot;创建文件是否成功：&quot;+isSuccess);\r\n        //创建文件夹\r\n        File file2 = new File(&quot;E:\\\\aaaaa&quot;);\r\n        boolean isSuccess2 = file2.mkdir();\r\n        System.out.println(&quot;创建文件夹是否成功：&quot;+isSuccess2);\r\n        //创建父子文件夹\r\n        File file3 = new File(&quot;E:\\\\aaaaaa\\\\bbbb&quot;);\r\n        boolean isSuccess3 = file3.mkdirs();\r\n        System.out.println(&quot;创建父子文件夹是否成功：&quot;+isSuccess3);\r\n        //重命名或剪切文件夹\r\n        boolean isRename = file.renameTo(new File(&quot;E:\\\\aa.txt&quot;));\r\n        System.out.println(&quot;重命名是否成功 ：&quot;+isRename);\r\n        boolean isRename2 = file.renameTo(new File(&quot;D:\\\\aa.txt&quot;));\r\n        System.out.println(&quot;剪切是否成功 ：&quot;+isRename2);\r\n\r\n    }\r\n}\r\n</code></pre><p>删除文件或者文件夹：</p>\r\n<p>boolean delete() 删除此抽象路径名表示的文件或目录。</p>\r\n<p>void deleteOnExit() 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</p>\r\n<p>注意：删除文件夹时只能删除空文件夹。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class DemoFile {\r\n    public static void main(String[] args) {\r\n        //删除文件\r\n        File file = new File(&quot;D:\\\\aa.txt&quot;);\r\n        System.out.println(&quot;删除文件是否成功：&quot;+file.delete());\r\n        //删除文件夹\r\n        File file2 = new File(&quot;E:\\\\aaaaaa\\\\bbbb&quot;);\r\n        System.out.println(&quot;删除文件夹是否成功：&quot;+file2.delete());\r\n        File file3 = new File(&quot;E:\\\\aaaaaa&quot;);\r\n        file3.deleteOnExit();\r\n        System.out.println(&quot;程序正在执行&quot;);\r\n    }\r\n}\r\n</code></pre><p>判断：</p>\r\n<p>boolean exists()  测试此抽象路径名表示的文件或目录是否存在。</p>\r\n<p>boolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件。</p>\r\n<p>boolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录。</p>\r\n<p>boolean isHidden() 测试此抽象路径名指定的文件是否是一个隐藏文件。</p>\r\n<p>boolean isAbsolute() 测试此抽象路径名是否为绝对路径名</p>\r\n<p>获取：</p>\r\n<p>String getName() 返回由此抽象路径名表示的文件或目录的名称。</p>\r\n<p>String getPath() 将此抽象路径名转换为一个路径名字符串。</p>\r\n<p>String getAbsoluteFile() 返回此抽象路径名的绝对路径名形式。</p>\r\n<p>String getParent()  返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</p>\r\n<p>long length() 返回由此抽象路径名表示的文件的长度。</p>\r\n<p>long lastModified() 返回此抽象路径名表示的文件最后一次被修改的时间。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class DemoFile {\r\n    public static void main(String[] args) {\r\n        //获取\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        System.out.println(&quot;文件名：&quot;+file.getName());\r\n        System.out.println(&quot;文件路径：&quot;+file.getPath());\r\n        System.out.println(&quot;文件绝对路径：&quot;+file.getAbsolutePath()); //如果file为相对路径，则绝对路径为当前路径+文件路径\r\n        System.out.println(&quot;文件父路径：&quot;+file.getParent()); //除了文件名以外的路径\r\n        System.out.println(&quot;文件大小：&quot;+file.length());\r\n        System.out.println(&quot;文件最后修改时间：&quot;+file.lastModified());\r\n    }\r\n}\r\n</code></pre><p>文件夹相关操作方法：</p>\r\n<p>static File[] listRoots() 列出可用的文件系统根。</p>\r\n<p>String[] list()  返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</p>\r\n<p>File[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</p>\r\n<p>File[] listFiles(FileFilter filter) 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</p>\r\n<p>String[] list(FilenameFilter filter) 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</p>\r\n<p>File[] listFiles(FilenameFilter filter)  返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</p>\r\n<p>File实战：</p>\r\n<p>1、指定一个文件夹，然后列出该文件夹下面所有java文件。</p>\r\n<p>代码如下：</p>\r\n<pre><code>import java.io.File;\r\nimport java.io.FileFilter;\r\nimport java.io.IOException;\r\n\r\nclass NickFileFilter implements FileFilter{\r\n\r\n    @Override\r\n    public boolean accept(File pathname) {\r\n\r\n        return pathname.isFile() &amp;&amp; pathname.getName().endsWith(&quot;.java&quot;);\r\n    }\r\n\r\n\r\n}\r\n\r\npublic class DemoFile {\r\n    public static void main(String[] args) {\r\n        File file = new File(&quot;C:\\\\Users\\\\Nick\\\\Desktop\\\\nick&quot;);\r\n        File[] files = file.listFiles(new NickFileFilter());\r\n        for (File file2 : files) {\r\n            System.out.println(file2.getName());\r\n        }\r\n    }\r\n}\r\n</code></pre><p>2、指定一个文件夹，然后列出文件夹下面的所有子文件与文件夹，但是格式要如下:</p>\r\n<p>　　文件夹：</p>\r\n<p>　　　　文件夹1</p>\r\n<p>　　　　文件夹2</p>\r\n<p>　　　　…………</p>\r\n<p>　　文件：</p>\r\n<p>　　　　文件1</p>\r\n<p>　　　　文件2</p>\r\n<p>　　　　………………</p>\r\n<p>代码示例如下：</p>\r\n<pre><code>public class DemoFile {\r\n    public static void main(String[] args) {\r\n        File file = new File(&quot;C:\\\\Users\\\\Nick\\\\Desktop\\\\nick&quot;);\r\n        File[] files = file.listFiles();\r\n        System.out.println(&quot;文件夹：&quot;);\r\n        for (File file2 : files) {\r\n            if (file2.isDirectory()) {\r\n                System.out.println(file2.getName());\r\n            }\r\n        }\r\n        System.out.println(&quot;文件：&quot;);\r\n        for (File file2 : files) {\r\n            if (file2.isFile()) {\r\n                System.out.println(file2.getName());\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre>', '32', 'FILE类\r\n\r\n　　存储在变量,数组和对象中的数据是暂时的,当程序终止时他们就会丢失.为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们需要学习一个和文件有密切关系的类,叫做File类,将要掌握获取文件的属性以及删除和重命名文件.最终如何向文件中写入数据和从文件中读取数据.\r\n\r\n　　那么File类关心的是在磁盘上文件的存储.\r\n\r\n　　File类描述的是一个文件或文件夹。（文件夹也可以称为目录）\r\n\r\n　　该类的出现是对文件系统的中的文件以及文件夹进行对象的封装。可以通过对象的思想来操作文件以及文件夹。可以用面向对象的处理问题，通过该对象的方法，可以得到文件或文件夹的信息方便了对文件与文件夹的属性信息进行操作。\r\n\r\n　　文件包含很多的信息:如文件名、创建修改时间、大小、可读可写属性等。\r\n\r\n路径分隔符\r\n\r\n　　 在windows机器上 的目录分隔符是 \\  ,在linux机器上的目录分隔符是/ 。\r\n\r\n注意：  在windows上面\\ 与 / 都可以使用作为目录分隔符。 而且，如果写/ 的时候只需要写一个即可。\r\n\r\njava的File类中提供了一个与系统有关的路径分隔符的常量：static String separator 与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。\r\n\r\n决定路径和相对路径\r\n\r\n对于UNIX平台，绝对路径名的前缀是\"/\"。相对路径名没有前缀。\r\n\r\n对于Windows平台，绝对路径名的前缀由驱动器号和一个\":\"组成，例\"c:\\\\...\"。相对路径没有盘符前缀。\r\n\r\n相对路径：\r\n\r\n    相对路径是指相对于某位置的路径，是指相对于当前目录。\r\n\r\n    在执行Java程序时，相对路径为执行java命令时当前所在的目录。\r\n\r\n. 代表当前路径\r\n .. 代表上一级路径\r\n注意： 如果程序当前所在的路径与资源文件不是在同一个盘下面，是没法写相对路径 的。\r\n\r\nFile类常用方法\r\n\r\n构造方法：\r\n\r\nFile(String pathname) 通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。\r\n\r\nFile(String parent, String child) 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。\r\n\r\nFile(File parent, String child) 根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。\r\n\r\n代码示例：\r\n\r\n```\r\nimport java.io.File;\r\n\r\npublic class DemoFile {\r\n    //构造方法\r\n    public static void main(String[] args) {\r\n        //根据全路径来创建File对象\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        System.out.println(\"是否存在文件：\"+file.exists());\r\n        //根据父路径和子路径字符串创建file\r\n        File file2 = new File(\"E:\\\\\",\"nick.txt\");\r\n        System.out.println(\"是否存在文件：\"+file2.exists());\r\n        //根据父File对象和子路径字符串创建File对象\r\n        File prarentFile = new File(\"E:\\\\\");\r\n        File file3 = new File(prarentFile, \"nick.txt\");\r\n        System.out.println(\"是否存在文件：\"+file3.exists());\r\n    }\r\n}\r\n```\r\n相对路径和决定路径测试：\r\n\r\n```\r\nimport java.io.File;\r\n\r\npublic class DemoFile {\r\n    //相对路径和决定路径\r\n    public static void main(String[] args) {\r\n        File file= new File(\".\");\r\n        System.out.println(\"当前路径：\"+file.getAbsolutePath());\r\n        File file2 = new File(\"..\\\\..\\\\nick.txt\");\r\n        System.out.println(\"是否存在文件：\"+file2.exists());\r\n    }\r\n}\r\n```\r\n创建文件或文件夹的常用方法：\r\n\r\nboolean createNewFile() 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。\r\n\r\nboolean mkdir()  创建此抽象路径名指定的目录。\r\n\r\nboolean mkdirs()  创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。\r\n\r\nboolean renameTo(File dest) 重新命名此抽象路径名表示的文件。如果dest文件路径和源文件路径一致，为重命名。如果不一致，则为剪切。\r\n\r\n代码示例：\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class DemoFile {\r\n    //创建\r\n    public static void main(String[] args) throws IOException {\r\n        //创建文件\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        boolean isSuccess = file.createNewFile(); //抛出异常\r\n        System.out.println(\"创建文件是否成功：\"+isSuccess);\r\n        //创建文件夹\r\n        File file2 = new File(\"E:\\\\aaaaa\");\r\n        boolean isSuccess2 = file2.mkdir();\r\n        System.out.println(\"创建文件夹是否成功：\"+isSuccess2);\r\n        //创建父子文件夹\r\n        File file3 = new File(\"E:\\\\aaaaaa\\\\bbbb\");\r\n        boolean isSuccess3 = file3.mkdirs();\r\n        System.out.println(\"创建父子文件夹是否成功：\"+isSuccess3);\r\n        //重命名或剪切文件夹\r\n        boolean isRename = file.renameTo(new File(\"E:\\\\aa.txt\"));\r\n        System.out.println(\"重命名是否成功 ：\"+isRename);\r\n        boolean isRename2 = file.renameTo(new File(\"D:\\\\aa.txt\"));\r\n        System.out.println(\"剪切是否成功 ：\"+isRename2);\r\n        \r\n    }\r\n}\r\n```\r\n删除文件或者文件夹：\r\n\r\nboolean delete() 删除此抽象路径名表示的文件或目录。\r\n\r\nvoid deleteOnExit() 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。\r\n\r\n注意：删除文件夹时只能删除空文件夹。\r\n\r\n代码示例：\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class DemoFile {\r\n    public static void main(String[] args) {\r\n        //删除文件\r\n        File file = new File(\"D:\\\\aa.txt\");\r\n        System.out.println(\"删除文件是否成功：\"+file.delete());\r\n        //删除文件夹\r\n        File file2 = new File(\"E:\\\\aaaaaa\\\\bbbb\");\r\n        System.out.println(\"删除文件夹是否成功：\"+file2.delete());\r\n        File file3 = new File(\"E:\\\\aaaaaa\");\r\n        file3.deleteOnExit();\r\n        System.out.println(\"程序正在执行\");\r\n    }\r\n}\r\n```\r\n判断：\r\n\r\nboolean exists()  测试此抽象路径名表示的文件或目录是否存在。\r\n\r\nboolean isFile() 测试此抽象路径名表示的文件是否是一个标准文件。\r\n\r\nboolean isDirectory() 测试此抽象路径名表示的文件是否是一个目录。\r\n\r\nboolean isHidden() 测试此抽象路径名指定的文件是否是一个隐藏文件。\r\n\r\nboolean isAbsolute() 测试此抽象路径名是否为绝对路径名\r\n\r\n获取：\r\n\r\nString getName() 返回由此抽象路径名表示的文件或目录的名称。\r\n\r\nString getPath() 将此抽象路径名转换为一个路径名字符串。\r\n\r\nString getAbsoluteFile() 返回此抽象路径名的绝对路径名形式。\r\n\r\nString getParent()  返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。\r\n\r\nlong length() 返回由此抽象路径名表示的文件的长度。\r\n\r\nlong lastModified() 返回此抽象路径名表示的文件最后一次被修改的时间。\r\n\r\n代码示例：\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class DemoFile {\r\n    public static void main(String[] args) {\r\n        //获取\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        System.out.println(\"文件名：\"+file.getName());\r\n        System.out.println(\"文件路径：\"+file.getPath());\r\n        System.out.println(\"文件绝对路径：\"+file.getAbsolutePath()); //如果file为相对路径，则绝对路径为当前路径+文件路径\r\n        System.out.println(\"文件父路径：\"+file.getParent()); //除了文件名以外的路径\r\n        System.out.println(\"文件大小：\"+file.length());\r\n        System.out.println(\"文件最后修改时间：\"+file.lastModified());\r\n    }\r\n}\r\n\r\n```\r\n文件夹相关操作方法：\r\n\r\nstatic File[] listRoots() 列出可用的文件系统根。\r\n\r\nString[] list()  返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。\r\n\r\nFile[] listFiles() 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。\r\n\r\nFile[] listFiles(FileFilter filter) 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。\r\n\r\nString[] list(FilenameFilter filter) 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。\r\n\r\nFile[] listFiles(FilenameFilter filter)  返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。\r\n\r\nFile实战：\r\n\r\n1、指定一个文件夹，然后列出该文件夹下面所有java文件。\r\n\r\n代码如下：\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileFilter;\r\nimport java.io.IOException;\r\n\r\nclass NickFileFilter implements FileFilter{\r\n\r\n    @Override\r\n    public boolean accept(File pathname) {\r\n        \r\n        return pathname.isFile() && pathname.getName().endsWith(\".java\");\r\n    }\r\n    \r\n    \r\n}\r\n\r\npublic class DemoFile {\r\n    public static void main(String[] args) {\r\n        File file = new File(\"C:\\\\Users\\\\Nick\\\\Desktop\\\\nick\");\r\n        File[] files = file.listFiles(new NickFileFilter());\r\n        for (File file2 : files) {\r\n            System.out.println(file2.getName());\r\n        }\r\n    }\r\n}\r\n```\r\n2、指定一个文件夹，然后列出文件夹下面的所有子文件与文件夹，但是格式要如下:\r\n\r\n　　文件夹：\r\n\r\n　　　　文件夹1\r\n\r\n　　　　文件夹2\r\n\r\n　　　　…………\r\n\r\n　　文件：\r\n\r\n　　　　文件1\r\n\r\n　　　　文件2\r\n\r\n　　　　………………\r\n\r\n代码示例如下：\r\n\r\n```\r\npublic class DemoFile {\r\n    public static void main(String[] args) {\r\n        File file = new File(\"C:\\\\Users\\\\Nick\\\\Desktop\\\\nick\");\r\n        File[] files = file.listFiles();\r\n        System.out.println(\"文件夹：\");\r\n        for (File file2 : files) {\r\n            if (file2.isDirectory()) {\r\n                System.out.println(file2.getName());\r\n            }\r\n        }\r\n        System.out.println(\"文件：\");\r\n        for (File file2 : files) {\r\n            if (file2.isFile()) {\r\n                System.out.println(file2.getName());\r\n            }\r\n        }\r\n    }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('18', '字节流', '<p>File类是文件的抽象表示，如果要对文件的内容进行读写就需要使用IO流技术。</p>\r\n<p>IO流简介：（Input/Output）</p>\r\n<pre><code>I/O类库中使用“流”这个抽象概念。Java对设备中数据的操作是通过流的方式。\r\n\r\n表示任何有能力产出数据的数据源对象，或者是有能力接受数据的接收端对象。“流”屏蔽了实际的I/O设备中处理数据的细节。IO流用来处理设备之间的数据传输。设备是指硬盘、内存、键盘录入、网络等。\r\n\r\nJava用于操作流的对象都在IO包中。IO流技术主要用来处理设备之间的数据传输。\r\n\r\n由于Java用于操作流的对象都在IO包中。所以使用IO流需要导包如：import java.io.*;\r\n</code></pre><p>IO流的分类</p>\r\n<pre><code>流按操作数据类型的不同分为两种：字节流与字符流。\r\n\r\n流按流向分为：输入流，输出流（以程序为参照物，输入到程序，或是从程序输出）\r\n</code></pre><p>字节流</p>\r\n<p>什么是字节流</p>\r\n<pre><code>计算机中都是二进制数据,一个字节是8个2进制位.字节可以表示所有的数据,比如文本,音频,视频.图片,都是作为字节存在的.也就是说字节流处理的数据非常多。\r\n</code></pre><p>在文本文件中存储的数据是以我们能读懂的方式表示的。而在二进制文件中存储的数据是用二进制形式表示的。我们是读不懂二进制文件的，因为二进制文件是为了让程序来读取而设计的。例如，Java的源程序(.java源文件)存储在文本文件中,可以使用文本编辑器阅读,但是Java的类(字节码文件)存储在二进制文件中,可以被Java虚拟机阅读。二进制文件的优势在于它的处理效率比文本文件高。</p>\r\n<p>字节流处理的单元是一个字节，用于操作二进制文件（计算机中所有文件都是二进制文件）。</p>\r\n<p>java中的字节流体系：输入字节流和输出字节流</p>\r\n<p>字节流体系</p>\r\n<p>输入字节流体系：<br>——| InputStream  输入字节流的基类。 抽象<br>—————| FileInputStream 读取文件数据的输入字节流<br>—————| BufferedInputStream 缓冲输入字节流    缓冲输入字节流的出现主要是为了提高读取文件数据的效率。其实该类内部只不过是维护了一个8kb的字节数组而已。</p>\r\n<p>输出字节流体系<br>————| OutputStream  所有输出字节流的基类  抽象类<br>——————| FileOutputStream 向文件输出数据的输出字节流<br>——————| Bufferedoutputstream  缓冲输出字节流    BufferedOutputStream出现的目的是为了提高写数据的效率。 内部也是维护了一个8kb的字节数组而已。</p>\r\n<p>注意：判断使用输入流还是输出流的依据是：以内存为参考物，数据进入内存使用input，数据出内存用output。</p>\r\n<p>输入字节流</p>\r\n<p>文件输入字节流文件：FileInputStream</p>\r\n<p>步骤：</p>\r\n<p>　 1. 找到目标文件</p>\r\n<pre><code>2. 建立数据的输入通道。\r\n3. 读取文件中的数据。\r\n4. 关闭资源.\r\n</code></pre><p>常用方法：<br>1、构造方法：</p>\r\n<p>FileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。</p>\r\n<p>FileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。</p>\r\n<p>2、读取方法：</p>\r\n<p>int read() 从此输入流中读取一个数据字节。返回读取的字节数据，如果到了文件末尾则返回-1</p>\r\n<p>int read(byte[] b)  从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。返回读入缓冲区的字节数，如果到了文件末尾返回-1；</p>\r\n<p>3、关闭资源方法：</p>\r\n<p>void close() 关闭此文件输入流并释放与此流有关的所有系统资源。</p>\r\n<p>代码示例:</p>\r\n<pre><code>public static void readFile(String fileName){\r\n        File file = null;\r\n        FileInputStream fileInputStream = null;\r\n        try {\r\n            file = new File(&quot;E:\\\\nick.txt&quot;);\r\n            fileInputStream = new FileInputStream(file);\r\n            byte[] buf = new byte[1024]; //数组的大小一般为1024的倍数\r\n            int count = 0;\r\n            while((count = fileInputStream.read(buf))!= -1){\r\n                System.out.println(new String(buf, 0, count));\r\n            }\r\n        }catch(IOException e){\r\n            System.out.println(&quot;文件读取错误&quot;);\r\n            throw new RuntimeException(e);\r\n        } finally {\r\n            try {\r\n                if (fileInputStream != null ) {\r\n                    fileInputStream.close();\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(&quot;关闭文件失败&quot;);\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n</code></pre><p>缓冲输入字节流BufferedInputStream</p>\r\n<p>此类的目的是提高程序读取文件的效率。实现原理是内部维护了一个8KB的byte数组，读取的时候会一次读取满数组的字节，然后在对内存中的数组进行操作，从而来提高效率。</p>\r\n<p>使用步骤：</p>\r\n<p>　 1. 找到目标文件。</p>\r\n<pre><code>2. 建立数据的输入通道。\r\n3. 建立缓冲输入字节流。\r\n4. 读取文件中的数据。\r\n5. 关闭文件。\r\n</code></pre><p>常用方法：1、构造方法：</p>\r\n<p>BufferedInputStream(InputStream in)  创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</p>\r\n<p>2、读取方法：</p>\r\n<p>int read() 从此输入流中读取一个数据字节。</p>\r\n<p>int  read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。</p>\r\n<p>3、关闭资源方法：</p>\r\n<p>void close() 关闭此文件输入流并释放与此流有关的所有系统资源。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.BufferedInputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileStream {\r\n    public static void main(String[] args){\r\n        ReadFile2();\r\n    }\r\n\r\n    public static void ReadFile2() {\r\n        File file = null;\r\n        FileInputStream fileInputStream = null;\r\n        BufferedInputStream bufferedInputStream = null;\r\n        try {\r\n            file = new File(&quot;E:\\\\nick.txt&quot;);\r\n            fileInputStream = new FileInputStream(file);\r\n            bufferedInputStream = new BufferedInputStream(fileInputStream);\r\n            int content = 0;\r\n            while((content = bufferedInputStream.read())!=-1){\r\n                System.out.print((char)content);\r\n            }\r\n        } catch (IOException e) {\r\n            System.out.println(&quot;读取文件失败&quot;);\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            if (fileInputStream != null) {\r\n                try {\r\n                    bufferedInputStream.close();\r\n                } catch (IOException e) {\r\n                    System.out.println(&quot;关闭文件失败&quot;);\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><p>输出字节流</p>\r\n<p>文件字节输出流：FileOutputStream</p>\r\n<p>步骤：</p>\r\n<p>　 1. 找到目标文件</p>\r\n<pre><code>2. 建立数据的输出通道。\r\n3. 把数据转换成字节数组写出。\r\n4. 关闭资源\r\n</code></pre><p>常用方法：</p>\r\n<p>1、构造方法</p>\r\n<p>FileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</p>\r\n<p>FileOutputStream(File file, boolean append) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。当append为true时，续写文件。当apend为false时，重写文件。</p>\r\n<p>FileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。</p>\r\n<p>FileOutputStream(String name, boolean append) 创建一个向具有指定 name 的文件中写入数据的输出文件流。</p>\r\n<p>2、写入方法：</p>\r\n<p>void write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中。</p>\r\n<p>void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</p>\r\n<p>void  write(int b) 将指定字节写入此文件输出流。</p>\r\n<p>3、关闭资源：</p>\r\n<p>void close() 关闭此文件输出流并释放与此流有关的所有系统资源。</p>\r\n<p>代码示例：</p>\r\n<pre><code>public static void writeFile(){\r\n        FileOutputStream fileOutputStream = null;\r\n        try{\r\n            File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n            fileOutputStream = new FileOutputStream(file,true);\r\n            String string = &quot;abc&quot;;\r\n            fileOutputStream.write(string.getBytes());\r\n            System.out.println(&quot;写入文件成功&quot;);\r\n        }catch(IOException e){\r\n            System.out.println(&quot;写入文件出错&quot;);\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            try {\r\n                if (fileOutputStream != null) {\r\n                    fileOutputStream.close();\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(&quot;关闭资源文件失败&quot;);\r\n                throw new RuntimeException(e);\r\n            }\r\n        }    \r\n    }\r\n</code></pre><p>注意事项：</p>\r\n<p>　 1. 使用FileOutputStream 的时候，如果目标文件不存在，那么会自动创建目标文件对象。 如果在目录不存在就会抛异常。</p>\r\n<pre><code>2. 使用FileOutputStream写数据的时候，如果目标文件已经存在，那么会先清空目标文件中的数据，然后再写入数据。\r\n3.使用FileOutputStream写数据的时候, 如果目标文件已经存在，需要在原来数据基础上追加数据的时候应该使用new FileOutputStream(file,true)构造函数，第二参数为true。\r\n4.使用FileOutputStream的write()方法写数据的时候，虽然接收的是一个int类型的数据，但是真正写出的只是一个字节的数据，只是把低八位的二进制数据写出，其他二十四位数据全部丢弃。\r\n</code></pre><p>缓冲输出字节流</p>\r\n<p>此类类似于BufferedInputStream,在内部也维护了一个8KB的byte数组。从而来提高文件写入的效率。</p>\r\n<p>步骤：</p>\r\n<p>　 1. 找到目标文件。</p>\r\n<pre><code>2. 建立数据的输入通道。\r\n3. 建立缓冲输入字节流。\r\n4. 写入文件。\r\n5. 关闭文件。\r\n</code></pre><p>常用方法</p>\r\n<p>1、构造方法：</p>\r\n<p>BufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</p>\r\n<p>2、写入方法：</p>\r\n<p>void write(int b) 将指定的字节写入此缓冲的输出流。</p>\r\n<p>void write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。</p>\r\n<p>void  flush() 刷新此缓冲的输出流。</p>\r\n<p>3、关闭资源：</p>\r\n<p>void close() 关闭此文件输出流并释放与此流有关的所有系统资源。</p>\r\n<p>代码示例：</p>\r\n<pre><code>public static void writeFile2() {\r\n        File file = null;\r\n        FileOutputStream fileOutputStream = null;\r\n        BufferedOutputStream bufferedOutputStream = null;\r\n        try {\r\n            file = new File(&quot;E:\\\\nick.txt&quot;);\r\n            fileOutputStream = new FileOutputStream(file,true);\r\n            bufferedOutputStream = new BufferedOutputStream(fileOutputStream);\r\n            String string = &quot;hello world&quot;;\r\n            bufferedOutputStream.write(string.getBytes());\r\n            bufferedOutputStream.flush();\r\n            System.out.println(&quot;写入文件成功&quot;);\r\n        } catch (Exception e) {\r\n            System.out.println(&quot;写入文件失败&quot;);\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            if (fileOutputStream != null) {\r\n                try {\r\n                    bufferedOutputStream.close();\r\n                } catch (IOException e) {\r\n                    System.out.println(&quot;关闭资源文件失败&quot;);\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n</code></pre><p>注意事项：</p>\r\n<p>　  1. 使用BufferedOutStream写数据的时候，它的write方法是是先把数据写到它内部维护的字节数组中。</p>\r\n<pre><code> 2. 使用BufferedOutStream写数据的时候，它的write方法是是先把数据写到它内部维护的字节数组中，如果需要把数据真正的写到硬盘上面，需要调用flush方法或者是close方法、 或者是内部维护的字节数组已经填满数据的时候。\r\n</code></pre><p>　　3.BufferedOutStream写入文件的时候是续写文件，并不清空原有文件中的数据。</p>\r\n<p>实战</p>\r\n<p>需求：拷贝图片。</p>\r\n<p>代码示例如下：</p>\r\n<pre><code>public static void copyImage(){\r\n        FileInputStream fileInputStream = null;\r\n        FileOutputStream fileOutputStream = null;\r\n        try {\r\n            File infile = new File(&quot;E:\\\\Image\\\\IMG_1885.JPG&quot;);\r\n            File outfile = new File(&quot;E:\\\\nick.jpg&quot;);\r\n            fileInputStream = new FileInputStream(infile);\r\n            fileOutputStream = new FileOutputStream(outfile);\r\n            byte[] buf = new byte[1024];\r\n            int count = 0;\r\n            while((count = fileInputStream.read(buf)) != -1){\r\n                fileOutputStream.write(buf, 0, count);\r\n            }\r\n        } catch (IOException e) {\r\n            System.out.println(&quot;复制图片失败&quot;);\r\n            throw new RuntimeException(e);\r\n        }finally{\r\n            if (fileOutputStream != null) {\r\n                try {\r\n                    fileOutputStream.close();\r\n                } catch (IOException e) {\r\n                    System.out.println(&quot;关闭输出流失败&quot;);\r\n                    throw new RuntimeException(e);\r\n                }finally {\r\n                    if (fileInputStream != null) {\r\n                        try {\r\n                            fileInputStream.close();\r\n                        } catch (IOException e) {\r\n                            System.out.println(&quot;关闭输入流失败&quot;);\r\n                            throw new RuntimeException(e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n</code></pre><p>注意：</p>\r\n<p>文件操作中对于资源的开启和关闭的原则：先开后关，后开先关。</p>\r\n', '33', 'File类是文件的抽象表示，如果要对文件的内容进行读写就需要使用IO流技术。\r\n\r\nIO流简介：（Input/Output）\r\n\r\n    I/O类库中使用“流”这个抽象概念。Java对设备中数据的操作是通过流的方式。\r\n\r\n    表示任何有能力产出数据的数据源对象，或者是有能力接受数据的接收端对象。“流”屏蔽了实际的I/O设备中处理数据的细节。IO流用来处理设备之间的数据传输。设备是指硬盘、内存、键盘录入、网络等。\r\n\r\n    Java用于操作流的对象都在IO包中。IO流技术主要用来处理设备之间的数据传输。\r\n\r\n    由于Java用于操作流的对象都在IO包中。所以使用IO流需要导包如：import java.io.*;\r\n\r\nIO流的分类\r\n\r\n    流按操作数据类型的不同分为两种：字节流与字符流。\r\n\r\n    流按流向分为：输入流，输出流（以程序为参照物，输入到程序，或是从程序输出）\r\n\r\n字节流\r\n\r\n什么是字节流\r\n\r\n    计算机中都是二进制数据,一个字节是8个2进制位.字节可以表示所有的数据,比如文本,音频,视频.图片,都是作为字节存在的.也就是说字节流处理的数据非常多。\r\n\r\n在文本文件中存储的数据是以我们能读懂的方式表示的。而在二进制文件中存储的数据是用二进制形式表示的。我们是读不懂二进制文件的，因为二进制文件是为了让程序来读取而设计的。例如，Java的源程序(.java源文件)存储在文本文件中,可以使用文本编辑器阅读,但是Java的类(字节码文件)存储在二进制文件中,可以被Java虚拟机阅读。二进制文件的优势在于它的处理效率比文本文件高。\r\n\r\n字节流处理的单元是一个字节，用于操作二进制文件（计算机中所有文件都是二进制文件）。\r\n\r\njava中的字节流体系：输入字节流和输出字节流\r\n\r\n字节流体系\r\n\r\n输入字节流体系： \r\n----| InputStream  输入字节流的基类。 抽象\r\n----------| FileInputStream 读取文件数据的输入字节流\r\n----------| BufferedInputStream 缓冲输入字节流    缓冲输入字节流的出现主要是为了提高读取文件数据的效率。其实该类内部只不过是维护了一个8kb的字节数组而已。\r\n\r\n输出字节流体系\r\n--------| OutputStream  所有输出字节流的基类  抽象类\r\n------------| FileOutputStream 向文件输出数据的输出字节流\r\n------------| Bufferedoutputstream  缓冲输出字节流    BufferedOutputStream出现的目的是为了提高写数据的效率。 内部也是维护了一个8kb的字节数组而已。\r\n\r\n注意：判断使用输入流还是输出流的依据是：以内存为参考物，数据进入内存使用input，数据出内存用output。\r\n\r\n输入字节流\r\n\r\n文件输入字节流文件：FileInputStream\r\n\r\n步骤：\r\n\r\n　 1. 找到目标文件\r\n    2. 建立数据的输入通道。\r\n    3. 读取文件中的数据。\r\n    4. 关闭资源.\r\n\r\n常用方法：\r\n1、构造方法：\r\n\r\nFileInputStream(File file) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。\r\n\r\nFileInputStream(String name) 通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。\r\n\r\n2、读取方法：\r\n\r\nint read() 从此输入流中读取一个数据字节。返回读取的字节数据，如果到了文件末尾则返回-1\r\n\r\nint read(byte[] b)  从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。返回读入缓冲区的字节数，如果到了文件末尾返回-1；\r\n\r\n3、关闭资源方法：\r\n\r\nvoid close() 关闭此文件输入流并释放与此流有关的所有系统资源。\r\n\r\n代码示例:\r\n\r\n```\r\npublic static void readFile(String fileName){\r\n        File file = null;\r\n        FileInputStream fileInputStream = null;\r\n        try {\r\n            file = new File(\"E:\\\\nick.txt\");\r\n            fileInputStream = new FileInputStream(file);\r\n            byte[] buf = new byte[1024]; //数组的大小一般为1024的倍数\r\n            int count = 0;\r\n            while((count = fileInputStream.read(buf))!= -1){\r\n                System.out.println(new String(buf, 0, count));\r\n            }\r\n        }catch(IOException e){\r\n            System.out.println(\"文件读取错误\");\r\n            throw new RuntimeException(e);\r\n        } finally {\r\n            try {\r\n                if (fileInputStream != null ) {\r\n                    fileInputStream.close();\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"关闭文件失败\");\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n```\r\n缓冲输入字节流BufferedInputStream\r\n\r\n此类的目的是提高程序读取文件的效率。实现原理是内部维护了一个8KB的byte数组，读取的时候会一次读取满数组的字节，然后在对内存中的数组进行操作，从而来提高效率。\r\n\r\n使用步骤：\r\n\r\n　 1. 找到目标文件。\r\n    2. 建立数据的输入通道。\r\n    3. 建立缓冲输入字节流。\r\n    4. 读取文件中的数据。\r\n    5. 关闭文件。\r\n\r\n常用方法：1、构造方法：\r\n\r\nBufferedInputStream(InputStream in)  创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。\r\n\r\n2、读取方法：\r\n\r\nint read() 从此输入流中读取一个数据字节。\r\n\r\nint  read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。\r\n\r\n3、关闭资源方法：\r\n\r\nvoid close() 关闭此文件输入流并释放与此流有关的所有系统资源。\r\n\r\n代码示例：\r\n\r\n```\r\nimport java.io.BufferedInputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\n\r\npublic class FileStream {\r\n    public static void main(String[] args){\r\n        ReadFile2();\r\n    }\r\n\r\n    public static void ReadFile2() {\r\n        File file = null;\r\n        FileInputStream fileInputStream = null;\r\n        BufferedInputStream bufferedInputStream = null;\r\n        try {\r\n            file = new File(\"E:\\\\nick.txt\");\r\n            fileInputStream = new FileInputStream(file);\r\n            bufferedInputStream = new BufferedInputStream(fileInputStream);\r\n            int content = 0;\r\n            while((content = bufferedInputStream.read())!=-1){\r\n                System.out.print((char)content);\r\n            }\r\n        } catch (IOException e) {\r\n            System.out.println(\"读取文件失败\");\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            if (fileInputStream != null) {\r\n                try {\r\n                    bufferedInputStream.close();\r\n                } catch (IOException e) {\r\n                    System.out.println(\"关闭文件失败\");\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n输出字节流\r\n\r\n文件字节输出流：FileOutputStream\r\n\r\n步骤：\r\n\r\n　 1. 找到目标文件\r\n    2. 建立数据的输出通道。\r\n    3. 把数据转换成字节数组写出。\r\n    4. 关闭资源\r\n\r\n常用方法：\r\n\r\n1、构造方法\r\n\r\nFileOutputStream(File file) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。\r\n\r\nFileOutputStream(File file, boolean append) 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。当append为true时，续写文件。当apend为false时，重写文件。\r\n\r\nFileOutputStream(String name) 创建一个向具有指定名称的文件中写入数据的输出文件流。\r\n\r\nFileOutputStream(String name, boolean append) 创建一个向具有指定 name 的文件中写入数据的输出文件流。\r\n\r\n2、写入方法：\r\n\r\nvoid write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中。\r\n\r\nvoid write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。\r\n\r\nvoid  write(int b) 将指定字节写入此文件输出流。\r\n\r\n3、关闭资源：\r\n\r\nvoid close() 关闭此文件输出流并释放与此流有关的所有系统资源。\r\n\r\n代码示例：\r\n```\r\npublic static void writeFile(){\r\n        FileOutputStream fileOutputStream = null;\r\n        try{\r\n            File file = new File(\"E:\\\\nick.txt\");\r\n            fileOutputStream = new FileOutputStream(file,true);\r\n            String string = \"abc\";\r\n            fileOutputStream.write(string.getBytes());\r\n            System.out.println(\"写入文件成功\");\r\n        }catch(IOException e){\r\n            System.out.println(\"写入文件出错\");\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            try {\r\n                if (fileOutputStream != null) {\r\n                    fileOutputStream.close();\r\n                }\r\n            } catch (IOException e) {\r\n                System.out.println(\"关闭资源文件失败\");\r\n                throw new RuntimeException(e);\r\n            }\r\n        }    \r\n    }\r\n```\r\n注意事项：\r\n\r\n　 1. 使用FileOutputStream 的时候，如果目标文件不存在，那么会自动创建目标文件对象。 如果在目录不存在就会抛异常。\r\n    2. 使用FileOutputStream写数据的时候，如果目标文件已经存在，那么会先清空目标文件中的数据，然后再写入数据。\r\n    3.使用FileOutputStream写数据的时候, 如果目标文件已经存在，需要在原来数据基础上追加数据的时候应该使用new FileOutputStream(file,true)构造函数，第二参数为true。\r\n    4.使用FileOutputStream的write()方法写数据的时候，虽然接收的是一个int类型的数据，但是真正写出的只是一个字节的数据，只是把低八位的二进制数据写出，其他二十四位数据全部丢弃。\r\n\r\n缓冲输出字节流\r\n\r\n此类类似于BufferedInputStream,在内部也维护了一个8KB的byte数组。从而来提高文件写入的效率。\r\n\r\n步骤：\r\n\r\n　 1. 找到目标文件。\r\n    2. 建立数据的输入通道。\r\n    3. 建立缓冲输入字节流。\r\n    4. 写入文件。\r\n    5. 关闭文件。\r\n\r\n常用方法\r\n\r\n1、构造方法：\r\n\r\nBufferedOutputStream(OutputStream out) 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。\r\n\r\n2、写入方法：\r\n\r\nvoid write(int b) 将指定的字节写入此缓冲的输出流。\r\n\r\nvoid write(byte[] b, int off, int len) 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此缓冲的输出流。\r\n\r\nvoid  flush() 刷新此缓冲的输出流。\r\n\r\n3、关闭资源：\r\n\r\nvoid close() 关闭此文件输出流并释放与此流有关的所有系统资源。\r\n\r\n代码示例：\r\n\r\n```\r\npublic static void writeFile2() {\r\n        File file = null;\r\n        FileOutputStream fileOutputStream = null;\r\n        BufferedOutputStream bufferedOutputStream = null;\r\n        try {\r\n            file = new File(\"E:\\\\nick.txt\");\r\n            fileOutputStream = new FileOutputStream(file,true);\r\n            bufferedOutputStream = new BufferedOutputStream(fileOutputStream);\r\n            String string = \"hello world\";\r\n            bufferedOutputStream.write(string.getBytes());\r\n            bufferedOutputStream.flush();\r\n            System.out.println(\"写入文件成功\");\r\n        } catch (Exception e) {\r\n            System.out.println(\"写入文件失败\");\r\n            throw new RuntimeException(e);\r\n        }finally {\r\n            if (fileOutputStream != null) {\r\n                try {\r\n                    bufferedOutputStream.close();\r\n                } catch (IOException e) {\r\n                    System.out.println(\"关闭资源文件失败\");\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n注意事项：\r\n\r\n　  1. 使用BufferedOutStream写数据的时候，它的write方法是是先把数据写到它内部维护的字节数组中。\r\n     2. 使用BufferedOutStream写数据的时候，它的write方法是是先把数据写到它内部维护的字节数组中，如果需要把数据真正的写到硬盘上面，需要调用flush方法或者是close方法、 或者是内部维护的字节数组已经填满数据的时候。\r\n\r\n　　3.BufferedOutStream写入文件的时候是续写文件，并不清空原有文件中的数据。\r\n\r\n实战\r\n\r\n需求：拷贝图片。\r\n\r\n代码示例如下：\r\n```\r\npublic static void copyImage(){\r\n        FileInputStream fileInputStream = null;\r\n        FileOutputStream fileOutputStream = null;\r\n        try {\r\n            File infile = new File(\"E:\\\\Image\\\\IMG_1885.JPG\");\r\n            File outfile = new File(\"E:\\\\nick.jpg\");\r\n            fileInputStream = new FileInputStream(infile);\r\n            fileOutputStream = new FileOutputStream(outfile);\r\n            byte[] buf = new byte[1024];\r\n            int count = 0;\r\n            while((count = fileInputStream.read(buf)) != -1){\r\n                fileOutputStream.write(buf, 0, count);\r\n            }\r\n        } catch (IOException e) {\r\n            System.out.println(\"复制图片失败\");\r\n            throw new RuntimeException(e);\r\n        }finally{\r\n            if (fileOutputStream != null) {\r\n                try {\r\n                    fileOutputStream.close();\r\n                } catch (IOException e) {\r\n                    System.out.println(\"关闭输出流失败\");\r\n                    throw new RuntimeException(e);\r\n                }finally {\r\n                    if (fileInputStream != null) {\r\n                        try {\r\n                            fileInputStream.close();\r\n                        } catch (IOException e) {\r\n                            System.out.println(\"关闭输入流失败\");\r\n                            throw new RuntimeException(e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n注意：\r\n\r\n文件操作中对于资源的开启和关闭的原则：先开后关，后开先关。');
INSERT INTO `article_info_true` VALUES ('19', '字符流', '<p>计算机并不区分二进制文件与文本文件。所有的文件都是以二进制形式来存储的，因此，从本质上说，所有的文件都是二进制文件。所以字符流是建立在字节流之上的，它能够提供字符层次的编码和解码。</p>\r\n<p>常见的码表</p>\r\n<p>ASCII：    美国标准信息交换码。用一个字节的7位可以表示。</p>\r\n<p>ISO8859-1：   拉丁码表。欧洲码表，用一个字节的8位表示。</p>\r\n<p>GB2312：   英文占一个字节，中文占两个字节.中国的中文编码表。</p>\r\n<p>GBK：      中国的中文编码表升级，融合了更多的中文文字符号。</p>\r\n<p>Unicode：  国际标准码规范，融合了多种文字。所有文字都用两个字节来表示，Java语言使用的就是unicode。</p>\r\n<p>UTF-8:     万国码，推行的。是1~3个字节不等长。英文存的是1个字节，中文存的是3个字节，是为了节省空间。</p>\r\n<p>字节流不适合读中文，因为字节流的单位以为1个字节，而在码表中文至少使用两个字节来表示。</p>\r\n<p>字符流的体系</p>\r\n<p>输入字符流:<br>———-| Reader 所有输入字符流的基类。 抽象类<br>—————| FileReader 读取文件字符串的输入字符流。<br>—————| BufferedReader   缓冲输入字符流  。 缓冲输入字符流出现的目的是为了提高读取文件的效率和拓展了FileReader的功能。其实该类内部也是维护了一个字符数组。</p>\r\n<p>输入字符流</p>\r\n<p>常用方法：</p>\r\n<p>1、构造方法</p>\r\n<p>FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader。</p>\r\n<p>FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。</p>\r\n<p>FileReader(FileDescriptor fd) 在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。</p>\r\n<p>2、读取方法</p>\r\n<p>和字节输入流的读取方法一样，只是读的时候是按照字符来读的。</p>\r\n<p>3、关闭资源的方法</p>\r\n<p>和字节输入流的关闭资源一样。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class ReaderWriter {\r\n    public static void main(String[] args) throws IOException {\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        FileReader fileReader = new FileReader(file);\r\n        int count = 0;\r\n        while((count = fileReader.read()) != -1){\r\n            System.out.print((char)count);\r\n        }\r\n        fileReader.close();\r\n    }\r\n}\r\n</code></pre><p>缓冲输入字符流</p>\r\n<p>缓冲输入字符流出现的目的是为了提高读取文件的效率和拓展了FileReader的功能。其实该类内部也是维护了一个字符数组。</p>\r\n<p>常用方法</p>\r\n<p>1、构造方法</p>\r\n<p>BufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。</p>\r\n<p>2、读取和关闭方法和输入字符流提供的方法一样。特有的方法：</p>\r\n<p>String readLine() 读取一个文本行。</p>\r\n<p>代码示例：</p>\r\n<pre><code>public static void readFile2() throws FileNotFoundException, IOException {\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        FileReader fileReader = new FileReader(file);\r\n        BufferedReader bufferedReader = new BufferedReader(fileReader);\r\n        String content = null;\r\n        while ((content = bufferedReader.readLine()) != null) {\r\n            System.out.println(content);\r\n        }\r\n        bufferedReader.close();\r\n    }\r\n</code></pre><p>输出字符流</p>\r\n<p>输出字符流<br>—————| Writer  所有输出字符流的基类，  抽象类。<br>———————- | FileWriter 向文件输出字符数据的输出字符流。<br>————————| BufferedWriter 缓冲输出字符流          缓冲输出字符流作用： 提高FileWriter的写数据效率与拓展FileWriter的功能。<br>BufferedWriter内部只不过是提供了一个8192长度的字符数组作为缓冲区而已，拓展了FileWriter的功能。</p>\r\n<p>常用方法：</p>\r\n<p>1、构造方法</p>\r\n<p>FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象。</p>\r\n<p>FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象。</p>\r\n<p>FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。</p>\r\n<p>FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。</p>\r\n<p>2、写入方法：写入方法和FileOutPutStream的方法大致一样，只是写入的单位是一个字符。特有方法</p>\r\n<p>void write(String str) 写入字符串</p>\r\n<p>void write(String str, int off, int len) 写入字符串的某一部分。</p>\r\n<p>3、关闭资源</p>\r\n<p>关闭资源方法和FileOutPutStream的方法一致、</p>\r\n<p>代码示例：</p>\r\n<pre><code>public static void writeFile() throws IOException {\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        FileWriter fileWriter = new FileWriter(file,true);\r\n        String string = &quot;Nick 好聪明呀&quot;;\r\n        fileWriter.write(string);\r\n        fileWriter.close();\r\n    }\r\n</code></pre><p>缓冲输出字符流</p>\r\n<p>缓冲输出字符流作用： 提高FileWriter的写数据效率与拓展FileWriter的功能。BufferedWriter内部只不过是提供了一个8192长度的字符数组作为缓冲区而已，拓展了FileWriter的功能。</p>\r\n<p>常用方法：</p>\r\n<p>1、构造方法：</p>\r\n<p>BufferedWriter(Writer out)  创建一个使用默认大小输出缓冲区的缓冲字符输出流。</p>\r\n<p>BufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。</p>\r\n<p>2、写入方法和关闭方法大致和FileWrite一样，特有的方法：</p>\r\n<p>void newLine()  写入一个行分隔符。</p>\r\n<p>代码示例如下：</p>\r\n<pre><code>public static void writeFile2() throws IOException {\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        FileWriter fileWriter = new FileWriter(file,true);\r\n        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\r\n        bufferedWriter.newLine();\r\n        bufferedWriter.write(&quot;我是大师&quot;);\r\n        bufferedWriter.close();\r\n    }\r\n</code></pre><p>实战</p>\r\n<p>缓冲输入输出字符流用户登陆注册…</p>\r\n<p>代码示例：</p>\r\n<pre><code>public class Login {\r\n\r\n    static Scanner scanner = new Scanner(System.in);\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        while(true){\r\n            System.out.println(&quot;请选择功能： A(注册)   B(登陆)&quot;);\r\n            String option =  scanner.next();\r\n            if(&quot;a&quot;.equalsIgnoreCase(option)){\r\n                //注册\r\n                reg();\r\n\r\n            }else if(&quot;b&quot;.equalsIgnoreCase(option)){\r\n                //登陆\r\n                login();\r\n\r\n            }else{\r\n                System.out.println(&quot;你的输入有误,请重新输入...&quot;);\r\n            }    \r\n        }\r\n    }\r\n\r\n\r\n    //登陆\r\n    public static void login() throws IOException{\r\n        System.out.println(&quot;请输入用户名：&quot;);\r\n        String userName = scanner.next();\r\n        System.out.println(&quot;请 输入密码：&quot;);\r\n        String password = scanner.next();\r\n        String info = userName+&quot; &quot;+ password;\r\n        //读取文件的信息，查看是否有该用户的信息存在，如果存在则登陆成功。\r\n        //建立数据的输入通道\r\n        //建立缓冲输入字符流\r\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;F:\\\\users.txt&quot;));\r\n        String line = null;\r\n\r\n        boolean isLogin = false; // 用于记录是否登陆成功的标识， 默认是登陆失败的。\r\n        //不断的读取文件的内容\r\n        while((line = bufferedReader.readLine())!=null){\r\n            if(info.equals(line)){\r\n                isLogin = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(isLogin){\r\n            System.out.println(&quot;欢迎&quot;+userName+&quot;登陆成功...&quot;);\r\n        }else{\r\n            System.out.println(&quot;不存在该用户信息，请注册!!&quot;);\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    //注册\r\n    public static void reg() throws IOException{\r\n        System.out.println(&quot;请输入用户名：&quot;);\r\n        String userName = scanner.next();\r\n        System.out.println(&quot;请 输入密码：&quot;);\r\n        String password = scanner.next();\r\n        String info = userName+&quot; &quot;+ password;\r\n        //把用户的注册的信息写到文件上\r\n        File file = new File(&quot;F:\\\\users.txt&quot;);\r\n        FileWriter fileWriter = new FileWriter(file,true);\r\n        //建立缓冲输出字符流\r\n        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\r\n        //把用户信息写出\r\n\r\n        bufferedWriter.write(info);\r\n        bufferedWriter.newLine();\r\n        //关闭资源\r\n        bufferedWriter.close();\r\n\r\n    }\r\n\r\n}\r\n</code></pre>', '34', '计算机并不区分二进制文件与文本文件。所有的文件都是以二进制形式来存储的，因此，从本质上说，所有的文件都是二进制文件。所以字符流是建立在字节流之上的，它能够提供字符层次的编码和解码。\r\n\r\n常见的码表\r\n\r\nASCII：    美国标准信息交换码。用一个字节的7位可以表示。\r\n\r\nISO8859-1：   拉丁码表。欧洲码表，用一个字节的8位表示。\r\n\r\nGB2312：   英文占一个字节，中文占两个字节.中国的中文编码表。\r\n\r\nGBK：      中国的中文编码表升级，融合了更多的中文文字符号。\r\n\r\nUnicode：  国际标准码规范，融合了多种文字。所有文字都用两个字节来表示，Java语言使用的就是unicode。\r\n\r\nUTF-8:     万国码，推行的。是1~3个字节不等长。英文存的是1个字节，中文存的是3个字节，是为了节省空间。\r\n\r\n字节流不适合读中文，因为字节流的单位以为1个字节，而在码表中文至少使用两个字节来表示。\r\n\r\n字符流的体系\r\n\r\n输入字符流:\r\n-------| Reader 所有输入字符流的基类。 抽象类\r\n----------| FileReader 读取文件字符串的输入字符流。\r\n----------| BufferedReader   缓冲输入字符流  。 缓冲输入字符流出现的目的是为了提高读取文件的效率和拓展了FileReader的功能。其实该类内部也是维护了一个字符数组。\r\n\r\n输入字符流\r\n\r\n常用方法：\r\n\r\n1、构造方法\r\n\r\nFileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader。\r\n\r\nFileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader。\r\n\r\nFileReader(FileDescriptor fd) 在给定从中读取数据的 FileDescriptor 的情况下创建一个新 FileReader。\r\n\r\n2、读取方法\r\n\r\n和字节输入流的读取方法一样，只是读的时候是按照字符来读的。\r\n\r\n3、关闭资源的方法\r\n\r\n和字节输入流的关闭资源一样。\r\n\r\n代码示例：\r\n```\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\npublic class ReaderWriter {\r\n    public static void main(String[] args) throws IOException {\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        FileReader fileReader = new FileReader(file);\r\n        int count = 0;\r\n        while((count = fileReader.read()) != -1){\r\n            System.out.print((char)count);\r\n        }\r\n        fileReader.close();\r\n    }\r\n}\r\n```\r\n缓冲输入字符流\r\n\r\n缓冲输入字符流出现的目的是为了提高读取文件的效率和拓展了FileReader的功能。其实该类内部也是维护了一个字符数组。\r\n\r\n常用方法\r\n\r\n1、构造方法\r\n\r\nBufferedReader(Reader in) 创建一个使用默认大小输入缓冲区的缓冲字符输入流。\r\n\r\n2、读取和关闭方法和输入字符流提供的方法一样。特有的方法：\r\n\r\nString readLine() 读取一个文本行。\r\n\r\n代码示例：\r\n\r\n```\r\npublic static void readFile2() throws FileNotFoundException, IOException {\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        FileReader fileReader = new FileReader(file);\r\n        BufferedReader bufferedReader = new BufferedReader(fileReader);\r\n        String content = null;\r\n        while ((content = bufferedReader.readLine()) != null) {\r\n            System.out.println(content);\r\n        }\r\n        bufferedReader.close();\r\n    }\r\n```\r\n输出字符流\r\n\r\n输出字符流\r\n----------| Writer  所有输出字符流的基类，  抽象类。\r\n--------------- | FileWriter 向文件输出字符数据的输出字符流。 \r\n----------------| BufferedWriter 缓冲输出字符流          缓冲输出字符流作用： 提高FileWriter的写数据效率与拓展FileWriter的功能。\r\nBufferedWriter内部只不过是提供了一个8192长度的字符数组作为缓冲区而已，拓展了FileWriter的功能。\r\n\r\n常用方法：\r\n\r\n1、构造方法\r\n\r\nFileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象。\r\n\r\nFileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象。\r\n\r\nFileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象。\r\n\r\nFileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。\r\n\r\n2、写入方法：写入方法和FileOutPutStream的方法大致一样，只是写入的单位是一个字符。特有方法\r\n\r\nvoid write(String str) 写入字符串\r\n\r\nvoid write(String str, int off, int len) 写入字符串的某一部分。\r\n\r\n3、关闭资源\r\n\r\n关闭资源方法和FileOutPutStream的方法一致、\r\n\r\n代码示例：\r\n\r\n```\r\npublic static void writeFile() throws IOException {\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        FileWriter fileWriter = new FileWriter(file,true);\r\n        String string = \"Nick 好聪明呀\";\r\n        fileWriter.write(string);\r\n        fileWriter.close();\r\n    }\r\n```\r\n缓冲输出字符流\r\n\r\n缓冲输出字符流作用： 提高FileWriter的写数据效率与拓展FileWriter的功能。BufferedWriter内部只不过是提供了一个8192长度的字符数组作为缓冲区而已，拓展了FileWriter的功能。\r\n\r\n常用方法：\r\n\r\n1、构造方法：\r\n\r\nBufferedWriter(Writer out)  创建一个使用默认大小输出缓冲区的缓冲字符输出流。\r\n\r\nBufferedWriter(Writer out, int sz) 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。\r\n\r\n2、写入方法和关闭方法大致和FileWrite一样，特有的方法：\r\n\r\nvoid newLine()  写入一个行分隔符。\r\n\r\n代码示例如下：\r\n\r\n```\r\npublic static void writeFile2() throws IOException {\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        FileWriter fileWriter = new FileWriter(file,true);\r\n        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\r\n        bufferedWriter.newLine();\r\n        bufferedWriter.write(\"我是大师\");\r\n        bufferedWriter.close();\r\n    }\r\n```\r\n实战\r\n\r\n缓冲输入输出字符流用户登陆注册...\r\n\r\n代码示例：\r\n\r\n\r\n```\r\npublic class Login {\r\n    \r\n    static Scanner scanner = new Scanner(System.in);\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        while(true){\r\n            System.out.println(\"请选择功能： A(注册)   B(登陆)\");\r\n            String option =  scanner.next();\r\n            if(\"a\".equalsIgnoreCase(option)){\r\n                //注册\r\n                reg();\r\n                \r\n            }else if(\"b\".equalsIgnoreCase(option)){\r\n                //登陆\r\n                login();\r\n                \r\n            }else{\r\n                System.out.println(\"你的输入有误,请重新输入...\");\r\n            }    \r\n        }\r\n    }\r\n    \r\n    \r\n    //登陆\r\n    public static void login() throws IOException{\r\n        System.out.println(\"请输入用户名：\");\r\n        String userName = scanner.next();\r\n        System.out.println(\"请 输入密码：\");\r\n        String password = scanner.next();\r\n        String info = userName+\" \"+ password;\r\n        //读取文件的信息，查看是否有该用户的信息存在，如果存在则登陆成功。\r\n        //建立数据的输入通道\r\n        //建立缓冲输入字符流\r\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(\"F:\\\\users.txt\"));\r\n        String line = null;\r\n        \r\n        boolean isLogin = false; // 用于记录是否登陆成功的标识， 默认是登陆失败的。\r\n        //不断的读取文件的内容\r\n        while((line = bufferedReader.readLine())!=null){\r\n            if(info.equals(line)){\r\n                isLogin = true;\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if(isLogin){\r\n            System.out.println(\"欢迎\"+userName+\"登陆成功...\");\r\n        }else{\r\n            System.out.println(\"不存在该用户信息，请注册!!\");\r\n        }\r\n        \r\n        \r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    //注册\r\n    public static void reg() throws IOException{\r\n        System.out.println(\"请输入用户名：\");\r\n        String userName = scanner.next();\r\n        System.out.println(\"请 输入密码：\");\r\n        String password = scanner.next();\r\n        String info = userName+\" \"+ password;\r\n        //把用户的注册的信息写到文件上\r\n        File file = new File(\"F:\\\\users.txt\");\r\n        FileWriter fileWriter = new FileWriter(file,true);\r\n        //建立缓冲输出字符流\r\n        BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);\r\n        //把用户信息写出\r\n        \r\n        bufferedWriter.write(info);\r\n        bufferedWriter.newLine();\r\n        //关闭资源\r\n        bufferedWriter.close();\r\n        \r\n    }\r\n\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('20', '序列流', '<p>SequenceInputStream 表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。</p>\r\n<p>常用方法：</p>\r\n<p>1、构造方法</p>\r\n<p>SequenceInputStream(InputStream s1, InputStream s2) 通过记住这两个参数来初始化新创建的 SequenceInputStream（将按顺序读取这两个参数，先读取 s1，然后读取 s2），以提供从此 SequenceInputStream 读取的字节。</p>\r\n<p>SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) 通过记住参数来初始化新创建的 SequenceInputStream，该参数必须是生成运行时类型为 InputStream 对象的 Enumeration 型参数。</p>\r\n<p>2、读取方法</p>\r\n<p>int read(byte[] b, int off, int len) 将最多 len 个数据字节从此输入流读入 byte 数组。</p>\r\n<p>int read()  从此输入流中读取下一个数据字节。</p>\r\n<p>3、关闭资源</p>\r\n<p>void close() 关闭此输入流并释放与此流关联的所有系统资源。</p>\r\n<p>常用操作就是合并读取</p>\r\n<p>示例代码：</p>\r\n<pre><code>// 需求： 把一首mp3先切割成n份，然后再把这些文件合并起来。\r\npublic class DemoSequenceInputStream {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n//        split();\r\n        merage();\r\n    }\r\n\r\n    //分隔\r\n    public static void split() throws IOException{\r\n        File inFile = new File(&quot;D:\\\\西单女孩-原点 (3D武侠动画《画江湖之不良人》主题曲).mp3&quot;);\r\n        FileInputStream fileInputStream = new FileInputStream(inFile);\r\n        byte[] buf = new byte[1024*1024];\r\n        int length = 0;\r\n        for(int i = 0; (length = fileInputStream.read(buf)) != -1;i++){\r\n            File outFile = new File(&quot;D:\\\\SplitMusic\\\\&quot;,&quot;part&quot;+i+&quot;.mp3&quot;);\r\n            FileOutputStream fileOutputStream = new FileOutputStream(outFile);\r\n            fileOutputStream.write(buf, 0, length);\r\n            fileOutputStream.close();\r\n        }\r\n        fileInputStream.close();\r\n    }\r\n\r\n    //合并\r\n    public static void merage() throws IOException{\r\n        File dir = new File(&quot;D:\\\\SplitMusic&quot;);\r\n        File[] files = dir.listFiles();\r\n        //对数据进行排序\r\n        Arrays.sort(files);\r\n        Vector&lt;FileInputStream&gt; vector = new Vector&lt;&gt;();\r\n        for (File file : files) {\r\n            if (file.getName().endsWith(&quot;.mp3&quot;)) {\r\n                FileInputStream fileInputStream = new FileInputStream(file);\r\n                vector.add(fileInputStream);\r\n            }\r\n        }\r\n        Enumeration&lt;FileInputStream&gt; enumeration = vector.elements();\r\n        SequenceInputStream sequenceInputStream = new SequenceInputStream(enumeration);\r\n        FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:\\\\合并.mp3&quot;);\r\n        int length = 0;\r\n        byte[] buf= new byte[1024*1024];\r\n        while((length = sequenceInputStream.read(buf)) != -1){\r\n            fileOutputStream.write(buf, 0, length);\r\n        }\r\n        fileOutputStream.close();\r\n        sequenceInputStream.close();\r\n    }\r\n}\r\n</code></pre>', '35', 'SequenceInputStream 表示其他输入流的逻辑串联。它从输入流的有序集合开始，并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末尾为止。\r\n\r\n常用方法：\r\n\r\n1、构造方法\r\n\r\nSequenceInputStream(InputStream s1, InputStream s2) 通过记住这两个参数来初始化新创建的 SequenceInputStream（将按顺序读取这两个参数，先读取 s1，然后读取 s2），以提供从此 SequenceInputStream 读取的字节。\r\n\r\nSequenceInputStream(Enumeration<? extends InputStream> e) 通过记住参数来初始化新创建的 SequenceInputStream，该参数必须是生成运行时类型为 InputStream 对象的 Enumeration 型参数。\r\n\r\n2、读取方法\r\n\r\nint read(byte[] b, int off, int len) 将最多 len 个数据字节从此输入流读入 byte 数组。\r\n\r\nint read()  从此输入流中读取下一个数据字节。\r\n\r\n3、关闭资源\r\n\r\nvoid close() 关闭此输入流并释放与此流关联的所有系统资源。\r\n\r\n常用操作就是合并读取\r\n\r\n示例代码：\r\n\r\n\r\n```\r\n// 需求： 把一首mp3先切割成n份，然后再把这些文件合并起来。\r\npublic class DemoSequenceInputStream {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n//        split();\r\n        merage();\r\n    }\r\n    \r\n    //分隔\r\n    public static void split() throws IOException{\r\n        File inFile = new File(\"D:\\\\西单女孩-原点 (3D武侠动画《画江湖之不良人》主题曲).mp3\");\r\n        FileInputStream fileInputStream = new FileInputStream(inFile);\r\n        byte[] buf = new byte[1024*1024];\r\n        int length = 0;\r\n        for(int i = 0; (length = fileInputStream.read(buf)) != -1;i++){\r\n            File outFile = new File(\"D:\\\\SplitMusic\\\\\",\"part\"+i+\".mp3\");\r\n            FileOutputStream fileOutputStream = new FileOutputStream(outFile);\r\n            fileOutputStream.write(buf, 0, length);\r\n            fileOutputStream.close();\r\n        }\r\n        fileInputStream.close();\r\n    }\r\n    \r\n    //合并\r\n    public static void merage() throws IOException{\r\n        File dir = new File(\"D:\\\\SplitMusic\");\r\n        File[] files = dir.listFiles();\r\n        //对数据进行排序\r\n        Arrays.sort(files);\r\n        Vector<FileInputStream> vector = new Vector<>();\r\n        for (File file : files) {\r\n            if (file.getName().endsWith(\".mp3\")) {\r\n                FileInputStream fileInputStream = new FileInputStream(file);\r\n                vector.add(fileInputStream);\r\n            }\r\n        }\r\n        Enumeration<FileInputStream> enumeration = vector.elements();\r\n        SequenceInputStream sequenceInputStream = new SequenceInputStream(enumeration);\r\n        FileOutputStream fileOutputStream = new FileOutputStream(\"D:\\\\合并.mp3\");\r\n        int length = 0;\r\n        byte[] buf= new byte[1024*1024];\r\n        while((length = sequenceInputStream.read(buf)) != -1){\r\n            fileOutputStream.write(buf, 0, length);\r\n        }\r\n        fileOutputStream.close();\r\n        sequenceInputStream.close();\r\n    }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('21', '对象的序列化和反序列化', '<p>对象的序列化：   将内存中的对象直接写入到文件设备中。</p>\r\n<p>对象的反序列化： 将文件设备中持久化的数据转换为内存对象。</p>\r\n<p>自定义类只要实现了Serializable接口，便可以通过对象输入输出流对对象进行序列化和反序列化。从而来实现对象的持久化存储。</p>\r\n<p>对象的输入输出流 : 对象的输入输出流 主要的作用是用于写对象的信息与读取对象的信息。</p>\r\n<p>对象信息一旦写到文件上那么对象的信息就可以做到持久化存储了。</p>\r\n<p>对象的输出流： ObjectOutputStream</p>\r\n<p>常用方法：</p>\r\n<p>1、构造方法</p>\r\n<p>ObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。</p>\r\n<p>2、写方法</p>\r\n<p>void writeObject(Object obj)  将指定的对象写入 ObjectOutputStream。 </p>\r\n<p>3、关闭资源方法</p>\r\n<p>void  close() 关闭流。</p>\r\n<p>对象的输入流: ObjectInputStream</p>\r\n<p>1、构造方法</p>\r\n<p>ObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。</p>\r\n<p>2、读方法</p>\r\n<p>Object readObject() 从 ObjectInputStream 读取对象。</p>\r\n<p>3、关闭资源方法</p>\r\n<p>void  close() 关闭流。</p>\r\n<p>对象输入输出流要注意的细节：</p>\r\n<pre><code> 1. 如果对象需要被写出到文件上，那么对象所属的类必须要实现Serializable接口。 Serializable接口没有任何的方法，是一个标识接口而已。\r\n 2. 对象的反序列化创建对象的时候并不会调用到构造方法的。\r\n 3. serialVersionUID 是用于记录class文件的版本信息的，serialVersionUID这个数字是通过一个类的类名、成员、包名、工程名算出的一个数字。\r\n 4. 使用ObjectInputStream反序列化的时候，ObjeectInputStream会先读取文件中的serialVersionUID，然后与本地的class文件的serialVersionUID进行对比，如果这两个id不一致，那么反序列化就失败了。\r\n 5. 如果序列化与反序列化的时候可能会修改类的成员，那么最好一开始就给这个类指定一个serialVersionUID，如果一类已经指定的serialVersionUID，然后在序列化与反序列化的时候，jvm都不会再自己算这个 class的serialVersionUID了。\r\n 6. 如果一个对象某个数据不想被序列化到硬盘上，可以使用关键字transient修饰。\r\n 7. 如果一个类维护了另外一个类的引用，那么另外一个类也需要实现Serializable接口。\r\n</code></pre><p>需求：存在两个类：用户类和地址类。用户类中有id，name，address，age属性。对用户类进行序列化和反序列化，并且不保存用户的年龄。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\nclass Address implements Serializable{\r\n    private static final long serialVersionUID = 1L;\r\n    int id;\r\n    String detailAddress;\r\n    public Address(int id, String detailAddress) {\r\n        this.id = id;\r\n        this.detailAddress = detailAddress;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return &quot;地址信息：  id&quot;+this.id + &quot;详细地址：&quot;+this.detailAddress;\r\n    }\r\n}\r\n\r\nclass User implements Serializable{\r\n    private static final long serialVersionUID = 1L;\r\n    int id;\r\n    String name;\r\n    Address address;\r\n    transient int age;\r\n    public User(int id, String name, Address address, int age) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.address = address;\r\n        this.age = age;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return &quot;用户信息：   用户id:&quot;+ this.id+&quot;用户名：&quot;+this.name +&quot;  年龄&quot;+this.age + this.address;\r\n    }  \r\n}\r\n\r\npublic class DemoObjectStream {\r\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\r\n\r\n        //序列化\r\n        User user = new User(123, &quot;张三&quot;, new Address(110, &quot;公安局&quot;), 12);\r\n        FileOutputStream fileOutputStream = new FileOutputStream(&quot;E:\\\\nick.txt&quot;);\r\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);\r\n        objectOutputStream.writeObject(user);\r\n        objectOutputStream.close();\r\n        //反序列化\r\n        FileInputStream fileInputStream = new FileInputStream(&quot;E:\\\\nick.txt&quot;);\r\n        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);\r\n        User user2 = (User)objectInputStream.readObject();\r\n        System.out.println(user2);\r\n        objectInputStream.close();\r\n    }\r\n}\r\n</code></pre>', '36', '对象的序列化：   将内存中的对象直接写入到文件设备中。\r\n\r\n对象的反序列化： 将文件设备中持久化的数据转换为内存对象。\r\n\r\n自定义类只要实现了Serializable接口，便可以通过对象输入输出流对对象进行序列化和反序列化。从而来实现对象的持久化存储。\r\n\r\n \r\n\r\n对象的输入输出流 : 对象的输入输出流 主要的作用是用于写对象的信息与读取对象的信息。\r\n\r\n对象信息一旦写到文件上那么对象的信息就可以做到持久化存储了。\r\n \r\n对象的输出流： ObjectOutputStream\r\n\r\n常用方法：\r\n\r\n1、构造方法\r\n\r\nObjectOutputStream(OutputStream out) 创建写入指定 OutputStream 的 ObjectOutputStream。\r\n\r\n2、写方法\r\n\r\nvoid writeObject(Object obj)  将指定的对象写入 ObjectOutputStream。 \r\n\r\n3、关闭资源方法\r\n\r\nvoid  close() 关闭流。\r\n \r\n对象的输入流: ObjectInputStream\r\n\r\n1、构造方法\r\n\r\nObjectInputStream(InputStream in) 创建从指定 InputStream 读取的 ObjectInputStream。\r\n\r\n2、读方法\r\n\r\nObject readObject() 从 ObjectInputStream 读取对象。\r\n\r\n3、关闭资源方法\r\n\r\nvoid  close() 关闭流。\r\n\r\n对象输入输出流要注意的细节：\r\n     1. 如果对象需要被写出到文件上，那么对象所属的类必须要实现Serializable接口。 Serializable接口没有任何的方法，是一个标识接口而已。\r\n     2. 对象的反序列化创建对象的时候并不会调用到构造方法的。\r\n     3. serialVersionUID 是用于记录class文件的版本信息的，serialVersionUID这个数字是通过一个类的类名、成员、包名、工程名算出的一个数字。\r\n     4. 使用ObjectInputStream反序列化的时候，ObjeectInputStream会先读取文件中的serialVersionUID，然后与本地的class文件的serialVersionUID进行对比，如果这两个id不一致，那么反序列化就失败了。\r\n     5. 如果序列化与反序列化的时候可能会修改类的成员，那么最好一开始就给这个类指定一个serialVersionUID，如果一类已经指定的serialVersionUID，然后在序列化与反序列化的时候，jvm都不会再自己算这个 class的serialVersionUID了。\r\n     6. 如果一个对象某个数据不想被序列化到硬盘上，可以使用关键字transient修饰。\r\n     7. 如果一个类维护了另外一个类的引用，那么另外一个类也需要实现Serializable接口。\r\n\r\n需求：存在两个类：用户类和地址类。用户类中有id，name，address，age属性。对用户类进行序列化和反序列化，并且不保存用户的年龄。\r\n\r\n代码示例：\r\n\r\n```\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\nclass Address implements Serializable{\r\n    private static final long serialVersionUID = 1L;\r\n    int id;\r\n    String detailAddress;\r\n    public Address(int id, String detailAddress) {\r\n        this.id = id;\r\n        this.detailAddress = detailAddress;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"地址信息：  id\"+this.id + \"详细地址：\"+this.detailAddress;\r\n    }\r\n}\r\n\r\nclass User implements Serializable{\r\n    private static final long serialVersionUID = 1L;\r\n    int id;\r\n    String name;\r\n    Address address;\r\n    transient int age;\r\n    public User(int id, String name, Address address, int age) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.address = address;\r\n        this.age = age;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"用户信息：   用户id:\"+ this.id+\"用户名：\"+this.name +\"  年龄\"+this.age + this.address;\r\n    }  \r\n}\r\n\r\npublic class DemoObjectStream {\r\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\r\n        \r\n        //序列化\r\n        User user = new User(123, \"张三\", new Address(110, \"公安局\"), 12);\r\n        FileOutputStream fileOutputStream = new FileOutputStream(\"E:\\\\nick.txt\");\r\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);\r\n        objectOutputStream.writeObject(user);\r\n        objectOutputStream.close();\r\n        //反序列化\r\n        FileInputStream fileInputStream = new FileInputStream(\"E:\\\\nick.txt\");\r\n        ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);\r\n        User user2 = (User)objectInputStream.readObject();\r\n        System.out.println(user2);\r\n        objectInputStream.close();\r\n    }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('22', '打印流', '<p>打印流（PrintStream和PrintWriter）  打印流可以打印任意类型的数据，而且打印数据之前都会先把数据转换成字符串再进行打印。</p>\r\n<p>PrintStream：打印字节流。System.out对应的类型就是PrintStream。</p>\r\n<p>print 方法和write方法的却别在于,print提供自动刷新。</p>\r\n<p>常用方法：</p>\r\n<p>1、构造方法</p>\r\n<p>PrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。</p>\r\n<p>PrintStream(String fileName) 创建具有指定文件名称且不带自动行刷新的新打印流。</p>\r\n<p>PrintStream(OutputStream out) 创建新的打印流。2、打印方法：</p>\r\n<p>void print(数据类型 变量) 打印变量的值。 如果打印自定义对象，打印出来的内容是toString方法中返回的字符串。</p>\r\n<p>PrintWriter:打印字符流。</p>\r\n<p>常用方法</p>\r\n<p>1、构造方法</p>\r\n<p>PrintWriter(File file) 使用指定文件创建不具有自动行刷新的新 PrintWriter。</p>\r\n<p>PrintWriter(OutputStream out) 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。</p>\r\n<p>2、打印方法：</p>\r\n<p>void print(数据类型 变量) 打印变量的值。 如果打印自定义对象，打印出来的内容是toString方法中返回的字符串。</p>\r\n<p>应用场景：</p>\r\n<p>1、把控制台的信息输出到指定的文件中。</p>\r\n<p>2、收集异常的日志信息到指定文件。</p>\r\n<pre><code>public class Demo6 {\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        //打印流可以打印任何类型的数据，而且打印数据之前都会先把数据转换成字符串再进行打印。\r\n        File file = new  File(&quot;F:\\\\a.txt&quot;);\r\n        //创建一个打印流\r\n        PrintStream printStream = new PrintStream(file);\r\n        /*\r\n        printStream.println(97);\r\n        printStream.println(3.14);\r\n        printStream.println(&#39;a&#39;);\r\n        printStream.println(true);\r\n        Animal a = new Animal(&quot;老鼠&quot;, &quot;黑色&quot;);\r\n        printStream.println(a);\r\n\r\n\r\n        //默认标准的输出流就是向控制台输出的，\r\n        System.setOut(printStream); //重新设置了标准的输出流对象\r\n        System.out.println(&quot;哈哈，猜猜我在哪里！！&quot;);\r\n        */\r\n\r\n        //收集异常的日志信息。\r\n        File logFile = new File(&quot;F:\\\\2015年1月8日.log&quot;);\r\n        PrintStream logPrintStream = new PrintStream( new FileOutputStream(logFile,true) );\r\n        try{\r\n            int c = 4/0;\r\n            System.out.println(&quot;c=&quot;+c);\r\n            int[] arr = null;\r\n            System.out.println(arr.length);\r\n        }catch(Exception e){\r\n            e.printStackTrace(logPrintStream);\r\n        }\r\n    }\r\n}\r\n</code></pre>', '37', '打印流（PrintStream和PrintWriter）  打印流可以打印任意类型的数据，而且打印数据之前都会先把数据转换成字符串再进行打印。\r\n\r\nPrintStream：打印字节流。System.out对应的类型就是PrintStream。\r\n\r\nprint 方法和write方法的却别在于,print提供自动刷新。\r\n\r\n常用方法：\r\n\r\n1、构造方法\r\n\r\nPrintStream(File file) 创建具有指定文件且不带自动行刷新的新打印流。\r\n\r\nPrintStream(String fileName) 创建具有指定文件名称且不带自动行刷新的新打印流。\r\n\r\nPrintStream(OutputStream out) 创建新的打印流。2、打印方法：\r\n\r\nvoid print(数据类型 变量) 打印变量的值。 如果打印自定义对象，打印出来的内容是toString方法中返回的字符串。\r\n\r\nPrintWriter:打印字符流。\r\n\r\n常用方法\r\n\r\n1、构造方法\r\n\r\nPrintWriter(File file) 使用指定文件创建不具有自动行刷新的新 PrintWriter。\r\n\r\nPrintWriter(OutputStream out) 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。\r\n\r\n2、打印方法：\r\n\r\nvoid print(数据类型 变量) 打印变量的值。 如果打印自定义对象，打印出来的内容是toString方法中返回的字符串。\r\n\r\n应用场景：\r\n\r\n1、把控制台的信息输出到指定的文件中。\r\n\r\n2、收集异常的日志信息到指定文件。\r\n\r\n\r\n```\r\npublic class Demo6 {\r\n    \r\n    public static void main(String[] args) throws IOException {\r\n        //打印流可以打印任何类型的数据，而且打印数据之前都会先把数据转换成字符串再进行打印。\r\n        File file = new  File(\"F:\\\\a.txt\");\r\n        //创建一个打印流\r\n        PrintStream printStream = new PrintStream(file);\r\n        /*\r\n        printStream.println(97);\r\n        printStream.println(3.14);\r\n        printStream.println(\'a\');\r\n        printStream.println(true);\r\n        Animal a = new Animal(\"老鼠\", \"黑色\");\r\n        printStream.println(a);\r\n        \r\n        \r\n        //默认标准的输出流就是向控制台输出的，\r\n        System.setOut(printStream); //重新设置了标准的输出流对象\r\n        System.out.println(\"哈哈，猜猜我在哪里！！\");\r\n        */\r\n        \r\n        //收集异常的日志信息。\r\n        File logFile = new File(\"F:\\\\2015年1月8日.log\");\r\n        PrintStream logPrintStream = new PrintStream( new FileOutputStream(logFile,true) );\r\n        try{\r\n            int c = 4/0;\r\n            System.out.println(\"c=\"+c);\r\n            int[] arr = null;\r\n            System.out.println(arr.length);\r\n        }catch(Exception e){\r\n            e.printStackTrace(logPrintStream);\r\n        }\r\n    }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('23', '编码和解码', '<p>编码： 把看得懂的字符变成看不懂码值这个过程我们称作为编码。</p>\r\n<p>解码： 把码值查找对应的字符，我们把这个过程称作为解码。</p>\r\n<p>注意： 以后编码与解码一般我们都使用统一的码表。否则非常容易出乱码。</p>\r\n<p>常用码表：</p>\r\n<p>ASCII： 美国标准信息交换码。用一个字节的7位可以表示。</p>\r\n<p>ISO8859-1：   拉丁码表。欧洲码表，用一个字节的8位表示。又称Latin-1(拉丁编码)或“西欧语言”。ASCII码是包含的仅仅是英文字母，并且没有完全占满256个编码位置，所以它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。从而支持德文，法文等。因而它依然是一个单字节编码，只是比ASCII更全面。</p>\r\n<p>GB2312：   英文占一个字节， 中文占两个字节。中国的中文编码表。</p>\r\n<p>GBK：      中国的中文编码表升级，融合了更多的中文文字符号。</p>\r\n<p>Unicode：  国际标准码，融合了多种文字。所有文字都用两个字节来表示，Java语言使用的就是unicode。</p>\r\n<p>UTF-8： 英文占一个字节，中文占三个字节。    最多用三个字节来表示一个字符。</p>\r\n<p>UTF-16:  不管英文中文都是占两个字节。</p>\r\n<p>注意：接触最多的是iso8859-1、gbk、utf-8。Unicode是一种标准不是码表，如果写Unicode则默认使用UTF-16。</p>\r\n', '38', '编码： 把看得懂的字符变成看不懂码值这个过程我们称作为编码。\r\n \r\n解码： 把码值查找对应的字符，我们把这个过程称作为解码。\r\n\r\n注意： 以后编码与解码一般我们都使用统一的码表。否则非常容易出乱码。\r\n\r\n常用码表：\r\n\r\nASCII： 美国标准信息交换码。用一个字节的7位可以表示。\r\n\r\nISO8859-1：   拉丁码表。欧洲码表，用一个字节的8位表示。又称Latin-1(拉丁编码)或“西欧语言”。ASCII码是包含的仅仅是英文字母，并且没有完全占满256个编码位置，所以它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。从而支持德文，法文等。因而它依然是一个单字节编码，只是比ASCII更全面。\r\n\r\nGB2312：   英文占一个字节， 中文占两个字节。中国的中文编码表。\r\n\r\nGBK：      中国的中文编码表升级，融合了更多的中文文字符号。\r\n\r\nUnicode：  国际标准码，融合了多种文字。所有文字都用两个字节来表示，Java语言使用的就是unicode。\r\n\r\nUTF-8： 英文占一个字节，中文占三个字节。    最多用三个字节来表示一个字符。\r\n\r\nUTF-16:  不管英文中文都是占两个字节。\r\n\r\n注意：接触最多的是iso8859-1、gbk、utf-8。Unicode是一种标准不是码表，如果写Unicode则默认使用UTF-16。');
INSERT INTO `article_info_true` VALUES ('24', '转换流', '<p>输入字节流的转换流：InputStreamReader 是字节流通向字符流的桥梁。</p>\r\n<p>输出字节流的转换流：OutputStreamWriter  可以把输出字节流转换成输出字符流 。  是符流通向字节流的桥梁。</p>\r\n<p>转换流的作用：</p>\r\n<pre><code>1. 如果目前所获取到的是一个字节流需要转换字符流使用，这时候就可以使用转换流。  字节流----&gt; 字符流\r\n2. 使用转换流可以指定编码表进行读写文件。\r\n</code></pre><p>输入字节流InputStreamReader常用构造方法</p>\r\n<p>InputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。</p>\r\n<p>输出字节流OutputStreamWriter</p>\r\n<p>代码示例：</p>\r\n<p>常用构造方法</p>\r\n<p>OutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter。</p>\r\n<p>代码示例：</p>\r\n<pre><code>import java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\npublic class DemoTStream {\r\n    public static void main(String[] args) throws IOException {\r\n//        write();\r\n        read();\r\n    }\r\n\r\n    public static void read() throws IOException {\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        InputStreamReader reader = new InputStreamReader(new FileInputStream(file), &quot;utf-8&quot;);\r\n        char[] buf = new char[1024];\r\n        int length =0;\r\n        while((length = reader.read(buf)) != -1){\r\n            System.out.println(new String(buf,0,length));\r\n        }\r\n    }\r\n\r\n    public static void write() throws IOException {\r\n        File file = new File(&quot;E:\\\\nick.txt&quot;);\r\n        OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file,true),&quot;utf-8&quot;);\r\n        writer.write(&quot;中华小当家&quot;);\r\n        writer.close();\r\n    }\r\n\r\n}\r\n</code></pre><p>复制代码</p>\r\n', '39', '输入字节流的转换流：InputStreamReader 是字节流通向字符流的桥梁。\r\n\r\n输出字节流的转换流：OutputStreamWriter  可以把输出字节流转换成输出字符流 。  是符流通向字节流的桥梁。\r\n\r\n转换流的作用：\r\n    1. 如果目前所获取到的是一个字节流需要转换字符流使用，这时候就可以使用转换流。  字节流----> 字符流\r\n    2. 使用转换流可以指定编码表进行读写文件。\r\n\r\n输入字节流InputStreamReader常用构造方法\r\n\r\nInputStreamReader(InputStream in) 创建一个使用默认字符集的 InputStreamReader。\r\n\r\n输出字节流OutputStreamWriter\r\n\r\n代码示例：\r\n\r\n常用构造方法\r\n\r\nOutputStreamWriter(OutputStream out) 创建使用默认字符编码的 OutputStreamWriter。\r\n\r\n代码示例：\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\n\r\npublic class DemoTStream {\r\n    public static void main(String[] args) throws IOException {\r\n//        write();\r\n        read();\r\n    }\r\n    \r\n    public static void read() throws IOException {\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        InputStreamReader reader = new InputStreamReader(new FileInputStream(file), \"utf-8\");\r\n        char[] buf = new char[1024];\r\n        int length =0;\r\n        while((length = reader.read(buf)) != -1){\r\n            System.out.println(new String(buf,0,length));\r\n        }\r\n    }\r\n    \r\n    public static void write() throws IOException {\r\n        File file = new File(\"E:\\\\nick.txt\");\r\n        OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file,true),\"utf-8\");\r\n        writer.write(\"中华小当家\");\r\n        writer.close();\r\n    }\r\n\r\n}\r\n```\r\n复制代码');
INSERT INTO `article_info_true` VALUES ('25', '概述', '<p>java中的集合分为单列集合和双列集合。</p>\r\n<p>单列集合的树形体系：</p>\r\n<p>————-| Collection 单例集合的根接口<br>——————| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。<br>———————-| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。<br>———————-| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。<br>———————-| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的<br>——————| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。<br>————————| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。<br>HashSet添加元素的原理：<br>    往HashSet添加元素的时候，首先HashSet会调用元素的hashCode方法得到元素的哈希码值，然后会经过一系列运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况：<br>    情况1：如果算出该元素的位置目前没有任何元素存储，那么该元素可以直接存储　<br>    情况2： 如果算出该元素的位置目前已经存有其他的元素，那么还会调用元素的equals方法与该位置的元素再比较一次。<br>    如果equals方法返回的是false，那么该元素允许存储，如果euqlas方法返回的是true，那么该元素被视为重复元素，不允许存储。</p>\r\n<p>—————————| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储。</p>\r\n<p>TreeSet要注意的事项：</p>\r\n<pre><code>1. 往TreeSet添加元素的时候，如果元素本身具备自然顺序的特性，那么会根据元素自然顺序的特性进行排序存储。\r\n2. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么元素所属的类必须要实现Comparable接口，把元素的比较规则定义在CompareTo方法上。\r\n3. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而且元素所属的类没有实现Comparable接口，那么必须要在创建TreeSet对象的时候传入比较器。\r\n4. 如果比较的方法(CompareTo 或者Compare )返回的是0的时候，那么该元素就被视为重复元素，不允许添加。\r\n\r\n比较器的定义格式：  自定义一个类实现COmparator接口即可。\r\n\r\n    class 类名  implements Comparator{\r\n\r\n    }\r\n</code></pre><p>双列集合的树形关系</p>\r\n<p>——————-| Map  如果是实现了Map接口的集合类，具备的特点： 存储的数据都是以键值对的形式存在的，键不可重复，值可以重复。<br>————————| HashMap  底层也是基于哈希表实现 的。<br>HashMap的存储原理：<br>    往HashMap添加元素的时候，首先会调用键的hashCode方法得到元素 的哈希码值，然后经过运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况：<br>    情况1： 如果算出的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中。<br>    情况2：如果算出的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较，如果equals方法返回的是false，那么该元素允许被存储，如果equals方法返回的是true，那么该元素被视为重复元素，会覆盖原来的记录。</p>\r\n<p>————————| TreeMap   TreeMap也是基于红黑树（二叉树）数据结构实现 的， 特点：会对元素的键进行排序存储。</p>\r\n<p>TreeMap 要注意的事项：</p>\r\n<pre><code>1.  往TreeMap添加元素的时候，如果元素的键具备自然顺序，那么就会按照键的自然顺序特性进行排序存储。\r\n2.  往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性， 那么键所属的类必须要实现Comparable接口，把键的比较规则定义在CompareTo方法上。 \r\n3. 往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性，而且键所属的类也没有实现Comparable接口，那么就必须在创建TreeMap对象的时候传入比较器。\r\n</code></pre><p>————————| Hashtable  和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。</p>\r\n', '41', 'java中的集合分为单列集合和双列集合。\r\n\r\n单列集合的树形体系：\r\n\r\n---------| Collection 单例集合的根接口\r\n------------| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。\r\n---------------| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。\r\n---------------| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。\r\n---------------| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的\r\n------------| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。\r\n----------------| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。\r\nHashSet添加元素的原理：\r\n    往HashSet添加元素的时候，首先HashSet会调用元素的hashCode方法得到元素的哈希码值，然后会经过一系列运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况：   \r\n    情况1：如果算出该元素的位置目前没有任何元素存储，那么该元素可以直接存储　 \r\n    情况2： 如果算出该元素的位置目前已经存有其他的元素，那么还会调用元素的equals方法与该位置的元素再比较一次。\r\n    如果equals方法返回的是false，那么该元素允许存储，如果euqlas方法返回的是true，那么该元素被视为重复元素，不允许存储。\r\n\r\n\r\n------------------| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储。\r\n\r\nTreeSet要注意的事项：\r\n    1. 往TreeSet添加元素的时候，如果元素本身具备自然顺序的特性，那么会根据元素自然顺序的特性进行排序存储。\r\n    2. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么元素所属的类必须要实现Comparable接口，把元素的比较规则定义在CompareTo方法上。\r\n    3. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而且元素所属的类没有实现Comparable接口，那么必须要在创建TreeSet对象的时候传入比较器。\r\n    4. 如果比较的方法(CompareTo 或者Compare )返回的是0的时候，那么该元素就被视为重复元素，不允许添加。\r\n    \r\n    比较器的定义格式：  自定义一个类实现COmparator接口即可。\r\n        \r\n        class 类名  implements Comparator{\r\n        \r\n        }\r\n\r\n \r\n\r\n双列集合的树形关系\r\n\r\n-------------| Map  如果是实现了Map接口的集合类，具备的特点： 存储的数据都是以键值对的形式存在的，键不可重复，值可以重复。\r\n----------------| HashMap  底层也是基于哈希表实现 的。\r\nHashMap的存储原理：\r\n    往HashMap添加元素的时候，首先会调用键的hashCode方法得到元素 的哈希码值，然后经过运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况： \r\n    情况1： 如果算出的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中。\r\n    情况2：如果算出的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较，如果equals方法返回的是false，那么该元素允许被存储，如果equals方法返回的是true，那么该元素被视为重复元素，会覆盖原来的记录。\r\n\r\n----------------| TreeMap   TreeMap也是基于红黑树（二叉树）数据结构实现 的， 特点：会对元素的键进行排序存储。\r\n\r\nTreeMap 要注意的事项：\r\n    1.  往TreeMap添加元素的时候，如果元素的键具备自然顺序，那么就会按照键的自然顺序特性进行排序存储。\r\n    2.  往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性， 那么键所属的类必须要实现Comparable接口，把键的比较规则定义在CompareTo方法上。 \r\n    3. 往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性，而且键所属的类也没有实现Comparable接口，那么就必须在创建TreeMap对象的时候传入比较器。\r\n    \r\n----------------| Hashtable  和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。');
INSERT INTO `article_info_true` VALUES ('26', '集合类', '<p>java中的集合分为单列集合和双列集合。</p>\r\n<p>单列集合的树形体系：</p>\r\n<p>————-| Collection 单例集合的根接口<br>——————| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。<br>———————-| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。<br>———————-| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。<br>———————-| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的<br>——————| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。<br>————————| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。<br>HashSet添加元素的原理：<br>    往HashSet添加元素的时候，首先HashSet会调用元素的hashCode方法得到元素的哈希码值，然后会经过一系列运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况：<br>    情况1：如果算出该元素的位置目前没有任何元素存储，那么该元素可以直接存储　<br>    情况2： 如果算出该元素的位置目前已经存有其他的元素，那么还会调用元素的equals方法与该位置的元素再比较一次。<br>    如果equals方法返回的是false，那么该元素允许存储，如果euqlas方法返回的是true，那么该元素被视为重复元素，不允许存储。</p>\r\n<p>—————————| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储。</p>\r\n<p>TreeSet要注意的事项：</p>\r\n<pre><code>1. 往TreeSet添加元素的时候，如果元素本身具备自然顺序的特性，那么会根据元素自然顺序的特性进行排序存储。\r\n2. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么元素所属的类必须要实现Comparable接口，把元素的比较规则定义在CompareTo方法上。\r\n3. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而且元素所属的类没有实现Comparable接口，那么必须要在创建TreeSet对象的时候传入比较器。\r\n4. 如果比较的方法(CompareTo 或者Compare )返回的是0的时候，那么该元素就被视为重复元素，不允许添加。\r\n\r\n比较器的定义格式：  自定义一个类实现COmparator接口即可。\r\n\r\n    class 类名  implements Comparator{\r\n\r\n    }\r\n</code></pre><p>双列集合的树形关系</p>\r\n<p>——————-| Map  如果是实现了Map接口的集合类，具备的特点： 存储的数据都是以键值对的形式存在的，键不可重复，值可以重复。<br>————————| HashMap  底层也是基于哈希表实现 的。<br>HashMap的存储原理：<br>    往HashMap添加元素的时候，首先会调用键的hashCode方法得到元素 的哈希码值，然后经过运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况：<br>    情况1： 如果算出的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中。<br>    情况2：如果算出的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较，如果equals方法返回的是false，那么该元素允许被存储，如果equals方法返回的是true，那么该元素被视为重复元素，会覆盖原来的记录。</p>\r\n<p>————————| TreeMap   TreeMap也是基于红黑树（二叉树）数据结构实现 的， 特点：会对元素的键进行排序存储。</p>\r\n<p>TreeMap 要注意的事项：</p>\r\n<pre><code>1.  往TreeMap添加元素的时候，如果元素的键具备自然顺序，那么就会按照键的自然顺序特性进行排序存储。\r\n2.  往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性， 那么键所属的类必须要实现Comparable接口，把键的比较规则定义在CompareTo方法上。 \r\n3. 往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性，而且键所属的类也没有实现Comparable接口，那么就必须在创建TreeMap对象的时候传入比较器。\r\n</code></pre><p>————————| Hashtable  和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。</p>\r\n', '40', 'java中的集合分为单列集合和双列集合。\r\n\r\n单列集合的树形体系：\r\n\r\n---------| Collection 单例集合的根接口\r\n------------| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。\r\n---------------| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。\r\n---------------| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。\r\n---------------| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的\r\n------------| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。\r\n----------------| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。\r\nHashSet添加元素的原理：\r\n    往HashSet添加元素的时候，首先HashSet会调用元素的hashCode方法得到元素的哈希码值，然后会经过一系列运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况：   \r\n    情况1：如果算出该元素的位置目前没有任何元素存储，那么该元素可以直接存储　 \r\n    情况2： 如果算出该元素的位置目前已经存有其他的元素，那么还会调用元素的equals方法与该位置的元素再比较一次。\r\n    如果equals方法返回的是false，那么该元素允许存储，如果euqlas方法返回的是true，那么该元素被视为重复元素，不允许存储。\r\n\r\n\r\n------------------| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储。\r\n\r\nTreeSet要注意的事项：\r\n    1. 往TreeSet添加元素的时候，如果元素本身具备自然顺序的特性，那么会根据元素自然顺序的特性进行排序存储。\r\n    2. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么元素所属的类必须要实现Comparable接口，把元素的比较规则定义在CompareTo方法上。\r\n    3. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而且元素所属的类没有实现Comparable接口，那么必须要在创建TreeSet对象的时候传入比较器。\r\n    4. 如果比较的方法(CompareTo 或者Compare )返回的是0的时候，那么该元素就被视为重复元素，不允许添加。\r\n    \r\n    比较器的定义格式：  自定义一个类实现COmparator接口即可。\r\n        \r\n        class 类名  implements Comparator{\r\n        \r\n        }\r\n\r\n \r\n\r\n双列集合的树形关系\r\n\r\n-------------| Map  如果是实现了Map接口的集合类，具备的特点： 存储的数据都是以键值对的形式存在的，键不可重复，值可以重复。\r\n----------------| HashMap  底层也是基于哈希表实现 的。\r\nHashMap的存储原理：\r\n    往HashMap添加元素的时候，首先会调用键的hashCode方法得到元素 的哈希码值，然后经过运算就可以算出该元素在哈希表中的存储位置。存储的过程中存在以下两种情况： \r\n    情况1： 如果算出的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中。\r\n    情况2：如果算出的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较，如果equals方法返回的是false，那么该元素允许被存储，如果equals方法返回的是true，那么该元素被视为重复元素，会覆盖原来的记录。\r\n\r\n----------------| TreeMap   TreeMap也是基于红黑树（二叉树）数据结构实现 的， 特点：会对元素的键进行排序存储。\r\n\r\nTreeMap 要注意的事项：\r\n    1.  往TreeMap添加元素的时候，如果元素的键具备自然顺序，那么就会按照键的自然顺序特性进行排序存储。\r\n    2.  往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性， 那么键所属的类必须要实现Comparable接口，把键的比较规则定义在CompareTo方法上。 \r\n    3. 往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性，而且键所属的类也没有实现Comparable接口，那么就必须在创建TreeMap对象的时候传入比较器。\r\n    \r\n----------------| Hashtable  和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。');
INSERT INTO `article_info_true` VALUES ('27', '单列集合', '<p>集合(二)———单列集合</p>\r\n<p>集合：集合是存储对象数据的集合容器。</p>\r\n<p>集合比数组的优势：</p>\r\n<pre><code>1. 集合可以存储任意类型的对象数据，数组只能存储同一种数据类型 的数据。\r\n2. 集合的长度是会发生变化的，数组的长度是固定的。\r\n</code></pre><p>单列集合体系：</p>\r\n<p>————-| Collection 单例集合的根接口<br>——————| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。<br>———————-| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。<br>———————-| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。<br>———————-| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的<br>——————| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。<br>————————| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。</p>\r\n<p>————————| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储。</p>\r\n<p>凡是容器都具有增删改查的功能和对应的方法。</p>\r\n<p>collection接口中的方法：</p>\r\n<p>增加：</p>\r\n<p>boolean add(E e)  确保此 collection 包含指定的元素（可选操作）。</p>\r\n<p>boolean addAll(Collection&lt;? extends E&gt; c)  将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。</p>\r\n<p>删除：</p>\r\n<p>void clear() 移除此 collection 中的所有元素（可选操作）。</p>\r\n<p>boolean remove(Object o) 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。</p>\r\n<p>boolean removeAll(Collection&lt;?&gt; c) 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。</p>\r\n<p>boolean retainAll(Collection&lt;?&gt; c) 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。</p>\r\n<p>查看：</p>\r\n<p>int size() 返回此 collection 中的元素数。</p>\r\n<p>判断：</p>\r\n<p>boolean isEmpty()  如果此 collection 不包含元素，则返回 true。</p>\r\n<p>boolean contains(Object o) 如果此 collection 包含指定的元素，则返回 true。</p>\r\n<p>boolean containsAll(Collection&lt;?&gt; c)   如果此 collection 包含指定 collection 中的所有元素，则返回 true。</p>\r\n<p>迭代：</p>\r\n<p>Object[] toArray()  返回包含此 collection 中所有元素的数组。</p>\r\n<p>Iterator<E> iterator() 返回在此 collection 的元素上进行迭代的迭代器。</p>\r\n<p>迭代器的方法：</p>\r\n<p>boolean hasNext() 如果仍有元素可以迭代，则返回 true。</p>\r\n<p>E  next()  返回迭代的下一个元素。</p>\r\n<p>void remove() 从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。只能用在调用next方法之后，否则会报异常：java.lang.IllegalStateException</p>\r\n<p>代码示例如下：</p>\r\n<p>···<br>import java.util.ArrayList;<br>import java.util.Arrays;<br>import java.util.Collection;<br>import java.util.Iterator;</p>\r\n<p>public class DemoCollection {</p>\r\n<pre><code>public static void main(String[] args) {\r\n    //加入\r\n    Collection&lt;String&gt; collection = new ArrayList&lt;String&gt;();\r\n    System.out.println(&quot;加入元素是否成功？&quot;+ collection.add(&quot;张三&quot;));\r\n    collection.add(&quot;李四&quot;);\r\n    System.out.println(&quot;add之后的collection&quot;+collection);\r\n\r\n    Collection&lt;String&gt; collection2 = new ArrayList&lt;String&gt;();\r\n    collection2.add(&quot;王五&quot;);\r\n    collection2.add(&quot;赵六&quot;);\r\n    collection.addAll(collection2);\r\n    System.out.println(&quot;addAll之后的collection&quot;+collection);\r\n    //删除\r\n    System.out.println(&quot;删除是否成功？&quot;+collection2.remove(&quot;赵六1&quot;));\r\n    System.out.println(&quot;删除是否成功？&quot;+collection2.remove(&quot;赵六&quot;));\r\n    System.out.println(&quot;remove之后的collection2&quot;+collection2);\r\n    System.out.println(&quot;删除是否成功？&quot;+collection.removeAll(collection2));\r\n    System.out.println(&quot;removeAll之后的collection&quot;+collection);\r\n\r\n    Collection&lt;String&gt; collection3 = new ArrayList&lt;String&gt;();\r\n    collection3.add(&quot;赵六&quot;);\r\n    System.out.println(&quot;删除是否成功？&quot;+collection.retainAll(collection3));\r\n    System.out.println(&quot;retainAll之后的&quot;+collection);\r\n\r\n    collection2.clear();\r\n    System.out.println(&quot;clear之后的collection2？&quot;+collection2);\r\n    //查看\r\n    System.out.println(&quot;collection的元素个数：&quot;+collection.size());\r\n    //判断\r\n    System.out.println(&quot;collection时候为空?&quot;+collection.isEmpty());\r\n    System.out.println(&quot;collection是否包含赵六?&quot;+collection.contains(&quot;赵六&quot;));\r\n    System.out.println(&quot;collection是否包含collection3?&quot;+collection.containsAll(collection3));\r\n    //迭代\r\n    Object[] array = collection.toArray();\r\n    System.out.println(Arrays.toString(array));\r\n\r\n    Iterator&lt;String&gt; iterator = collection.iterator();\r\n    while (iterator.hasNext()) {\r\n        System.out.println(iterator.next());\r\n    }\r\n\r\n    Iterator&lt;String&gt; iterator2 = collection.iterator();\r\n    iterator2.next();\r\n    iterator2.remove();\r\n    System.out.println(&quot;collection中的&quot;+collection);\r\n}\r\n</code></pre><p>}<br>···</p>\r\n<p>List接口特有的方法：</p>\r\n<p>增加：</p>\r\n<p>void add(int index, E element) 在列表的指定位置插入指定元素（可选操作）。</p>\r\n<p>boolean addAll(int index, Collection&lt;? extends E&gt; c)  将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。</p>\r\n<p>修改：</p>\r\n<p>E set(int index, E element)  用指定元素替换列表中指定位置的元素（可选操作）。</p>\r\n<p>查看：</p>\r\n<p>E get(int index) 返回列表中指定位置的元素。</p>\r\n<p>int indexOf(Object o) 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。</p>\r\n<p>int lastIndexOf(Object o) 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。</p>\r\n<p>List<E> subList(int fromIndex, int toIndex) 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。</p>\r\n<p>迭代器：</p>\r\n<p>ListIterator<E> listIterator() 返回此列表元素的列表迭代器（按适当顺序）。</p>\r\n<p>ListIterator<E> listIterator(int index) 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。</p>\r\n<p>ListIterator接口特有的方法：</p>\r\n<p>boolean hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。</p>\r\n<p>E previous() 返回列表中的前一个元素。</p>\r\n<p>void add(E e)  将指定的元素插入列表（可选操作）。意思是把当前有元素插入到当前指针指向的位置上。</p>\r\n<p>void set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。</p>\r\n<p>迭代器在变量元素的时候要注意事项：</p>\r\n<p>1、在迭代器迭代元素 的过程中，不允许使用集合对象改变集合中的元素 个数，如果需要添加或者删除只能使用迭代器的方法进行操作。</p>\r\n<p>2、如果使用过了集合对象改变集合中元素个数那么就会出现ConcurrentModificationException异常。    </p>\r\n<p>迭代元素的过程中: 迭代器创建到使用结束的时间。</p>\r\n<p>代码示例如下：</p>\r\n<pre><code>import java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\n\r\npublic class DemoList {\r\n    public static void main(String[] args) {\r\n        List&lt;String&gt; list = new ArrayList&lt;String&gt;();\r\n        //增加\r\n        list.add(0, &quot;张三&quot;);\r\n        System.out.println(list);\r\n        List&lt;String&gt; list2 = new ArrayList&lt;String&gt;();\r\n        list2.add(&quot;李四&quot;);\r\n        list2.add(&quot;王五&quot;);\r\n        list.addAll(1, list2);\r\n        System.out.println(list);\r\n        //修改\r\n        list.set(2, &quot;赵六&quot;);\r\n        System.out.println(list);\r\n        //查看\r\n        System.out.println(&quot;索引为0的元素：&quot;+list.get(0));\r\n        System.out.println(&quot;李四的索引为：&quot;+list.indexOf(&quot;李四&quot;));\r\n        list.add(&quot;张三&quot;);\r\n        System.out.println(&quot;张三的索引为：&quot;+list.indexOf(&quot;张三&quot;));\r\n        System.out.println(&quot;张三最后一次出现的索引为：&quot;+list.lastIndexOf(&quot;张三&quot;));\r\n\r\n        List&lt;String&gt; list3 = list.subList(1, 3);\r\n        System.out.println(list3);\r\n\r\n        //迭代器\r\n        System.out.println(list);\r\n        ListIterator&lt;String&gt; listIterator = list.listIterator();\r\n        while(listIterator.hasNext()){\r\n            listIterator.add(&quot;哈哈&quot;);\r\n            System.out.print(listIterator.next()+&quot;,&quot;);\r\n//            listIterator.set(&quot;==&quot;); //只能用在next或者previous之后\r\n        }\r\n        System.out.println();\r\n        System.out.println(list);\r\n        while(listIterator.hasPrevious()){\r\n            list.remove(&quot;张三&quot;); //在迭代中不能修改List，否则会报异常ConcurrentModificationException\r\n            System.out.print(listIterator.previous()+&quot;,&quot;);\r\n        }\r\n    }\r\n}\r\n</code></pre><p>ArrayList类特有的方法：</p>\r\n<p>void ensureCapacity(int minCapacity)  如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。</p>\r\n<p>void trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。</p>\r\n<p>注意：ArrayList底层是维护了一个Object数组实现 的，使用无参构造函数时，Object数组默认的容量是10，当长度不够时，自动增长0.5倍。</p>\r\n<p>需求： 编写一个函数清除集合中重复书籍，书号相等即为重复。</p>\r\n<p>代码如下：</p>\r\n<pre><code>import java.util.ArrayList;\r\nimport java.util.ListIterator;\r\n\r\nclass Book{\r\n    int id;\r\n    String name;\r\n    public Book(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Book book = (Book) obj;\r\n        return this.id == book.id;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return &quot;[编号：&quot;+this.id +&quot;书名：&quot;+this.name+&quot;]&quot;;\r\n    }\r\n}\r\n\r\n\r\npublic class DemoList {\r\n    public static void main(String[] args) {\r\n        ArrayList&lt;Book&gt; list = new ArrayList&lt;Book&gt;();\r\n        list.add(new Book(110, &quot;西游记&quot;));\r\n        list.add(new Book(220, &quot;水浒传&quot;));\r\n        list.add(new Book(110, &quot;西门庆与潘金莲&quot;));\r\n        System.out.println(list);\r\n        System.out.println(clearRepeat(list));\r\n    }\r\n\r\n    public static ArrayList&lt;Book&gt; clearRepeat(ArrayList&lt;Book&gt; arrayList) {\r\n        ArrayList&lt;Book&gt; newList = new ArrayList&lt;Book&gt;();\r\n        ListIterator&lt;Book&gt; listIterator = arrayList.listIterator();\r\n        while(listIterator.hasNext()){\r\n            Book book = listIterator.next();\r\n            if (!newList.contains(book)) {\r\n                newList.add(book);\r\n            }\r\n        }\r\n        return newList;\r\n    }\r\n}\r\n</code></pre><p> LinkList类特有的方法：</p>\r\n<p>增加：</p>\r\n<p>void addFirst(E e) 将指定元素插入此列表的开头。</p>\r\n<p>void addLast(E e)  将指定元素添加到此列表的结尾。</p>\r\n<p>删除：</p>\r\n<p>E removeFirst() 移除并返回此列表的第一个元素。</p>\r\n<p>E removeLast() 移除并返回此列表的最后一个元素。</p>\r\n<p>查看：</p>\r\n<p>E getFirst() 返回此列表的第一个元素。</p>\r\n<p>E getLast() 返回此列表的最后一个元素。</p>\r\n<p>逆序迭代器：</p>\r\n<p>Iterator<E> descendingIterator() 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。</p>\r\n<p>与数据结构相关的函数：</p>\r\n<p>1：栈 （1.6）  : 主要是用于实现堆栈数据结构的存储方式。<br>      先进后出<br>      void push(E e) 将元素推入此列表所表示的堆栈。<br>      E pop() 从此列表所表示的堆栈处弹出一个元素。<br>2：队列（双端队列1.5）： 主要是为了让你们可以使用LinkedList模拟队列数据结构的存储方式。<br>      先进先出<br>      boolean offer(E e)  将指定元素添加到此列表的末尾（最后一个元素）。<br>      E poll()  获取并移除此列表的头（第一个元素）</p>\r\n<p>代码示例如下：</p>\r\n<pre><code>public class DemoList {\r\n    public static void main(String[] args) {\r\n        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();\r\n        //增加\r\n        list.add(&quot;李四&quot;);\r\n        list.addFirst(&quot;张三&quot;);\r\n        list.addLast(&quot;王五&quot;);\r\n        System.out.println(list);\r\n        //查看\r\n        System.out.println(list.getFirst());\r\n        System.out.println(list.getLast());\r\n        //逆序构造器\r\n        Iterator&lt;String&gt; iterator = list.descendingIterator();\r\n        while(iterator.hasNext()){\r\n            System.out.println(iterator.next());\r\n        }\r\n        //删除\r\n        list.removeLast();\r\n        System.out.println(list);\r\n        list.removeFirst();\r\n        System.out.println(list);\r\n        //与数据结构\r\n        //栈\r\n        list.push(&quot;战三&quot;);\r\n        System.out.println(list);\r\n        list.pop();\r\n        System.out.println(list);\r\n        //队列\r\n        list.offer(&quot;张三&quot;);\r\n        System.out.println(list);\r\n        list.poll();\r\n        System.out.println(list);\r\n\r\n    }\r\n}\r\n</code></pre><p>需求：使用LinkedList实现堆栈数据结构的存储方式与队列的数据结构存储方式。   </p>\r\n<p>代码如下：</p>\r\n<pre><code>class StackList&lt;T&gt;{\r\n    LinkedList&lt;T&gt; list;\r\n\r\n    public StackList() {\r\n        this.list = new LinkedList&lt;T&gt;();\r\n    }\r\n\r\n    public void push(T t) {\r\n        this.list.addFirst(t);\r\n    }\r\n\r\n    public T pop() {\r\n        return this.list.removeFirst();\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return list.toString();\r\n    }\r\n\r\n}\r\n\r\nclass QueueList&lt;T&gt;{\r\n    LinkedList&lt;T&gt; list;\r\n\r\n    public QueueList() {\r\n        this.list = new LinkedList&lt;T&gt;();\r\n    }\r\n\r\n    public boolean offer(T t) {\r\n        return this.list.offer(t);\r\n    }\r\n\r\n    public T poll() {\r\n        return this.list.poll();\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return this.list.toString();\r\n    }\r\n}\r\n\r\npublic class DemoList {\r\n    public static void main(String[] args) {\r\n        StackList&lt;String&gt; stackList = new StackList&lt;String&gt;();\r\n        stackList.push(&quot;张三&quot;);\r\n        stackList.push(&quot;李四&quot;);\r\n        stackList.push(&quot;王五&quot;);\r\n        System.out.println(stackList);\r\n        stackList.pop();\r\n        System.out.println(stackList);\r\n\r\n        QueueList&lt;String&gt; queueList = new QueueList&lt;String&gt;();\r\n        queueList.offer(&quot;张三&quot;);\r\n        queueList.offer(&quot;李四&quot;);\r\n        queueList.offer(&quot;王五&quot;);\r\n        System.out.println(queueList);\r\n        queueList.poll();\r\n        System.out.println(queueList);\r\n\r\n    }\r\n}\r\n</code></pre><p>需求： 使用LinkedList存储一副扑克牌，然后实现洗牌功能。</p>\r\n<pre><code>//扑克类\r\nclass Poker{\r\n\r\n    String  color; //花色\r\n    String num;    //点数\r\n\r\n    public Poker(String color, String num) {\r\n        super();\r\n        this.color = color;\r\n        this.num = num;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return &quot;{&quot;+color+num+&quot;}&quot;;\r\n    }\r\n}\r\n\r\npublic class Demo2 {\r\n\r\n    public static void main(String[] args) {\r\n        LinkedList pokers = createPoker();\r\n        shufflePoker(pokers);\r\n        showPoker(pokers);\r\n    }\r\n\r\n    //洗牌的功能\r\n    public static void shufflePoker(LinkedList pokers){\r\n        //创建随机数对象\r\n        Random random = new Random();\r\n        for(int i = 0 ; i &lt;100; i++){ \r\n            //随机产生两个索引值\r\n            int index1 = random.nextInt(pokers.size());\r\n            int index2 = random.nextInt(pokers.size());\r\n            //根据索引值取出两张牌，然后交换两张牌的顺序\r\n            Poker poker1 = (Poker) pokers.get(index1);\r\n            Poker poker2 = (Poker) pokers.get(index2);\r\n            pokers.set(index1, poker2);\r\n            pokers.set(index2, poker1);\r\n        }\r\n    }\r\n\r\n    //显示扑克牌\r\n    public static void showPoker(LinkedList pokers){\r\n        for(int i = 0 ; i&lt;pokers.size() ; i++){\r\n            System.out.print(pokers.get(i));\r\n            //换行\r\n            if(i%13==12){\r\n                System.out.println();\r\n            }\r\n        }\r\n    }\r\n\r\n    //生成扑克牌的方法\r\n    public static LinkedList createPoker(){\r\n        //该集合用于存储扑克对象。\r\n        LinkedList list = new LinkedList();        \r\n        //定义数组存储所有的花色与点数\r\n        String[] colors = {&quot;黑桃&quot;,&quot;红桃&quot;,&quot;梅花&quot;,&quot;方块&quot;};\r\n        String[] nums = {&quot;A&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;};\r\n        for(int i = 0 ; i &lt; colors.length ; i++){\r\n            for(int j = 0 ; j&lt;nums.length ; j++){\r\n                list.add(new Poker(colors[i], nums[j]));\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n}\r\n</code></pre><p>笔试题: 说出ArrayLsit与Vector的区别?<br>    相同点： ArrayList与Vector底层都是使用了Object数组实现的。<br>    不同点： </p>\r\n<pre><code>    1. ArrayList是线程不同步的，操作效率高。 \r\n       Vector是线程同步的，操作效率低。\r\n    2. ArrayList是JDK1.2出现，Vector是jdk1.0的时候出现的。\r\n</code></pre><p>set接口没有特有的方法</p>\r\n<p>set中的元素是无序不可重复的。</p>\r\n<p>hashSet的实现原理：底层是使用了一个哈希表支持的。</p>\r\n<p>往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中的存储位置。存储过程中有一下两种情况。<br>     情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。<br>　  情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不添加，如果equals方法返回的是false，那么该元素允许添加。</p>\r\n<p>需求：接受键盘录入用户名和密码来进行用户注册。如果用户名和密码已经存在，则不能完成注册。如果不存在，则注册成功。</p>\r\n<p>代码示例如下：</p>\r\n<pre><code>import java.util.HashSet;\r\nimport java.util.Scanner;\r\n\r\n//接受键盘录入用户名和密码来进行用户注册。如果用户名和密码已经存在，则不能完成注册。如果不存在，则注册成功。\r\nclass User{\r\n    String userName;\r\n    String password;\r\n    public User(String userName, String password) {\r\n        this.userName = userName;\r\n        this.password = password;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        // 如果两个字符串的内容一致，那么返回的hashCode 码肯定也会一致的。\r\n        return this.userName.hashCode() + this.password.hashCode();\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        User user = (User)obj;\r\n        return this.userName.equals(user.userName) &amp;&amp; this.password.equals(user.password);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n\r\n        return &quot;当前用户名：&quot;+this.userName + &quot;密码：&quot;+this.password;\r\n    }\r\n\r\n}\r\n\r\npublic class Set {\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n        HashSet&lt;User&gt; set = new HashSet&lt;User&gt;();\r\n        while(true){\r\n            System.out.println(&quot;请输入账号：&quot;);\r\n            String userName = scanner.next();\r\n            System.out.println(&quot;请输入密码：&quot;);\r\n            String password = scanner.next();\r\n            User user = new User(userName, password);\r\n\r\n            if (set.add(user)) {\r\n                System.out.println(&quot;注册成功&quot;);\r\n                System.out.println(set);\r\n            }else{\r\n                System.out.println(&quot;注册失败&quot;);\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><p>复制代码<br>treeSet</p>\r\n<p>内部实现：</p>\r\n<p>　　底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储</p>\r\n<p>注意事项：</p>\r\n<p>　  1. 往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。</p>\r\n<pre><code> 2. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable接口，把元素\r\n 的比较规则定义在compareTo(T o)方法上。 \r\n 3. 如果比较元素的时候，compareTo方法返回 的是0，那么该元素就被视为重复元素，不允许添加.(注意：TreeSet与HashCode、equals方法是没有任何关系。)\r\n 4. 往TreeSet添加元素的时候, 如果元素本身没有具备自然顺序 的特性，而元素所属的类也没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个比较器。\r\n 5.  往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口， 在创建TreeSet对象的时候也传入了比较器，那么是以比较器的比较规则优先使用。\r\n</code></pre><p>如何自定义定义比较器：</p>\r\n<p>　　自定义一个类实现Comparator接口即可，把元素与元素之间的比较规则定义在compare方法内即可。<br>自定义比较器的格式 ：<br>             class  类名  implements Comparator{<br>             }</p>\r\n<p>推荐使用：使用比较器(Comparator)。</p>\r\n<p>TreeSet存储具备自然顺序的元素，代码示例如下：</p>\r\n<pre><code>public class Set {\r\n\r\n    public static void main(String[] args) {\r\n        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;Integer&gt;();\r\n        treeSet.add(1);\r\n        treeSet.add(10);\r\n        treeSet.add(8);\r\n        treeSet.add(3);\r\n        treeSet.add(2);\r\n        System.out.println(treeSet);\r\n    }\r\n}\r\n</code></pre><p>TreeSet存储不具备自然顺序的元素，代码示例如下：</p>\r\n<p>当前类实现Comparable接口和public int compareTo(Object o)方法</p>\r\n<pre><code>class User implements Comparable&lt;User&gt;{\r\n    Integer id;\r\n    String userName;\r\n    String password;\r\n    public User(Integer id, String userName, String password) {\r\n        this.id = id;\r\n        this.userName = userName;\r\n        this.password = password;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(User o) {\r\n        User user = (User)o;\r\n        return this.id - user.id;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return &quot;id:&quot;+ this.id +&quot;  名字：&quot;+this.userName ;\r\n    }\r\n\r\n}\r\n\r\npublic class Set {\r\n\r\n    public static void main(String[] args) {\r\n        TreeSet&lt;User&gt; treeSet = new TreeSet&lt;User&gt;();\r\n        treeSet.add(new User(110, &quot;张三&quot;, &quot;123&quot;));\r\n        treeSet.add(new User(310, &quot;王五&quot;, &quot;123&quot;));\r\n        treeSet.add(new User(210, &quot;李四&quot;, &quot;123&quot;));\r\n        System.out.println(treeSet);\r\n    }\r\n}\r\n</code></pre><p>自定义比较器类</p>\r\n<pre><code>class User{\r\n    Integer id;\r\n    String userName;\r\n    String password;\r\n    public User(Integer id, String userName, String password) {\r\n        this.id = id;\r\n        this.userName = userName;\r\n        this.password = password;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return &quot;id:&quot;+ this.id +&quot;  名字：&quot;+this.userName ;\r\n    }\r\n\r\n}\r\n\r\nclass myComparator implements Comparator&lt;User&gt;{\r\n\r\n    @Override\r\n    public int compare(User o1, User o2) {\r\n        return o1.id - o2.id;\r\n    }\r\n}\r\n\r\npublic class Set {\r\n\r\n    public static void main(String[] args) {\r\n        TreeSet&lt;User&gt; treeSet = new TreeSet&lt;User&gt;(new myComparator());\r\n        treeSet.add(new User(110, &quot;张三&quot;, &quot;123&quot;));\r\n        treeSet.add(new User(310, &quot;王五&quot;, &quot;123&quot;));\r\n        treeSet.add(new User(210, &quot;李四&quot;, &quot;123&quot;));\r\n        System.out.println(treeSet);\r\n    }\r\n}\r\n</code></pre>', '42', '集合(二)------单列集合\r\n\r\n集合：集合是存储对象数据的集合容器。\r\n\r\n集合比数组的优势：\r\n    1. 集合可以存储任意类型的对象数据，数组只能存储同一种数据类型 的数据。\r\n    2. 集合的长度是会发生变化的，数组的长度是固定的。\r\n\r\n单列集合体系：\r\n\r\n---------| Collection 单例集合的根接口\r\n------------| List  如果是实现了List接口的集合类， 具备的特点：有序，重复。\r\n---------------| ArraryList  底层 是使用了Object数组实现的，特点： 查询速度快，增删慢。\r\n---------------| LinkedList 底层是使用了链表数据结构实现 的， 特点： 查询速度慢，增删快。\r\n---------------| Vector Vector的实现与ArrayList是一致，但是是线程安全 的，操作效率低。 jdk1.0的时候出现的\r\n------------| Set  如果是实现了Set接口的集合类，具备的特点：无序，不可重复。\r\n----------------| HashSet  底层是使用了一个哈希表支持的， 特点：存取速度快。\r\n\r\n----------------| TreeSet  底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储。\r\n\r\n \r\n\r\n凡是容器都具有增删改查的功能和对应的方法。\r\n\r\ncollection接口中的方法：\r\n\r\n增加：\r\n\r\nboolean add(E e)  确保此 collection 包含指定的元素（可选操作）。\r\n\r\nboolean addAll(Collection<? extends E> c)  将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。\r\n\r\n删除：\r\n\r\nvoid clear() 移除此 collection 中的所有元素（可选操作）。\r\n\r\nboolean remove(Object o) 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。\r\n\r\nboolean removeAll(Collection<?> c) 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。\r\n\r\nboolean retainAll(Collection<?> c) 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。\r\n\r\n查看：\r\n\r\nint size() 返回此 collection 中的元素数。\r\n\r\n判断：\r\n\r\nboolean isEmpty()  如果此 collection 不包含元素，则返回 true。\r\n\r\nboolean contains(Object o) 如果此 collection 包含指定的元素，则返回 true。\r\n\r\nboolean containsAll(Collection<?> c)   如果此 collection 包含指定 collection 中的所有元素，则返回 true。\r\n\r\n迭代：\r\n\r\nObject[] toArray()  返回包含此 collection 中所有元素的数组。\r\n\r\nIterator<E> iterator() 返回在此 collection 的元素上进行迭代的迭代器。\r\n\r\n迭代器的方法：\r\n\r\nboolean hasNext() 如果仍有元素可以迭代，则返回 true。\r\n\r\nE  next()  返回迭代的下一个元素。\r\n\r\nvoid remove() 从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。只能用在调用next方法之后，否则会报异常：java.lang.IllegalStateException\r\n\r\n代码示例如下：\r\n\r\n\r\n···\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collection;\r\nimport java.util.Iterator;\r\n\r\npublic class DemoCollection {\r\n\r\n    public static void main(String[] args) {\r\n        //加入\r\n        Collection<String> collection = new ArrayList<String>();\r\n        System.out.println(\"加入元素是否成功？\"+ collection.add(\"张三\"));\r\n        collection.add(\"李四\");\r\n        System.out.println(\"add之后的collection\"+collection);\r\n        \r\n        Collection<String> collection2 = new ArrayList<String>();\r\n        collection2.add(\"王五\");\r\n        collection2.add(\"赵六\");\r\n        collection.addAll(collection2);\r\n        System.out.println(\"addAll之后的collection\"+collection);\r\n        //删除\r\n        System.out.println(\"删除是否成功？\"+collection2.remove(\"赵六1\"));\r\n        System.out.println(\"删除是否成功？\"+collection2.remove(\"赵六\"));\r\n        System.out.println(\"remove之后的collection2\"+collection2);\r\n        System.out.println(\"删除是否成功？\"+collection.removeAll(collection2));\r\n        System.out.println(\"removeAll之后的collection\"+collection);\r\n        \r\n        Collection<String> collection3 = new ArrayList<String>();\r\n        collection3.add(\"赵六\");\r\n        System.out.println(\"删除是否成功？\"+collection.retainAll(collection3));\r\n        System.out.println(\"retainAll之后的\"+collection);\r\n        \r\n        collection2.clear();\r\n        System.out.println(\"clear之后的collection2？\"+collection2);\r\n        //查看\r\n        System.out.println(\"collection的元素个数：\"+collection.size());\r\n        //判断\r\n        System.out.println(\"collection时候为空?\"+collection.isEmpty());\r\n        System.out.println(\"collection是否包含赵六?\"+collection.contains(\"赵六\"));\r\n        System.out.println(\"collection是否包含collection3?\"+collection.containsAll(collection3));\r\n        //迭代\r\n        Object[] array = collection.toArray();\r\n        System.out.println(Arrays.toString(array));\r\n        \r\n        Iterator<String> iterator = collection.iterator();\r\n        while (iterator.hasNext()) {\r\n            System.out.println(iterator.next());\r\n        }\r\n        \r\n        Iterator<String> iterator2 = collection.iterator();\r\n        iterator2.next();\r\n        iterator2.remove();\r\n        System.out.println(\"collection中的\"+collection);\r\n    }\r\n    \r\n}\r\n···\r\n\r\nList接口特有的方法：\r\n\r\n增加：\r\n\r\nvoid add(int index, E element) 在列表的指定位置插入指定元素（可选操作）。\r\n\r\nboolean addAll(int index, Collection<? extends E> c)  将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。\r\n\r\n修改：\r\n\r\nE set(int index, E element)  用指定元素替换列表中指定位置的元素（可选操作）。\r\n\r\n查看：\r\n\r\nE get(int index) 返回列表中指定位置的元素。\r\n\r\nint indexOf(Object o) 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。\r\n\r\nint lastIndexOf(Object o) 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。\r\n\r\nList<E> subList(int fromIndex, int toIndex) 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。\r\n\r\n迭代器：\r\n\r\nListIterator<E> listIterator() 返回此列表元素的列表迭代器（按适当顺序）。\r\n\r\nListIterator<E> listIterator(int index) 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。\r\n\r\nListIterator接口特有的方法：\r\n\r\nboolean hasPrevious() 如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。\r\n\r\nE previous() 返回列表中的前一个元素。\r\n\r\nvoid add(E e)  将指定的元素插入列表（可选操作）。意思是把当前有元素插入到当前指针指向的位置上。\r\n\r\nvoid set(E e) 用指定元素替换 next 或 previous 返回的最后一个元素（可选操作）。\r\n\r\n迭代器在变量元素的时候要注意事项：\r\n\r\n1、在迭代器迭代元素 的过程中，不允许使用集合对象改变集合中的元素 个数，如果需要添加或者删除只能使用迭代器的方法进行操作。\r\n \r\n2、如果使用过了集合对象改变集合中元素个数那么就会出现ConcurrentModificationException异常。    \r\n \r\n迭代元素的过程中: 迭代器创建到使用结束的时间。\r\n\r\n代码示例如下：\r\n\r\n```\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.ListIterator;\r\n\r\npublic class DemoList {\r\n    public static void main(String[] args) {\r\n        List<String> list = new ArrayList<String>();\r\n        //增加\r\n        list.add(0, \"张三\");\r\n        System.out.println(list);\r\n        List<String> list2 = new ArrayList<String>();\r\n        list2.add(\"李四\");\r\n        list2.add(\"王五\");\r\n        list.addAll(1, list2);\r\n        System.out.println(list);\r\n        //修改\r\n        list.set(2, \"赵六\");\r\n        System.out.println(list);\r\n        //查看\r\n        System.out.println(\"索引为0的元素：\"+list.get(0));\r\n        System.out.println(\"李四的索引为：\"+list.indexOf(\"李四\"));\r\n        list.add(\"张三\");\r\n        System.out.println(\"张三的索引为：\"+list.indexOf(\"张三\"));\r\n        System.out.println(\"张三最后一次出现的索引为：\"+list.lastIndexOf(\"张三\"));\r\n        \r\n        List<String> list3 = list.subList(1, 3);\r\n        System.out.println(list3);\r\n        \r\n        //迭代器\r\n        System.out.println(list);\r\n        ListIterator<String> listIterator = list.listIterator();\r\n        while(listIterator.hasNext()){\r\n            listIterator.add(\"哈哈\");\r\n            System.out.print(listIterator.next()+\",\");\r\n//            listIterator.set(\"==\"); //只能用在next或者previous之后\r\n        }\r\n        System.out.println();\r\n        System.out.println(list);\r\n        while(listIterator.hasPrevious()){\r\n            list.remove(\"张三\"); //在迭代中不能修改List，否则会报异常ConcurrentModificationException\r\n            System.out.print(listIterator.previous()+\",\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nArrayList类特有的方法：\r\n\r\nvoid ensureCapacity(int minCapacity)  如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。\r\n\r\nvoid trimToSize() 将此 ArrayList 实例的容量调整为列表的当前大小。\r\n\r\n注意：ArrayList底层是维护了一个Object数组实现 的，使用无参构造函数时，Object数组默认的容量是10，当长度不够时，自动增长0.5倍。\r\n\r\n需求： 编写一个函数清除集合中重复书籍，书号相等即为重复。\r\n\r\n代码如下：\r\n\r\n```\r\nimport java.util.ArrayList;\r\nimport java.util.ListIterator;\r\n\r\nclass Book{\r\n    int id;\r\n    String name;\r\n    public Book(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    \r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Book book = (Book) obj;\r\n        return this.id == book.id;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"[编号：\"+this.id +\"书名：\"+this.name+\"]\";\r\n    }\r\n}\r\n\r\n\r\npublic class DemoList {\r\n    public static void main(String[] args) {\r\n        ArrayList<Book> list = new ArrayList<Book>();\r\n        list.add(new Book(110, \"西游记\"));\r\n        list.add(new Book(220, \"水浒传\"));\r\n        list.add(new Book(110, \"西门庆与潘金莲\"));\r\n        System.out.println(list);\r\n        System.out.println(clearRepeat(list));\r\n    }\r\n    \r\n    public static ArrayList<Book> clearRepeat(ArrayList<Book> arrayList) {\r\n        ArrayList<Book> newList = new ArrayList<Book>();\r\n        ListIterator<Book> listIterator = arrayList.listIterator();\r\n        while(listIterator.hasNext()){\r\n            Book book = listIterator.next();\r\n            if (!newList.contains(book)) {\r\n                newList.add(book);\r\n            }\r\n        }\r\n        return newList;\r\n    }\r\n}\r\n```\r\n LinkList类特有的方法：\r\n\r\n增加：\r\n\r\nvoid addFirst(E e) 将指定元素插入此列表的开头。\r\n\r\nvoid addLast(E e)  将指定元素添加到此列表的结尾。\r\n\r\n删除：\r\n\r\nE removeFirst() 移除并返回此列表的第一个元素。\r\n\r\nE removeLast() 移除并返回此列表的最后一个元素。\r\n\r\n查看：\r\n\r\nE getFirst() 返回此列表的第一个元素。\r\n\r\nE getLast() 返回此列表的最后一个元素。\r\n\r\n逆序迭代器：\r\n\r\nIterator<E> descendingIterator() 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。\r\n\r\n与数据结构相关的函数：\r\n\r\n1：栈 （1.6）  : 主要是用于实现堆栈数据结构的存储方式。\r\n      先进后出\r\n      void push(E e) 将元素推入此列表所表示的堆栈。\r\n      E pop() 从此列表所表示的堆栈处弹出一个元素。\r\n2：队列（双端队列1.5）： 主要是为了让你们可以使用LinkedList模拟队列数据结构的存储方式。\r\n      先进先出\r\n      boolean offer(E e)  将指定元素添加到此列表的末尾（最后一个元素）。\r\n      E poll()  获取并移除此列表的头（第一个元素）\r\n\r\n代码示例如下：\r\n```\r\npublic class DemoList {\r\n    public static void main(String[] args) {\r\n        LinkedList<String> list = new LinkedList<String>();\r\n        //增加\r\n        list.add(\"李四\");\r\n        list.addFirst(\"张三\");\r\n        list.addLast(\"王五\");\r\n        System.out.println(list);\r\n        //查看\r\n        System.out.println(list.getFirst());\r\n        System.out.println(list.getLast());\r\n        //逆序构造器\r\n        Iterator<String> iterator = list.descendingIterator();\r\n        while(iterator.hasNext()){\r\n            System.out.println(iterator.next());\r\n        }\r\n        //删除\r\n        list.removeLast();\r\n        System.out.println(list);\r\n        list.removeFirst();\r\n        System.out.println(list);\r\n        //与数据结构\r\n        //栈\r\n        list.push(\"战三\");\r\n        System.out.println(list);\r\n        list.pop();\r\n        System.out.println(list);\r\n        //队列\r\n        list.offer(\"张三\");\r\n        System.out.println(list);\r\n        list.poll();\r\n        System.out.println(list);\r\n        \r\n    }\r\n}\r\n```\r\n需求：使用LinkedList实现堆栈数据结构的存储方式与队列的数据结构存储方式。   \r\n\r\n代码如下：\r\n\r\n\r\n```\r\nclass StackList<T>{\r\n    LinkedList<T> list;\r\n\r\n    public StackList() {\r\n        this.list = new LinkedList<T>();\r\n    }\r\n    \r\n    public void push(T t) {\r\n        this.list.addFirst(t);\r\n    }\r\n    \r\n    public T pop() {\r\n        return this.list.removeFirst();\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return list.toString();\r\n    }\r\n    \r\n}\r\n\r\nclass QueueList<T>{\r\n    LinkedList<T> list;\r\n\r\n    public QueueList() {\r\n        this.list = new LinkedList<T>();\r\n    }\r\n    \r\n    public boolean offer(T t) {\r\n        return this.list.offer(t);\r\n    }\r\n    \r\n    public T poll() {\r\n        return this.list.poll();\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return this.list.toString();\r\n    }\r\n}\r\n\r\npublic class DemoList {\r\n    public static void main(String[] args) {\r\n        StackList<String> stackList = new StackList<String>();\r\n        stackList.push(\"张三\");\r\n        stackList.push(\"李四\");\r\n        stackList.push(\"王五\");\r\n        System.out.println(stackList);\r\n        stackList.pop();\r\n        System.out.println(stackList);\r\n        \r\n        QueueList<String> queueList = new QueueList<String>();\r\n        queueList.offer(\"张三\");\r\n        queueList.offer(\"李四\");\r\n        queueList.offer(\"王五\");\r\n        System.out.println(queueList);\r\n        queueList.poll();\r\n        System.out.println(queueList);\r\n        \r\n    }\r\n}\r\n```\r\n需求： 使用LinkedList存储一副扑克牌，然后实现洗牌功能。\r\n\r\n\r\n```\r\n//扑克类\r\nclass Poker{\r\n    \r\n    String  color; //花色\r\n    String num;    //点数\r\n\r\n    public Poker(String color, String num) {\r\n        super();\r\n        this.color = color;\r\n        this.num = num;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"{\"+color+num+\"}\";\r\n    }\r\n}\r\n\r\npublic class Demo2 {\r\n    \r\n    public static void main(String[] args) {\r\n        LinkedList pokers = createPoker();\r\n        shufflePoker(pokers);\r\n        showPoker(pokers);\r\n    }\r\n    \r\n    //洗牌的功能\r\n    public static void shufflePoker(LinkedList pokers){\r\n        //创建随机数对象\r\n        Random random = new Random();\r\n        for(int i = 0 ; i <100; i++){ \r\n            //随机产生两个索引值\r\n            int index1 = random.nextInt(pokers.size());\r\n            int index2 = random.nextInt(pokers.size());\r\n            //根据索引值取出两张牌，然后交换两张牌的顺序\r\n            Poker poker1 = (Poker) pokers.get(index1);\r\n            Poker poker2 = (Poker) pokers.get(index2);\r\n            pokers.set(index1, poker2);\r\n            pokers.set(index2, poker1);\r\n        }\r\n    }\r\n    \r\n    //显示扑克牌\r\n    public static void showPoker(LinkedList pokers){\r\n        for(int i = 0 ; i<pokers.size() ; i++){\r\n            System.out.print(pokers.get(i));\r\n            //换行\r\n            if(i%13==12){\r\n                System.out.println();\r\n            }\r\n        }\r\n    }\r\n    \r\n    //生成扑克牌的方法\r\n    public static LinkedList createPoker(){\r\n        //该集合用于存储扑克对象。\r\n        LinkedList list = new LinkedList();        \r\n        //定义数组存储所有的花色与点数\r\n        String[] colors = {\"黑桃\",\"红桃\",\"梅花\",\"方块\"};\r\n        String[] nums = {\"A\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\"};\r\n        for(int i = 0 ; i < colors.length ; i++){\r\n            for(int j = 0 ; j<nums.length ; j++){\r\n                list.add(new Poker(colors[i], nums[j]));\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n笔试题: 说出ArrayLsit与Vector的区别?\r\n    相同点： ArrayList与Vector底层都是使用了Object数组实现的。\r\n    不同点： \r\n        1. ArrayList是线程不同步的，操作效率高。 \r\n           Vector是线程同步的，操作效率低。\r\n        2. ArrayList是JDK1.2出现，Vector是jdk1.0的时候出现的。\r\n\r\nset接口没有特有的方法\r\n\r\nset中的元素是无序不可重复的。\r\n\r\nhashSet的实现原理：底层是使用了一个哈希表支持的。\r\n\r\n往Haset添加元素的时候，HashSet会先调用元素的hashCode方法得到元素的哈希值 ，然后通过元素 的哈希值经过移位等运算，就可以算出该元素在哈希表中的存储位置。存储过程中有一下两种情况。\r\n     情况1： 如果算出元素存储的位置目前没有任何元素存储，那么该元素可以直接存储到该位置上。\r\n　  情况2： 如果算出该元素的存储位置目前已经存在有其他的元素了，那么会调用该元素的equals方法与该位置的元素再比较一次，如果equals返回的是true，那么该元素与这个位置上的元素就视为重复元素，不添加，如果equals方法返回的是false，那么该元素允许添加。\r\n\r\n需求：接受键盘录入用户名和密码来进行用户注册。如果用户名和密码已经存在，则不能完成注册。如果不存在，则注册成功。\r\n\r\n代码示例如下：\r\n\r\n\r\n```\r\nimport java.util.HashSet;\r\nimport java.util.Scanner;\r\n\r\n//接受键盘录入用户名和密码来进行用户注册。如果用户名和密码已经存在，则不能完成注册。如果不存在，则注册成功。\r\nclass User{\r\n    String userName;\r\n    String password;\r\n    public User(String userName, String password) {\r\n        this.userName = userName;\r\n        this.password = password;\r\n    }\r\n    \r\n    @Override\r\n    public int hashCode() {\r\n        // 如果两个字符串的内容一致，那么返回的hashCode 码肯定也会一致的。\r\n        return this.userName.hashCode() + this.password.hashCode();\r\n    }\r\n    \r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        User user = (User)obj;\r\n        return this.userName.equals(user.userName) && this.password.equals(user.password);\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        \r\n        return \"当前用户名：\"+this.userName + \"密码：\"+this.password;\r\n    }\r\n    \r\n}\r\n\r\npublic class Set {\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n        HashSet<User> set = new HashSet<User>();\r\n        while(true){\r\n            System.out.println(\"请输入账号：\");\r\n            String userName = scanner.next();\r\n            System.out.println(\"请输入密码：\");\r\n            String password = scanner.next();\r\n            User user = new User(userName, password);\r\n            \r\n            if (set.add(user)) {\r\n                System.out.println(\"注册成功\");\r\n                System.out.println(set);\r\n            }else{\r\n                System.out.println(\"注册失败\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n复制代码\r\ntreeSet\r\n\r\n内部实现：\r\n\r\n　　底层是使用了红黑树（二叉树）数据结构实现的， 特点：会对元素进行排序存储\r\n\r\n注意事项：\r\n\r\n　  1. 往TreeSet添加元素的时候，如果元素本身具备了自然顺序的特性，那么就按照元素自然顺序的特性进行排序存储。\r\n     2. 往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，那么该元素所属的类必须要实现Comparable接口，把元素\r\n     的比较规则定义在compareTo(T o)方法上。 \r\n     3. 如果比较元素的时候，compareTo方法返回 的是0，那么该元素就被视为重复元素，不允许添加.(注意：TreeSet与HashCode、equals方法是没有任何关系。)\r\n     4. 往TreeSet添加元素的时候, 如果元素本身没有具备自然顺序 的特性，而元素所属的类也没有实现Comparable接口，那么必须要在创建TreeSet的时候传入一个比较器。\r\n     5.  往TreeSet添加元素的时候，如果元素本身不具备自然顺序的特性，而元素所属的类已经实现了Comparable接口， 在创建TreeSet对象的时候也传入了比较器，那么是以比较器的比较规则优先使用。\r\n\r\n如何自定义定义比较器：\r\n\r\n　　自定义一个类实现Comparator接口即可，把元素与元素之间的比较规则定义在compare方法内即可。\r\n自定义比较器的格式 ：\r\n             class  类名  implements Comparator{\r\n             }\r\n     \r\n推荐使用：使用比较器(Comparator)。\r\n\r\nTreeSet存储具备自然顺序的元素，代码示例如下：\r\n\r\n```\r\npublic class Set {\r\n    \r\n    public static void main(String[] args) {\r\n        TreeSet<Integer> treeSet = new TreeSet<Integer>();\r\n        treeSet.add(1);\r\n        treeSet.add(10);\r\n        treeSet.add(8);\r\n        treeSet.add(3);\r\n        treeSet.add(2);\r\n        System.out.println(treeSet);\r\n    }\r\n}\r\n```\r\nTreeSet存储不具备自然顺序的元素，代码示例如下：\r\n\r\n当前类实现Comparable接口和public int compareTo(Object o)方法\r\n\r\n\r\n```\r\nclass User implements Comparable<User>{\r\n    Integer id;\r\n    String userName;\r\n    String password;\r\n    public User(Integer id, String userName, String password) {\r\n        this.id = id;\r\n        this.userName = userName;\r\n        this.password = password;\r\n    }\r\n    \r\n    @Override\r\n    public int compareTo(User o) {\r\n        User user = (User)o;\r\n        return this.id - user.id;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"id:\"+ this.id +\"  名字：\"+this.userName ;\r\n    }\r\n    \r\n}\r\n\r\npublic class Set {\r\n    \r\n    public static void main(String[] args) {\r\n        TreeSet<User> treeSet = new TreeSet<User>();\r\n        treeSet.add(new User(110, \"张三\", \"123\"));\r\n        treeSet.add(new User(310, \"王五\", \"123\"));\r\n        treeSet.add(new User(210, \"李四\", \"123\"));\r\n        System.out.println(treeSet);\r\n    }\r\n}\r\n```\r\n自定义比较器类\r\n\r\n\r\n```\r\nclass User{\r\n    Integer id;\r\n    String userName;\r\n    String password;\r\n    public User(Integer id, String userName, String password) {\r\n        this.id = id;\r\n        this.userName = userName;\r\n        this.password = password;\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"id:\"+ this.id +\"  名字：\"+this.userName ;\r\n    }\r\n    \r\n}\r\n\r\nclass myComparator implements Comparator<User>{\r\n    \r\n    @Override\r\n    public int compare(User o1, User o2) {\r\n        return o1.id - o2.id;\r\n    }\r\n}\r\n\r\npublic class Set {\r\n    \r\n    public static void main(String[] args) {\r\n        TreeSet<User> treeSet = new TreeSet<User>(new myComparator());\r\n        treeSet.add(new User(110, \"张三\", \"123\"));\r\n        treeSet.add(new User(310, \"王五\", \"123\"));\r\n        treeSet.add(new User(210, \"李四\", \"123\"));\r\n        System.out.println(treeSet);\r\n    }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('28', '双列集合', '<p>所谓双列集合就是存在映射关系并且是成对存在的。</p>\r\n<p>双列集合体系：</p>\r\n<p>——————-| Map  如果是实现了Map接口的集合类，具备的特点： 存储的数据都是以键值对的形式存在的，键不可重复，值可以重复。<br>————————| HashMap  底层也是基于哈希表实现 的。<br>————————| TreeMap   TreeMap也是基于红黑树（二叉树）数据结构实现 的， 特点：会对元素的键进行排序存储。<br>————————| Hashtable 和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。</p>\r\n<p>Map接口常用方法：</p>\r\n<p>增加：</p>\r\n<p>V put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。</p>\r\n<p>void putAll(Map&lt;? extends K,? extends V&gt; m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</p>\r\n<p>删除：</p>\r\n<p>V remove(Object key)  如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</p>\r\n<p>void clear()  从此映射中移除所有映射关系（可选操作）。</p>\r\n<p>查看：</p>\r\n<p>int size() 返回此映射中的键-值映射关系数。</p>\r\n<p>V get(Object key)  返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</p>\r\n<p>判断：</p>\r\n<p>boolean isEmpty() 如果此映射未包含键-值映射关系，则返回 true。</p>\r\n<p>boolen containsKey(Object key) 如果此映射包含指定键的映射关系，则返回 true。</p>\r\n<p>boolen  containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true。</p>\r\n<p>迭代</p>\r\n<p>Set<K>keySet()  返回此映射中包含的键的 Set 视图。</p>\r\n<p>Collection<V> values()  返回此映射中包含的值的 Collection 视图。</p>\r\n<p>Set<Map.Entry<K,V>&gt; entrySet()  返回此映射中包含的映射关系的 Set 视图。</p>\r\n<p>Map.entr<K,V>中的方法</p>\r\n<p>K getKey() 返回与此项对应的键。</p>\r\n<p>V getValue() 返回与此项对应的值。</p>\r\n<p>V setValue(V value) 用指定的值替换与此项对应的值（可选操作）。返回与此项对应的旧值</p>\r\n<p>代码示例：</p>\r\n<pre><code>public class DemoMap {\r\n    public static void main(String[] args) {\r\n        Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();\r\n        //添加\r\n        map.put(&quot;a&quot;, &quot;张三&quot;);\r\n        map.put(&quot;b&quot;, &quot;李四&quot;);\r\n        map.put(&quot;c&quot;, &quot;王五&quot;);\r\n        System.out.println(map);\r\n        map.put(&quot;a&quot;, &quot;赵六&quot;);\r\n        System.out.println(map);\r\n\r\n        Map&lt;String, String&gt; map2 = new HashMap&lt;String,String&gt;();\r\n        map2.put(&quot;d&quot;, &quot;李磊&quot;);\r\n        map2.put(&quot;e&quot;, &quot;韩梅梅&quot;);\r\n        map.putAll(map2);\r\n        System.out.println(map);\r\n\r\n        //查看\r\n        System.out.println(&quot;size:&quot; + map.size());\r\n        System.out.println(&quot;value:&quot; + map.get(&quot;a&quot;));\r\n        //迭代\r\n        Set&lt;String&gt; set = map.keySet();\r\n        System.out.println(&quot;map中的key：&quot;+set);\r\n        Collection&lt;String&gt; collection = map.values();\r\n        System.out.println(&quot;map中的value：&quot;+collection);\r\n        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();\r\n        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entrySet.iterator();\r\n        while(iterator.hasNext()){\r\n            Map.Entry&lt;String, String&gt; entry = iterator.next();\r\n//            entry.setValue(&quot;哈哈哈&quot;);\r\n            System.out.println(&quot;key:&quot;+entry.getKey() + &quot; value:&quot;+entry.getValue());\r\n        }\r\n\r\n        //判断\r\n        System.out.println(&quot;是否为空：&quot;+map.isEmpty());\r\n        System.out.println(&quot;key是否a：&quot;+map.containsKey(&quot;a&quot;));\r\n        System.out.println(&quot;value是否为空：&quot;+map.containsValue(&quot;李磊&quot;));\r\n        //删除\r\n        map.remove(&quot;e&quot;);\r\n        System.out.println(map);\r\n        map.clear();\r\n        System.out.println(map);\r\n    }\r\n}\r\n</code></pre><p>HashMap</p>\r\n<p>HashMap的存储原理：<br>    往HashMap添加元素的时候，首先会调用键的hashCode方法得到元素 的哈希码值，然后经过运算就可以算出该元素在哈希表中的存储位置。<br>    情况1： 如果算出的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中。<br>    情况2：如果算出 的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较，如果equals方法返回的是false，那么该元素允许被存储，如果equals方法返回的是true，那么该元素被视为重复元素，替换掉原来的旧值。</p>\r\n<p>代码示例：</p>\r\n<pre><code>class Person{\r\n    int id;\r\n    String name;\r\n    public Person(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Person person = (Person)obj;\r\n        return this.id == person.id;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return &quot;{id :&quot;+ this.id + &quot;  名字:&quot;+ this.name+&quot;}&quot;;\r\n    }\r\n}\r\n\r\npublic class DemoMap {\r\n    public static void main(String[] args) {\r\n        HashMap&lt;Person, String&gt; map = new HashMap&lt;Person,String&gt;();\r\n        map.put(new Person(110, &quot;张三&quot;), &quot;110&quot;);\r\n        map.put(new Person(210, &quot;李四&quot;), &quot;210&quot;);\r\n        map.put(new Person(310, &quot;王五&quot;), &quot;310&quot;);\r\n        System.out.println(map);\r\n        map.put(new Person(310, &quot;赵六&quot;), &quot;410&quot;);\r\n        System.out.println(map);\r\n    }\r\n}\r\n</code></pre><p>TreeMap</p>\r\n<p>TreeMap 要注意的事项：</p>\r\n<p>　 1.  往TreeMap添加元素的时候，如果元素的键具备自然顺序，那么就会按照键的自然顺序特性进行排序存储。</p>\r\n<pre><code>2.  往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性， 那么键所属的类必须要实现Comparable接口，把键的比较规则定义在CompareTo方法上。\r\n3. 往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性，而且键所属的类也没有实现Comparable接口，那么就必须在创建TreeMap对象的时候传入比较器。\r\n</code></pre><p>代码示例：</p>\r\n<p>实现Comparable接口</p>\r\n<pre><code>class Person implements Comparable&lt;Person&gt;{\r\n    int id;\r\n    String name;\r\n    public Person(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Person person = (Person)obj;\r\n        return this.id == person.id;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return &quot;{id :&quot;+ this.id + &quot;  名字:&quot;+ this.name+&quot;}&quot;;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Person o) {\r\n        return this.id-o.id;\r\n    }\r\n}\r\n\r\npublic class DemoMap {\r\n    public static void main(String[] args) {\r\n        TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;Person, String&gt;();\r\n        treeMap.put(new Person(110, &quot;张三&quot;), &quot;110&quot;);\r\n        treeMap.put(new Person(310, &quot;王五&quot;), &quot;310&quot;);\r\n        treeMap.put(new Person(210, &quot;李四&quot;), &quot;210&quot;);\r\n        System.out.println(treeMap);\r\n    }\r\n}\r\n</code></pre><p>自定义比较器</p>\r\n<pre><code>import java.util.Comparator;\r\nimport java.util.TreeMap;\r\n\r\n\r\nclass Person{\r\n    int id;\r\n    String name;\r\n    public Person(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Person person = (Person)obj;\r\n        return this.id == person.id;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return &quot;{id :&quot;+ this.id + &quot;  名字:&quot;+ this.name+&quot;}&quot;;\r\n    }\r\n\r\n}\r\n\r\nclass MapComparator implements Comparator&lt;Person&gt;{\r\n\r\n    @Override\r\n    public int compare(Person o1, Person o2) {\r\n        return o1.id - o2.id;\r\n    }\r\n}\r\n\r\npublic class DemoMap {\r\n    public static void main(String[] args) {\r\n        TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;Person, String&gt;(new MapComparator());\r\n        treeMap.put(new Person(110, &quot;张三&quot;), &quot;110&quot;);\r\n        treeMap.put(new Person(310, &quot;王五&quot;), &quot;310&quot;);\r\n        treeMap.put(new Person(210, &quot;李四&quot;), &quot;210&quot;);\r\n        System.out.println(treeMap);\r\n    }\r\n}\r\n</code></pre><p>HashTable</p>\r\n<p>和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。</p>\r\n', '43', '所谓双列集合就是存在映射关系并且是成对存在的。\r\n\r\n双列集合体系：\r\n\r\n-------------| Map  如果是实现了Map接口的集合类，具备的特点： 存储的数据都是以键值对的形式存在的，键不可重复，值可以重复。\r\n----------------| HashMap  底层也是基于哈希表实现 的。\r\n----------------| TreeMap   TreeMap也是基于红黑树（二叉树）数据结构实现 的， 特点：会对元素的键进行排序存储。\r\n----------------| Hashtable 和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。\r\n\r\nMap接口常用方法：\r\n\r\n增加：\r\n\r\nV put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。\r\n\r\nvoid putAll(Map<? extends K,? extends V> m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。\r\n\r\n删除：\r\n\r\nV remove(Object key)  如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。\r\n\r\nvoid clear()  从此映射中移除所有映射关系（可选操作）。\r\n\r\n查看：\r\n\r\nint size() 返回此映射中的键-值映射关系数。\r\n\r\nV get(Object key)  返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。\r\n\r\n \r\n\r\n判断：\r\n\r\nboolean isEmpty() 如果此映射未包含键-值映射关系，则返回 true。\r\n\r\nboolen containsKey(Object key) 如果此映射包含指定键的映射关系，则返回 true。\r\n\r\nboolen  containsValue(Object value) 如果此映射将一个或多个键映射到指定值，则返回 true。\r\n\r\n迭代\r\n\r\nSet<K>keySet()  返回此映射中包含的键的 Set 视图。\r\n\r\nCollection<V> values()  返回此映射中包含的值的 Collection 视图。\r\n\r\nSet<Map.Entry<K,V>> entrySet()  返回此映射中包含的映射关系的 Set 视图。\r\n\r\nMap.entr<K,V>中的方法\r\n\r\nK getKey() 返回与此项对应的键。\r\n\r\nV getValue() 返回与此项对应的值。\r\n\r\nV setValue(V value) 用指定的值替换与此项对应的值（可选操作）。返回与此项对应的旧值\r\n\r\n代码示例：\r\n```\r\npublic class DemoMap {\r\n    public static void main(String[] args) {\r\n        Map<String,String> map = new HashMap<String, String>();\r\n        //添加\r\n        map.put(\"a\", \"张三\");\r\n        map.put(\"b\", \"李四\");\r\n        map.put(\"c\", \"王五\");\r\n        System.out.println(map);\r\n        map.put(\"a\", \"赵六\");\r\n        System.out.println(map);\r\n        \r\n        Map<String, String> map2 = new HashMap<String,String>();\r\n        map2.put(\"d\", \"李磊\");\r\n        map2.put(\"e\", \"韩梅梅\");\r\n        map.putAll(map2);\r\n        System.out.println(map);\r\n        \r\n        //查看\r\n        System.out.println(\"size:\" + map.size());\r\n        System.out.println(\"value:\" + map.get(\"a\"));\r\n        //迭代\r\n        Set<String> set = map.keySet();\r\n        System.out.println(\"map中的key：\"+set);\r\n        Collection<String> collection = map.values();\r\n        System.out.println(\"map中的value：\"+collection);\r\n        Set<Map.Entry<String, String>> entrySet = map.entrySet();\r\n        Iterator<Map.Entry<String, String>> iterator = entrySet.iterator();\r\n        while(iterator.hasNext()){\r\n            Map.Entry<String, String> entry = iterator.next();\r\n//            entry.setValue(\"哈哈哈\");\r\n            System.out.println(\"key:\"+entry.getKey() + \" value:\"+entry.getValue());\r\n        }\r\n        \r\n        //判断\r\n        System.out.println(\"是否为空：\"+map.isEmpty());\r\n        System.out.println(\"key是否a：\"+map.containsKey(\"a\"));\r\n        System.out.println(\"value是否为空：\"+map.containsValue(\"李磊\"));\r\n        //删除\r\n        map.remove(\"e\");\r\n        System.out.println(map);\r\n        map.clear();\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\nHashMap\r\n\r\nHashMap的存储原理：\r\n    往HashMap添加元素的时候，首先会调用键的hashCode方法得到元素 的哈希码值，然后经过运算就可以算出该元素在哈希表中的存储位置。 \r\n    情况1： 如果算出的位置目前没有任何元素存储，那么该元素可以直接添加到哈希表中。\r\n    情况2：如果算出 的位置目前已经存在其他的元素，那么还会调用该元素的equals方法与这个位置上的元素进行比较，如果equals方法返回的是false，那么该元素允许被存储，如果equals方法返回的是true，那么该元素被视为重复元素，替换掉原来的旧值。\r\n\r\n代码示例：\r\n```\r\nclass Person{\r\n    int id;\r\n    String name;\r\n    public Person(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Person person = (Person)obj;\r\n        return this.id == person.id;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"{id :\"+ this.id + \"  名字:\"+ this.name+\"}\";\r\n    }\r\n}\r\n\r\npublic class DemoMap {\r\n    public static void main(String[] args) {\r\n        HashMap<Person, String> map = new HashMap<Person,String>();\r\n        map.put(new Person(110, \"张三\"), \"110\");\r\n        map.put(new Person(210, \"李四\"), \"210\");\r\n        map.put(new Person(310, \"王五\"), \"310\");\r\n        System.out.println(map);\r\n        map.put(new Person(310, \"赵六\"), \"410\");\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\nTreeMap\r\n\r\nTreeMap 要注意的事项：\r\n\r\n　 1.  往TreeMap添加元素的时候，如果元素的键具备自然顺序，那么就会按照键的自然顺序特性进行排序存储。\r\n    2.  往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性， 那么键所属的类必须要实现Comparable接口，把键的比较规则定义在CompareTo方法上。\r\n    3. 往TreeMap添加元素的时候，如果元素的键不具备自然顺序特性，而且键所属的类也没有实现Comparable接口，那么就必须在创建TreeMap对象的时候传入比较器。\r\n\r\n代码示例：\r\n\r\n实现Comparable接口\r\n\r\n```\r\nclass Person implements Comparable<Person>{\r\n    int id;\r\n    String name;\r\n    public Person(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Person person = (Person)obj;\r\n        return this.id == person.id;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"{id :\"+ this.id + \"  名字:\"+ this.name+\"}\";\r\n    }\r\n    \r\n    @Override\r\n    public int compareTo(Person o) {\r\n        return this.id-o.id;\r\n    }\r\n}\r\n\r\npublic class DemoMap {\r\n    public static void main(String[] args) {\r\n        TreeMap<Person, String> treeMap = new TreeMap<Person, String>();\r\n        treeMap.put(new Person(110, \"张三\"), \"110\");\r\n        treeMap.put(new Person(310, \"王五\"), \"310\");\r\n        treeMap.put(new Person(210, \"李四\"), \"210\");\r\n        System.out.println(treeMap);\r\n    }\r\n}\r\n```\r\n自定义比较器\r\n\r\n\r\n```\r\nimport java.util.Comparator;\r\nimport java.util.TreeMap;\r\n\r\n\r\nclass Person{\r\n    int id;\r\n    String name;\r\n    public Person(int id, String name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public int hashCode() {\r\n        return this.id;\r\n    }\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        Person person = (Person)obj;\r\n        return this.id == person.id;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"{id :\"+ this.id + \"  名字:\"+ this.name+\"}\";\r\n    }\r\n\r\n}\r\n\r\nclass MapComparator implements Comparator<Person>{\r\n    \r\n    @Override\r\n    public int compare(Person o1, Person o2) {\r\n        return o1.id - o2.id;\r\n    }\r\n}\r\n\r\npublic class DemoMap {\r\n    public static void main(String[] args) {\r\n        TreeMap<Person, String> treeMap = new TreeMap<Person, String>(new MapComparator());\r\n        treeMap.put(new Person(110, \"张三\"), \"110\");\r\n        treeMap.put(new Person(310, \"王五\"), \"310\");\r\n        treeMap.put(new Person(210, \"李四\"), \"210\");\r\n        System.out.println(treeMap);\r\n    }\r\n}\r\n```\r\nHashTable\r\n\r\n和hashMap实现原理一样，但是是线程安全的，执行效率低。出现于JDK1.0。');
INSERT INTO `article_info_true` VALUES ('29', 'COLLECTIONS和ARRAYS常用方法', '<p>Collections：常见方法：</p>\r\n<p>1， 对list进行二分查找：</p>\r\n<p>前提该集合一定要有序。</p>\r\n<p>int binarySearch(list,key);</p>\r\n<p>//必须根据元素自然顺序对列表进行升级排序</p>\r\n<p>//要求list 集合中的元素都是Comparable 的子类。</p>\r\n<p>int binarySearch(list,key,Comparator);</p>\r\n<p>2，对list集合进行排序。</p>\r\n<p>sort(list);</p>\r\n<p>//对list进行排序,其实使用的事list容器中的对象的compareTo方法</p>\r\n<p>sort(list,comaprator);</p>\r\n<p>//按照指定比较器进行排序</p>\r\n<p>3，对集合取最大值或者最小值。</p>\r\n<p>max(Collection)</p>\r\n<p>max(Collection,comparator)</p>\r\n<p>min(Collection)</p>\r\n<p>min(Collection,comparator)<br>4，对list集合进行反转。</p>\r\n<p>reverse(list);</p>\r\n<p>8，可以将不同步的集合变成同步的集合。</p>\r\n<p>Set synchronizedSet(Set<T> s)</p>\r\n<p>Map synchronizedMap(Map<K,V> m)</p>\r\n<p>List synchronizedList(List<T> list)</p>\r\n<p>Arrays常用的方法</p>\r\n<p>1，二分查找,数组需要有序</p>\r\n<p>binarySearch(int[])</p>\r\n<p>binarySearch(double[])</p>\r\n<p>2，数组排序</p>\r\n<p>sort(int[])</p>\r\n<p>sort(char[])……</p>\r\n<p>1， 将数组变成字符串。</p>\r\n<p> toString(int[])</p>\r\n<p>2， 复制数组。<br> copyOf();</p>\r\n<p>3， 复制部分数组。</p>\r\n<p>copyOfRange():</p>\r\n<p>4， 比较两个数组是否相同。</p>\r\n<p>equals(int[],int[]);</p>\r\n<p>5， 将数组变成集合。</p>\r\n<p>List asList(T[]);</p>\r\n<p>这样可以通过集合的操作来操作数组中元素，</p>\r\n<p>但是不可以使用增删方法，add，remove。因为数组长度是固定的，会出现UnsupportOperationExcetion。可以使用的方法：contains，indexOf。。。</p>\r\n<p>如果数组中存入的基本数据类型，那么asList会将数组实体作为集合中的元素。如果数组中的存入的引用数据类型，那么asList会将数组中的元素作为集合中的元素。</p>\r\n', '44', 'Collections：常见方法：\r\n\r\n1， 对list进行二分查找：\r\n\r\n前提该集合一定要有序。\r\n\r\nint binarySearch(list,key);\r\n\r\n//必须根据元素自然顺序对列表进行升级排序\r\n\r\n//要求list 集合中的元素都是Comparable 的子类。\r\n\r\nint binarySearch(list,key,Comparator);\r\n\r\n2，对list集合进行排序。\r\n\r\nsort(list);\r\n\r\n//对list进行排序,其实使用的事list容器中的对象的compareTo方法\r\n\r\nsort(list,comaprator);\r\n\r\n//按照指定比较器进行排序\r\n\r\n3，对集合取最大值或者最小值。\r\n\r\nmax(Collection)\r\n\r\nmax(Collection,comparator)\r\n\r\nmin(Collection)\r\n\r\nmin(Collection,comparator)\r\n4，对list集合进行反转。\r\n\r\nreverse(list);\r\n\r\n8，可以将不同步的集合变成同步的集合。\r\n\r\nSet synchronizedSet(Set<T> s)\r\n\r\nMap synchronizedMap(Map<K,V> m)\r\n\r\nList synchronizedList(List<T> list)\r\n\r\nArrays常用的方法\r\n\r\n1，二分查找,数组需要有序\r\n\r\nbinarySearch(int[])\r\n\r\nbinarySearch(double[])\r\n\r\n \r\n\r\n2，数组排序\r\n\r\nsort(int[])\r\n\r\nsort(char[])……\r\n\r\n1， 将数组变成字符串。\r\n\r\n toString(int[])\r\n\r\n2， 复制数组。\r\n copyOf();\r\n\r\n3， 复制部分数组。\r\n\r\ncopyOfRange():\r\n\r\n4， 比较两个数组是否相同。\r\n\r\nequals(int[],int[]);\r\n\r\n5， 将数组变成集合。\r\n\r\nList asList(T[]);\r\n\r\n这样可以通过集合的操作来操作数组中元素，\r\n\r\n但是不可以使用增删方法，add，remove。因为数组长度是固定的，会出现UnsupportOperationExcetion。可以使用的方法：contains，indexOf。。。\r\n\r\n如果数组中存入的基本数据类型，那么asList会将数组实体作为集合中的元素。如果数组中的存入的引用数据类型，那么asList会将数组中的元素作为集合中的元素。');
INSERT INTO `article_info_true` VALUES ('30', '变量和数据类型', '<p><img src=\"http://ww3.sinaimg.cn/large/006pQ25sgw1f2u1avb9tfj30bb06h0t2.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1. 变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 变量</h3><p>计算机处理数据，变量被用来存储处理的数据，之所以叫做变量因为你可以改变存储的值。更确切的说，一个变量指向着一块存储特定类型值的地址，换句话说，一个变量有名称、类型和值。一个变量有一个名称，例如radius、area、age和height，每个变量的名称都是唯一的，这边可以方便我们设置和获取变量的值。</p>\r\n<p>一个变量有一种类型，下面是Java类型的列子:</p>\r\n<ul>\r\n<li>int: 表示整数例如123和-456</li><li>double: 表示浮点数例如3.1416、-55.66、1.2e3和-4.5E-6</li><li>String: 表示文本例如”Hello”、”Good Morning!”，文本通常嵌入在双引号里面</li><li>char: 表示单个字符例如’a’,’8’，单个字符通常嵌入在单引号里面。</li></ul>\r\n<p>变量存储特定类型的值，编程中要特别注意变量类型，举例：一个int变量存储整数123，但是不能存储浮点数12.34，同样也不能存储文本”Hello”。<br>早期的编程语言中引入了类型的概念来解释二进制01数据，类型定义了数据的结构、大小、范围以及针对该类型的一系列操作。</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_Variable.png\" alt=\"variable\"></p>\r\n<h3 id=\"h3-2-\"><a name=\"2. 名称\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 名称</h3><p>需要唯一的标识来命名变量，Java遵循以下标识的命名方式：</p>\r\n<ul>\r\n<li>标识由大小写字母、数字、下划线和$的任意长度的字符序列组成。</li><li>空白 (空格、制表符、换行符)和其他特殊字符 (如+ - * / @ ＆, 等)是不允许的，错误的命名方式：max value和max-value。</li><li>标识符不能以数字(0-9)开头必须以字母(a-z, A-Z)、下划线(_)和$开头，系统保留以$开头的标识。</li><li>标识符不能使用关键字和预留字段 (例如：class,int,double,if,else,for,true,false,null)。</li><li>标识符是区分大小写的，rose、Rose和ROSE是3个不同的变量。</li></ul>\r\n<p>使用驼峰给变量命名：theFontSize、roomNumber、xMax、yMin、xTopLeft和thisIsAVeryLongVariableName, 可以参考下面的建议:</p>\r\n<ul>\r\n<li>选择一个有意义的变量名是非常重要的，建议使用numberOfStudents和numStudents来表示学生人数，而不是n或x。</li><li>这些变量名a, b, c, d, i, j, k, i1, j99毫无意义</li><li>x通常用作异常，y、z用来表示坐标，i表示循环索引。</li><li>对单复数变量加以区分，row表示单行，rows表示多行。</li></ul>\r\n<h3 id=\"h3-3-\"><a name=\"3. 定义变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 定义变量</h3><p>你需要定义变量的名称和类型才能在程序中使用变量，你可以使用下面的其中一种语法：</p>\r\n<pre><code>// 定义特定类型的变量, type identifier\r\nint option;\r\n\r\n// 定义多个同类型变量，变量之间用逗号分隔,type identifier1, identifier2, ..., identifierN\r\ndouble sum, difference, product, quotient;\r\n\r\n// 定义变量并初始化, type identifier = initialValue\r\nint magicNumber = 88;\r\n\r\n// 定义多个同类型变量并初始化, type identifier1 = initValue1, ..., identifierN = initValueN\r\nString greetingMsg = &quot;Hi!&quot;, quitMsg = &quot;Bye!&quot;;\r\n</code></pre><p>注意：</p>\r\n<ul>\r\n<li>Java是强类型的语言，一个变量对应着一种类型，变量声明后不能存储其它类型的数据。</li><li>每个变量只能声明一次。</li><li>使用前你可以在程序的任意位置进行声明。</li><li>变量声明之后它的类型不能更改。</li><li>一个变量声明的语句以类型开始，变量自始自终都为这种类型服务，一个变量声明的语句只能使用单一的类型。</li></ul>\r\n<h3 id=\"h3-4-\"><a name=\"4. 常量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 常量</h3><p>常量的命名规范：使用大写的单词，多个单词使用下划线连接，例如：MIN_VALUE，MAX_SIZE。<br>常量是不可变的，使用关键字final进行声明，常量声明后需要初始化</p>\r\n<pre><code>final double PI = 3.1415926;\r\n</code></pre><h3 id=\"h3-5-\"><a name=\"5. 表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 表达式</h3><p>表达式是由运算符和操作数组合而成，通过计算可以输出单个类型的值，例如</p>\r\n<pre><code>1 + 2 * 3                        // 计算得到7\r\n\r\nint sum, number;\r\nsum + number                     // 计算得到一个int值\r\n\r\ndouble principal, interestRate;\r\nprincipal * (1 + interestRate)   // 计算得到一个double值\r\n</code></pre><h3 id=\"h3-6-\"><a name=\"6. 赋值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 赋值</h3><p>指派一个右操作数赋值给左操作数，例如：x=1。<br>计算表达式的值并赋值给左操作数，例如：x=(y + z) / 2。</p>\r\n<p>赋值语句的语法：</p>\r\n<pre><code>// 直接赋值, variable = literalValue\r\nnumber = 88;\r\n\r\n// 计算表达式之后赋值, variable = expression\r\nnumber = number + 1;  // 计算表达式number＋1，最后将结果赋值给number\r\n\r\n8 = number;           // 错误的使用\r\nnumber + 1 = sum;     // 错误的使用\r\n</code></pre><h3 id=\"h3-7-\"><a name=\"7. 基本类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 基本类型</h3><p>在Java中有两种类型：基本类型 (int、double等)和引用类型 (类和数组)。</p>\r\n<ul>\r\n<li><strong>byte:</strong> 8位有符号整型取值范围：[-2^7, 2^7-1] = [-128, 127]。</li><li><strong>short:</strong> 16位有符号整型取值范围：[-2^15, 2^15-1] = [-32768, 32767]。</li><li><strong>int:</strong> 32位有符号整型取值范围：[-2^31, 2^31-1] = [-2147483648, 2147483647]?(≈9 digits)。</li><li><strong>long:</strong> 64位有符号整型取值范围：[-2^63, 2^63-1] = [-9223372036854775808, +9223372036854775807]?(≈19 digits)。</li><li><strong>float:</strong> 32位单精度浮点数(≈6-7位小数, 取值范围：±[≈10^-45, ≈10^38])。</li><li><strong>double:</strong> 64位双精度浮点数(≈精确到14-15位小树, 取值范围：±[≈10^-324, ≈10^308])。</li><li><strong>char:</strong> 表示16位Unicode编码，取值范围：’\\u0000’?到?’\\uFFFF’, 可以理解成16位无符号整型，取值范围：[0, 65535]。</li><li><strong>boolean:</strong> 布尔取值只能是true或false,布尔数据类型的大小在Java虽然没有定义, 但是至少需要1比特。</li></ul>\r\n<p>内建的基本类型</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Type_Primitive.gif\" alt=\"primitive types\"></p>\r\n<p>基本类型内建在程序语言中，从上面的图中我们可以看出Java有8种基本类型。</p>\r\n<ul>\r\n<li>有4种有符号的整型：8位byte，16位short，32位int，64位long。</li><li>32位单精度类型float，float近似的取值范围±1.40239846×10^-45到±3.40282347×10^38。</li><li>64位双精度类型double, double近似的取值范围±4.94065645841246544×10^-324到±1.79769313486231570×10^308。</li><li>char表示单个字符，例如’0’,?’A’,?’a’，在Java中，char采用16位Unicode(UCS-2格式)来支持国际化(i18n)。</li><li>Java中引入了二进制的布尔类型，它只能包含true和false两个值。</li></ul>\r\n<p>例子：下面的程序用来输出打印基本类型的最大值、最小值和比特长度。</p>\r\n<pre><code>/*\r\n * 输出基本类型的最大值、最小值和比特长度\r\n */\r\npublic class PrimitiveTypesMinMax {\r\n   public static void main(String[] args) {\r\n      // int (32位有符号整型)\r\n      System.out.println(&quot;int(min) = &quot; + Integer.MIN_VALUE);\r\n      System.out.println(&quot;int(max) = &quot; + Integer.MAX_VALUE);\r\n      System.out.println(&quot;int(bit-length) = &quot; + Integer.SIZE);\r\n      // byte (8位有符号整型)\r\n      System.out.println(&quot;byte(min) = &quot; + Byte.MIN_VALUE);\r\n      System.out.println(&quot;byte(max) = &quot; + Byte.MAX_VALUE);\r\n      System.out.println(&quot;byte(bit-length)=&quot; + Byte.SIZE);\r\n      // short (16位有符号整型)\r\n      System.out.println(&quot;short(min) = &quot; + Short.MIN_VALUE);\r\n      System.out.println(&quot;short(max) = &quot; + Short.MAX_VALUE);\r\n      System.out.println(&quot;short(bit-length) = &quot; + Short.SIZE);\r\n      // long (64位有符号整型)\r\n      System.out.println(&quot;long(min) = &quot; + Long.MIN_VALUE);\r\n      System.out.println(&quot;long(max) = &quot; + Long.MAX_VALUE);\r\n      System.out.println(&quot;long(bit-length) = &quot; + Long.SIZE);\r\n      // char (16位字符或者16位无符号整型)\r\n      System.out.println(&quot;char(min) = &quot; + (int)Character.MIN_VALUE);\r\n      System.out.println(&quot;char(max) = &quot; + (int)Character.MAX_VALUE);\r\n      System.out.println(&quot;char(bit-length) = &quot; + Character.SIZE);\r\n      // float (32位浮点数)\r\n      System.out.println(&quot;float(min) = &quot; + Float.MIN_VALUE);\r\n      System.out.println(&quot;float(max) = &quot; + Float.MAX_VALUE);\r\n      System.out.println(&quot;float(bit-length) = &quot; + Float.SIZE);\r\n      // double (64位浮点数)\r\n      System.out.println(&quot;double(min) = &quot; + Double.MIN_VALUE);\r\n      System.out.println(&quot;double(max) = &quot; + Double.MAX_VALUE);\r\n      System.out.println(&quot;double(bit-length) = &quot; + Double.SIZE);\r\n   }\r\n}\r\n\r\nint(min) = -2147483648\r\nint(max) = 2147483647\r\nint(bit-length) = 32\r\n\r\nbyte(min) = -128\r\nbyte(max) = 127\r\nbyte(bit-length)=8\r\n\r\nshort(min) = -32768\r\nshort(max) = 32767\r\nshort(bit-length) = 16\r\n\r\nlong(min) = -9223372036854775808\r\nlong(max) = 9223372036854775807\r\nlong(bit-length) = 64\r\n\r\nchar(min) = 0\r\nchar(max) = 65535\r\nchar(bit-length) = 16\r\n\r\nfloat(min) = 1.4E-45\r\nfloat(max) = 3.4028235E38\r\nfloat(bit-length) = 32\r\ndouble(min) = 4.9E-324\r\ndouble(max) = 1.7976931348623157E308\r\ndouble(bit-length) = 64\r\n</code></pre><h4 id=\"h4-string\"><a name=\"String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>String</h4><p>String不是基本类型，是另外一种常用的类型，它表示文本内容，在Java中字符串使用双引号。</p>\r\n<pre><code>String message = &quot;Hello, world!&quot;; // 字符串使用双引号\r\nchar gender = &#39;m&#39;;                // 字符使用单引号\r\n</code></pre><p>为变量选择数据类型</p>\r\n<p>开发中需要设计合适的变量类型，多数时我们不难选择，你可以用int来存储整型，用float来存储有小数的数值，用String来存储文本，用char来存储单个字符和用boolean来存储二元结果。</p>\r\n<p><strong>经验法则</strong></p>\r\n<ul>\r\n<li>由于int类型非常精确、运行效率高，因此常被用作计数和索引。</li><li>尽可能的使用int类型。</li></ul>\r\n<p><strong>数据表示</strong></p>\r\n<p>值得注意的是char ‘1’与int 1、byte 1、short 1、float 1.0、double 1.0、String ?”1”是不相同的，它们在计算机的内存中有着不同的精度和说明，举例说明：</p>\r\n<ul>\r\n<li>byte 1表示00000001</li><li>short 1表示00000000 00000001</li><li>int 1表示00000000 00000000 00000000 00000001</li><li>long 1表示00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001</li><li>float 1.0表示0 01111111 0000000 00000000 00000000</li><li>double 1.0表示0 01111111111 0000 00000000 00000000 00000000 00000000 00000000 00000000</li><li>char ‘1’表示00000000 00110001</li><li>String “1”表示复杂的对象</li></ul>\r\n<p>下面我们来看一个变量名称和类型的例子：<br>Paul买了一台abc品牌的笔记本电脑，3.2GHZ高速处理器、4GB内存、500GB硬盘、15英寸显示器，总价为$1650.45，在现场从服务计划A、B、C中选择了B计划，定义涉及的相关变量和类型。</p>\r\n<pre><code>String name = &quot;Paul&quot;;\r\nString brand = &quot;abc&quot;;\r\ndouble processorSpeedInGHz = 3.2;  // 或者 float\r\ndouble ramSizeInGB = 4;            // 或者 float\r\nint harddiskSizeInGB = 500;        // 或者 short\r\nint monitorInInch = 15;            // 或者 byte\r\ndouble price = 1650.45;\r\nchar servicePlan = &#39;B&#39;;\r\nboolean onSiteService = true;\r\n</code></pre><h4 id=\"h4--\"><a name=\"练习：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习：</h4><p>假设你正在为学校开发一款收集学生信息的软件，学生的信息包括年龄、地址、电话、性别、生日、身高、体重、年级、入学时间等，每个学生被分配一个8位数字标识，下面来使用变量定义它们吧。</p>\r\n<h3 id=\"h3-8-string-\"><a name=\"8. 用于基本类型和String类型的字面值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. 用于基本类型和String类型的字面值</h3><p>编程中使用的文字、字面值都是特定的常量，例如123,-456,3.14,-1.2e3,’a’,”Hello”, 可以用做赋值或表达式。</p>\r\n<p><strong>Integer(int,long,short,byte)字面值</strong></p>\r\n<pre><code>// 整数默认的都被视作int类型，例如123和-456，在Java中32位的int取值范围从-2,147,483,628(-2^31)到2,147,483,627(2^31-1)\r\nint number = -123;\r\nint sum = 1234567890;            // 这个值在int取值范围内\r\nint bigSum = 8234567890;         // 错误: 这个值超出了int取值范围\r\n\r\n// int字面值没有特殊说明都表示10进制，以0开头的数字表示8进制，以&#39;0x&#39;开头的数字表示16进制。\r\nint number = 1234;               // 10进制1234\r\nint number = 01234;              // 8进制1234, 10进制668\r\nint number = 0x1abc;             // 16进制1ABC, 10进制6844\r\n\r\n// 从JDK1.7开始，你可以使用&#39;0b&#39;或者&#39;0B&#39;为前缀来表示二进制，你也可以使用下划线_对数字进行分组来提高可读性，但是开头和结尾必须使用数字。\r\nint number1 = 0b01010000101000101101000010100010;\r\nint number2 = 0b0101_0000_1010_0010_1101_0000_1010_0010;\r\nint number3 = 2_123_456;\r\n\r\n// long字面值用数字加上后缀&#39;L&#39;或&#39;l&#39;来表示\r\nlong bigNumber = 1234567890123L;\r\nlong sum = 123;                   // int类型123会被自动转换成long类型123L\r\n\r\n// byte和short字面值不需要添加后缀，你可以直接使用整数初始化\r\nbyte smallNumber = 12345;         // 错误: 超出了byte取值范围\r\nbyte smallNumber = 123;\r\nshort midSizeNumber = -12345;\r\n\r\n// 有小数点的数值例如55.66和－33.44默认的被视作double类型，同样你可以用科学计数法表示，例如1.2e3,?-5.5E-6, 大写E小写e表示10的指数，你可以用数字加上后缀&#39;d&#39;或&#39;D&#39;表示。\r\nfloat average = 55.66;            // 错误! 右操作是double类型， 需要后缀&#39;f&#39;来表示\r\nfloat average = 55.66f;\r\n</code></pre><p><strong>字符字面值和转义序列</strong></p>\r\n<pre><code>// 字符嵌入在单引号里面表示char类型，char类型使用16位的Unicode编码，算术运算上等同于16位无符号整型\r\nchar letter = &#39;a&#39;;                 // 等同于97\r\nchar anotherLetter = 98;           // 等同于&#39;b&#39;\r\nSystem.out.println(letter);        // 输出&#39;a&#39;\r\nSystem.out.println(anotherLetter); // 输出&#39;b&#39;代替数字\r\nanotherLetter += 2;                // 100或&#39;d&#39;\r\nSystem.out.println(anotherLetter); // 输出&#39;d&#39;\r\n</code></pre><p>非打印的控制字符通常被称为转义序列，通常以反斜线\\开始，下面是常用的转义序列：</p>\r\n<ul>\r\n<li>换行符: \\n等同于000AH (10D)</li><li>回车符: \\r等同于000DH (13D)</li><li>制表符: \\t等同于0009H (9D)</li><li>双引号: \\”等同于0022H (34D)</li><li>单引号: \\’等同于0027H (39D)</li><li>反斜线: \\等同于005CH (92D)</li></ul>\r\n<p>说明：</p>\r\n<ul>\r\n<li>用转义序列\\n和\\r分别表示换行符(000AH)和回车符(000DH)，值得注意的是在Unix和Mac中使用\\n(0AH)表示换行，而Windows使用\\r\\n(0D0AH)表示。</li><li>用转义序列\\t表示制表符(0009H)。</li><li>为了解决歧义，反斜线()，单引号(‘)，双引号(“)，分别用转义序列\\，\\’和\\”来表示。</li><li>其它不太常用的转义序列:?\\a警报, \\b退格, \\f换页, \\v垂直标签，某些控制台可能无法支持。</li></ul>\r\n<p><strong>String字面值</strong></p>\r\n<p>长度不定的字符串嵌入在双引号里面表示字符串字面值，例如”Hello, world!”，”The sum is: “，举例说明：</p>\r\n<pre><code>String directionMsg = &quot;Turn Right&quot;;\r\nString greetingMsg = &quot;Hello&quot;;\r\nString statusMsg = &quot;&quot;;   // 空字符串\r\n\r\n// 字符串字面值可能包含转义序列，在字符串你里面，你需要使用 \\&quot;来表示双引号，单引号不需要转义，举例说明：\r\nSystem.out.println(&quot;Use \\\\\\&quot; to place\\n a \\&quot; within\\ta\\tstring&quot;);\r\n\r\nUse \\&quot; to place\r\n a &quot; within    a    string\r\n</code></pre><p><strong>练习：编写程序打印输出下面的字符。</strong></p>\r\n<pre>    `<span class=\"hljs-string\">\'__\'</span>\r\n          (oo)\r\n  +========\\/\r\n / || %%% ||\r\n*  ||-----||\r\n   <span class=\"hljs-string\">\"\"</span>     <span class=\"hljs-string\">\"\"</span>` \r\n</pre>\r\n\r\n<p><strong>boolean字面值</strong></p>\r\n<pre><code>// boolean字面值紧包含两个值：true和false\r\nboolean done = true;\r\nboolean gameOver = false;\r\n</code></pre><p><strong>字面值的例子</strong></p>\r\n<pre><code>public class LiteralTest {\r\n   public static void main(String[] args) {\r\n      String name = &quot;Tan Ah Teck&quot;; // String使用双引号\r\n      char gender = &#39;m&#39;;           // char使用单引号\r\n      boolean isMarried = true;    // true或者false\r\n      byte numChildren = 8;        // byte取值范围[-127, 128]\r\n      short yearOfBirth = 1945;    // short取值范围[-32767, 32768]\r\n      int salary = 88000;\r\n      long netAsset = 8234567890L;\r\n      double weight = 88.88;\r\n      float gpa = 3.88f;\r\n\r\n      // 输出\r\n      System.out.println(&quot;Name is &quot; + name);\r\n      System.out.println(&quot;Gender is &quot; + gender);\r\n      System.out.println(&quot;Is married is &quot; + isMarried);\r\n      System.out.println(&quot;Number of children is &quot; + numChildren);\r\n      System.out.println(&quot;Year of birth is &quot; + yearOfBirth);\r\n      System.out.println(&quot;Salary is &quot; + salary);\r\n      System.out.println(&quot;Net Asset is &quot; + netAsset);\r\n      System.out.println(&quot;Weight is &quot; + weight);\r\n      System.out.println(&quot;GPA is &quot; + gpa);\r\n   }\r\n}\r\n\r\nName is Tan Ah Teck\r\nGender is m\r\nIs married is true\r\nNumber of children is 8\r\nYear of birth is 1945\r\nSalary is 88000\r\nNet Asset is 1234567890\r\nWeight is 88.88\r\nHeight is 188.8\r\n</code></pre>', '47', '![](http://ww3.sinaimg.cn/large/006pQ25sgw1f2u1avb9tfj30bb06h0t2.jpg)\r\n### 1\\. 变量\r\n\r\n计算机处理数据，变量被用来存储处理的数据，之所以叫做变量因为你可以改变存储的值。更确切的说，一个变量指向着一块存储特定类型值的地址，换句话说，一个变量有名称、类型和值。一个变量有一个名称，例如radius、area、age和height，每个变量的名称都是唯一的，这边可以方便我们设置和获取变量的值。\r\n\r\n一个变量有一种类型，下面是Java类型的列子:\r\n\r\n*   int: 表示整数例如123和-456\r\n*   double: 表示浮点数例如3.1416、-55.66、1.2e3和-4.5E-6\r\n*   String: 表示文本例如\"Hello\"、\"Good Morning!\"，文本通常嵌入在双引号里面\r\n*   char: 表示单个字符例如\'a\',\'8\'，单个字符通常嵌入在单引号里面。\r\n\r\n变量存储特定类型的值，编程中要特别注意变量类型，举例：一个int变量存储整数123，但是不能存储浮点数12.34，同样也不能存储文本\"Hello\"。\r\n早期的编程语言中引入了类型的概念来解释二进制01数据，类型定义了数据的结构、大小、范围以及针对该类型的一系列操作。\r\n\r\n![variable](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_Variable.png)\r\n\r\n### 2\\. 名称\r\n\r\n需要唯一的标识来命名变量，Java遵循以下标识的命名方式：\r\n\r\n*   标识由大小写字母、数字、下划线和$的任意长度的字符序列组成。\r\n*   空白 (空格、制表符、换行符)和其他特殊字符 (如+ - * / @ ＆, 等)是不允许的，错误的命名方式：max value和max-value。\r\n*   标识符不能以数字(0-9)开头必须以字母(a-z, A-Z)、下划线(_)和$开头，系统保留以$开头的标识。\r\n*   标识符不能使用关键字和预留字段 (例如：class,int,double,if,else,for,true,false,null)。\r\n*   标识符是区分大小写的，rose、Rose和ROSE是3个不同的变量。\r\n\r\n使用驼峰给变量命名：theFontSize、roomNumber、xMax、yMin、xTopLeft和thisIsAVeryLongVariableName, 可以参考下面的建议:\r\n\r\n*   选择一个有意义的变量名是非常重要的，建议使用numberOfStudents和numStudents来表示学生人数，而不是n或x。\r\n*   这些变量名a, b, c, d, i, j, k, i1, j99毫无意义\r\n*   x通常用作异常，y、z用来表示坐标，i表示循环索引。\r\n*   对单复数变量加以区分，row表示单行，rows表示多行。\r\n\r\n### 3\\. 定义变量\r\n\r\n你需要定义变量的名称和类型才能在程序中使用变量，你可以使用下面的其中一种语法：\r\n\r\n```\r\n// 定义特定类型的变量, type identifier\r\nint option;\r\n\r\n// 定义多个同类型变量，变量之间用逗号分隔,type identifier1, identifier2, ..., identifierN\r\ndouble sum, difference, product, quotient;\r\n\r\n// 定义变量并初始化, type identifier = initialValue\r\nint magicNumber = 88;\r\n\r\n// 定义多个同类型变量并初始化, type identifier1 = initValue1, ..., identifierN = initValueN\r\nString greetingMsg = \"Hi!\", quitMsg = \"Bye!\";\r\n\r\n```\r\n\r\n注意：\r\n\r\n*   Java是强类型的语言，一个变量对应着一种类型，变量声明后不能存储其它类型的数据。\r\n*   每个变量只能声明一次。\r\n*   使用前你可以在程序的任意位置进行声明。\r\n*   变量声明之后它的类型不能更改。\r\n*   一个变量声明的语句以类型开始，变量自始自终都为这种类型服务，一个变量声明的语句只能使用单一的类型。\r\n\r\n### 4\\. 常量\r\n\r\n常量的命名规范：使用大写的单词，多个单词使用下划线连接，例如：MIN_VALUE，MAX_SIZE。\r\n常量是不可变的，使用关键字final进行声明，常量声明后需要初始化\r\n\r\n```\r\nfinal double PI = 3.1415926;\r\n```\r\n\r\n### 5\\. 表达式\r\n\r\n表达式是由运算符和操作数组合而成，通过计算可以输出单个类型的值，例如\r\n\r\n```\r\n1 + 2 * 3                        // 计算得到7\r\n\r\nint sum, number;\r\nsum + number                     // 计算得到一个int值\r\n\r\ndouble principal, interestRate;\r\nprincipal * (1 + interestRate)   // 计算得到一个double值   \r\n```\r\n\r\n### 6\\. 赋值\r\n\r\n指派一个右操作数赋值给左操作数，例如：x=1。\r\n计算表达式的值并赋值给左操作数，例如：x=(y + z) / 2。\r\n\r\n赋值语句的语法：\r\n\r\n```\r\n// 直接赋值, variable = literalValue\r\nnumber = 88;\r\n\r\n// 计算表达式之后赋值, variable = expression\r\nnumber = number + 1;  // 计算表达式number＋1，最后将结果赋值给number\r\n\r\n8 = number;           // 错误的使用\r\nnumber + 1 = sum;     // 错误的使用\r\n\r\n```\r\n\r\n### 7\\. 基本类型\r\n\r\n在Java中有两种类型：基本类型 (int、double等)和引用类型 (类和数组)。\r\n\r\n*   **byte:** 8位有符号整型取值范围：[-2^7, 2^7-1] = [-128, 127]。\r\n*   **short:** 16位有符号整型取值范围：[-2^15, 2^15-1] = [-32768, 32767]。\r\n*   **int:** 32位有符号整型取值范围：[-2^31, 2^31-1] = [-2147483648, 2147483647]?(≈9 digits)。\r\n*   **long:** 64位有符号整型取值范围：[-2^63, 2^63-1] = [-9223372036854775808, +9223372036854775807]?(≈19 digits)。\r\n*   **float:** 32位单精度浮点数(≈6-7位小数, 取值范围：±[≈10^-45, ≈10^38])。\r\n*   **double:** 64位双精度浮点数(≈精确到14-15位小树, 取值范围：±[≈10^-324, ≈10^308])。\r\n*   **char:** 表示16位Unicode编码，取值范围：\'\\u0000\'?到?\'\\uFFFF\', 可以理解成16位无符号整型，取值范围：[0, 65535]。\r\n*   **boolean:** 布尔取值只能是true或false,布尔数据类型的大小在Java虽然没有定义, 但是至少需要1比特。\r\n\r\n内建的基本类型\r\n\r\n![primitive types](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Type_Primitive.gif)\r\n\r\n基本类型内建在程序语言中，从上面的图中我们可以看出Java有8种基本类型。\r\n\r\n*   有4种有符号的整型：8位byte，16位short，32位int，64位long。\r\n*   32位单精度类型float，float近似的取值范围±1.40239846×10^-45到±3.40282347×10^38。\r\n*   64位双精度类型double, double近似的取值范围±4.94065645841246544×10^-324到±1.79769313486231570×10^308。\r\n*   char表示单个字符，例如\'0\',?\'A\',?\'a\'，在Java中，char采用16位Unicode(UCS-2格式)来支持国际化(i18n)。\r\n*   Java中引入了二进制的布尔类型，它只能包含true和false两个值。\r\n\r\n例子：下面的程序用来输出打印基本类型的最大值、最小值和比特长度。\r\n\r\n```\r\n/*\r\n * 输出基本类型的最大值、最小值和比特长度\r\n */\r\npublic class PrimitiveTypesMinMax {\r\n   public static void main(String[] args) {\r\n      // int (32位有符号整型)\r\n      System.out.println(\"int(min) = \" + Integer.MIN_VALUE);\r\n      System.out.println(\"int(max) = \" + Integer.MAX_VALUE);\r\n      System.out.println(\"int(bit-length) = \" + Integer.SIZE);\r\n      // byte (8位有符号整型)\r\n      System.out.println(\"byte(min) = \" + Byte.MIN_VALUE);\r\n      System.out.println(\"byte(max) = \" + Byte.MAX_VALUE);\r\n      System.out.println(\"byte(bit-length)=\" + Byte.SIZE);\r\n      // short (16位有符号整型)\r\n      System.out.println(\"short(min) = \" + Short.MIN_VALUE);\r\n      System.out.println(\"short(max) = \" + Short.MAX_VALUE);\r\n      System.out.println(\"short(bit-length) = \" + Short.SIZE);\r\n      // long (64位有符号整型)\r\n      System.out.println(\"long(min) = \" + Long.MIN_VALUE);\r\n      System.out.println(\"long(max) = \" + Long.MAX_VALUE);\r\n      System.out.println(\"long(bit-length) = \" + Long.SIZE);\r\n      // char (16位字符或者16位无符号整型)\r\n      System.out.println(\"char(min) = \" + (int)Character.MIN_VALUE);\r\n      System.out.println(\"char(max) = \" + (int)Character.MAX_VALUE);\r\n      System.out.println(\"char(bit-length) = \" + Character.SIZE);\r\n      // float (32位浮点数)\r\n      System.out.println(\"float(min) = \" + Float.MIN_VALUE);\r\n      System.out.println(\"float(max) = \" + Float.MAX_VALUE);\r\n      System.out.println(\"float(bit-length) = \" + Float.SIZE);\r\n      // double (64位浮点数)\r\n      System.out.println(\"double(min) = \" + Double.MIN_VALUE);\r\n      System.out.println(\"double(max) = \" + Double.MAX_VALUE);\r\n      System.out.println(\"double(bit-length) = \" + Double.SIZE);\r\n   }\r\n}\r\n\r\nint(min) = -2147483648\r\nint(max) = 2147483647\r\nint(bit-length) = 32\r\n\r\nbyte(min) = -128\r\nbyte(max) = 127\r\nbyte(bit-length)=8\r\n\r\nshort(min) = -32768\r\nshort(max) = 32767\r\nshort(bit-length) = 16\r\n\r\nlong(min) = -9223372036854775808\r\nlong(max) = 9223372036854775807\r\nlong(bit-length) = 64\r\n\r\nchar(min) = 0\r\nchar(max) = 65535\r\nchar(bit-length) = 16\r\n\r\nfloat(min) = 1.4E-45\r\nfloat(max) = 3.4028235E38\r\nfloat(bit-length) = 32\r\ndouble(min) = 4.9E-324\r\ndouble(max) = 1.7976931348623157E308\r\ndouble(bit-length) = 64\r\n```\r\n\r\n#### String\r\n\r\nString不是基本类型，是另外一种常用的类型，它表示文本内容，在Java中字符串使用双引号。\r\n\r\n```\r\nString message = \"Hello, world!\"; // 字符串使用双引号\r\nchar gender = \'m\';                // 字符使用单引号\r\n```\r\n\r\n为变量选择数据类型\r\n\r\n开发中需要设计合适的变量类型，多数时我们不难选择，你可以用int来存储整型，用float来存储有小数的数值，用String来存储文本，用char来存储单个字符和用boolean来存储二元结果。\r\n\r\n**经验法则**\r\n\r\n*   由于int类型非常精确、运行效率高，因此常被用作计数和索引。\r\n*   尽可能的使用int类型。\r\n\r\n**数据表示**\r\n\r\n值得注意的是char \'1\'与int 1、byte 1、short 1、float 1.0、double 1.0、String ?\"1\"是不相同的，它们在计算机的内存中有着不同的精度和说明，举例说明：\r\n\r\n*   byte 1表示00000001\r\n*   short 1表示00000000 00000001\r\n*   int 1表示00000000 00000000 00000000 00000001\r\n*   long 1表示00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001\r\n*   float 1.0表示0 01111111 0000000 00000000 00000000\r\n*   double 1.0表示0 01111111111 0000 00000000 00000000 00000000 00000000 00000000 00000000\r\n*   char \'1\'表示00000000 00110001\r\n*   String \"1\"表示复杂的对象\r\n\r\n下面我们来看一个变量名称和类型的例子：\r\nPaul买了一台abc品牌的笔记本电脑，3.2GHZ高速处理器、4GB内存、500GB硬盘、15英寸显示器，总价为$1650.45，在现场从服务计划A、B、C中选择了B计划，定义涉及的相关变量和类型。\r\n\r\n```\r\nString name = \"Paul\";\r\nString brand = \"abc\";\r\ndouble processorSpeedInGHz = 3.2;  // 或者 float\r\ndouble ramSizeInGB = 4;            // 或者 float\r\nint harddiskSizeInGB = 500;        // 或者 short\r\nint monitorInInch = 15;            // 或者 byte\r\ndouble price = 1650.45;\r\nchar servicePlan = \'B\';\r\nboolean onSiteService = true;\r\n```\r\n\r\n#### 练习：\r\n\r\n假设你正在为学校开发一款收集学生信息的软件，学生的信息包括年龄、地址、电话、性别、生日、身高、体重、年级、入学时间等，每个学生被分配一个8位数字标识，下面来使用变量定义它们吧。\r\n\r\n### 8\\. 用于基本类型和String类型的字面值\r\n\r\n编程中使用的文字、字面值都是特定的常量，例如123,-456,3.14,-1.2e3,\'a\',\"Hello\", 可以用做赋值或表达式。\r\n\r\n**Integer(int,long,short,byte)字面值**\r\n\r\n```\r\n// 整数默认的都被视作int类型，例如123和-456，在Java中32位的int取值范围从-2,147,483,628(-2^31)到2,147,483,627(2^31-1)\r\nint number = -123;\r\nint sum = 1234567890;            // 这个值在int取值范围内\r\nint bigSum = 8234567890;         // 错误: 这个值超出了int取值范围\r\n\r\n// int字面值没有特殊说明都表示10进制，以0开头的数字表示8进制，以\'0x\'开头的数字表示16进制。\r\nint number = 1234;               // 10进制1234\r\nint number = 01234;              // 8进制1234, 10进制668\r\nint number = 0x1abc;             // 16进制1ABC, 10进制6844\r\n\r\n// 从JDK1.7开始，你可以使用\'0b\'或者\'0B\'为前缀来表示二进制，你也可以使用下划线_对数字进行分组来提高可读性，但是开头和结尾必须使用数字。\r\nint number1 = 0b01010000101000101101000010100010;\r\nint number2 = 0b0101_0000_1010_0010_1101_0000_1010_0010;\r\nint number3 = 2_123_456;\r\n\r\n// long字面值用数字加上后缀\'L\'或\'l\'来表示\r\nlong bigNumber = 1234567890123L;\r\nlong sum = 123;                   // int类型123会被自动转换成long类型123L\r\n\r\n// byte和short字面值不需要添加后缀，你可以直接使用整数初始化\r\nbyte smallNumber = 12345;         // 错误: 超出了byte取值范围\r\nbyte smallNumber = 123;\r\nshort midSizeNumber = -12345;\r\n\r\n// 有小数点的数值例如55.66和－33.44默认的被视作double类型，同样你可以用科学计数法表示，例如1.2e3,?-5.5E-6, 大写E小写e表示10的指数，你可以用数字加上后缀\'d\'或\'D\'表示。\r\nfloat average = 55.66;            // 错误! 右操作是double类型， 需要后缀\'f\'来表示\r\nfloat average = 55.66f;\r\n```\r\n\r\n**字符字面值和转义序列**\r\n\r\n```\r\n// 字符嵌入在单引号里面表示char类型，char类型使用16位的Unicode编码，算术运算上等同于16位无符号整型\r\nchar letter = \'a\';                 // 等同于97\r\nchar anotherLetter = 98;           // 等同于\'b\'\r\nSystem.out.println(letter);        // 输出\'a\'\r\nSystem.out.println(anotherLetter); // 输出\'b\'代替数字\r\nanotherLetter += 2;                // 100或\'d\'\r\nSystem.out.println(anotherLetter); // 输出\'d\'\r\n```\r\n\r\n非打印的控制字符通常被称为转义序列，通常以反斜线\\开始，下面是常用的转义序列：\r\n\r\n*   换行符: \\n等同于000AH (10D)\r\n*   回车符: \\r等同于000DH (13D)\r\n*   制表符: \\t等同于0009H (9D)\r\n*   双引号: \\\"等同于0022H (34D)\r\n*   单引号: \\\'等同于0027H (39D)\r\n*   反斜线: \\\\等同于005CH (92D)\r\n\r\n说明：\r\n\r\n*   用转义序列\\n和\\r分别表示换行符(000AH)和回车符(000DH)，值得注意的是在Unix和Mac中使用\\n(0AH)表示换行，而Windows使用\\r\\n(0D0AH)表示。\r\n*   用转义序列\\t表示制表符(0009H)。\r\n*   为了解决歧义，反斜线(\\)，单引号(\')，双引号(\")，分别用转义序列\\\\，\\\'和\\\"来表示。\r\n*   其它不太常用的转义序列:?\\a警报, \\b退格, \\f换页, \\v垂直标签，某些控制台可能无法支持。\r\n\r\n**String字面值**\r\n\r\n长度不定的字符串嵌入在双引号里面表示字符串字面值，例如\"Hello, world!\"，\"The sum is: \"，举例说明：\r\n\r\n```\r\nString directionMsg = \"Turn Right\";\r\nString greetingMsg = \"Hello\";\r\nString statusMsg = \"\";   // 空字符串\r\n\r\n// 字符串字面值可能包含转义序列，在字符串你里面，你需要使用 \\\"来表示双引号，单引号不需要转义，举例说明：\r\nSystem.out.println(\"Use \\\\\\\" to place\\n a \\\" within\\ta\\tstring\");\r\n\r\nUse \\\" to place\r\n a \" within	a	string\r\n```\r\n\r\n**练习：编写程序打印输出下面的字符。**\r\n\r\n<pre>    `<span class=\"hljs-string\">\'__\'</span>\r\n          (oo)\r\n  +========\\/\r\n / || %%% ||\r\n*  ||-----||\r\n   <span class=\"hljs-string\">\"\"</span>     <span class=\"hljs-string\">\"\"</span>` \r\n</pre>\r\n\r\n**boolean字面值**\r\n\r\n```\r\n// boolean字面值紧包含两个值：true和false\r\nboolean done = true;\r\nboolean gameOver = false;\r\n```\r\n\r\n**字面值的例子**\r\n\r\n```\r\npublic class LiteralTest {\r\n   public static void main(String[] args) {\r\n      String name = \"Tan Ah Teck\"; // String使用双引号\r\n      char gender = \'m\';           // char使用单引号\r\n      boolean isMarried = true;    // true或者false\r\n      byte numChildren = 8;        // byte取值范围[-127, 128]\r\n      short yearOfBirth = 1945;    // short取值范围[-32767, 32768]\r\n      int salary = 88000;\r\n      long netAsset = 8234567890L;\r\n      double weight = 88.88;\r\n      float gpa = 3.88f;\r\n\r\n      // 输出\r\n      System.out.println(\"Name is \" + name);\r\n      System.out.println(\"Gender is \" + gender);\r\n      System.out.println(\"Is married is \" + isMarried);\r\n      System.out.println(\"Number of children is \" + numChildren);\r\n      System.out.println(\"Year of birth is \" + yearOfBirth);\r\n      System.out.println(\"Salary is \" + salary);\r\n      System.out.println(\"Net Asset is \" + netAsset);\r\n      System.out.println(\"Weight is \" + weight);\r\n      System.out.println(\"GPA is \" + gpa);\r\n   }\r\n}\r\n\r\nName is Tan Ah Teck\r\nGender is m\r\nIs married is true\r\nNumber of children is 8\r\nYear of birth is 1945\r\nSalary is 88000\r\nNet Asset is 1234567890\r\nWeight is 88.88\r\nHeight is 188.8\r\n```');
INSERT INTO `article_info_true` VALUES ('31', '运算操作符', '<p><img src=\"http://ww4.sinaimg.cn/large/006pQ25sgw1f2vf75caoej30dw0afjs0.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1. 算术运算\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 算术运算</h3><p>Java支持以下的算术运算：</p>\r\n<p>| 运算符 | 描述 | 使用 | 例子 |<br>| * | 乘法 | <em>expr1</em>?*?<em>expr2</em> | 2 * 3 → 6<br>3.3 * 1.0 → 3.3 |<br>| / | 除法 | <em>expr1</em>?/?<em>expr2</em> | 1 / 2 → 0<br>1.0 / 2.0 → 0.5 |<br>| % | 取余 | <em>expr1</em>?%?<em>expr2</em> | 5 % 2 → 1<br>-5 % 2 → -1<br>5.5 % 2.2 → 1.1 |<br>| + | 加法(正号) | <em>expr1</em>?+?<em>expr2</em><br>+expr | 1 + 2 → 3<br>1.1 + 2.2 → 3.3 |<br>| - | 减法(负号) | <em>expr1</em>?-?<em>expr2</em><br>-expr | 1 - 2 → -1<br>1.1 - 2.2 → -1.1 |</p>\r\n<h3 id=\"h3-2-\"><a name=\"2. 算术表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 算术表达式</h3><p>对于下面的表达式：</p>\r\n<p><img src=\"http://ww3.sinaimg.cn/large/006pQ25sgw1f2v9pdv1iej309o01lgln.jpg\" alt=\"\"></p>\r\n<p>转化为编码(1+2*a)/3 + (4*(b+c)*(5-d-e))/f - 6*(7/g+h)，需要注意的不能省略乘号(*)。</p>\r\n<h5 id=\"h5--\"><a name=\"优先级：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>优先级：</h5><p>*   乘法(*)，除法(/)和取余(%)优先于加法(+)和减法(-)运算，例如1+2*3-4/2可以表示为1+(2*3)-(4/2)。<br>*   正号(+)和负号(-)拥有更高级别。<br>*   括号()拥有最高级别，常用来调整运算顺序。<br>*   对于同级别运算符号，表达式结果从左到右计算，例如1+2-3+4等价于((1+2)-3)+4，1*2%3/4等价于((1*2)%3)/4。</p>\r\n<h3 id=\"h3-3-\"><a name=\"3. 混合类型运算\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 混合类型运算</h3><p>算术运算仅适用于基本类型：byte, ?short, ?int, ?long, ?float, ?double和char，其中不包括boolean。</p>\r\n<p>如果两个操作数的类型是int/long/float/double, 运算操作会直接使用此类型进行计算，例如int 5 + int 6 → int 11;?double 2.1 + double 1.2 → double 3.3。</p>\r\n<p>值得注意的是对于int的除法运算，计算结果会被截断，例如1/2 → 0而不是0.5。</p>\r\n<p>如果两个操作数的类型是byte，short或者char，运算操作会使用int类型进行计算，char会被转化为16位无符号整数，例如byte 127 + byte 1 → int 127 + int 1 → int 128。<br>如果两个操作数属于不同的类型，较小的类型会被隐式的转换成较大的类型，运算操作会使用较大的类型进行计算。</p>\r\n<h5 id=\"h5--\"><a name=\"举例说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举例说明：</h5><p>*   int/double → double/double → double，1/2 → 0, 1.0/2.0 → 0.5, 1.0/2 → 0.5, 1/2.0 → 0.5。<br>*   char + float → int + float → float + float → float。<br>*   9 / 5 * 20.1 → (9 / 5) * 20.1 → 1 * 20.1 → 1.0 * 20.1 → 20.1?(你可能不会想到这个答案)。<br>*   byte 1 + byte 2 → int 1 + int 2 → int 3?(结果是int，不是byte)。</p>\r\n<p>二元运算操作对于类型的转换概括如下：</p>\r\n<p>*   如果其中一个操作数是double，另一个操作数默认转为double。<br>*   如果其中一个操作数是float，另一个操作数默认转为float。<br>*   如果其中一个操作数是long，另一个操作数默认转为long。<br>*   其余的操作数默认的转为int。</p>\r\n<p>一元运算操(正号、负号)对于类型的转换概括如下：</p>\r\n<p>*   如果操作数是double，float，long或者int，不需要转换。<br>*   其余的如果是byte，short或char，会默认转换为int。</p>\r\n<h5 id=\"h5--\"><a name=\"举例说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举例说明：</h5><pre><code>byte b1 = 1;\r\nbyte b2 = -b1;  // 编译会出错， 因为-b1会返回int，不能转换成byte\r\n</code></pre><h5 id=\"h5-u53D6u4F59u8FD0u7B97u7B26\"><a name=\"取余运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>取余运算符</h5><p>为了计算余数会重复的运行减法运算，直到差值的绝对值小于右操作数的绝对值，举例说明：</p>\r\n<ul>\r\n<li>-5 % 2 =&gt; -3 % 2 =&gt; -1</li><li>5.5 % 2.2 =&gt; 3.3 % 2.2 =&gt; 1.1</li></ul>\r\n<h5 id=\"h5-u6307u6570\"><a name=\"指数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>指数</h5><p>在Java中是没有指数运算符的，你看到的’^’运算符是异或，不过你可以使用Math.exp(X,Y)进行指数的运算。</p>\r\n<h3 id=\"h3-4-\"><a name=\"4. 向上溢出/向下溢出\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 向上溢出/向下溢出</h3><p>研究下面的代码并解释输出输出：</p>\r\n<pre><code>/\\*\r\n \\* &quot;int&quot;溢出说明\r\n \\*/\r\npublic class OverflowTest {\r\n    public static void main(String[] args) {\r\n    // int取值范围[-2147483648, 2147483647]\r\n    int i1 = 2147483647;           // int最大值\r\n    System.out.println(i1 + 1);    // -2147483648 (溢出)\r\n    System.out.println(i1 + 2);    // -2147483647\r\n    System.out.println(i1 \\* i1);   // 1\r\n\r\n    int i2 = -2147483648;          // int最小值\r\n    System.out.println(i2 - 1);    // 2147483647 (溢出)\r\n    System.out.println(i2 - 2);    // 2147483646\r\n    System.out.println(i2 \\* i2);   // 0\r\n    }\r\n}\r\n</code></pre><p>对于运算过程中的溢出，Java不会发出错误或者警告信息，但会产生不正确的结果。<br>另一方面整数除法会产生截断的整数，我们称之为向下溢出，例如1/2?→ 0，而不是0.5。<br>做为程序员你有责任去检查编程中的溢出。<br>这时候我们也许会问，为什么计算机不去标记溢出？由于历史的原因, 当时处理器很慢，检查溢出会消耗性能。</p>\r\n<h3 id=\"h3-5-\"><a name=\"5. 类型转换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 类型转换</h3><p>在Java中，如果将double或float数据赋值给int变量会产生编译错误。</p>\r\n<pre><code>double d = 3.5;\r\nint i;\r\ni = d;            // 编译错误\r\nint sum = 55.66f; // 编译错误\r\n</code></pre><h5 id=\"h5-u663Eu793Au7C7Bu578Bu8F6Cu6362u548Cu7C7Bu578Bu8F6Cu6362\"><a name=\"显示类型转换和类型转换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>显示类型转换和类型转换</h5><p>double赋值给int变量，你需要使用显示类型转换，形式为(int)value，返回的结果是被截断的int数据，举例说明：</p>\r\n<pre><code>double d = 3.5;\r\nint i;\r\ni = (int) d;    // 将double类型的3.5转换成int类型的3，之后赋值给i\r\n</code></pre><p>类型转换只需要一个操作数，Java中有两种类型转换：</p>\r\n<p>*   以(new-type)操作数的形式进行显示类型转换。<br>*   如果没有精度缺失，编译器自动的会进行隐示类型转换。</p>\r\n<pre><code>int i = 3;\r\ndouble d;\r\nd = i;                 // 正确, 不需要进行类型转换，d=3.0\r\nd = (double) i;        // 也可以使用显示类型转换\r\ndouble aDouble = 55;   // 编译器会自动的将int 55转换成double 55.0\r\ndouble nought = 0;     // 编译器会自动的将int 0转换成double 0.0\r\n ? ? ? ? ? ? ? ? ? ? ? // 值得注意的是int 0和double 0.0是不同的\r\n</code></pre><p>下面的这幅图展示了编译器隐示类型转换的顺序，转换规则是将小类型晋升为大类型，这样做可以防止精度缺失。降级类型需要显示类型转换，精度会缺失，值得注意的是char会被视作16位无符号整数，取值范围[0, 65535]，boolean类型不支持转换。</p>\r\n<p><img src=\"http://ww4.sinaimg.cn/large/006pQ25sgw1f2vc7ivmqkj30dw03qt98.jpg\" alt=\"隐式转换\"></p>\r\n<p>例子，计算从1到100的平均值，仔细研究下面的代码</p>\r\n<pre><code>public class Sum1To100 {\r\n   public static void main(String[] args) {\r\n      int sum = 0;\r\n      double average;\r\n      int number = 1;\r\n      while (number &lt;= 100) {\r\n         sum += number;      // sum最后的结果为int 5050\r\n         ++number;\r\n      }\r\n      average = sum / 100;   // average = 50.0而不是50.5\r\n      System.out.println(&quot;Average is &quot; + average);  // 平均值为50.0\r\n   }\r\n}\r\n</code></pre><p>这是因为sum与100都是int类型，二者相除返回的是被截断的int，如果想得到正确的结果，你可以采用下面的方式：</p>\r\n<pre><code>average = (double)sum / 100;     // 进行除法运算前显示的将sum转成double类型\r\naverage = sum / (double)100;     // 进行除法运算前显示的将100转成double类型\r\naverage = sum / 100.0;\r\naverage = (double)(sum / 100);   // 这种做法是错误的，你知道是什么原因吗？\r\n</code></pre><h3 id=\"h3-6-\"><a name=\"6. 复合赋值运算\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 复合赋值运算</h3><p>除了前面介绍的常用的赋值运算＝，Java还提供了其它的复合赋值运算：</p>\r\n<p>| 操作符 | 解释 | 使用 | 例子 |<br>| = | 赋值<br>将右操作数赋值给左操作数 | <em>var</em>?=?<em>expr</em> | x = 5; |<br>| += | </p>\r\n<p>复合加法运算</p>\r\n<p> | <em>var</em>?+=?<em>expr</em><br>等价于<em>var</em>?=?<em>var</em>?+?<em>expr</em> | x += 5;<br>等价于x = x + 5 |<br>| -= | 复合减法运算 | <em>var</em>?-=?<em>expr</em><br>等价于<em>var</em>?=?<em>var</em>?-?<em>expr</em> | x -= 5;<br>等价于x = x - 5 |<br>| *= | 复合乘法运算 | <em>var</em>?*=?<em>expr</em><br>等价于<em>var</em>?=?<em>var</em>?*?<em>expr</em> | x *= 5;<br>等价于x = x * 5 |<br>| /= | 复合除法运算 | <em>var</em>?/=?<em>expr</em><br>等价于<em>var</em>?=?<em>var</em>?/?<em>expr</em> | x /= 5;<br>等价于x = x / 5 |<br>| %= | 复合取余运算 | <em>var</em>?%=?<em>expr</em><br>等价于<em>var</em>?=?<em>var</em>?%?<em>expr</em> | x %= 5;<br>等价于x = x % 5 |</p>\r\n<h3 id=\"h3-7-\"><a name=\"7. 自增/自减\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 自增/自减</h3><p>对于一元运算自增(++)和自减(—)，适用于除boolean类型以外的其它 基本类型byte, ?short, ?char, ?int, ?long, ?float和double。</p>\r\n<p>| 操作符 | 解释 | 例子 |<br>| ++ | 原数值加1<br>x++或++x等价于x += 1或x = x + 1 | int x = 5;<br>x++;?<br>++x; |<br>| — | 原数值减1<br>x—或—x等价于x -= 1或x = x - 1 | int y = 6;<br>y—;<br>—y; |</p>\r\n<p>自增和自减都是基于自身的操作，例如x++自增后重新返回给x。<br>自增/自减操作符号可以放置于操作数之前，也可以放在操作数之后，但是两者有着不同的意义。</p>\r\n<p>如果这些运算符基于自身操作，运算符前置和后置具有同样的效果，例如++x和x++，因为表达式的值会被忽略。<br>如果用于其它的操作，例如y=x++或y=++x，对于y值来说运算符前置和后置有不同的值。</p>\r\n<p>| 操作符 | 解释 | 例子 |<br>| ++var | 自增<br>首先var加1，计算结果使用var | y = ++x;<br>等价于x=x+1; y=x; |<br>| var++ | 自增<br>首先计算结果使用var<em>，接着var加1</em> | y = x++;<br>等价于oldX=x; x=x+1; y=oldX; |<br>| —var | 自减 | y = —x;<br>等价于x=x-1; y=x; |<br>| var— | 自减 | y = x—;<br>等价于oldX=x; x=x-1; y=oldX; |</p>\r\n<h3 id=\"h3-8-\"><a name=\"8. 关系和逻辑运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. 关系和逻辑运算符</h3><p>很多时候，你需要对两个值进行比较之后，才会进行某些操作，举例如果mark值大于等于50，输出”PASS!”。<br>Java提供了6种比较运算符，经过比较运算后返回布尔值即true或false。</p>\r\n<p>| 操作符 | 解释 | 使用 | 例子(x=5, y=8) |<br>| **==** | 相等 | <em>expr1</em>?==?<em>expr2</em> | (x == y) → false |<br>| **!=** | 不相等 | <em>expr1</em>?!=?<em>expr2</em> | (x != y) → true |<br>| **&gt;** | 大于 | <em>expr1</em>?&gt;?<em>expr2</em> | (x &gt; y) → false |<br>| **&gt;=** | 大于等于 | <em>expr1</em>?&gt;=?<em>expr2</em> | (x &gt;= 5) → true |<br>| **&lt;** | 小于 | <em>expr1</em>?&lt;?<em>expr2</em> | (y &lt; 8) → false |<br>| **&lt;=** | 小于等于 | <em>expr1</em>?&gt;=?<em>expr2</em> | (y &lt;= 8) → true |</p>\r\n<p>每个比较运算符需要两个操作数，正确的写法：x &gt; 1 &amp;&amp; x &lt; 100，错误的写法 1 &lt; x &lt; 100， 这里面&amp;&amp;表示与操作。<br>Java提供了4种基于boolean的逻辑运算，按照优先级顺序如下：</p>\r\n<p>| 操作符 | 解释 | 使用 |<br>| ! | 逻辑非 | !<em>booleanExpr</em> |<br>| ^ | 逻辑异或 | <em>booleanExpr1</em>?^?<em>booleanExpr2</em> |<br>| &amp;&amp; | 逻辑与 | <em>booleanExpr1</em>?&amp;&amp;?<em>booleanExpr2</em> |<br>| || | 逻辑或 | <em>booleanExpr1</em>?||?<em>booleanExpr2</em> |</p>\r\n<p>真值表如下：</p>\r\n<p>| 与?(&amp;&amp;) | true | false |<br>| true | true | false |<br>| false | false | false |<br>| ? | ? | ? |<br>| 或?(||) | true | false |<br>| true | true | true |<br>| false | true | false |<br>| ? | ? | ? |<br>| 非?(!) | true | false |<br>| Result | false | true |<br>| ? | ? | ? |<br>| 异或?(^) | true | false |<br>| true | false | true |<br>| false | true | false |</p>\r\n<p>**举例说明：**</p>\r\n<pre><code>// 如果x取值范围在［0,100]，返回true\r\n(x &gt;= 0) &amp;&amp; (x &lt;= 100)\r\n\r\n// 如果x取值范围不在[0,100]，返回true\r\n(x &lt; 0) || (x &gt; 100)\r\n!((x &gt;= 0) &amp;&amp; (x &lt;= 100))\r\n\r\n// 计算是否为闰年：某年被4但不能被100整除，或者被400整除\r\n((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)\r\n</code></pre><p>练习：研究下面的程序并解释输出。</p>\r\n<pre><code>public class RelationalLogicalOpTest {\r\n   public static void main(String[] args) {\r\n      int age = 18;\r\n      double weight = 71.23;\r\n      int height = 191;\r\n      boolean married = false;\r\n      boolean attached = false;\r\n      char gender = &#39;m&#39;;\r\n\r\n      System.out.println(!married &amp;&amp; !attached &amp;&amp; (gender == &#39;m&#39;));\r\n      System.out.println(married &amp;&amp; (gender == &#39;f&#39;));\r\n      System.out.println((height &gt;= 180) &amp;&amp; (weight &gt;= 65) &amp;&amp; (weight &lt;= 80));\r\n      System.out.println((height &gt;= 180) || (weight &gt;= 90));\r\n   }\r\n}\r\n</code></pre><h5 id=\"h5--\"><a name=\"练习：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习：</h5><p>根据提供的日期：年、月(1-12)和日(1-31)，计算该日期是否早于1582年10月15日。</p>\r\n<h5 id=\"h5-u8FD0u7B97u7B26u4F18u5148u7EA7\"><a name=\"运算符优先级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运算符优先级</h5><p>优先级由高到低：’!’，?’^’，’&amp;&amp;’，’||’，编程中如果不确定，请使用括号()。</p>\r\n<pre><code>System.out.println(true || true &amp;&amp; false);    // true (和下面的一样)\r\nSystem.out.println(true || (true &amp;&amp; false));  // true\r\nSystem.out.println((true || true) &amp;&amp; false);  // false\r\n\r\nSystem.out.println(false &amp;&amp; true ^ true);     // false (和下面的一样)\r\nSystem.out.println(false &amp;&amp; (true ^ true));   // false\r\nSystem.out.println((false &amp;&amp; true) ^ true);   // true\r\n</code></pre><h5 id=\"h5-u77EDu8DEFu64CDu4F5Cu7B26\"><a name=\"短路操作符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>短路操作符</h5><p>逻辑与(&amp;&amp;)和逻辑或(||)被称为短路操作符，这意味计算结果如果可以通过左操作数来确定，那么右操作数会被忽略，例如false &amp;&amp; …会返回false，true || …会返回true。</p>\r\n', '48', '![](http://ww4.sinaimg.cn/large/006pQ25sgw1f2vf75caoej30dw0afjs0.jpg)\r\n### 1\\. 算术运算\r\n\r\nJava支持以下的算术运算：\r\n\r\n| 运算符 | 描述 | 使用 | 例子 |\r\n| \\* | 乘法 | _expr1_?\\*?_expr2_ | 2 \\* 3 → 6\r\n3.3 \\* 1.0 → 3.3 |\r\n| / | 除法 | _expr1_?/?_expr2_ | 1 / 2 → 0\r\n1.0 / 2.0 → 0.5 |\r\n| % | 取余 | _expr1_?%?_expr2_ | 5 % 2 → 1\r\n-5 % 2 → -1\r\n5.5 % 2.2 → 1.1 |\r\n| + | 加法(正号) | _expr1_?+?_expr2_\r\n+expr | 1 + 2 → 3\r\n1.1 + 2.2 → 3.3 |\r\n| - | 减法(负号) | _expr1_?-?_expr2_\r\n-expr | 1 - 2 → -1\r\n1.1 - 2.2 → -1.1 |\r\n\r\n### 2\\. 算术表达式\r\n\r\n对于下面的表达式：\r\n\r\n![](http://ww3.sinaimg.cn/large/006pQ25sgw1f2v9pdv1iej309o01lgln.jpg)\r\n\r\n转化为编码(1+2\\*a)/3 + (4\\*(b+c)\\*(5-d-e))/f - 6\\*(7/g+h)，需要注意的不能省略乘号(\\*)。\r\n\r\n##### 优先级：\r\n\r\n\\*   乘法(\\*)，除法(/)和取余(%)优先于加法(+)和减法(-)运算，例如1+2\\*3-4/2可以表示为1+(2\\*3)-(4/2)。\r\n\\*   正号(+)和负号(-)拥有更高级别。\r\n\\*   括号()拥有最高级别，常用来调整运算顺序。\r\n\\*   对于同级别运算符号，表达式结果从左到右计算，例如1+2-3+4等价于((1+2)-3)+4，1\\*2%3/4等价于((1\\*2)%3)/4。\r\n\r\n### 3\\. 混合类型运算\r\n\r\n算术运算仅适用于基本类型：byte, ?short, ?int, ?long, ?float, ?double和char，其中不包括boolean。\r\n\r\n如果两个操作数的类型是int/long/float/double, 运算操作会直接使用此类型进行计算，例如int 5 + int 6 → int 11;?double 2.1 + double 1.2 → double 3.3。\r\n\r\n值得注意的是对于int的除法运算，计算结果会被截断，例如1/2 → 0而不是0.5。\r\n\r\n如果两个操作数的类型是byte，short或者char，运算操作会使用int类型进行计算，char会被转化为16位无符号整数，例如byte 127 + byte 1 → int 127 + int 1 → int 128。\r\n如果两个操作数属于不同的类型，较小的类型会被隐式的转换成较大的类型，运算操作会使用较大的类型进行计算。\r\n\r\n##### 举例说明：\r\n\r\n\\*   int/double → double/double → double，1/2 → 0, 1.0/2.0 → 0.5, 1.0/2 → 0.5, 1/2.0 → 0.5。\r\n\\*   char + float → int + float → float + float → float。\r\n\\*   9 / 5 \\* 20.1 → (9 / 5) \\* 20.1 → 1 \\* 20.1 → 1.0 \\* 20.1 → 20.1?(你可能不会想到这个答案)。\r\n\\*   byte 1 + byte 2 → int 1 + int 2 → int 3?(结果是int，不是byte)。\r\n\r\n二元运算操作对于类型的转换概括如下：\r\n\r\n\\*   如果其中一个操作数是double，另一个操作数默认转为double。\r\n\\*   如果其中一个操作数是float，另一个操作数默认转为float。\r\n\\*   如果其中一个操作数是long，另一个操作数默认转为long。\r\n\\*   其余的操作数默认的转为int。\r\n\r\n一元运算操(正号、负号)对于类型的转换概括如下：\r\n\r\n\\*   如果操作数是double，float，long或者int，不需要转换。\r\n\\*   其余的如果是byte，short或char，会默认转换为int。\r\n\r\n##### 举例说明：\r\n\r\n```\r\nbyte b1 = 1;\r\nbyte b2 = -b1;  // 编译会出错， 因为-b1会返回int，不能转换成byte\r\n```\r\n\r\n##### 取余运算符\r\n\r\n为了计算余数会重复的运行减法运算，直到差值的绝对值小于右操作数的绝对值，举例说明：\r\n\r\n*   -5 % 2 => -3 % 2 => -1\r\n*   5.5 % 2.2 => 3.3 % 2.2 => 1.1\r\n\r\n##### 指数\r\n\r\n在Java中是没有指数运算符的，你看到的\'^\'运算符是异或，不过你可以使用Math.exp(X,Y)进行指数的运算。\r\n\r\n### 4\\. 向上溢出/向下溢出\r\n\r\n研究下面的代码并解释输出输出：\r\n\r\n```\r\n/\\*\r\n \\* \"int\"溢出说明\r\n \\*/\r\npublic class OverflowTest {\r\n    public static void main(String[] args) {\r\n    // int取值范围[-2147483648, 2147483647]\r\n    int i1 = 2147483647;           // int最大值\r\n    System.out.println(i1 + 1);    // -2147483648 (溢出)\r\n    System.out.println(i1 + 2);    // -2147483647\r\n    System.out.println(i1 \\* i1);   // 1\r\n\r\n    int i2 = -2147483648;          // int最小值\r\n    System.out.println(i2 - 1);    // 2147483647 (溢出)\r\n    System.out.println(i2 - 2);    // 2147483646\r\n    System.out.println(i2 \\* i2);   // 0\r\n    }\r\n}\r\n```\r\n\r\n对于运算过程中的溢出，Java不会发出错误或者警告信息，但会产生不正确的结果。\r\n另一方面整数除法会产生截断的整数，我们称之为向下溢出，例如1/2?→ 0，而不是0.5。\r\n做为程序员你有责任去检查编程中的溢出。\r\n这时候我们也许会问，为什么计算机不去标记溢出？由于历史的原因, 当时处理器很慢，检查溢出会消耗性能。\r\n\r\n### 5\\. 类型转换\r\n\r\n在Java中，如果将double或float数据赋值给int变量会产生编译错误。\r\n\r\n```\r\ndouble d = 3.5;\r\nint i;\r\ni = d;            // 编译错误\r\nint sum = 55.66f; // 编译错误\r\n```\r\n\r\n##### 显示类型转换和类型转换\r\n\r\ndouble赋值给int变量，你需要使用显示类型转换，形式为(int)value，返回的结果是被截断的int数据，举例说明：\r\n\r\n```\r\ndouble d = 3.5;\r\nint i;\r\ni = (int) d;    // 将double类型的3.5转换成int类型的3，之后赋值给i\r\n```\r\n\r\n类型转换只需要一个操作数，Java中有两种类型转换：\r\n\r\n\\*   以(new-type)操作数的形式进行显示类型转换。\r\n\\*   如果没有精度缺失，编译器自动的会进行隐示类型转换。\r\n\r\n```\r\nint i = 3;\r\ndouble d;\r\nd = i;                 // 正确, 不需要进行类型转换，d=3.0\r\nd = (double) i;        // 也可以使用显示类型转换\r\ndouble aDouble = 55;   // 编译器会自动的将int 55转换成double 55.0\r\ndouble nought = 0;     // 编译器会自动的将int 0转换成double 0.0\r\n ? ? ? ? ? ? ? ? ? ? ? // 值得注意的是int 0和double 0.0是不同的\r\n```\r\n\r\n下面的这幅图展示了编译器隐示类型转换的顺序，转换规则是将小类型晋升为大类型，这样做可以防止精度缺失。降级类型需要显示类型转换，精度会缺失，值得注意的是char会被视作16位无符号整数，取值范围[0, 65535]，boolean类型不支持转换。\r\n\r\n![隐式转换](http://ww4.sinaimg.cn/large/006pQ25sgw1f2vc7ivmqkj30dw03qt98.jpg)\r\n\r\n例子，计算从1到100的平均值，仔细研究下面的代码\r\n\r\n```\r\npublic class Sum1To100 {\r\n   public static void main(String[] args) {\r\n      int sum = 0;\r\n      double average;\r\n      int number = 1;\r\n      while (number <= 100) {\r\n         sum += number;      // sum最后的结果为int 5050\r\n         ++number;\r\n      }\r\n      average = sum / 100;   // average = 50.0而不是50.5\r\n      System.out.println(\"Average is \" + average);  // 平均值为50.0\r\n   }\r\n}\r\n```\r\n\r\n这是因为sum与100都是int类型，二者相除返回的是被截断的int，如果想得到正确的结果，你可以采用下面的方式：\r\n\r\n```\r\naverage = (double)sum / 100;     // 进行除法运算前显示的将sum转成double类型\r\naverage = sum / (double)100;     // 进行除法运算前显示的将100转成double类型\r\naverage = sum / 100.0;\r\naverage = (double)(sum / 100);   // 这种做法是错误的，你知道是什么原因吗？\r\n```\r\n\r\n### 6\\. 复合赋值运算\r\n\r\n除了前面介绍的常用的赋值运算＝，Java还提供了其它的复合赋值运算：\r\n\r\n| 操作符 | 解释 | 使用 | 例子 |\r\n| = | 赋值\r\n将右操作数赋值给左操作数 | _var_?=?_expr_ | x = 5; |\r\n| += | \r\n\r\n复合加法运算\r\n\r\n | _var_?+=?_expr_\r\n等价于_var_?=?_var_?+?_expr_ | x += 5;\r\n等价于x = x + 5 |\r\n| -= | 复合减法运算 | _var_?-=?_expr_\r\n等价于_var_?=?_var_?-?_expr_ | x -= 5;\r\n等价于x = x - 5 |\r\n| \\*= | 复合乘法运算 | _var_?\\*=?_expr_\r\n等价于_var_?=?_var_?\\*?_expr_ | x \\*= 5;\r\n等价于x = x \\* 5 |\r\n| /= | 复合除法运算 | _var_?/=?_expr_\r\n等价于_var_?=?_var_?/?_expr_ | x /= 5;\r\n等价于x = x / 5 |\r\n| %= | 复合取余运算 | _var_?%=?_expr_\r\n等价于_var_?=?_var_?%?_expr_ | x %= 5;\r\n等价于x = x % 5 |\r\n\r\n### 7\\. 自增/自减\r\n\r\n对于一元运算自增(++)和自减(--)，适用于除boolean类型以外的其它 基本类型byte, ?short, ?char, ?int, ?long, ?float和double。\r\n\r\n| 操作符 | 解释 | 例子 |\r\n| ++ | 原数值加1\r\nx++或++x等价于x += 1或x = x + 1 | int x = 5;\r\nx++;?\r\n++x; |\r\n| -- | 原数值减1\r\nx--或--x等价于x -= 1或x = x - 1 | int y = 6;\r\ny--;\r\n--y; |\r\n\r\n自增和自减都是基于自身的操作，例如x++自增后重新返回给x。\r\n自增/自减操作符号可以放置于操作数之前，也可以放在操作数之后，但是两者有着不同的意义。\r\n\r\n如果这些运算符基于自身操作，运算符前置和后置具有同样的效果，例如++x和x++，因为表达式的值会被忽略。\r\n如果用于其它的操作，例如y=x++或y=++x，对于y值来说运算符前置和后置有不同的值。\r\n\r\n| 操作符 | 解释 | 例子 |\r\n| ++var | 自增\r\n首先var加1，计算结果使用var | y = ++x;\r\n等价于x=x+1; y=x; |\r\n| var++ | 自增\r\n首先计算结果使用var_，接着var加1_ | y = x++;\r\n等价于oldX=x; x=x+1; y=oldX; |\r\n| --var | 自减 | y = --x;\r\n等价于x=x-1; y=x; |\r\n| var-- | 自减 | y = x--;\r\n等价于oldX=x; x=x-1; y=oldX; |\r\n\r\n### 8\\. 关系和逻辑运算符\r\n\r\n很多时候，你需要对两个值进行比较之后，才会进行某些操作，举例如果mark值大于等于50，输出\"PASS!\"。\r\nJava提供了6种比较运算符，经过比较运算后返回布尔值即true或false。\r\n\r\n| 操作符 | 解释 | 使用 | 例子(x=5, y=8) |\r\n| \\*\\*==\\*\\* | 相等 | _expr1_?==?_expr2_ | (x == y) → false |\r\n| \\*\\*!=\\*\\* | 不相等 | _expr1_?!=?_expr2_ | (x != y) → true |\r\n| \\*\\*>\\*\\* | 大于 | _expr1_?>?_expr2_ | (x > y) → false |\r\n| \\*\\*>=\\*\\* | 大于等于 | _expr1_?>=?_expr2_ | (x >= 5) → true |\r\n| \\*\\*<\\*\\* | 小于 | _expr1_?<?_expr2_ | (y < 8) → false |\r\n| \\*\\*<=\\*\\* | 小于等于 | _expr1_?>=?_expr2_ | (y <= 8) → true |\r\n\r\n每个比较运算符需要两个操作数，正确的写法：x > 1 && x < 100，错误的写法 1 < x < 100， 这里面&&表示与操作。\r\nJava提供了4种基于boolean的逻辑运算，按照优先级顺序如下：\r\n\r\n| 操作符 | 解释 | 使用 |\r\n| ! | 逻辑非 | !_booleanExpr_ |\r\n| ^ | 逻辑异或 | _booleanExpr1_?^?_booleanExpr2_ |\r\n| && | 逻辑与 | _booleanExpr1_?&&?_booleanExpr2_ |\r\n| || | 逻辑或 | _booleanExpr1_?||?_booleanExpr2_ |\r\n\r\n真值表如下：\r\n\r\n| 与?(&&) | true | false |\r\n| true | true | false |\r\n| false | false | false |\r\n| ? | ? | ? |\r\n| 或?(||) | true | false |\r\n| true | true | true |\r\n| false | true | false |\r\n| ? | ? | ? |\r\n| 非?(!) | true | false |\r\n| Result | false | true |\r\n| ? | ? | ? |\r\n| 异或?(^) | true | false |\r\n| true | false | true |\r\n| false | true | false |\r\n\r\n\\*\\*举例说明：\\*\\*\r\n\r\n```\r\n// 如果x取值范围在［0,100]，返回true\r\n(x >= 0) && (x <= 100)\r\n\r\n// 如果x取值范围不在[0,100]，返回true\r\n(x < 0) || (x > 100)\r\n!((x >= 0) && (x <= 100))\r\n\r\n// 计算是否为闰年：某年被4但不能被100整除，或者被400整除\r\n((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)\r\n```\r\n\r\n练习：研究下面的程序并解释输出。\r\n\r\n```\r\npublic class RelationalLogicalOpTest {\r\n   public static void main(String[] args) {\r\n      int age = 18;\r\n      double weight = 71.23;\r\n      int height = 191;\r\n      boolean married = false;\r\n      boolean attached = false;\r\n      char gender = \'m\';\r\n\r\n      System.out.println(!married && !attached && (gender == \'m\'));\r\n      System.out.println(married && (gender == \'f\'));\r\n      System.out.println((height >= 180) && (weight >= 65) && (weight <= 80));\r\n      System.out.println((height >= 180) || (weight >= 90));\r\n   }\r\n}\r\n```\r\n\r\n##### 练习：\r\n\r\n根据提供的日期：年、月(1-12)和日(1-31)，计算该日期是否早于1582年10月15日。\r\n\r\n##### 运算符优先级\r\n\r\n优先级由高到低：\'!\'，?\'^\'，\'&&\'，\'||\'，编程中如果不确定，请使用括号()。\r\n\r\n```\r\nSystem.out.println(true || true && false);    // true (和下面的一样)\r\nSystem.out.println(true || (true && false));  // true\r\nSystem.out.println((true || true) && false);  // false\r\n\r\nSystem.out.println(false && true ^ true);     // false (和下面的一样)\r\nSystem.out.println(false && (true ^ true));   // false\r\nSystem.out.println((false && true) ^ true);   // true\r\n```\r\n\r\n##### 短路操作符\r\n\r\n逻辑与(&&)和逻辑或(||)被称为短路操作符，这意味计算结果如果可以通过左操作数来确定，那么右操作数会被忽略，例如false && ...会返回false，true || ...会返回true。');
INSERT INTO `article_info_true` VALUES ('32', '字符串', '<p><img src=\"http://ww1.sinaimg.cn/large/006pQ25sgw1f2wfcv0kf9j30dw06bjrm.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1. 前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 前言</h3><p>String是嵌入在双引号里的字符序列，例如：</p>\r\n<pre><code>String s1 = &quot;Hi, This is a string!&quot;;\r\nString s2 = &quot;&quot;                       // 空串\r\n</code></pre><p>如果想输出特殊的控制字符，你需要使用反斜线\\来进行转义，单引号不需要转义，例如：</p>\r\n<pre><code>String s3 = &quot;A \\&quot;string\\&quot; nested \\\\inside\\\\ a string&quot;;\r\nString s4 = &quot;Hello, \\u60a8\\u597d!&quot;;   // &quot;Hello, 您好!&quot;\r\nString s5 = &quot;Hi, I&#39;m a string!&quot;;      // 单引号\r\n</code></pre><h3 id=\"h3-2-string-\"><a name=\"2. String和’+’运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. String和’+’运算符</h3><p>在Java中，’+’是被重载的运算符，重载意味着对于不同类型有着不同的操作。</p>\r\n<p>如果两个操作数都是数字(byte, short, int, long, float, double, char)，’+’会执行加法运算，例如：</p>\r\n<pre><code>1 + 2 → 3\r\n1.2 + 2.2 → 3.4\r\n1 + 2.2 → 1.0 + 2.2 → 3.2\r\n</code></pre><p>如果两个操作数是字符串，’+’会将两个字符串拼接在一起返回，例如：</p>\r\n<pre><code>&quot;Hello&quot; + &quot;world&quot; → &quot;Helloworld&quot;\r\n&quot;Hi&quot; + &quot;, &quot; + &quot;world&quot; + &quot;!&quot; → &quot;Hi, world!&quot;\r\n</code></pre><p>如果其中一个操作数是字符串，另外一个操作数是数字，’+’会首先将数字转化为字符串，之后进行字符串的拼接操作，例如：</p>\r\n<pre><code>&quot;The number is &quot; + 5 → &quot;The number is &quot; + &quot;5&quot; → &quot;The number is 5&quot;\r\n&quot;The average is &quot; + average + &quot;!&quot; (suppose average=5.5) → &quot;The average is &quot; + &quot;5.5&quot; + &quot;!&quot; → &quot;The average is 5.5!&quot;\r\n&quot;How about &quot; + a + b (suppose a=1, b=1) → &quot;How about 11&quot;\r\n</code></pre><h3 id=\"h3-3-string-\"><a name=\"3. String操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. String操作</h3><p>最常用的String操作：</p>\r\n<ul>\r\n<li>length(): 返回字符串的长度。</li><li>charAt(int index): 返回某个字符的索引位置(索引位置是从0开始到length()-1结束)。</li><li>equals(): 常用来比较两个字符串文本内容是否相等，切忌请不要使用”==”，”==”比较的是引用。</li></ul>\r\n<h5 id=\"h5--\"><a name=\"举例说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举例说明：</h5><pre><code>String str = &quot;Java is cool!&quot;;\r\nSystem.out.println(str.length());                      // 返回int 13\r\nSystem.out.println(str.charAt(2));                     // 返回char &#39;v&#39;\r\nSystem.out.println(str.charAt(5));                     // 返回char &#39;i&#39;\r\n\r\n// 比较两个字符串\r\nString anotherStr = &quot;Java is COOL!&quot;;\r\nSystem.out.println(str.equals(anotherStr));            // 返回 boolean false\r\nSystem.out.println(str.equalsIgnoreCase(anotherStr));  // 返回 boolean true\r\nSystem.out.println(anotherStr.equals(str));            // 返回 boolean false\r\nSystem.out.println(anotherStr.equalsIgnoreCase(str));  // 返回 boolean true\r\n\r\n// 其它常用的方法\r\nSystem.out.println(str.substring(0, 3));               // 返回String &quot;Jav&quot;\r\nSystem.out.println(str.indexOf(&#39;a&#39;));                  // 返回int 1\r\nSystem.out.println(str.lastIndexOf(&#39;a&#39;));              // 返回int 3\r\nSystem.out.println(str.endsWith(&quot;cool!&quot;));             // 返回boolean true\r\nSystem.out.println(str.toUpperCase());                 // 返回新的String &quot;JAVA IS COOL!&quot;\r\nSystem.out.println(str.toLowerCase());                 // 返回新的String &quot;java is cool!&quot;\r\n</code></pre><h3 id=\"h3-4-stirng-\"><a name=\"4. Stirng和基本类型的转换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. Stirng和基本类型的转换</h3><h5 id=\"h5-string-int-byte-short-long\"><a name=\"String转换为int/byte/short/long\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>String转换为int/byte/short/long</h5><p>可以使用Integer.parseInt(anIntStr)，Byte.parseByte(aByteStr), ?Short.parseShort(aShortStr), ?Long.parseLong(aLongStr)进行相应的转换，需要注意的是字符串中包含非数字，运行时会抛出NumberFormatException异常，例如：</p>\r\n<pre><code>String inStr = &quot;5566&quot;;\r\nint number = Integer.parseInt(inStr);   // 返回int类型\r\n</code></pre><h5 id=\"h5-string-double-float\"><a name=\"String转换为double/float\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>String转换为double/float</h5><p>可以使用Double.parseDouble(aDoubleStr)或Float.parseFloat(aFloatStr)进行转换，例如：</p>\r\n<pre><code>String inStr = &quot;55.66&quot;;\r\nfloat aFloat = Float.parseFloat(inStr);         // 返回float类型\r\n</code></pre><h5 id=\"h5-string-char\"><a name=\"String转换为char\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>String转换为char</h5><p>可以使用aStr.charAt(index)从字符串中提取单个字符，例如：</p>\r\n<pre><code>String msg = &quot;101100111001!&quot;;\r\nint pos = 0;\r\nwhile (pos &lt; msg.length()) {\r\n   char binChar = msg.charAt(pos);\r\n   .......\r\n   ++pos;\r\n}\r\n</code></pre><h5 id=\"h5-string-boolean\"><a name=\"String转换为boolean\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>String转换为boolean</h5><p>可以使用Boolean.parseBoolean(aBooleanStr)将文本”true”或”false”转换为boolean类型的true或false，例如：</p>\r\n<pre><code>String boolStr = &quot;true&quot;;\r\nboolean done = Boolean.parseBoolean(boolStr);  // 返回boolean类型\r\n</code></pre><h5 id=\"h5--int-double-float-byte-short-long-char-boolean-string\"><a name=\"基本类型(int/double/float/byte/short/long/char/boolean)转换为String\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基本类型(int/double/float/byte/short/long/char/boolean)转换为String</h5><p>可以使用’+’操作符: 基本类型变量+ 空串(“”), 或者使用String.valueOf(aPrimitve), 或者根据类型调用相应的方法进行转换: String.valueOf(aPrimitve),Integer.toString(anInt), Double.toString(aDouble),Character.toString(aChar),Boolean.toString(aBoolean)。</p>\r\n<pre><code>// 使用连接符&#39;+&#39;，a适用于所有的基本类型\r\nString s1 = 123 + &quot;&quot;;                // int 123 -&gt; &quot;123&quot;\r\nString s2 = 12.34 + &quot;&quot;;              // double 12.34 -&gt; &quot;12.34&quot;\r\nString s3 = &#39;c&#39; + &quot;&quot;;                // char &#39;c&#39; -&gt; &quot;c&quot;\r\nString s4 = true + &quot;&quot;;               // boolean true -&gt; &quot;true&quot;\r\n // String.valueOf(aPrimitive)同样适用于所有的基本类型\r\nString s1 = String.valueOf(12345);   // int 12345 -&gt; &quot;12345&quot;\r\nString s2 = String.valueof(true);    // boolean true -&gt; &quot;true&quot;\r\ndouble d = 55.66;\r\nString s3 = String.valueOf(d);       // double 55.66 -&gt; &quot;55.66&quot;\r\n // toString()适用于每个基本类型，但是要防止空指针的异常\r\nString s4 = Integer.toString(1234);  // int 1234 -&gt; &quot;1234&quot;\r\nString s5 = Double.toString(1.23);   // double 1.23 -&gt; &quot;1.23&quot;\r\nchar c1   = Character.toString(&#39;z&#39;); // char &#39;z&#39; -&gt; &quot;z&quot;\r\n\r\n// char转换为String\r\nchar c = &#39;a&#39;;\r\nString s5 = c;                       // 编译错误\r\nString s6 = c + &quot;&quot;;                  // 将char转换为String\r\n\r\n// boolean转换为String\r\nboolean done = false;\r\nString s7 = done + &quot;&quot;;               // boolean false -&gt; &quot;false&quot;\r\nString s8 = Boolean.toString(done);\r\nString s9 = String.valueOf(done);\r\n</code></pre><h5 id=\"h5-char-int\"><a name=\"char转换为int\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>char转换为int</h5><p>如果想将char’0’到’9’转换为int0到9，可以用该字符减去’0’即可，例如’8’ - ‘0’ ?→ 8。</p>\r\n', '49', '![](http://ww1.sinaimg.cn/large/006pQ25sgw1f2wfcv0kf9j30dw06bjrm.jpg)\r\n### 1\\. 前言\r\n\r\nString是嵌入在双引号里的字符序列，例如：\r\n\r\n```\r\nString s1 = \"Hi, This is a string!\";\r\nString s2 = \"\"                       // 空串\r\n\r\n```\r\n\r\n如果想输出特殊的控制字符，你需要使用反斜线\\来进行转义，单引号不需要转义，例如：\r\n\r\n```\r\nString s3 = \"A \\\"string\\\" nested \\\\inside\\\\ a string\";\r\nString s4 = \"Hello, \\u60a8\\u597d!\";   // \"Hello, 您好!\"\r\nString s5 = \"Hi, I\'m a string!\";      // 单引号\r\n```\r\n\r\n### 2\\. String和\'+\'运算符\r\n\r\n在Java中，\'+\'是被重载的运算符，重载意味着对于不同类型有着不同的操作。\r\n\r\n如果两个操作数都是数字(byte, short, int, long, float, double, char)，\'+\'会执行加法运算，例如：\r\n\r\n```\r\n1 + 2 → 3\r\n1.2 + 2.2 → 3.4\r\n1 + 2.2 → 1.0 + 2.2 → 3.2\r\n```\r\n\r\n如果两个操作数是字符串，\'+\'会将两个字符串拼接在一起返回，例如：\r\n\r\n```\r\n\"Hello\" + \"world\" → \"Helloworld\"\r\n\"Hi\" + \", \" + \"world\" + \"!\" → \"Hi, world!\"\r\n```\r\n\r\n如果其中一个操作数是字符串，另外一个操作数是数字，\'+\'会首先将数字转化为字符串，之后进行字符串的拼接操作，例如：\r\n\r\n```\r\n\"The number is \" + 5 → \"The number is \" + \"5\" → \"The number is 5\"\r\n\"The average is \" + average + \"!\" (suppose average=5.5) → \"The average is \" + \"5.5\" + \"!\" → \"The average is 5.5!\"\r\n\"How about \" + a + b (suppose a=1, b=1) → \"How about 11\"\r\n```\r\n\r\n### 3\\. String操作\r\n\r\n最常用的String操作：\r\n\r\n*   length(): 返回字符串的长度。\r\n*   charAt(int index): 返回某个字符的索引位置(索引位置是从0开始到length()-1结束)。\r\n*   equals(): 常用来比较两个字符串文本内容是否相等，切忌请不要使用\"==\"，\"==\"比较的是引用。\r\n\r\n##### 举例说明：\r\n\r\n```\r\nString str = \"Java is cool!\";\r\nSystem.out.println(str.length());                      // 返回int 13\r\nSystem.out.println(str.charAt(2));                     // 返回char \'v\'\r\nSystem.out.println(str.charAt(5));                     // 返回char \'i\'\r\n\r\n// 比较两个字符串\r\nString anotherStr = \"Java is COOL!\";\r\nSystem.out.println(str.equals(anotherStr));            // 返回 boolean false\r\nSystem.out.println(str.equalsIgnoreCase(anotherStr));  // 返回 boolean true\r\nSystem.out.println(anotherStr.equals(str));            // 返回 boolean false\r\nSystem.out.println(anotherStr.equalsIgnoreCase(str));  // 返回 boolean true\r\n\r\n// 其它常用的方法\r\nSystem.out.println(str.substring(0, 3));               // 返回String \"Jav\"\r\nSystem.out.println(str.indexOf(\'a\'));                  // 返回int 1\r\nSystem.out.println(str.lastIndexOf(\'a\'));              // 返回int 3\r\nSystem.out.println(str.endsWith(\"cool!\"));             // 返回boolean true\r\nSystem.out.println(str.toUpperCase());                 // 返回新的String \"JAVA IS COOL!\"\r\nSystem.out.println(str.toLowerCase());                 // 返回新的String \"java is cool!\"\r\n\r\n```\r\n\r\n### 4\\. Stirng和基本类型的转换\r\n\r\n##### String转换为int/byte/short/long\r\n\r\n可以使用Integer.parseInt(anIntStr)，Byte.parseByte(aByteStr), ?Short.parseShort(aShortStr), ?Long.parseLong(aLongStr)进行相应的转换，需要注意的是字符串中包含非数字，运行时会抛出NumberFormatException异常，例如：\r\n\r\n```\r\nString inStr = \"5566\";\r\nint number = Integer.parseInt(inStr);   // 返回int类型 \r\n```\r\n\r\n##### String转换为double/float\r\n\r\n可以使用Double.parseDouble(aDoubleStr)或Float.parseFloat(aFloatStr)进行转换，例如：\r\n\r\n```\r\nString inStr = \"55.66\";\r\nfloat aFloat = Float.parseFloat(inStr);         // 返回float类型\r\n```\r\n\r\n##### String转换为char\r\n\r\n可以使用aStr.charAt(index)从字符串中提取单个字符，例如：\r\n\r\n```\r\nString msg = \"101100111001!\";\r\nint pos = 0;\r\nwhile (pos < msg.length()) {\r\n   char binChar = msg.charAt(pos);\r\n   .......\r\n   ++pos;\r\n}\r\n```\r\n\r\n##### String转换为boolean\r\n\r\n可以使用Boolean.parseBoolean(aBooleanStr)将文本\"true\"或\"false\"转换为boolean类型的true或false，例如：\r\n\r\n```\r\nString boolStr = \"true\";\r\nboolean done = Boolean.parseBoolean(boolStr);  // 返回boolean类型\r\n```\r\n\r\n##### 基本类型(int/double/float/byte/short/long/char/boolean)转换为String\r\n\r\n可以使用\'+\'操作符: 基本类型变量+ 空串(\"\"), 或者使用String.valueOf(aPrimitve), 或者根据类型调用相应的方法进行转换: String.valueOf(aPrimitve),Integer.toString(anInt), Double.toString(aDouble),Character.toString(aChar),Boolean.toString(aBoolean)。\r\n\r\n```\r\n// 使用连接符\'+\'，a适用于所有的基本类型\r\nString s1 = 123 + \"\";                // int 123 -> \"123\"\r\nString s2 = 12.34 + \"\";              // double 12.34 -> \"12.34\"\r\nString s3 = \'c\' + \"\";                // char \'c\' -> \"c\"\r\nString s4 = true + \"\";               // boolean true -> \"true\"\r\n // String.valueOf(aPrimitive)同样适用于所有的基本类型\r\nString s1 = String.valueOf(12345);   // int 12345 -> \"12345\"\r\nString s2 = String.valueof(true);    // boolean true -> \"true\"\r\ndouble d = 55.66;\r\nString s3 = String.valueOf(d);       // double 55.66 -> \"55.66\"\r\n // toString()适用于每个基本类型，但是要防止空指针的异常\r\nString s4 = Integer.toString(1234);  // int 1234 -> \"1234\"\r\nString s5 = Double.toString(1.23);   // double 1.23 -> \"1.23\"\r\nchar c1   = Character.toString(\'z\'); // char \'z\' -> \"z\"\r\n\r\n// char转换为String\r\nchar c = \'a\';\r\nString s5 = c;                       // 编译错误\r\nString s6 = c + \"\";                  // 将char转换为String\r\n\r\n// boolean转换为String\r\nboolean done = false;\r\nString s7 = done + \"\";               // boolean false -> \"false\"\r\nString s8 = Boolean.toString(done);\r\nString s9 = String.valueOf(done);\r\n```\r\n\r\n##### char转换为int\r\n\r\n如果想将char\'0\'到\'9\'转换为int0到9，可以用该字符减去\'0\'即可，例如\'8\' - \'0\' ?→ 8。');
INSERT INTO `article_info_true` VALUES ('33', 'java基础', '<p><img src=\"http://images.cnitblog.com/blog/413416/201303/31193650-11637d001c184b7fb6a906de853eece6.jpg\" alt=\"\"><br>Java是面向对象语言。这门语言其实相当年轻，于1995年才出现，由Sun公司出品。James Gosling领导了Java的项目小组。该项目的最初只想为家电设计一门容易移植的语言。然而，在获得了Netscape浏览器支持后，Java快速推广，应用广泛。</p>\r\n<p>Java受到C和C++的强烈影响。Java与C++相近，都是静态类型，但移除了C++中容易出错的一些特征，比如指针和多重继承。Java的垃圾回收可以自动的管理和清理内存。清理内存工作转交给编译器后，程序员的负担大大减小。Java产出效率高，又有良好的运行效率，在PC端、服务器端和移动端都有不俗的表现。Android更是为Java注入新鲜血液。Java又是一门完全的面向对象语言，所以是了解其他面向对象语言的一个好范本。</p>\r\n', '28', '![](http://images.cnitblog.com/blog/413416/201303/31193650-11637d001c184b7fb6a906de853eece6.jpg)\r\nJava是面向对象语言。这门语言其实相当年轻，于1995年才出现，由Sun公司出品。James Gosling领导了Java的项目小组。该项目的最初只想为家电设计一门容易移植的语言。然而，在获得了Netscape浏览器支持后，Java快速推广，应用广泛。\r\n\r\nJava受到C和C++的强烈影响。Java与C++相近，都是静态类型，但移除了C++中容易出错的一些特征，比如指针和多重继承。Java的垃圾回收可以自动的管理和清理内存。清理内存工作转交给编译器后，程序员的负担大大减小。Java产出效率高，又有良好的运行效率，在PC端、服务器端和移动端都有不俗的表现。Android更是为Java注入新鲜血液。Java又是一门完全的面向对象语言，所以是了解其他面向对象语言的一个好范本。');
INSERT INTO `article_info_true` VALUES ('34', '输入输出', '<p><img src=\"http://ww3.sinaimg.cn/large/006pQ25sgw1f44ggzh5loj30dw0a43zo.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-printf-jdk1-5-\"><a name=\"1. printf方法(JDK1.5)：格式化输出语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. printf方法(JDK1.5)：格式化输出语句</h3><p>System.out.printf()和println()不支持格式化输出，例如输出int和double值的同时，输出特定数量的空格。</p>\r\n<p>我们可以通过使用JDK1.5中提供的新方法printf()来格式化输出，形式如下：</p>\r\n<p>printf(formatting-string, arg1, arg2, arg3, … );</p>\r\n<p>Formatting-string包含普通文本或格式化说明符，普通文本即时输出，格式化说明符”%[flag][width]转换符”需要转化处理，flag表示对齐方式，width表示固定宽度，转换符d表示Integer、f表示float、c表示char、s表示String，举例说明：</p>\r\n<ul>\r\n<li>%αd: 输出固定宽度的整数。</li><li>%αs: 输出固定宽度的字符串。</li><li>%α.βf: 输出固定宽度的浮点数，其中β表示小数位数。</li><li>%n: 换行符，Windows使用”\\r\\n”，Unix和Mac使用”\\n”。</li></ul>\r\n<h5 id=\"h5--\"><a name=\"举例说明：这里我们＊表示空格\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举例说明：这里我们＊表示空格</h5><pre><code>System.out.printf(&quot;Hello%2d and %6s%n&quot;, 8, &quot;HI!!!&quot;);\r\n// Hello*8 and *HI!!!\r\n\r\nSystem.out.printf(&quot;Hi,%s%4d%n&quot;, &quot;Hello&quot;, 88);\r\n// Hi,Hello**88\r\n\r\nSystem.out.printf(&quot;Hi, %d %4.2f%n&quot;, 8, 5.556);\r\n// Hi, 8 5.56\r\n\r\nSystem.out.printf(&quot;Hi,%-4s&amp;%6.2f%n&quot;, &quot;Hi&quot;, 5.5);  // &#39;%-ns&#39;表示左对齐\r\n// Hi,Hi**&amp;**5.50\r\n\r\nSystem.out.printf(&quot;Hi, Hi, %.4f%n&quot;, 5.56);\r\n// Hi, Hi, 5.5600\r\n</code></pre><h3 id=\"h3-2-scanner-\"><a name=\"2. 使用Scanner读取键盘输入\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 使用Scanner读取键盘输入</h3><p>Java支持标准的输入/输出流：System.in(标准输入装置)，System.out(标准输出装置)，System.err(标准错误装置)，默认情况下System.out和System.err会将信息输出到控制台上，我们也可以通过重定向输出到其它装置，例如我们常用来使用磁盘来存储日志信息。</p>\r\n<p>JDK1.5中引入了新的java.util.Scanner类来简化格式输入，Scanner类nextInt()方法读取输入的int值，nextDouble()读取double值，next()读取文本信息，读取过程中空格、tab和换行符会被忽略。</p>\r\n<pre><code>import java.util.Scanner;\r\n\r\npublic class ScannerTest {\r\n    public static void main(String[] args) {\r\n        int num1;\r\n        double num2;\r\n        String str;\r\n\r\n        // 通过使用System.in来构造Scanner的实例\r\n        Scanner in = new Scanner(System.in);\r\n\r\n        // 从键盘读取输入\r\n        System.out.print(&quot;请输入整数: &quot;);\r\n        num1 = in.nextInt();\r\n        System.out.print(&quot;请输入浮点数: &quot;);\r\n        num2 = in.nextDouble();\r\n        System.out.print(&quot;请输入文本: &quot;);\r\n        str  = in.next();\r\n        System.out.printf(&quot;%s, %d 和 %.2f和为: %.2f%n&quot;, str, num1, num2, num1+num2);\r\n        in.close();\r\n    }\r\n}\r\n\r\n// 你还可以使用nextLine()方法来读取用户输入的一整行信息，其中可以包含空格，但不包含换行符。\r\nimport java.util.Scanner;\r\npublic class ScannerNextLineTest {\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        System.out.print(&quot;请输入文本(包含空格): &quot;);\r\n        String str  = in.nextLine();\r\n        System.out.printf(&quot;%s%n&quot;, str);\r\n        in.close();\r\n    }\r\n}\r\n\r\n// Scanner类提供的方法不仅仅是这些，通过查看JDK帮助文档来了解更多的方法。\r\n</code></pre><h3 id=\"h3-3-scanner-\"><a name=\"3. 使用Scanner读取文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 使用Scanner读取文件</h3><p>Scanner不仅可以读取键盘输入，同时还可以读取各种不同的输入源，例如文件或网络Socket。</p>\r\n<p>举例说明：</p>\r\n<pre><code>Scanner in = new Scanner(new File(&quot;in.txt&quot;)); // 使用文件构造\r\nint anInt = in.nextInt();                     // 读取文本\r\ndouble aDouble = in.nextDouble();             // 读取double\r\nString str = in.next();                       // 读取int\r\nString line = in.nextLine();                  // 读取整行信息\r\n</code></pre><p>如果想打开文件，你需要处理FileNotFoundException异常，否则编译不通过，有两种方式处理这个异常：throws或者try-catch。</p>\r\n<p>通过使用throws处理异常：</p>\r\n<pre><code>import java.util.Scanner;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\n\r\npublic class TextFileScannerWithThrows {\r\n    public static void main(String[] args) throws FileNotFoundException {  \r\n        // 在这里定义&quot;throws&quot;\r\n        int num1;\r\n        double num2;\r\n        String name;\r\n        Scanner in = new Scanner(new File(&quot;in.txt&quot;));  // 通过文件构造\r\n        num1 = in.nextInt();      // 读取int\r\n        num2 = in.nextDouble();   // 读取double\r\n        name = in.next();         // 读取文本\r\n        System.out.printf(&quot;%s, %d 和 %.2f和为: %.2f%n&quot;, name, num1, num2, num1+num2);\r\n        in.close();\r\n    }\r\n}\r\n</code></pre><p>为了运行上面的程序，你需要新建文件in.txt，内容如下：</p>\r\n<p>1234<br>55.66<br>Happy’s home</p>\r\n<p>通过使用try-catch处理异常：</p>\r\n<pre><code>import java.io.FileNotFoundException;\r\nimport java.util.Scanner;\r\n\r\npublic class TextFileScannerWithCatch {\r\n    public static void main(String[] args) {\r\n        int num1;\r\n        double num2;\r\n        String name;\r\n        Scanner in = null;\r\n\r\n        try {\r\n            in = new Scanner(new File(&quot;in.txt&quot;));  // 通过文件构造\r\n            num1 = in.nextInt();      // 读取int\r\n            num2 = in.nextDouble();   // 读取double\r\n            name = in.next();         // 读取文本\r\n            System.out.printf(&quot;%s, %d 和 %.2f和为: %.2f%n&quot;, name, num1, num2, num1+num2);\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();        \r\n        } finally {\r\n            if(in != null){\r\n                in.close();\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-4-\"><a name=\"4. 文件中写入格式化输出的语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 文件中写入格式化输出的语句</h3><p>JDK1.5中引入Formatter类来格式化输出，Formatter类的format()方法与System.in.printf()方法类似。</p>\r\n<pre><code>import java.io.File;\r\nimport java.util.Formatter;            \r\nimport java.io.FileNotFoundException; \r\n\r\npublic class TextFileFormatterWithThrows {\r\n    public static void main(String[] args) throws FileNotFoundException {          // 通过使用输出文件来构造Formatter类的实例\r\n        Formatter out = new Formatter(new File(&quot;out.txt&quot;));\r\n        int num1 = 1234;\r\n        double num2 = 55.66;\r\n        String name = &quot;开心的冰屋&quot;;\r\n        out.format(&quot;您好: %s,%n&quot;, name);\r\n        out.format(&quot;%d 和 %.2f和为: %.2f%n&quot;, num1, num2, num1+num2);\r\n        out.close();               \r\n    }\r\n}\r\n// 程序运行结束后，通过查看&quot;out.txt&quot;来验证输出的结果。\r\n</code></pre>', '51', '![](http://ww3.sinaimg.cn/large/006pQ25sgw1f44ggzh5loj30dw0a43zo.jpg)\r\n### 1\\. printf方法(JDK1.5)：格式化输出语句\r\n\r\nSystem.out.printf()和println()不支持格式化输出，例如输出int和double值的同时，输出特定数量的空格。\r\n\r\n我们可以通过使用JDK1.5中提供的新方法printf()来格式化输出，形式如下：\r\n\r\nprintf(formatting-string, arg1, arg2, arg3, ... );\r\n\r\nFormatting-string包含普通文本或格式化说明符，普通文本即时输出，格式化说明符\"%[flag][width]转换符\"需要转化处理，flag表示对齐方式，width表示固定宽度，转换符d表示Integer、f表示float、c表示char、s表示String，举例说明：\r\n\r\n*   %αd: 输出固定宽度的整数。\r\n*   %αs: 输出固定宽度的字符串。\r\n*   %α.βf: 输出固定宽度的浮点数，其中β表示小数位数。\r\n*   %n: 换行符，Windows使用\"\\r\\n\"，Unix和Mac使用\"\\n\"。\r\n\r\n##### 举例说明：这里我们＊表示空格\r\n\r\n```\r\nSystem.out.printf(\"Hello%2d and %6s%n\", 8, \"HI!!!\");\r\n// Hello*8 and *HI!!!\r\n\r\nSystem.out.printf(\"Hi,%s%4d%n\", \"Hello\", 88);\r\n// Hi,Hello**88\r\n\r\nSystem.out.printf(\"Hi, %d %4.2f%n\", 8, 5.556);\r\n// Hi, 8 5.56\r\n\r\nSystem.out.printf(\"Hi,%-4s&%6.2f%n\", \"Hi\", 5.5);  // \'%-ns\'表示左对齐\r\n// Hi,Hi**&**5.50\r\n\r\nSystem.out.printf(\"Hi, Hi, %.4f%n\", 5.56);\r\n// Hi, Hi, 5.5600\r\n```\r\n\r\n### 2\\. 使用Scanner读取键盘输入\r\n\r\nJava支持标准的输入/输出流：System.in(标准输入装置)，System.out(标准输出装置)，System.err(标准错误装置)，默认情况下System.out和System.err会将信息输出到控制台上，我们也可以通过重定向输出到其它装置，例如我们常用来使用磁盘来存储日志信息。\r\n\r\nJDK1.5中引入了新的java.util.Scanner类来简化格式输入，Scanner类nextInt()方法读取输入的int值，nextDouble()读取double值，next()读取文本信息，读取过程中空格、tab和换行符会被忽略。\r\n\r\n```\r\nimport java.util.Scanner;\r\n\r\npublic class ScannerTest {\r\n    public static void main(String[] args) {\r\n        int num1;\r\n        double num2;\r\n        String str;\r\n\r\n        // 通过使用System.in来构造Scanner的实例\r\n        Scanner in = new Scanner(System.in);\r\n\r\n        // 从键盘读取输入\r\n        System.out.print(\"请输入整数: \");\r\n        num1 = in.nextInt();\r\n        System.out.print(\"请输入浮点数: \");\r\n        num2 = in.nextDouble();\r\n        System.out.print(\"请输入文本: \");\r\n        str  = in.next();\r\n        System.out.printf(\"%s, %d 和 %.2f和为: %.2f%n\", str, num1, num2, num1+num2);\r\n        in.close();\r\n    }\r\n}\r\n\r\n// 你还可以使用nextLine()方法来读取用户输入的一整行信息，其中可以包含空格，但不包含换行符。\r\nimport java.util.Scanner;\r\npublic class ScannerNextLineTest {\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        System.out.print(\"请输入文本(包含空格): \");\r\n        String str  = in.nextLine();\r\n        System.out.printf(\"%s%n\", str);\r\n        in.close();\r\n    }\r\n}\r\n\r\n// Scanner类提供的方法不仅仅是这些，通过查看JDK帮助文档来了解更多的方法。\r\n\r\n```\r\n\r\n### 3\\. 使用Scanner读取文件\r\n\r\nScanner不仅可以读取键盘输入，同时还可以读取各种不同的输入源，例如文件或网络Socket。\r\n\r\n举例说明：\r\n\r\n```\r\nScanner in = new Scanner(new File(\"in.txt\")); // 使用文件构造\r\nint anInt = in.nextInt();                     // 读取文本\r\ndouble aDouble = in.nextDouble();             // 读取double\r\nString str = in.next();                       // 读取int\r\nString line = in.nextLine();                  // 读取整行信息\r\n```\r\n\r\n如果想打开文件，你需要处理FileNotFoundException异常，否则编译不通过，有两种方式处理这个异常：throws或者try-catch。\r\n\r\n通过使用throws处理异常：\r\n\r\n```\r\nimport java.util.Scanner;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\n\r\npublic class TextFileScannerWithThrows {\r\n    public static void main(String[] args) throws FileNotFoundException {  \r\n        // 在这里定义\"throws\"\r\n        int num1;\r\n        double num2;\r\n        String name;\r\n        Scanner in = new Scanner(new File(\"in.txt\"));  // 通过文件构造\r\n        num1 = in.nextInt();      // 读取int\r\n        num2 = in.nextDouble();   // 读取double\r\n        name = in.next();         // 读取文本\r\n        System.out.printf(\"%s, %d 和 %.2f和为: %.2f%n\", name, num1, num2, num1+num2);\r\n        in.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n为了运行上面的程序，你需要新建文件in.txt，内容如下：\r\n\r\n1234\r\n55.66\r\nHappy\'s home\r\n\r\n通过使用try-catch处理异常：\r\n\r\n```\r\nimport java.io.FileNotFoundException;\r\nimport java.util.Scanner;\r\n\r\npublic class TextFileScannerWithCatch {\r\n    public static void main(String[] args) {\r\n        int num1;\r\n        double num2;\r\n        String name;\r\n        Scanner in = null;\r\n\r\n        try {\r\n            in = new Scanner(new File(\"in.txt\"));  // 通过文件构造\r\n            num1 = in.nextInt();      // 读取int\r\n            num2 = in.nextDouble();   // 读取double\r\n            name = in.next();         // 读取文本\r\n            System.out.printf(\"%s, %d 和 %.2f和为: %.2f%n\", name, num1, num2, num1+num2);\r\n        } catch (FileNotFoundException e) {\r\n            e.printStackTrace();        \r\n        } finally {\r\n            if(in != null){\r\n                in.close();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 4\\. 文件中写入格式化输出的语句\r\n\r\nJDK1.5中引入Formatter类来格式化输出，Formatter类的format()方法与System.in.printf()方法类似。\r\n\r\n```\r\nimport java.io.File;\r\nimport java.util.Formatter;            \r\nimport java.io.FileNotFoundException; \r\n\r\npublic class TextFileFormatterWithThrows {\r\n    public static void main(String[] args) throws FileNotFoundException {          // 通过使用输出文件来构造Formatter类的实例\r\n        Formatter out = new Formatter(new File(\"out.txt\"));\r\n        int num1 = 1234;\r\n        double num2 = 55.66;\r\n        String name = \"开心的冰屋\";\r\n        out.format(\"您好: %s,%n\", name);\r\n        out.format(\"%d 和 %.2f和为: %.2f%n\", num1, num2, num1+num2);\r\n        out.close();               \r\n    }\r\n}\r\n// 程序运行结束后，通过查看\"out.txt\"来验证输出的结果。\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('35', '流程控制', '<p><img src=\"http://ww1.sinaimg.cn/large/006pQ25sgw1f37ldupa6ij30dw0af40e.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1. 前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 前言</h3><p>有三种流控制的结构：顺序、条件和循环，如下图所示：</p>\r\n<p><img src=\"http://ww2.sinaimg.cn/large/006pQ25sgw1f37lnz1vmoj30dw05ewf2.jpg\" alt=\"控制结构.png\"></p>\r\n<h3 id=\"h3-2-\"><a name=\"2. 顺序流控制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 顺序流控制</h3><p>程序是一个指令序列。顺序流在程序中使用的是最直接、最常用的，程序语句的执行依赖于写入的顺序。</p>\r\n<h3 id=\"h3-3-\"><a name=\"3. ?条件流控制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. ?条件流控制</h3><p>条件流控制的几种类型：if-then，if-then-else，if-elseif-elseif-…-else，switch-case和条件表达式。</p>\r\n<p>| 语法 | 例子 | 流程图 |<br>| </p>\r\n<pre><code>// if-then\r\nif ( booleanExpression ) {\r\n    true-block ;\r\n}\r\n</code></pre><p> | </p>\r\n<pre><code>if (mark &gt;= 50) {\r\n    System.out.println(&quot;恭喜!&quot;);\r\n    System.out.println(&quot;坚持!&quot;);\r\n}\r\n</code></pre><p> | <img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_IfThen.png\" alt=\"流程控制.png\"> |<br>| </p>\r\n<pre><code>// if-then-else\r\nif ( booleanExpression ) {\r\n    true-block ;\r\n} else {\r\n    false-block ;\r\n}\r\n</code></pre><p> | </p>\r\n<pre><code>if (mark &gt;= 50) {\r\n    System.out.println(&quot;恭喜!&quot;);\r\n    System.out.println(&quot;坚持!&quot;);\r\n} else {\r\n    System.out.println(&quot;努力!&quot;);\r\n}\r\n</code></pre><p> | <img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_IfElse.png\" alt=\"流程控制.png\"> |<br>| </p>\r\n<pre><code>if ( booleanExpr-1 ) {\r\n    block-1 ;\r\n} else if ( booleanExpr-2 ) {\r\n    block-2 ;\r\n} else if ( booleanExpr-3 ) {\r\n    block-3 ;\r\n} else if ( booleanExpr-4 ) {\r\n    ......\r\n} else {\r\n    elseBlock ;\r\n}\r\n</code></pre><p> | </p>\r\n<pre><code>if (mark &gt;= 80) {\r\n    System.out.println(&quot;A&quot;);\r\n} else if (mark &gt;= 70) {\r\n    System.out.println(&quot;B&quot;);\r\n} else if (mark &gt;= 60) {\r\n    System.out.println(&quot;C&quot;);\r\n} else if (mark &gt;= 50) {\r\n    System.out.println(&quot;D&quot;);\r\n} else {\r\n    System.out.println(&quot;F&quot;);\r\n}\r\n</code></pre><p> | <img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_NestedIf.png\" alt=\"流程控制.png\"> |<br>| </p>\r\n<pre><code>// switch-case-default\r\nswitch ( selector ) {\r\n    case value-1:\r\n        block-1; break;\r\n    case value-2:\r\n        block-2; break;\r\n    case value-3:\r\n        block-3; break;\r\n    ......\r\n    case value-n:\r\n        block-n; break;\r\n    default:\r\n        default-block;\r\n}\r\n</code></pre><p> | </p>\r\n<pre><code>char oper; int num1, num2, result;\r\n......\r\nswitch (oper) {\r\n    case &#39;+&#39;:\r\n        result = num1 + num2; break;\r\n    case &#39;-&#39;:\r\n        result = num1 - num2; break;\r\n    case &#39;*&#39;:\r\n        result = num1 * num2; break;\r\n    case &#39;/&#39;:\r\n        result = num1 / num2; break;\r\n    default:\r\n        System.err.println(&quot;error&quot;);\r\n}\r\n</code></pre><p> | <img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_SwitchCase.png\" alt=\"Flowchart_SwitchCase.png\"> |</p>\r\n<p>括号：当块中只有一条语句，括号是可以省略的，不过建议你保留，括号提高了代码的可读性，举例说明：</p>\r\n<pre><code>if (mark &gt;= 50)\r\n    System.out.println(&quot;通过&quot;);   // 不推荐这样使用\r\nelse {\r\n    System.out.println(&quot;失败&quot;);\r\n    System.out.println(&quot;努力!&quot;);\r\n}\r\n</code></pre><h5 id=\"h5-switch-case-default\"><a name=\"switch-case-default\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>switch-case-default</h5><p>switch-case可以代替nested-if，对于switch-case每种假设必须有break语句，如果缺失break，紧临的假设会被执行，假设条件可以使用int，short或者char（在JDK1.7中可以使用String），不可以使用long，float，double和boolean。</p>\r\n<h5 id=\"h5--\"><a name=\"条件运算符(? :)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>条件运算符(? :)</h5><p>条件运算符是一个3元运算符。</p>\r\n<p>| 语法 | 例子 |<br>| </p>\r\n<pre><code>booleanExpr ? trueExpr : falseExpr\r\n</code></pre><p> | </p>\r\n<pre><code>System.out.println((mark &gt;= 50) ? &quot;PASS&quot; : &quot;FAIL&quot;);\r\nmax = (a &gt; b) ? a : b;   // RHS返回a或者b\r\nabs = (a &gt; 0) ? a : -a;  // RHS返回a或者-a\r\n</code></pre><p> |</p>\r\n<h3 id=\"h3-4-\"><a name=\"4. 循环控制流\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 循环控制流</h3><p>在Java中有几种类型的循环语句：for, while-do, and do-while。</p>\r\n<p>| 语法 | 例子 | 流程图 |<br>| </p>\r\n<pre><code>// for-loop\r\nfor (initialization; test; post-processing){\r\n    body;\r\n}\r\n</code></pre><p> | </p>\r\n<pre><code>// 从1加到1000\r\nint sum = 0;\r\nfor (int number = 1; number &lt;= 1000; ++number) {\r\n    sum += number;\r\n}\r\n</code></pre><p> | <img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_For.png\" alt=\"Flowchart_For.png\"> |<br>| </p>\r\n<pre><code>// while-do loop\r\nwhile ( test ) {\r\n    body;\r\n}\r\n</code></pre><p> | </p>\r\n<pre><code>int sum = 0, number = 1;\r\nwhile (number &lt;= 1000) {\r\n    sum += number;\r\n    ++number;\r\n}\r\n</code></pre><p> | <img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_While.png\" alt=\"Flowchart_While.png\"> |<br>| </p>\r\n<pre><code>// do-while loop\r\ndo {\r\n    body;\r\n} while(test);\r\n</code></pre><p> | </p>\r\n<pre><code>int sum = 0, number = 1;\r\ndo {\r\n    sum += number;\r\n    ++number;\r\n} while (number &lt;= 1000);\r\n</code></pre><p> | <img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_DoWhile.png\" alt=\"Flowchart_DoWhile.png\"> |</p>\r\n<p>while-do和do-while的区别在于主体和条件优先执行的次序，在while-do中，优先判断条件，条件为真主体才执行；在do－while中，主体先执行接着判断条件。值得注意的是在do-while中主体至少被执行一次，而对于while-do有可能一次也没有执行。</p>\r\n<p>举例说明:? 循环验证用户输入的内容是否为数字，并且在1到10之间。</p>\r\n<pre><code>boolean valid = true;\r\nint number;\r\ndo {\r\n    // 你可以提示用户输入1到10\r\n    ......\r\n    valid = number &lt; 1 || number &gt; 10;\r\n} while (valid);\r\n\r\n// 使用while-do的例子\r\nboolean valid = true;\r\nwhile(valid){\r\n    // 你可以提示用户输入1到10\r\n    ......\r\n    valid = number &lt; 1 || number &gt; 10;\r\n}\r\n</code></pre><h5 id=\"h5-u7A7Au5FAAu73AFu4F53\"><a name=\"空循环体\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>空循环体</h5><p>for ( ; ; ) { body }被称作空循环, 空的初始化语句、测试和后处理，这个空循环体会不断的执行，你可以使用break语句跳出循环。</p>\r\n<h5 id=\"h5-for-loop-\"><a name=\"for-loop和逗号操作符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>for-loop和逗号操作符</h5><p>初始化和后处理你可以使用多条语句，语句之间用逗号分隔，举例：</p>\r\n<pre><code>for (int row = 0, col = 0; row &lt; SIZE; ++row, ++col) {\r\n    ......\r\n}\r\n</code></pre><h3 id=\"h3-5-break-continue\"><a name=\"5. break和continue\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. break和continue</h3><p>break语句用来跳出循环体，continue语句中止当前循环并进行下次循环。</p>\r\n<p>break和continue破坏了代码结构，使代码变的难于理解，所以非必要的时候不推荐使用。</p>\r\n<h5 id=\"h5--break-\"><a name=\"举例说明 (break):?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举例说明 (break):?</h5><p>打印2和上界之间的非素数。</p>\r\n<pre><code>public class NonPrimeList {\r\n    public static void main(String[] args) {\r\n        int upperbound = 100;\r\n\r\n        for (int number = 2; number &lt;= upperbound; ++number) {\r\n            // 非素数可以整除2和该数平方根之间的一个数\r\n            int maxFactor = (int)Math.sqrt(number);\r\n            for (int factor = 2; factor &lt;= maxFactor; ++factor) {\r\n                if (number % factor == 0) {\r\n                    System.out.println(number + &quot;是一个非素数&quot;);\r\n                    break;   // 找到一个整除的数即可\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><p>让我们来改写上面的程序，打印出2和上届之间的素数。</p>\r\n<pre><code>public class PrimeListWithBreak {\r\n    public static void main(String[] args) {\r\n        int upperbound = 100;\r\n\r\n        for (int number = 2; number &lt;= upperbound; ++number) {\r\n            int maxFactor = (int)Math.sqrt(number);\r\n            boolean isPrime = true;  // 假设当前为素数\r\n            for (int factor = 2; factor &lt;= maxFactor; ++factor) {\r\n                if (number % factor == 0) {\r\n                    isPrime = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (isPrime) System.out.println(number + &quot;是一个素数&quot;);\r\n        }\r\n    }\r\n}\r\n</code></pre><p>让我们来改写上面的程序，不使用break语句，用一个while-loop循环来替代。</p>\r\n<pre><code>public class PrimeList {\r\n    public static void main(String[] args) {\r\n        int upperbound = 100;\r\n\r\n        for (int number = 2; number &lt;= upperbound; ++number) {\r\n            int maxFactor = (int)Math.sqrt(number);\r\n            boolean isPrime = true;\r\n            int factor = 2;\r\n            while (isPrime &amp;&amp; factor &lt;= maxFactor) {\r\n                if (number % factor == 0) {\r\n                    isPrime = false;\r\n                }\r\n                ++factor;\r\n            }\r\n\r\n            if (isPrime) System.out.println(number + &quot;是一个素数&quot;);\r\n        }\r\n    }\r\n}\r\n</code></pre><h5 id=\"h5--continue-\"><a name=\"举例说明 (continue):\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举例说明 (continue):</h5><pre><code>/*\r\n* 从1累加到上届，11, 22, 33,...\r\n*/\r\nint upperbound = 100;\r\nint sum = 0;\r\n\r\nfor (int number = 1; number &lt;= upperbound; ++number) {\r\n    if (number % 11 == 0) continue;  // 跳过剩下的语句，继续进行下一次迭代\r\n    sum += number;\r\n}\r\n\r\n// 这样写更好\r\nfor (int number = 1; number &lt;= upperbound; ++number) {\r\n    if (number % 11 != 0) sum += number;\r\n}\r\n</code></pre><h5 id=\"h5--break-and-continue-\"><a name=\"举例说明 (break and continue):\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>举例说明 (break and continue):</h5><pre><code>public class MysterySeries {\r\n    public static void main(String[] args) {\r\n        int number = 1;\r\n\r\n        while(true) {\r\n            ++number;\r\n            if ((number % 3) == 0) continue;\r\n            if (number == 133) break;\r\n            if ((number % 2) == 0) {\r\n                number += 3;\r\n            } else {\r\n                number -= 3;\r\n            }\r\n            System.out.print(number + &quot; &quot;);\r\n        }\r\n    }\r\n}\r\n</code></pre><h5 id=\"h5--break-\"><a name=\"标签break.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>标签break.</h5><p>在嵌套循环中，使用break语句可以跳出内层循环同时继续下一次外层循环，有时候出于某些原因想跳出所有循环，虽然可以使用布尔进行标记，但是未免有些笨拙。这时候我们推荐使用标签break来标记每个循环，例如：</p>\r\n<pre><code>level1:                             // 定义level1循环标签\r\nfor (.....) {\r\n    level2:                         // 定义level2循环标签\r\n    for (.....) {\r\n        for (......) {              // level3循环标签\r\n            if (...) break level1;  // 跳出所有循环\r\n            if (...) break level2:  // 跳出level2循环，继续下一次level1循环\r\n                ......\r\n        }\r\n    }\r\n}\r\n</code></pre><h5 id=\"h5--continue\"><a name=\"标签continue\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>标签continue</h5><p>在嵌套循环中，与标签break类似，你可以使用标签continue来继续指定的循环，例如：</p>\r\n<pre><code>level1:\r\nfor (.....) {\r\n    level2:\r\n    for (.....) {\r\n        for (......) {\r\n            if (...) continue level1;  // 马上执行下一次level1循环\r\n            if (...) continue level2:  // 马上执行下一次level2循环\r\n            ......\r\n        }\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-6-\"><a name=\"6. 终止程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 终止程序</h3><p>System.exit(int exitCode)：你可以调用方法System.exit(int exitCode)来终止程序并将控制权返还给Java，按照惯例，exitCode＝0表示正常终止，exitCode !=0表示异常终止，例如：</p>\r\n<pre><code>if (errorCount &gt; 10) {\r\n    System.out.println(&quot;太多的异常&quot;);\r\n    System.exit(1);  // 异常终止\r\n}\r\n</code></pre><p>同样的，你也可以使用retrun语句直接终止程序。</p>\r\n<pre><code>public static void main(String[] args) {\r\n    ...\r\n    if (errorCount &gt; 10) {\r\n        System.out.println(&quot;too many errors&quot;);\r\n        return;\r\n    }\r\n    ...\r\n}\r\n</code></pre><h3 id=\"h3-7-\"><a name=\"7. 嵌套循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 嵌套循环</h3><p>编写程序，使用嵌套循环输出8x8的＃，如下：</p>\r\n<pre><code># # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n\r\npublic class PrintSquarePattern {\r\n    public static void main(String[] args) {\r\n        int size = 8;\r\n        for (int row = 1; row &lt;= size; ++row) {      // 打印行\r\n            for (int col = 1; col &lt;= size; ++col) {  // 打印列\r\n                System.out.print(&quot;# &quot;);\r\n            }\r\n            System.out.println();                    // 下一行\r\n        }\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-8-\"><a name=\"8. 控制流中的一些问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. 控制流中的一些问题</h3><p>摇摆不定的else：想想下面的else匹配哪个if。</p>\r\n<pre><code>if (i == 0)\r\n    if (j == 0)\r\n        System.out.println(&quot;i和j都是0&quot;);\r\nelse\r\n    System.out.println(&quot;i不是0&quot;);   // 本打算匹配最外层的if\r\n</code></pre><p>上面的else看上去可以匹配外层if或者内层if，但是Java编译器的匹配规则是就近匹配if，为了使代码的逻辑正确，我们可以使用括号解决，如下所示：</p>\r\n<pre><code>if ( i == 0) {\r\n    if (j == 0) System.out.println(&quot;i和j都是0&quot;);\r\n} else {\r\n    System.out.println(&quot;i不是0&quot;);   // 明确的匹配外层if\r\n}\r\n</code></pre><p>无限循环：请看下面的结构，</p>\r\n<pre><code>while (true) { ...... }\r\n</code></pre><p>这种写法很常用，通常在循环体内部使用break或者return语句跳出循环，但是这种代码不容易理解，非必要的时候不推荐使用。</p>\r\n', '50', '![](http://ww1.sinaimg.cn/large/006pQ25sgw1f37ldupa6ij30dw0af40e.jpg)\r\n### 1\\. 前言\r\n\r\n有三种流控制的结构：顺序、条件和循环，如下图所示：\r\n\r\n![控制结构.png](http://ww2.sinaimg.cn/large/006pQ25sgw1f37lnz1vmoj30dw05ewf2.jpg)\r\n\r\n### 2\\. 顺序流控制\r\n\r\n程序是一个指令序列。顺序流在程序中使用的是最直接、最常用的，程序语句的执行依赖于写入的顺序。\r\n\r\n### 3\\. ?条件流控制\r\n\r\n条件流控制的几种类型：if-then，if-then-else，if-elseif-elseif-...-else，switch-case和条件表达式。\r\n\r\n| 语法 | 例子 | 流程图 |\r\n| \r\n\r\n```\r\n// if-then\r\nif ( booleanExpression ) {\r\n    true-block ;\r\n}\r\n\r\n```\r\n\r\n | \r\n\r\n```\r\nif (mark >= 50) {\r\n    System.out.println(\"恭喜!\");\r\n    System.out.println(\"坚持!\");\r\n}\r\n```\r\n\r\n | ![流程控制.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_IfThen.png) |\r\n| \r\n\r\n```\r\n// if-then-else\r\nif ( booleanExpression ) {\r\n    true-block ;\r\n} else {\r\n    false-block ;\r\n}\r\n```\r\n\r\n | \r\n\r\n```\r\nif (mark >= 50) {\r\n    System.out.println(\"恭喜!\");\r\n    System.out.println(\"坚持!\");\r\n} else {\r\n    System.out.println(\"努力!\");\r\n}\r\n```\r\n\r\n | ![流程控制.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_IfElse.png) |\r\n| \r\n\r\n```\r\nif ( booleanExpr-1 ) {\r\n    block-1 ;\r\n} else if ( booleanExpr-2 ) {\r\n    block-2 ;\r\n} else if ( booleanExpr-3 ) {\r\n    block-3 ;\r\n} else if ( booleanExpr-4 ) {\r\n    ......\r\n} else {\r\n    elseBlock ;\r\n}\r\n```\r\n\r\n | \r\n\r\n```\r\nif (mark >= 80) {\r\n    System.out.println(\"A\");\r\n} else if (mark >= 70) {\r\n    System.out.println(\"B\");\r\n} else if (mark >= 60) {\r\n    System.out.println(\"C\");\r\n} else if (mark >= 50) {\r\n    System.out.println(\"D\");\r\n} else {\r\n    System.out.println(\"F\");\r\n}\r\n\r\n```\r\n\r\n | ![流程控制.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_NestedIf.png) |\r\n| \r\n\r\n```\r\n// switch-case-default\r\nswitch ( selector ) {\r\n    case value-1:\r\n        block-1; break;\r\n    case value-2:\r\n        block-2; break;\r\n    case value-3:\r\n        block-3; break;\r\n    ......\r\n    case value-n:\r\n        block-n; break;\r\n    default:\r\n        default-block;\r\n}\r\n```\r\n\r\n | \r\n\r\n```\r\nchar oper; int num1, num2, result;\r\n......\r\nswitch (oper) {\r\n    case \'+\':\r\n        result = num1 + num2; break;\r\n    case \'-\':\r\n        result = num1 - num2; break;\r\n    case \'*\':\r\n        result = num1 * num2; break;\r\n    case \'/\':\r\n        result = num1 / num2; break;\r\n    default:\r\n        System.err.println(\"error\");\r\n}\r\n```\r\n\r\n | ![Flowchart_SwitchCase.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_SwitchCase.png) |\r\n\r\n括号：当块中只有一条语句，括号是可以省略的，不过建议你保留，括号提高了代码的可读性，举例说明：\r\n\r\n```\r\nif (mark >= 50)\r\n    System.out.println(\"通过\");   // 不推荐这样使用\r\nelse {\r\n    System.out.println(\"失败\");\r\n    System.out.println(\"努力!\");\r\n}\r\n```\r\n\r\n##### switch-case-default\r\n\r\nswitch-case可以代替nested-if，对于switch-case每种假设必须有break语句，如果缺失break，紧临的假设会被执行，假设条件可以使用int，short或者char（在JDK1.7中可以使用String），不可以使用long，float，double和boolean。\r\n\r\n##### 条件运算符(? :)\r\n\r\n条件运算符是一个3元运算符。\r\n\r\n| 语法 | 例子 |\r\n| \r\n\r\n```\r\nbooleanExpr ? trueExpr : falseExpr\r\n```\r\n\r\n | \r\n\r\n```\r\nSystem.out.println((mark >= 50) ? \"PASS\" : \"FAIL\");\r\nmax = (a > b) ? a : b;   // RHS返回a或者b\r\nabs = (a > 0) ? a : -a;  // RHS返回a或者-a\r\n```\r\n\r\n |\r\n\r\n### 4\\. 循环控制流\r\n\r\n在Java中有几种类型的循环语句：for, while-do, and do-while。\r\n\r\n| 语法 | 例子 | 流程图 |\r\n| \r\n\r\n```\r\n// for-loop\r\nfor (initialization; test; post-processing){\r\n    body;\r\n}\r\n\r\n```\r\n\r\n | \r\n\r\n```\r\n// 从1加到1000\r\nint sum = 0;\r\nfor (int number = 1; number <= 1000; ++number) {\r\n    sum += number;\r\n}\r\n```\r\n\r\n | ![Flowchart_For.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_For.png) |\r\n| \r\n\r\n```\r\n// while-do loop\r\nwhile ( test ) {\r\n    body;\r\n}\r\n\r\n```\r\n\r\n | \r\n\r\n```\r\nint sum = 0, number = 1;\r\nwhile (number <= 1000) {\r\n    sum += number;\r\n    ++number;\r\n}\r\n```\r\n\r\n | ![Flowchart_While.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_While.png) |\r\n| \r\n\r\n```\r\n// do-while loop\r\ndo {\r\n    body;\r\n} while(test);\r\n```\r\n\r\n | \r\n\r\n```\r\nint sum = 0, number = 1;\r\ndo {\r\n    sum += number;\r\n    ++number;\r\n} while (number <= 1000);\r\n```\r\n\r\n | ![Flowchart_DoWhile.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Flowchart_DoWhile.png) |\r\n\r\nwhile-do和do-while的区别在于主体和条件优先执行的次序，在while-do中，优先判断条件，条件为真主体才执行；在do－while中，主体先执行接着判断条件。值得注意的是在do-while中主体至少被执行一次，而对于while-do有可能一次也没有执行。\r\n\r\n举例说明:? 循环验证用户输入的内容是否为数字，并且在1到10之间。\r\n\r\n```\r\nboolean valid = true;\r\nint number;\r\ndo {\r\n    // 你可以提示用户输入1到10\r\n    ......\r\n    valid = number < 1 || number > 10;\r\n} while (valid);\r\n\r\n// 使用while-do的例子\r\nboolean valid = true;\r\nwhile(valid){\r\n    // 你可以提示用户输入1到10\r\n    ......\r\n    valid = number < 1 || number > 10;\r\n} \r\n```\r\n\r\n##### 空循环体\r\n\r\nfor ( ; ; ) { body }被称作空循环, 空的初始化语句、测试和后处理，这个空循环体会不断的执行，你可以使用break语句跳出循环。\r\n\r\n##### for-loop和逗号操作符\r\n\r\n初始化和后处理你可以使用多条语句，语句之间用逗号分隔，举例：\r\n\r\n```\r\nfor (int row = 0, col = 0; row < SIZE; ++row, ++col) {\r\n    ......\r\n}\r\n```\r\n\r\n### 5\\. break和continue\r\n\r\nbreak语句用来跳出循环体，continue语句中止当前循环并进行下次循环。\r\n\r\nbreak和continue破坏了代码结构，使代码变的难于理解，所以非必要的时候不推荐使用。\r\n\r\n##### 举例说明 (break):?\r\n\r\n打印2和上界之间的非素数。\r\n\r\n```\r\npublic class NonPrimeList {\r\n    public static void main(String[] args) {\r\n        int upperbound = 100;\r\n\r\n        for (int number = 2; number <= upperbound; ++number) {\r\n            // 非素数可以整除2和该数平方根之间的一个数\r\n            int maxFactor = (int)Math.sqrt(number);\r\n            for (int factor = 2; factor <= maxFactor; ++factor) {\r\n                if (number % factor == 0) {\r\n                    System.out.println(number + \"是一个非素数\");\r\n                    break;   // 找到一个整除的数即可\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n让我们来改写上面的程序，打印出2和上届之间的素数。\r\n\r\n```\r\npublic class PrimeListWithBreak {\r\n    public static void main(String[] args) {\r\n        int upperbound = 100;\r\n\r\n        for (int number = 2; number <= upperbound; ++number) {\r\n            int maxFactor = (int)Math.sqrt(number);\r\n            boolean isPrime = true;  // 假设当前为素数\r\n            for (int factor = 2; factor <= maxFactor; ++factor) {\r\n                if (number % factor == 0) {\r\n                    isPrime = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (isPrime) System.out.println(number + \"是一个素数\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n让我们来改写上面的程序，不使用break语句，用一个while-loop循环来替代。\r\n\r\n```\r\npublic class PrimeList {\r\n    public static void main(String[] args) {\r\n        int upperbound = 100;\r\n\r\n        for (int number = 2; number <= upperbound; ++number) {\r\n            int maxFactor = (int)Math.sqrt(number);\r\n            boolean isPrime = true;\r\n            int factor = 2;\r\n            while (isPrime && factor <= maxFactor) {\r\n                if (number % factor == 0) {\r\n                    isPrime = false;\r\n                }\r\n                ++factor;\r\n            }\r\n\r\n            if (isPrime) System.out.println(number + \"是一个素数\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n##### 举例说明 (continue):\r\n\r\n```\r\n/*\r\n* 从1累加到上届，11, 22, 33,...\r\n*/\r\nint upperbound = 100;\r\nint sum = 0;\r\n\r\nfor (int number = 1; number <= upperbound; ++number) {\r\n    if (number % 11 == 0) continue;  // 跳过剩下的语句，继续进行下一次迭代\r\n    sum += number;\r\n}\r\n\r\n// 这样写更好\r\nfor (int number = 1; number <= upperbound; ++number) {\r\n    if (number % 11 != 0) sum += number;\r\n}\r\n```\r\n\r\n##### 举例说明 (break and continue):\r\n\r\n```\r\npublic class MysterySeries {\r\n    public static void main(String[] args) {\r\n        int number = 1;\r\n\r\n        while(true) {\r\n            ++number;\r\n            if ((number % 3) == 0) continue;\r\n            if (number == 133) break;\r\n            if ((number % 2) == 0) {\r\n                number += 3;\r\n            } else {\r\n                number -= 3;\r\n            }\r\n            System.out.print(number + \" \");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n##### 标签break.\r\n\r\n在嵌套循环中，使用break语句可以跳出内层循环同时继续下一次外层循环，有时候出于某些原因想跳出所有循环，虽然可以使用布尔进行标记，但是未免有些笨拙。这时候我们推荐使用标签break来标记每个循环，例如：\r\n\r\n```\r\nlevel1:                             // 定义level1循环标签\r\nfor (.....) {\r\n    level2:                         // 定义level2循环标签\r\n    for (.....) {\r\n        for (......) {              // level3循环标签\r\n            if (...) break level1;  // 跳出所有循环\r\n            if (...) break level2:  // 跳出level2循环，继续下一次level1循环\r\n                ......\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n##### 标签continue\r\n\r\n在嵌套循环中，与标签break类似，你可以使用标签continue来继续指定的循环，例如：\r\n\r\n```\r\nlevel1:\r\nfor (.....) {\r\n    level2:\r\n    for (.....) {\r\n        for (......) {\r\n            if (...) continue level1;  // 马上执行下一次level1循环\r\n            if (...) continue level2:  // 马上执行下一次level2循环\r\n            ......\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 6\\. 终止程序\r\n\r\nSystem.exit(int exitCode)：你可以调用方法System.exit(int exitCode)来终止程序并将控制权返还给Java，按照惯例，exitCode＝0表示正常终止，exitCode !=0表示异常终止，例如：\r\n\r\n```\r\nif (errorCount > 10) {\r\n    System.out.println(\"太多的异常\");\r\n    System.exit(1);  // 异常终止\r\n}\r\n```\r\n\r\n同样的，你也可以使用retrun语句直接终止程序。\r\n\r\n```\r\npublic static void main(String[] args) {\r\n    ...\r\n    if (errorCount > 10) {\r\n        System.out.println(\"too many errors\");\r\n        return;\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n### 7\\. 嵌套循环\r\n\r\n编写程序，使用嵌套循环输出8x8的＃，如下：\r\n\r\n```\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n# # # # # # # #\r\n\r\npublic class PrintSquarePattern {\r\n    public static void main(String[] args) {\r\n        int size = 8;\r\n        for (int row = 1; row <= size; ++row) {      // 打印行\r\n            for (int col = 1; col <= size; ++col) {  // 打印列\r\n                System.out.print(\"# \");\r\n            }\r\n            System.out.println();                    // 下一行\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 8\\. 控制流中的一些问题\r\n\r\n摇摆不定的else：想想下面的else匹配哪个if。\r\n\r\n```\r\nif (i == 0)\r\n    if (j == 0)\r\n        System.out.println(\"i和j都是0\");\r\nelse\r\n    System.out.println(\"i不是0\");   // 本打算匹配最外层的if\r\n```\r\n\r\n上面的else看上去可以匹配外层if或者内层if，但是Java编译器的匹配规则是就近匹配if，为了使代码的逻辑正确，我们可以使用括号解决，如下所示：\r\n\r\n```\r\nif ( i == 0) {\r\n    if (j == 0) System.out.println(\"i和j都是0\");\r\n} else {\r\n    System.out.println(\"i不是0\");   // 明确的匹配外层if\r\n}\r\n```\r\n\r\n无限循环：请看下面的结构，\r\n\r\n```\r\nwhile (true) { ...... }\r\n```\r\n\r\n这种写法很常用，通常在循环体内部使用break或者return语句跳出循环，但是这种代码不容易理解，非必要的时候不推荐使用。');
INSERT INTO `article_info_true` VALUES ('36', '类和对象', '<p>程序界的至理名言：万物皆对象<br>类：同一种类型的事物公共属性和行为的抽取。<br>类的定义：<br>    class 类名{</p>\r\n<pre><code>    事物的公共属性；\r\n\r\n    事物的公共行为；\r\n}\r\n</code></pre><p>对象：真实存在的唯一事物。<br>对象的种类：<br>    普通对象：有引用类型指向的对象。<br>    匿名对象；<br>创建格式：<br>    普通对象通过类创建对象的格式：<br>        类名 对象名 = new 类名();<br>    匿名对象创建格式：<br>        类名();<br>匿名对象要注意的事项：<br>    1、一般不会给匿名对象赋予初始值，因为永远无法获取到。<br>    2、匿名对象永远都不可能是同一个对象。<br>匿名对象使用场景：<br>    1、如果一个对象需要调用一个方法一次的时候，而调用完这个方法之后，该对象就不在使用，这时可以使用匿名对象。<br>    2、可以作为一个函数的实参。<br>匿名对象的好处： 简化书写。</p>\r\n<p>构造函数<br>作用：给对应的对象进行初始化。<br>格式：<br>    修饰符 类名(形式参数){<br>        函数体……；<br>    }<br>注意细节：<br>    1、构造函数没有返回值。<br>    2、构造函数函数名必须与类名一致。<br>    3、构造函数并不是由手动调用，而是在创建对象的时候，jvm自动调用的。<br>    4、如果一个类没有显示的写上一个构造方法，那么java编译器会为此类添加一个无参的构造方法。<br>    5、如果一个类已经显示的写上了一个构造方法，那么java编译器不会为此类添加一个无参的构造方法。<br>    6、构造方法在一个类中可以以函数重载的形式存在多个。<br>构造函数和普通函数的区别：<br>    1、返回值类型的区别：<br>        （1）构造函数没有返回值类型。<br>        （2）普通函数有返回值类型，即使函数没有返回值，函数的返回值类型也要写上void。<br>    2、函数名的区别：<br>        （1）构造函数的函数名必须与类名一致。<br>        （2）普通函数的函数名只要符合标识符的命名规范即可。<br>    3、调用方式的区别：<br>        （1）构造函数是在创建对象的时候jvm自动调用。<br>        （2）普通函数是由使用对象调用的，一个对象可以多次调用普通函数。<br>    4、作用上的区别：<br>        （1）构造函数用于初始化一个对象。<br>        （2）普通函数用来描述一类事物的公共行为。</p>\r\n<p>构造代码块<br>作用：给对象进行统一的初始化。<br>格式：<br>    {<br>        语句；<br>    }<br>位置：构造代码块必须位于成员位置（方法以外，类之内）上。<br>构造代码块的注意事项：<br>    1、java编译器编译一个java源文件的时候，会把成员变量的声明提前至一个类的最前端。<br>    2、成员变量的初始化工作其实是在构造函数中执行的。<br>    3、一旦进过java编译器编译后，那么构造代码块的代码会被移动到构造函数中执行且是在最前面执行，构造函数中的代码是在最后执行的。<br>    4、成员变量的显示初始化与构造代码块的的代码是按当前代码的顺序执行的。<br>代码块的种类：<br>    1、构造代码块。<br>    2、局部代码块。大括号位于方法之内。作用：缩短局部变量的生命周期，节省一点点内存。<br>    3、静态代码块。 static修饰的。</p>\r\n<p>访问对象的属性或者调用对象的行为。<br>1、访问对象属性的格式：<br>    对象.属性名；<br>2、设置对象的属性：<br>    对象.属性名 = 数据；<br>3、访问对象的行为：<br>    对象.函数名();</p>\r\n<p>this关键字<br>this关键字代表了所属函数的调用者对象。<br>this关键字的作用：<br>    1、如果存在同名的成员变量与局部变量时，在方法内部默认方位局部变量的数据，可以通过this关键字指定访问成员变量的数据。<br>    2、在一个构造函数中可以调用另一个构造函数初始化对象。<br>       this关键字调用其他构造函数的注意事项：<br>        （1）this关键字调用其他的构造函数时，this关键字必须要位于构造函数中的第一个语句。<br>        （2）this关键字在构造函数中不能出现相互调用的性情况，因为是死循环。<br>this关键字注意事项：<br>    1、存在同名的成员变量和局部变量时，在方法的内部访问的是局部变量（java采用的是“就近原则”的机制访问的）。<br>    2、如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的前面默认添加this关键字。</p>\r\n<p>代买示例如下：</p>\r\n<pre><code>class Car{\r\n    String name;\r\n    String color;\r\n    int wheel;\r\n    public void run(){\r\n        System.out.println(name + &quot;使用&quot; + wheel + &quot;个轮子&quot; + &quot;飞快的跑起来了！！！&quot;);\r\n    }\r\n\r\n    public void discard(){\r\n        System.out.println(&quot;因不合格直接报废处理！！！！&quot;);\r\n    }\r\n}\r\n\r\nclass Baby{\r\n    int id;\r\n    String name;\r\n    String color = &quot;白色&quot;;\r\n    //构造代码块\r\n    {\r\n        color = &quot;黄色&quot;;\r\n        System.out.println(&quot;我是有血有肉的……&quot;);\r\n    }\r\n    //有参构造方法\r\n    public Baby(int id, String name){\r\n        this(); //调用无参构造方法初始化肤色\r\n        this.id = id;\r\n        this.name = name;\r\n        System.out.println(&quot;Baby的属性初始化完毕&quot;);\r\n    }\r\n    //无参构造方法\r\n    public Baby(){\r\n        color = &quot;黑色&quot;;\r\n        System.out.println(&quot;无参的构造方法被调用了&quot;);\r\n    }\r\n    //普通方法\r\n    public void cry(){\r\n        System.out.println(name + &quot;哇哇哭……&quot;);\r\n    }\r\n\r\n}\r\n\r\nclass Demo{\r\n    public static void main(String[] args){\r\n        //对象的创建\r\n        Car car = new Car();\r\n        //设置属性值\r\n        car.name = &quot;宝马&quot;;\r\n        car.color = &quot;蓝色&quot;;\r\n        car.wheel = 4;\r\n        //调用属性\r\n        System.out.println(&quot;名字：&quot; + car.name +&quot;        &quot;+&quot;颜色：&quot; + car.color);\r\n        //调用方法\r\n        car.run();\r\n\r\n        //匿名对象调用方法\r\n        new Car().discard();\r\n        //匿名对象作为函数的实参\r\n        System.out.println(new Car() == new Car());\r\n\r\n        //初始化一个白户（出生的时候就有Id和name）\r\n        Baby boy = new Baby(123,&quot;小明&quot;);\r\n        boy.cry();\r\n        System.out.println(&quot;新生儿的肤色&quot; + boy.color);\r\n        Baby girl = new Baby();\r\n        girl.cry();\r\n        System.out.println(&quot;新生儿的肤色&quot; + girl.color);\r\n    }\r\n}\r\n</code></pre>', '52', '程序界的至理名言：万物皆对象\r\n类：同一种类型的事物公共属性和行为的抽取。\r\n类的定义：\r\n    class 类名{\r\n\r\n        事物的公共属性；\r\n\r\n        事物的公共行为；\r\n    }\r\n\r\n对象：真实存在的唯一事物。\r\n对象的种类：\r\n    普通对象：有引用类型指向的对象。\r\n    匿名对象；\r\n创建格式：\r\n    普通对象通过类创建对象的格式：\r\n        类名 对象名 = new 类名();\r\n    匿名对象创建格式：\r\n        类名();\r\n匿名对象要注意的事项：\r\n    1、一般不会给匿名对象赋予初始值，因为永远无法获取到。\r\n    2、匿名对象永远都不可能是同一个对象。\r\n匿名对象使用场景：\r\n    1、如果一个对象需要调用一个方法一次的时候，而调用完这个方法之后，该对象就不在使用，这时可以使用匿名对象。\r\n    2、可以作为一个函数的实参。\r\n匿名对象的好处： 简化书写。\r\n\r\n构造函数\r\n作用：给对应的对象进行初始化。\r\n格式：\r\n    修饰符 类名(形式参数){\r\n        函数体……；\r\n    }\r\n注意细节：\r\n    1、构造函数没有返回值。\r\n    2、构造函数函数名必须与类名一致。\r\n    3、构造函数并不是由手动调用，而是在创建对象的时候，jvm自动调用的。\r\n    4、如果一个类没有显示的写上一个构造方法，那么java编译器会为此类添加一个无参的构造方法。\r\n    5、如果一个类已经显示的写上了一个构造方法，那么java编译器不会为此类添加一个无参的构造方法。\r\n    6、构造方法在一个类中可以以函数重载的形式存在多个。\r\n构造函数和普通函数的区别：\r\n    1、返回值类型的区别：\r\n        （1）构造函数没有返回值类型。\r\n        （2）普通函数有返回值类型，即使函数没有返回值，函数的返回值类型也要写上void。\r\n    2、函数名的区别：\r\n        （1）构造函数的函数名必须与类名一致。\r\n        （2）普通函数的函数名只要符合标识符的命名规范即可。\r\n    3、调用方式的区别：\r\n        （1）构造函数是在创建对象的时候jvm自动调用。\r\n        （2）普通函数是由使用对象调用的，一个对象可以多次调用普通函数。\r\n    4、作用上的区别：\r\n        （1）构造函数用于初始化一个对象。\r\n        （2）普通函数用来描述一类事物的公共行为。\r\n\r\n构造代码块\r\n作用：给对象进行统一的初始化。\r\n格式：\r\n    {\r\n        语句；\r\n    }\r\n位置：构造代码块必须位于成员位置（方法以外，类之内）上。\r\n构造代码块的注意事项：\r\n    1、java编译器编译一个java源文件的时候，会把成员变量的声明提前至一个类的最前端。\r\n    2、成员变量的初始化工作其实是在构造函数中执行的。\r\n    3、一旦进过java编译器编译后，那么构造代码块的代码会被移动到构造函数中执行且是在最前面执行，构造函数中的代码是在最后执行的。\r\n    4、成员变量的显示初始化与构造代码块的的代码是按当前代码的顺序执行的。\r\n代码块的种类：\r\n    1、构造代码块。\r\n    2、局部代码块。大括号位于方法之内。作用：缩短局部变量的生命周期，节省一点点内存。\r\n    3、静态代码块。 static修饰的。\r\n\r\n访问对象的属性或者调用对象的行为。\r\n1、访问对象属性的格式：\r\n    对象.属性名；\r\n2、设置对象的属性：\r\n    对象.属性名 = 数据；\r\n3、访问对象的行为：\r\n    对象.函数名();\r\n\r\nthis关键字\r\nthis关键字代表了所属函数的调用者对象。\r\nthis关键字的作用：\r\n    1、如果存在同名的成员变量与局部变量时，在方法内部默认方位局部变量的数据，可以通过this关键字指定访问成员变量的数据。\r\n    2、在一个构造函数中可以调用另一个构造函数初始化对象。\r\n       this关键字调用其他构造函数的注意事项：\r\n        （1）this关键字调用其他的构造函数时，this关键字必须要位于构造函数中的第一个语句。\r\n        （2）this关键字在构造函数中不能出现相互调用的性情况，因为是死循环。\r\nthis关键字注意事项：\r\n    1、存在同名的成员变量和局部变量时，在方法的内部访问的是局部变量（java采用的是“就近原则”的机制访问的）。\r\n    2、如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的前面默认添加this关键字。\r\n\r\n代买示例如下：\r\n```\r\nclass Car{\r\n    String name;\r\n    String color;\r\n    int wheel;\r\n    public void run(){\r\n        System.out.println(name + \"使用\" + wheel + \"个轮子\" + \"飞快的跑起来了！！！\");\r\n    }\r\n\r\n    public void discard(){\r\n        System.out.println(\"因不合格直接报废处理！！！！\");\r\n    }\r\n}\r\n\r\nclass Baby{\r\n    int id;\r\n    String name;\r\n    String color = \"白色\";\r\n    //构造代码块\r\n    {\r\n        color = \"黄色\";\r\n        System.out.println(\"我是有血有肉的……\");\r\n    }\r\n    //有参构造方法\r\n    public Baby(int id, String name){\r\n        this(); //调用无参构造方法初始化肤色\r\n        this.id = id;\r\n        this.name = name;\r\n        System.out.println(\"Baby的属性初始化完毕\");\r\n    }\r\n    //无参构造方法\r\n    public Baby(){\r\n        color = \"黑色\";\r\n        System.out.println(\"无参的构造方法被调用了\");\r\n    }\r\n    //普通方法\r\n    public void cry(){\r\n        System.out.println(name + \"哇哇哭……\");\r\n    }\r\n\r\n}\r\n\r\nclass Demo{\r\n    public static void main(String[] args){\r\n        //对象的创建\r\n        Car car = new Car();\r\n        //设置属性值\r\n        car.name = \"宝马\";\r\n        car.color = \"蓝色\";\r\n        car.wheel = 4;\r\n        //调用属性\r\n        System.out.println(\"名字：\" + car.name +\"        \"+\"颜色：\" + car.color);\r\n        //调用方法\r\n        car.run();\r\n\r\n        //匿名对象调用方法\r\n        new Car().discard();\r\n        //匿名对象作为函数的实参\r\n        System.out.println(new Car() == new Car());\r\n\r\n        //初始化一个白户（出生的时候就有Id和name）\r\n        Baby boy = new Baby(123,\"小明\");\r\n        boy.cry();\r\n        System.out.println(\"新生儿的肤色\" + boy.color);\r\n        Baby girl = new Baby();\r\n        girl.cry();\r\n        System.out.println(\"新生儿的肤色\" + girl.color);\r\n    }\r\n}\r\n\r\n```');
INSERT INTO `article_info_true` VALUES ('37', '变量、方法以及静态和非静态', '<p>变量<br>变量的种类：<br>    1、成员变量<br>    2、局部变量<br>成员变量与局部变量的区别：<br>    定义位置的区别<br>        1、成员变量定义在方法之外，类之内。<br>        2.局部变量定义在方法之内。<br>    作用的区别：<br>        1、成员变量用于描述事物的公共属性。<br>        2、局部变量提供一个一个变量给方法内部使用。<br>    生命周期的区别：<br>        1、成员变量随着对象的创建而存在，对着对象的消失而消失。<br>        2、局部变量在调用了对应的方法时执行到了创建该变量的语句时存在，一旦出了自己的作用域会马上从内存中消失。<br>    初始值得区别：<br>        1、成员变量有默认初始值：<br>            数据类型            默认初始值<br>            int             0<br>            float            0.0f<br>            double            0.0<br>            boolean            false<br>            char            ‘’（空字符）<br>            String            null<br>        2、局部变量没有默认值，必须先初始化在使用。<br>方法：函数也被称为方法。</p>\r\n<p>静态- static修饰符<br>static 修饰成员变量（静态成员变量）<br>    使用场景：如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰。例如统计一个类被使用了几次。<br>    静态成员变量的访问方式：<br>        1、可以通过对象进行访问<br>            格式：对象.变量名<br>        2、可以使用类名进行访问<br>            格式：类名.变量名<br>    注意事项：<br>        1、非静态成员变量只能使用对象访问，不能使用类名访问。<br>        2、千万不要为了方便访问数据而使用static修饰成员变量。只有成员变量数据真正需要被共享的时候才使用static修饰。<br>static 修饰方法（静态成员方法）<br>    使用场景：如果一个函数没有直接访问到非静态的成员时，那么就可以使用static修饰了，一般用于工具类型的方法。——静态函数只要存在对象，也可以访问非静态数据，只要不能直接访问而已。<br>    静态成员函数的访问方式：<br>        1、可以通过对象进行访问<br>            格式：对象.静态函数名(形参列表);<br>        2、可以使用类名进行访问<br>            格式：类名.静态函数名(形参列表);<br>    注意事项：<br>        1、 静态函数是可以调用类名或者对象进行调用的，而非静态函数只能使用对象进行调用。<br>        2、静态的函数可以直接访问静态的成员，但是不能直接访问非静态的成员。<br>            原因：静态函数是可以使用类名直接调用的，这时候可能还没有存在对象，<br>            而非静态的成员数据是随着对象的存在而存在的。<br>        3、非静态的函数是可以直接访问静态与非静态的成员。<br>            原因：非静态函数只能由对象调用，当对象存在的时候，静态数据老早就已经存在了，而非静态<br>            数据也随着对象的创建而存在了。<br>        4、静态函数不能出现this或者super关键字。<br>            原因：因为静态的函数是可以使用类名调用的，一旦使用类名调用这时候不存在对象，而this<br>            关键字是代表了一个函数的调用者对象，这时候产生了冲突。</p>\r\n<p>静态的数据的生命周期：静态的成员变量数据是优先于对象存在的。<br><em>*</em>推荐使用类名访问静态的成员</p>\r\n<p>静态的成员变量与非静态的成员变量的区别：</p>\r\n<pre><code>1. 作用上的区别：\r\n    1. 静态的成员变量的作用共享一个数据给所有的对象使用。\r\n    2. 非静态的成员变量的作用是描述一类事物的公共属性。\r\n2. 数量与存储位置上的区别：\r\n    1. 静态成员变量是存储方法区内存中，而且只会存在一份数据。\r\n    2. 非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。\r\n3. 生命周期的区别：\r\n    1. 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失。\r\n    2.非静态的成员数据是随着对象的创建而存在，随着对象被垃圾回收器回收而消失。\r\n</code></pre><p>代码示例如下：</p>\r\n<pre><code>class ArrayTool{\r\n    static int count = 0; //统计使用的次数\r\n    {\r\n        count++;\r\n    }\r\n    public static void showCount(){\r\n        System.out.println(&quot;创建了&quot;+count+&quot;个对象&quot;);\r\n    }\r\n\r\n    //转化为字符串并以&quot;,&quot;分割\r\n    public static String toString(int[] arr){\r\n        String result  = &quot;&quot;;\r\n        for(int i = 0;  i &lt; arr.length ; i++){\r\n            if (i==0){\r\n                result+=&quot;[&quot;+arr[i]+&quot;,&quot;;\r\n            }else if(i==(arr.length-1)){\r\n                result+= arr[i]+&quot;]&quot;;\r\n            }else{\r\n                result+=arr[i]+&quot;,&quot;;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //从小到大排序\r\n    public static void sort(int[] arr){\r\n        for(int i = 0; i &lt; arr.length-1 ; i++){\r\n            for(int j = i+1 ; j&lt;arr.length ; j++){\r\n                if(arr[i]&gt;arr[j]){\r\n                    int temp = arr[i];\r\n                    arr[i] = arr[j];\r\n                    arr[j] = temp;\r\n                }\r\n            }\r\n        }    \r\n    }\r\n}\r\n\r\nclass Demo{\r\n    public static void main(String[] args){\r\n        ArrayTool at1 = new ArrayTool();\r\n        ArrayTool at2 = new ArrayTool();\r\n        ArrayTool at3 = new ArrayTool();\r\n        ArrayTool at4 = new ArrayTool();\r\n        ArrayTool.showCount();\r\n\r\n        int[] arr = {12,1,456,165};\r\n        ArrayTool.sort(arr);\r\n        String info = ArrayTool.toString(arr);\r\n        System.out.println(&quot;数组的元素：&quot;+ info);\r\n    }\r\n}\r\n</code></pre>', '53', '变量\r\n变量的种类：\r\n    1、成员变量\r\n    2、局部变量\r\n成员变量与局部变量的区别：\r\n    定义位置的区别\r\n        1、成员变量定义在方法之外，类之内。\r\n        2.局部变量定义在方法之内。\r\n    作用的区别：\r\n        1、成员变量用于描述事物的公共属性。\r\n        2、局部变量提供一个一个变量给方法内部使用。\r\n    生命周期的区别：\r\n        1、成员变量随着对象的创建而存在，对着对象的消失而消失。\r\n        2、局部变量在调用了对应的方法时执行到了创建该变量的语句时存在，一旦出了自己的作用域会马上从内存中消失。\r\n    初始值得区别：\r\n        1、成员变量有默认初始值：\r\n            数据类型            默认初始值\r\n            int             0\r\n            float            0.0f\r\n            double            0.0\r\n            boolean            false\r\n            char            \'\'（空字符）\r\n            String            null\r\n        2、局部变量没有默认值，必须先初始化在使用。\r\n方法：函数也被称为方法。\r\n\r\n静态- static修饰符\r\nstatic 修饰成员变量（静态成员变量）\r\n    使用场景：如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰。例如统计一个类被使用了几次。\r\n    静态成员变量的访问方式：\r\n        1、可以通过对象进行访问\r\n            格式：对象.变量名\r\n        2、可以使用类名进行访问\r\n            格式：类名.变量名\r\n    注意事项：\r\n        1、非静态成员变量只能使用对象访问，不能使用类名访问。\r\n        2、千万不要为了方便访问数据而使用static修饰成员变量。只有成员变量数据真正需要被共享的时候才使用static修饰。\r\nstatic 修饰方法（静态成员方法）\r\n    使用场景：如果一个函数没有直接访问到非静态的成员时，那么就可以使用static修饰了，一般用于工具类型的方法。----静态函数只要存在对象，也可以访问非静态数据，只要不能直接访问而已。\r\n    静态成员函数的访问方式：\r\n        1、可以通过对象进行访问\r\n            格式：对象.静态函数名(形参列表);\r\n        2、可以使用类名进行访问\r\n            格式：类名.静态函数名(形参列表);\r\n    注意事项：\r\n        1、 静态函数是可以调用类名或者对象进行调用的，而非静态函数只能使用对象进行调用。\r\n        2、静态的函数可以直接访问静态的成员，但是不能直接访问非静态的成员。    \r\n            原因：静态函数是可以使用类名直接调用的，这时候可能还没有存在对象，\r\n            而非静态的成员数据是随着对象的存在而存在的。\r\n        3、非静态的函数是可以直接访问静态与非静态的成员。\r\n            原因：非静态函数只能由对象调用，当对象存在的时候，静态数据老早就已经存在了，而非静态\r\n            数据也随着对象的创建而存在了。\r\n        4、静态函数不能出现this或者super关键字。\r\n            原因：因为静态的函数是可以使用类名调用的，一旦使用类名调用这时候不存在对象，而this\r\n            关键字是代表了一个函数的调用者对象，这时候产生了冲突。\r\n\r\n静态的数据的生命周期：静态的成员变量数据是优先于对象存在的。\r\n***推荐使用类名访问静态的成员\r\n\r\n静态的成员变量与非静态的成员变量的区别：\r\n    1. 作用上的区别：\r\n        1. 静态的成员变量的作用共享一个数据给所有的对象使用。\r\n        2. 非静态的成员变量的作用是描述一类事物的公共属性。\r\n    2. 数量与存储位置上的区别：\r\n        1. 静态成员变量是存储方法区内存中，而且只会存在一份数据。\r\n        2. 非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。\r\n    3. 生命周期的区别：\r\n        1. 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失。\r\n        2.非静态的成员数据是随着对象的创建而存在，随着对象被垃圾回收器回收而消失。\r\n\r\n \r\n\r\n代码示例如下：\r\n```\r\nclass ArrayTool{\r\n    static int count = 0; //统计使用的次数\r\n    {\r\n        count++;\r\n    }\r\n    public static void showCount(){\r\n        System.out.println(\"创建了\"+count+\"个对象\");\r\n    }\r\n\r\n    //转化为字符串并以\",\"分割\r\n    public static String toString(int[] arr){\r\n        String result  = \"\";\r\n        for(int i = 0;  i < arr.length ; i++){\r\n            if (i==0){\r\n                result+=\"[\"+arr[i]+\",\";\r\n            }else if(i==(arr.length-1)){\r\n                result+= arr[i]+\"]\";\r\n            }else{\r\n                result+=arr[i]+\",\";\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //从小到大排序\r\n    public static void sort(int[] arr){\r\n        for(int i = 0; i < arr.length-1 ; i++){\r\n            for(int j = i+1 ; j<arr.length ; j++){\r\n                if(arr[i]>arr[j]){\r\n                    int temp = arr[i];\r\n                    arr[i] = arr[j];\r\n                    arr[j] = temp;\r\n                }\r\n            }\r\n        }    \r\n    }\r\n}\r\n\r\nclass Demo{\r\n    public static void main(String[] args){\r\n        ArrayTool at1 = new ArrayTool();\r\n        ArrayTool at2 = new ArrayTool();\r\n        ArrayTool at3 = new ArrayTool();\r\n        ArrayTool at4 = new ArrayTool();\r\n        ArrayTool.showCount();\r\n\r\n        int[] arr = {12,1,456,165};\r\n        ArrayTool.sort(arr);\r\n        String info = ArrayTool.toString(arr);\r\n        System.out.println(\"数组的元素：\"+ info);\r\n    }\r\n}\r\n\r\n```');
INSERT INTO `article_info_true` VALUES ('38', '封装', '<p>在理解封装之前，必须要先了解“权限修饰符”。<br>    权限修饰符是用来控制访问权限的。Java语言中的访问权限修饰符有4种，但是仅有3个关键字，因为不写访问权限，在Java中被称为默认权限，或同包权限，本文（default）代替。下面按照权限从小到大的顺序对4中访问权限分别介绍。<br>  　　 1.私有权限（private）<br>            private可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。<br>        2.默认权限（default）<br>            类，数据成员，构造方法，方法成员，都能够使用默认权限，即不写任何关键字。默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。<br>        3.受保护权限（protected）<br>            protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。<br>        4.公共权限（public）<br>        public可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。<br>    有关Java语言的修饰符，需要注意的问题有如下几个：<br>        1.并不是每个修饰符都可以修饰类（指外部类），只有public和default可以。<br>        2.所有修饰符都可以修饰数据成员，方法成员，构造方法。<br>        3.为了代码安全起见，修饰符不要尽量使用权限大的，而是适用即可。比如，数据成员，如果没有特殊需要，尽可能用private。<br>        4.修饰符修饰的是“被访问”的权限。</p>\r\n<pre><code>了解完权限修饰符，接下来看一下封装。\r\n封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\r\n对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。\r\n使用封装有三大好处：\r\n    1、良好的封装能够减少耦合。\r\n     2、类内部的结构可以自由修改。\r\n      3、可以对成员进行更精确的控制。\r\n    4、隐藏信息，实现细节。\r\n封装的步骤：\r\n1. 使用private修饰需要被封装的属性.\r\n2. 根据需要提供get或者set方法设置以及获取属性。\r\n3. 根据需求来选择合适的权限修饰符来修饰成员方法。\r\n\r\n规范 ： 在现实开发中一般实体类的所有成员属性（成员变量）都要封装起来。\r\n</code></pre><p>代码示例如下：</p>\r\n<pre><code>//属性封装\r\nclass People{\r\n    private String name; //姓名\r\n    private String sex; //性别 0：女 1：男\r\n    private String sexName; //性别显示\r\n    private int age; //年龄\r\n    //对外开放设置属性的接口 setter和getter方法\r\n    public String getName(){\r\n        return name;\r\n    }\r\n    public void setName(String name){\r\n        this.name = name;\r\n    }\r\n    public String getSex(){\r\n        return sex;\r\n    }\r\n    public void setSex(String sex){\r\n        this.sex = sex;\r\n    }\r\n    public int getAge(){\r\n        return age;\r\n    }\r\n    public void setAge(int age){\r\n        //对属性值进行检测\r\n        if (age &gt; 120) {\r\n            System.out.println(&quot;设置的年龄不符合实际&quot;);\r\n        }else{\r\n            this.age = age;\r\n        }\r\n    }\r\n\r\n    //获取有意义的属性值\r\n    public String getSexName(){\r\n        if (sex.equals(&quot;0&quot;)) {\r\n            sexName = &quot;女&quot;;\r\n        }else if (sex.equals(&quot;1&quot;)) {\r\n            sexName = &quot;男&quot;;\r\n        }else{\r\n            sexName = &quot;人妖&quot;;\r\n        }\r\n        return sexName;\r\n    }\r\n}\r\n\r\n//功能封装\r\nclass Calculator{\r\n    public int num1; //第一个操作数\r\n    public int num2; //第二个操作数\r\n    public char operate; //操作符\r\n\r\n    //构造方法 - 一个类不一定要有getter 和 setter\r\n    public Calculator(int num1, int num2, char operate){\r\n        this.num1 = num1;\r\n        this.num2 = num2;\r\n        if (operate==&#39;+&#39;||operate==&#39;-&#39;||operate==&#39;*&#39;||operate==&#39;/&#39;) {\r\n            this.operate = operate;\r\n        }else{\r\n            this.operate = &#39;+&#39;;\r\n        }\r\n    }\r\n\r\n    //计算功能\r\n    public void calculate(){\r\n        switch(operate){\r\n            case &#39;+&#39;:\r\n                System.out.println(&quot;做加法运算,结果是：&quot;+(num1+num2));\r\n                break;\r\n            case &#39;-&#39;:\r\n                System.out.println(&quot;做减法运算,结果是：&quot;+(num1-num2));\r\n                break;\r\n            case &#39;*&#39;:\r\n                System.out.println(&quot;做乘法运算,结果是：&quot;+(num1*num2));\r\n                break;\r\n            case &#39;/&#39;:\r\n                System.out.println(&quot;做除法运算,结果是：&quot;+(num1/num2));\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nclass Demo{\r\n    public static void main(String[] args){\r\n        //测试封装属性\r\n        People people = new People();\r\n        people.setName(&quot;张三&quot;);\r\n        people.setSex(&quot;1&quot;);\r\n        people.setAge(130);\r\n        System.out.println(people.getName() +&quot; 的性别是 &quot; + people.getSexName() + &quot; 年龄是 &quot;+people.getAge());\r\n        //功能封装\r\n        Calculator calculator = new Calculator(2,1,&#39;*&#39;);\r\n        calculator.calculate();\r\n    }\r\n}\r\n</code></pre>', '54', '在理解封装之前，必须要先了解“权限修饰符”。\r\n    权限修饰符是用来控制访问权限的。Java语言中的访问权限修饰符有4种，但是仅有3个关键字，因为不写访问权限，在Java中被称为默认权限，或同包权限，本文（default）代替。下面按照权限从小到大的顺序对4中访问权限分别介绍。\r\n  　　 1.私有权限（private）\r\n            private可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。\r\n        2.默认权限（default）\r\n            类，数据成员，构造方法，方法成员，都能够使用默认权限，即不写任何关键字。默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。\r\n        3.受保护权限（protected）\r\n            protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。\r\n        4.公共权限（public）\r\n        public可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。\r\n    有关Java语言的修饰符，需要注意的问题有如下几个：\r\n        1.并不是每个修饰符都可以修饰类（指外部类），只有public和default可以。\r\n        2.所有修饰符都可以修饰数据成员，方法成员，构造方法。\r\n        3.为了代码安全起见，修饰符不要尽量使用权限大的，而是适用即可。比如，数据成员，如果没有特殊需要，尽可能用private。\r\n        4.修饰符修饰的是“被访问”的权限。\r\n\r\n    了解完权限修饰符，接下来看一下封装。\r\n    封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\r\n    对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。\r\n    使用封装有三大好处：\r\n        1、良好的封装能够减少耦合。\r\n         2、类内部的结构可以自由修改。\r\n          3、可以对成员进行更精确的控制。\r\n        4、隐藏信息，实现细节。\r\n    封装的步骤：\r\n    1. 使用private修饰需要被封装的属性.\r\n    2. 根据需要提供get或者set方法设置以及获取属性。\r\n    3. 根据需求来选择合适的权限修饰符来修饰成员方法。\r\n\r\n    规范 ： 在现实开发中一般实体类的所有成员属性（成员变量）都要封装起来。\r\n\r\n\r\n代码示例如下：\r\n```\r\n//属性封装\r\nclass People{\r\n    private String name; //姓名\r\n    private String sex; //性别 0：女 1：男\r\n    private String sexName; //性别显示\r\n    private int age; //年龄\r\n    //对外开放设置属性的接口 setter和getter方法\r\n    public String getName(){\r\n        return name;\r\n    }\r\n    public void setName(String name){\r\n        this.name = name;\r\n    }\r\n    public String getSex(){\r\n        return sex;\r\n    }\r\n    public void setSex(String sex){\r\n        this.sex = sex;\r\n    }\r\n    public int getAge(){\r\n        return age;\r\n    }\r\n    public void setAge(int age){\r\n        //对属性值进行检测\r\n        if (age > 120) {\r\n            System.out.println(\"设置的年龄不符合实际\");\r\n        }else{\r\n            this.age = age;\r\n        }\r\n    }\r\n\r\n    //获取有意义的属性值\r\n    public String getSexName(){\r\n        if (sex.equals(\"0\")) {\r\n            sexName = \"女\";\r\n        }else if (sex.equals(\"1\")) {\r\n            sexName = \"男\";\r\n        }else{\r\n            sexName = \"人妖\";\r\n        }\r\n        return sexName;\r\n    }\r\n}\r\n\r\n//功能封装\r\nclass Calculator{\r\n    public int num1; //第一个操作数\r\n    public int num2; //第二个操作数\r\n    public char operate; //操作符\r\n\r\n    //构造方法 - 一个类不一定要有getter 和 setter\r\n    public Calculator(int num1, int num2, char operate){\r\n        this.num1 = num1;\r\n        this.num2 = num2;\r\n        if (operate==\'+\'||operate==\'-\'||operate==\'*\'||operate==\'/\') {\r\n            this.operate = operate;\r\n        }else{\r\n            this.operate = \'+\';\r\n        }\r\n    }\r\n\r\n    //计算功能\r\n    public void calculate(){\r\n        switch(operate){\r\n            case \'+\':\r\n                System.out.println(\"做加法运算,结果是：\"+(num1+num2));\r\n                break;\r\n            case \'-\':\r\n                System.out.println(\"做减法运算,结果是：\"+(num1-num2));\r\n                break;\r\n            case \'*\':\r\n                System.out.println(\"做乘法运算,结果是：\"+(num1*num2));\r\n                break;\r\n            case \'/\':\r\n                System.out.println(\"做除法运算,结果是：\"+(num1/num2));\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nclass Demo{\r\n    public static void main(String[] args){\r\n        //测试封装属性\r\n        People people = new People();\r\n        people.setName(\"张三\");\r\n        people.setSex(\"1\");\r\n        people.setAge(130);\r\n        System.out.println(people.getName() +\" 的性别是 \" + people.getSexName() + \" 年龄是 \"+people.getAge());\r\n        //功能封装\r\n        Calculator calculator = new Calculator(2,1,\'*\');\r\n        calculator.calculate();\r\n    }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('39', '神奇的MAIN方法详解', '<p>main函数的详解：<br>    public ： 公共的。 权限是最大，在任何情况下都可以访问。<br>        原因： 为了保证让jvm在任何情况下都可以访问到main方法。<br>    static:  静态。<br>        原因：静态可以让jvm调用main函数的时候更加的方便。不需要通过对象调用。<br>    void:  没有返回值。<br>        原因：返回的数据是给jvm的，而jvm使用这个数据是没有意义的。<br>    main: 函数名。<br>        注意： main并不是关键字,只不过是jvm能识别的一个特殊的函数名而已。<br>    arguments ：担心某些程序在启动需要参数。</p>\r\n<p>代码示例如下：</p>\r\n<pre><code class=\"lang-java\">class Demo{\r\n\r\n    public static  void main(String[] args)\r\n    {\r\n        System.out.println(&quot;数组的长度：&quot;+ args.length);\r\n        for(int i = 0 ; i &lt;args.length ; i++){\r\n            System.out.println(args[i]+&quot;,&quot;);\r\n        }\r\n    }\r\n}\r\n</code></pre>\r\n<p>运行的时候输入参数，如：<br>java Demo4 aa bb cc</p>\r\n', '55', 'main函数的详解：\r\n    public ： 公共的。 权限是最大，在任何情况下都可以访问。\r\n        原因： 为了保证让jvm在任何情况下都可以访问到main方法。\r\n    static:  静态。\r\n        原因：静态可以让jvm调用main函数的时候更加的方便。不需要通过对象调用。\r\n    void:  没有返回值。 \r\n        原因：返回的数据是给jvm的，而jvm使用这个数据是没有意义的。\r\n    main: 函数名。   \r\n        注意： main并不是关键字,只不过是jvm能识别的一个特殊的函数名而已。\r\n    arguments ：担心某些程序在启动需要参数。\r\n\r\n代码示例如下：\r\n\r\n```java\r\nclass Demo{\r\n\r\n    public static  void main(String[] args)\r\n    {\r\n        System.out.println(\"数组的长度：\"+ args.length);\r\n        for(int i = 0 ; i <args.length ; i++){\r\n            System.out.println(args[i]+\",\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n运行的时候输入参数，如：\r\njava Demo4 aa bb cc');
INSERT INTO `article_info_true` VALUES ('40', '面向过程', '<p>面向过程的程序设计是一种自上而下的设计方法，设计者用一个main函数概括出整个应用程序须要做的事，而main函数由对一系列子函数的调用组成。对于main中的每个子函数，都又能够再被精炼成更小的函数。反复这个过程，就能够完毕一个过程式的设计。其特征是以函数为中心，用函数来作为划分程序的基本单位，数据在过程式设计中往往处于从属的位置。<br>　　<br>　　面向过程式设计的长处是易于理解和掌握，这样的逐步细化问题的设计方法和大多数人的思维方式比較接近。<br>　　<br>　　然而，过程式设计对于比較复杂的问题，或是在开发中需求变化比較多的时候，往往显得力不从心。这是由于过程式的设计是自上而下的，这要求设计者在一開始就要对须要解决的问题有一定的了解。在问题比較复杂的时候，要做到这一点会比較困难，而当开发中需求变化的时候，曾经对问题的理解或许会变得不再适用。其实，开发一个系统的过程往往也是一个对系统不断了解和学习的过程，而过程式的设计方法忽略了这一点。<br>　　<br>　　在面向过程式设计的语言中，一般都既有定义数据的元素，如C语言中的结构，也有定义操作的元素，如C语言中的函数。这样做的结果是数据和操作被分离开，easy导致对一种数据的操作分布在整个程序的各个角落，而一个操作也可能会用到非常多种数据，在这样的情况下，对数据和操作的不论什么一部分进行改动都会变得非常困难。<br>　　<br>　　在面向过程式设计中，main()函数处于一个非常重要的地位。设计者正是在main()函数中，对整个系统进行一个概括的描写叙述，再以此为起点，逐步细化出整个应用程序。然而，这样做的一个后果，是easy将一些较外延和易变化的逻辑（比方用户交互）同程序的核心逻辑混淆在一起。如果我们编写一个图形界面的计算器程序和一个命令行界面的计算器程序，能够想象这两个版本号的main()函数会有非常大的差异，由此衍生出来的程序非常有可能也会迥然不同，而这两个版本号的程序本应该有非常大部分能够共用才对。</p>\r\n', '56', '面向过程的程序设计是一种自上而下的设计方法，设计者用一个main函数概括出整个应用程序须要做的事，而main函数由对一系列子函数的调用组成。对于main中的每个子函数，都又能够再被精炼成更小的函数。反复这个过程，就能够完毕一个过程式的设计。其特征是以函数为中心，用函数来作为划分程序的基本单位，数据在过程式设计中往往处于从属的位置。\r\n　　\r\n　　面向过程式设计的长处是易于理解和掌握，这样的逐步细化问题的设计方法和大多数人的思维方式比較接近。\r\n　　\r\n　　然而，过程式设计对于比較复杂的问题，或是在开发中需求变化比較多的时候，往往显得力不从心。这是由于过程式的设计是自上而下的，这要求设计者在一開始就要对须要解决的问题有一定的了解。在问题比較复杂的时候，要做到这一点会比較困难，而当开发中需求变化的时候，曾经对问题的理解或许会变得不再适用。其实，开发一个系统的过程往往也是一个对系统不断了解和学习的过程，而过程式的设计方法忽略了这一点。\r\n　　\r\n　　在面向过程式设计的语言中，一般都既有定义数据的元素，如C语言中的结构，也有定义操作的元素，如C语言中的函数。这样做的结果是数据和操作被分离开，easy导致对一种数据的操作分布在整个程序的各个角落，而一个操作也可能会用到非常多种数据，在这样的情况下，对数据和操作的不论什么一部分进行改动都会变得非常困难。\r\n　　\r\n　　在面向过程式设计中，main()函数处于一个非常重要的地位。设计者正是在main()函数中，对整个系统进行一个概括的描写叙述，再以此为起点，逐步细化出整个应用程序。然而，这样做的一个后果，是easy将一些较外延和易变化的逻辑（比方用户交互）同程序的核心逻辑混淆在一起。如果我们编写一个图形界面的计算器程序和一个命令行界面的计算器程序，能够想象这两个版本号的main()函数会有非常大的差异，由此衍生出来的程序非常有可能也会迥然不同，而这两个版本号的程序本应该有非常大部分能够共用才对。');
INSERT INTO `article_info_true` VALUES ('41', '面向对象', '<p>　面向对象是一种自下而上的程序设计方法。不像过程式设计那样一開始就要用main概括出整个程序，面向对象设计往往从问题的一部分着手，一点一点地构建出整个程序。面向对象设计以数据为中心，类作为表现数据的工具，是划分程序的基本单位。而函数在面向对象设计中成为了类的接口。<br>　　<br>　　面向对象设计自下而上的特性，同意开发人员从问题的局部開始，在开发过程中逐步加深对系统的理解。这些新的理解以及开发中遇到的需求变化，都会再作用到系统开发本身，形成一种螺旋式的开发方式。(在这样的开发方式中，对于已有的代码，常须要运用Refactoring技术来做代码重构以体现系统的变化。)<br>　　<br>　　和函数相比，数据应该是程序中更稳定的部分，比方，一个网上购物程序，不管怎么变化，大概都会处理货物、客户这些数据对象。只是在这里，仅仅有从抽象的角度来看，数据才是稳定的，假设考虑这些数据对象的详细实现，它们甚至比函数还要不稳定，由于在一个数据对象中增减字段在程序开发中是常事。因此，在以数据为中心构建程序的同一时候，我们须要一种手段来抽象地描写叙述数据，这样的手段就是使用函数。在面向对象设计中，类封装了数据，而类的成员函数作为其对外的接口，抽象地描写叙述了类。用类将数据和操作这些数据的函数放在一起，这能够说就是面向对象设计方法的本质。</p>\r\n', '57', '　面向对象是一种自下而上的程序设计方法。不像过程式设计那样一開始就要用main概括出整个程序，面向对象设计往往从问题的一部分着手，一点一点地构建出整个程序。面向对象设计以数据为中心，类作为表现数据的工具，是划分程序的基本单位。而函数在面向对象设计中成为了类的接口。\r\n　　\r\n　　面向对象设计自下而上的特性，同意开发人员从问题的局部開始，在开发过程中逐步加深对系统的理解。这些新的理解以及开发中遇到的需求变化，都会再作用到系统开发本身，形成一种螺旋式的开发方式。(在这样的开发方式中，对于已有的代码，常须要运用Refactoring技术来做代码重构以体现系统的变化。)\r\n　　\r\n　　和函数相比，数据应该是程序中更稳定的部分，比方，一个网上购物程序，不管怎么变化，大概都会处理货物、客户这些数据对象。只是在这里，仅仅有从抽象的角度来看，数据才是稳定的，假设考虑这些数据对象的详细实现，它们甚至比函数还要不稳定，由于在一个数据对象中增减字段在程序开发中是常事。因此，在以数据为中心构建程序的同一时候，我们须要一种手段来抽象地描写叙述数据，这样的手段就是使用函数。在面向对象设计中，类封装了数据，而类的成员函数作为其对外的接口，抽象地描写叙述了类。用类将数据和操作这些数据的函数放在一起，这能够说就是面向对象设计方法的本质。');
INSERT INTO `article_info_true` VALUES ('42', 'java高级', '<h3 id=\"h3-java-\"><a name=\"java高级知识点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>java高级知识点</h3><p>1.1 Collection和Map<br>　　(1)掌握Collection和Map的继承体系。<br>　　(2)掌握ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap、WeakHashMap、EnumMap、TreeMap、HashTable的特点和实现原理。<br>　　(3)掌握CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap的实现原理和适用场景。<br>　　1.2 IO<br>　　(1)掌握InputStream、OutputStream、Reader、Writer的继承体系。<br>　　(2)掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。<br>　　(3)掌握NIO实现原理及使用方法。<br>　　1.3 异常<br>　　(1)掌握Throwable继承体系。<br>　　(2)掌握异常工作原理。<br>　　(3)了解常见受检异常(比如FileNotFoundException)、非受检异常(比如NullPointerException)和错误(比如IOError)。<br>　　1.4 多线程<br>　　(1)掌握Executors可以创建的三种(JAVA8增加了一种，共四种)线程池的特点及适用范围。<br>　　(2)掌握多线程同步机制，并熟练运用。<br>　　1.5 Socket<br>　　(1)掌握Socket通信原理。<br>　　(2)熟练使用多线程结合Socket进行编程<br>　　(2)熟练使用多线程结合Socket进行编程。</p>\r\n', '30', '### java高级知识点\r\n1.1 Collection和Map \r\n　　(1)掌握Collection和Map的继承体系。 \r\n　　(2)掌握ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、LinkedHashMap、TreeMap、WeakHashMap、EnumMap、TreeMap、HashTable的特点和实现原理。 \r\n　　(3)掌握CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap的实现原理和适用场景。 \r\n　　1.2 IO \r\n　　(1)掌握InputStream、OutputStream、Reader、Writer的继承体系。 \r\n　　(2)掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。 \r\n　　(3)掌握NIO实现原理及使用方法。 \r\n　　1.3 异常 \r\n　　(1)掌握Throwable继承体系。 \r\n　　(2)掌握异常工作原理。 \r\n　　(3)了解常见受检异常(比如FileNotFoundException)、非受检异常(比如NullPointerException)和错误(比如IOError)。 \r\n　　1.4 多线程 \r\n　　(1)掌握Executors可以创建的三种(JAVA8增加了一种，共四种)线程池的特点及适用范围。 \r\n　　(2)掌握多线程同步机制，并熟练运用。 \r\n　　1.5 Socket \r\n　　(1)掌握Socket通信原理。 \r\n　　(2)熟练使用多线程结合Socket进行编程 \r\n　　(2)熟练使用多线程结合Socket进行编程。');
INSERT INTO `article_info_true` VALUES ('43', '文件操作', '<p>存储在变量,数组和对象中的数据是暂时的,当程序终止时他们就会丢失.为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们需要学习如何通过java对文件进行操作</p>\r\n', '46', '存储在变量,数组和对象中的数据是暂时的,当程序终止时他们就会丢失.为了能够永久的保存程序中创建的数据,需要将他们存储到硬盘或光盘的文件中.这些文件可以移动,传送,亦可以被其他程序使用.由于数据存储在文件中,所以我们需要学习如何通过java对文件进行操作');
INSERT INTO `article_info_true` VALUES ('44', 'Java开发准备基础', '<h1 id=\"h1--java-\"><a name=\"一Java语言概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一Java语言概述</h1><p><span style=\"font-size:18px\"><a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>是一种可以撰写跨平台应用程序的面向对象的程序设计语言。Java 技术具有卓越的通用性、高效性、平台</span></p>\r\n<p><span style=\"font-size:18px\">移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，同时拥有全球最大</span></p>\r\n<p><span style=\"font-size:18px\">的开发者专业社群。</span></p>\r\n<p><span style=\"font-size:18px\"> Java由四方面组成：</span></p>\r\n<p><span style=\"font-size:18px\"> (1)Java编程语言，即语法。</span></p>\r\n<p><span style=\"font-size:18px\"> (2)Java文件格式，即各种文件夹、文件的后缀。</span></p>\r\n<p><span style=\"font-size:18px\"> (3)Java虚拟机(JVM)，即处理*.class文件的解释器。</span></p>\r\n<p><span style=\"font-size:18px\"> (4)Java应用程序接口(<a href=\"http://lib.csdn.net/base/java\" title=\"Java 知识库\">Java</a> API)。</span></p>\r\n<h1 id=\"h1--java-\"><a name=\"二Java语言平台版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二Java语言平台版本</h1><p><span style=\"font-size:18px\"> JavaSE(Java 2 Platform Standard Edition)标准版</span></p>\r\n<p><span style=\"font-size:18px\"> 是为开发普通桌面和商务应用程序提供的解决方案。</span><span style=\"font-size:18px\">该技术体系是其他两者的基础，可以完成一些桌面应用程序</span></p>\r\n<p><span style=\"font-size:18px\">的开发。</span></p>\r\n<p><span style=\"font-size:18px\"> JavaME(Java 2 Platform Micro Edition)小型版</span></p>\r\n<p><span style=\"font-size:18px\"> 是为开发电子消费产品和<a href=\"http://lib.csdn.net/base/embeddeddevelopment\" title=\"嵌入式开发知识库\">嵌入式</a>设备提供的解决方案。</span></p>\r\n<p><span style=\"font-size:18px\"> JavaEE(Java 2 Platform Enterprise Edition)企业版</span></p>\r\n<p><span style=\"font-size:18px\"> 是为开发企业环境下的应用程序提供的一套解决方案。</span><span style=\"font-size:18px\">该技术体系中包含的技术如 Servlet、Jsp等，主要针对于</span></p>\r\n<p><span style=\"font-size:18px\">Web应用程序开发。</span></p>\r\n<h1 id=\"h1--java-\"><a name=\"三Java语言特点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三Java语言特点</h1><p><span style=\"font-size:18px\"> (1)简单性?</span></p>\r\n<p><span style=\"font-size:18px\"> Java语言是一种面向对象的语言,它通过提供最基本的方法来完成指定的任务,只需理解一些基本的概念,就可以用</span></p>\r\n<p><span style=\"font-size:18px\">它编写出适合于各种情况的应用程序。Java略去了运算符重载、多重继承等模糊的概</span><span style=\"font-size:18px\">念,并且通过实现自动垃圾收集大</span></p>\r\n<p><span style=\"font-size:18px\">大简化了程序设计者的内存管理工作。</span></p>\r\n<p><span style=\"font-size:18px\"> (2)面向对象?</span></p>\r\n<p><span style=\"font-size:18px\"> Java语言的设计集中于对象及其接口,它提供了简单的类机制以及动态的接口模型。对象中封装了它的状态变量以</span></p>\r\n<p><span style=\"font-size:18px\">及相应的方法,实现了模块化和信息隐藏;而类则提供了一类对象的原型,并且通过继承</span><span style=\"font-size:18px\">机制,子类可以使用父类所提供的</span></p>\r\n<p><span style=\"font-size:18px\">方法,实现了代码的复用。?</span></p>\r\n<p><span style=\"font-size:18px\"> (3)分布式处理</span></p>\r\n<p><span style=\"font-size:18px\"> Java是面向网络的语言。通过它提供的类库可以处理TCP/IP协议,用户可以通过URL地址在网络上很方便地访问其</span></p>\r\n<p><span style=\"font-size:18px\">它对象。 ?</span></p>\r\n<p><span style=\"font-size:18px\"> (4)结构中立</span></p>\r\n<p><span style=\"font-size:18px\"> Java解释器生成与体系结构无关的字节码指令,只要安装了Java运行时系统,Java程序就可在任意的处理器上运</span></p>\r\n<p><span style=\"font-size:18px\">行。这些字节码指令对应于Java虚拟机中的表示,Java解释器得到字节码后,对它进行转</span><span style=\"font-size:18px\">换,使之能够在不同的平台运</span></p>\r\n<p><span style=\"font-size:18px\">行。 ??</span></p>\r\n<p><span style=\"font-size:18px\"> <span style=\"color:#ff0000\">(5)开源</span> ?</span></p>\r\n<p><span style=\"font-size:18px\"> Java是一种开源的语言，我们可以看到别人的Java代码。</span></p>\r\n<p><span style=\"font-size:18px\"> <span style=\"color:#ff0000\">(6)跨平台</span></span></p>\r\n<p><span style=\"font-size:18px\"> 与平台无关的特性使Java程序可以方便地被移植到网络上的不同机器。同时,Java的类库中也实现了与不同平台的</span></p>\r\n<p><span style=\"font-size:18px\">接口,使这些类库可以移植。另外,Java编译器是由Java语言实现的,Java运行时系统由标准C实现,这使得Java系统本身</span></p>\r\n<p><span style=\"font-size:18px\">也具有可移植性。</span></p>\r\n<p><span style=\"font-size:18px\"> (7)解释性</span></p>\r\n<p><span style=\"font-size:18px\"> Java解释器直接对Java字节码进行解释执行。字节码本身携带了许多编译时信息,使得连接过程更加简单。<br></span></p>\r\n<p><span style=\"font-size:18px\"> (8)高性能</span></p>\r\n<p><span style=\"font-size:18px\"> 和其它解释执行的语言如BASIC、TCL不同,Java字节码的设计使之能很容易地直接转换成对应于特定CPU的机器</span></p>\r\n<p><span style=\"font-size:18px\">码,从而得到较高的性能。</span></p>\r\n<p><span style=\"font-size:18px\"> (9)多线程 ?</span></p>\r\n<p><span style=\"font-size:18px\"> 多线程机制使应用程序能够并行执行,而且同步机制保证了对共享数据的正确操作。通过使用多线程,程序设计者可</span></p>\r\n<p><span style=\"font-size:18px\">以分别用不同的线程完成特定的行为,而不需要采用全局的事件循环机制,这样就很容</span><span style=\"font-size:18px\">易地实现网络上的实时交互行</span></p>\r\n<p><span style=\"font-size:18px\">为。</span></p>\r\n<p><span style=\"font-size:18px\"> (10)动态性</span></p>\r\n<p><span style=\"font-size:18px\"> ava的设计使它适合于一个不断发展的环境。在类库中可以自由地加入新的方法和实例变量而不会影响用户程序的</span></p>\r\n<p><span style=\"font-size:18px\">执行。并且Java通过接口来支持多重继承,使之比严格的类继承具有更灵活的方式和扩</span><span style=\"font-size:18px\">展性。 ?</span></p>\r\n<p><span style=\"font-size:18px\"> (11)安全性</span></p>\r\n<p><span style=\"font-size:18px\"> 用于网络、分布环境下的Java必须要防止病毒的入侵。Java不支持指针,一切对内存的访问都必通过对象的实例变</span></p>\r\n<p><span style=\"font-size:18px\">量来实现,这样就防止程序员使用”特洛伊”木马等欺骗手段访问对象的私有成员,同时也避免了指针操作中容易产生的错</span></p>\r\n<p><span style=\"font-size:18px\">误。</span></p>\r\n<h1 id=\"h1--java-\"><a name=\"四Java语言的跨平台性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四Java语言的跨平台性</h1><p><span style=\"font-size:18px\"> 通过Java语言编写的应用程序在不同的系统平台上都可以运行。只要在需要运行java应用程序的<a href=\"http://lib.csdn.net/base/operatingsystem\" title=\"操作系统知识库\">操作系统</a>上，先</span></p>\r\n<p><span style=\"font-size:18px\">安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在</span><span style=\"font-size:18px\">该系统中的运行。我们里看一个图</span></p>\r\n<p><span style=\"font-size:18px\">解：</span></p>\r\n<p><span style=\"font-size:18px\"></span></p>\r\n<div style=\"text-align:center\"><img src=\"http://img.blog.csdn.net/20160118175722329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></div>\r\n\r\n<p><span style=\"font-size:18px\">因为有了JVM，所以同一个Java程序在三个不同的操作系统中都可以执行。这样就实现了Java程序的跨平台性。</span></p>\r\n<p><span style=\"font-size:18px\">也称为Java具有良好的可移植性。注意一点：Java语言是跨平台的，而JVM不是跨平台的。</span></p>\r\n<h1 id=\"h1--jdk-jre-jvm-\"><a name=\"五JDK、JRE、JVM的作用和关系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五JDK、JRE、JVM的作用和关系</h1><p><span style=\"font-size:18px\"> JRE(Java Runtime Environment ? Java运行环境)：包括Java虚拟机(JVM Java Virtual?Machine)和Java程序所需的</span></p>\r\n<p><span style=\"font-size:18px\">核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。也就是JRE:JVM+类库。</span></p>\r\n<p><span style=\"font-size:18px\"> JDK(Java Development Kit ? ? Java开发工具包)：JDK是提供给Java开发人员使用的，其中包含了java的开发工</span></p>\r\n<p><span style=\"font-size:18px\">具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具</span><span style=\"font-size:18px\">：编译工具(javac.exe)打包工具</span></p>\r\n<p><span style=\"font-size:18px\">(jar.exe)等。也就是JDK:JRE+JAVA的开发工具。</span></p>\r\n<p><span style=\"font-size:18px\"> 为什么JDK中包含一个JRE呢？</span></p>\r\n<p><span style=\"font-size:18px\"> 其一，开发完的程序，总需要运行一下看看效果。<br></span></p>\r\n<p><span style=\"font-size:18px\"> 其二，也是最重要的，JDK中的开发工具其实都是java语言编写的应用程序，为了方便使用才打包成exe文件，如</span></p>\r\n<p><span style=\"font-size:18px\">果没有JRE，那么这些工具是运行不了的。</span></p>\r\n<p><span style=\"font-size:18px\"> <span style=\"color:#ff0000\">三者的关系简单而言就是：使用JDK开发完成的java程序，交给JRE去运行，由JVM保证跨平台。</span></span></p>\r\n<h1 id=\"h1--jdk-\"><a name=\"六JDK的下载和安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六JDK的下载和安装</h1><h2 id=\"h2-u4E0Bu8F7D\"><a name=\"下载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>下载</h2><p><span style=\"font-size:18px\"> (1)打开<a href=\"http://lib.csdn.net/base/oracle\" title=\"Oracle知识库\">Oracle</a>官网：<a href=\"http://www.oracle.com\">http://www.oracle.com</a></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180131972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"> (2)点击Downloads和选择Java for Developers</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180143894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"> (3)选择Downloads和<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java SE</a></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180150724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"> (4)针对不同操作系统，下载不同的JDK版本识别计算机的操作系统</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180158581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h2 id=\"h2-u5B89u88C5\"><a name=\"安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装</h2><p><span style=\"font-size:18px\"> 安装的过程中记住自己所安装的路径。我的安装路径为：E:\\Java\\develop\\jdk1.8.0_25</span></p>\r\n<h1 id=\"h1--helloworld-\"><a name=\"七HelloWorld案例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七HelloWorld案例</h1><p><span style=\"font-size:18px\"> (1)打开E:\\Java\\develop\\jdk1.8.0_25中的bin目录，我们可以看到很多的应用程序文件，其中有两个我们需要使</span></p>\r\n<p><span style=\"font-size:18px\">用，就</span><span style=\"font-size:18px\">是javac.exe和java.exe。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180320381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"> (2)首先编写java源代码程序，扩展名.java。我们在这个文件夹新建一个记事本文件，编写以下的代码，最后将记</span></p>\r\n<p><span style=\"font-size:18px\">事本文件保存为HelloWorld.java格式的文件。因为现在只有当前目录下有javac和java，所以现在将Java源文件保存在</span></p>\r\n<p><span style=\"font-size:18px\">当前目录下。</span></p>\r\n<p><span style=\"font-size:18px\"></span></p>\r\n<ol>\r\n<li><span><span class=\"keyword\">public</span><span>?</span><span class=\"keyword\">class</span><span>?HelloWorld{??</span></span></li><li><span>????????<span class=\"keyword\">public</span><span>?</span><span class=\"keyword\">static</span><span>?</span><span class=\"keyword\">void</span><span>?main(String[?]?args)??</span></span></li><li><span>????????????????System.out.println(<span class=\"string\">“Hello?World”</span><span>);??</span></span></li><li><span>????????}??</span></li><li><span>}??</span></li></ol>\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\"><a href=\"javascript:;\"><img src=\"http://static.blog.csdn.net/images/save_snippets.png\" alt=\"\"></a></div>\r\n\r\n<p></div></p>\r\n<pre code_snippet_id=\"1558963\" snippet_file_name=\"blog_20160118_1_4533566\" name=\"code\" class=\"java\" style=\"display: none;\">public class HelloWorld{\r\n        public static void main(String[ ] args)\r\n                System.out.println(\"Hello World\");\r\n        }\r\n}</pre>\r\n\r\n<p><span style=\"font-size:18px\">?<img src=\"http://img.blog.csdn.net/20160118180325872?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\r\n<p><span style=\"font-size:18px\">(3)打开DOS，使用cd命令进入到指定的文件夹：E:\\Java\\develop\\jdk1.8.0_25\\bin</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180331723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"> (4)在命令行模式中，输入javac命令对源代码进行编译，生成字节码文件</span></p>\r\n<p><span style=\"font-size:18px\"> 格式为：javac HelloWorld.java</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180337217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"> (5)编译完成后，如果没有报错信息，输入java命令对class字节码文件进行解释运行,执行时不需</span><span style=\"font-size:18px\">要添加.class扩展</span></p>\r\n<p><span style=\"font-size:18px\">名。</span></p>\r\n<p><span style=\"font-size:18px\">格式为：java HelloWorld</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118180343108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">最后我们用图来解释Java程序的运行和工作原理：</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160118181234466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">?</span></p>\r\n<p><span style=\"font-size:18px\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><br></span></p>\r\n', '59', '# 一Java语言概述\r\n\r\n<span style=\"font-size:18px\">[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")是一种可以撰写跨平台应用程序的面向对象的程序设计语言。Java 技术具有卓越的通用性、高效性、平台</span>\r\n\r\n<span style=\"font-size:18px\">移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，同时拥有全球最大</span>\r\n\r\n<span style=\"font-size:18px\">的开发者专业社群。</span>\r\n\r\n<span style=\"font-size:18px\"> Java由四方面组成：</span>\r\n\r\n<span style=\"font-size:18px\"> (1)Java编程语言，即语法。</span>\r\n\r\n<span style=\"font-size:18px\"> (2)Java文件格式，即各种文件夹、文件的后缀。</span>\r\n\r\n<span style=\"font-size:18px\"> (3)Java虚拟机(JVM)，即处理*.class文件的解释器。</span>\r\n\r\n<span style=\"font-size:18px\"> (4)Java应用程序接口([Java](http://lib.csdn.net/base/java \"Java 知识库\") API)。</span>\r\n\r\n# 二Java语言平台版本\r\n\r\n<span style=\"font-size:18px\"> JavaSE(Java 2 Platform Standard Edition)标准版</span>\r\n\r\n<span style=\"font-size:18px\"> 是为开发普通桌面和商务应用程序提供的解决方案。</span><span style=\"font-size:18px\">该技术体系是其他两者的基础，可以完成一些桌面应用程序</span>\r\n\r\n<span style=\"font-size:18px\">的开发。</span>\r\n\r\n<span style=\"font-size:18px\"> JavaME(Java 2 Platform Micro Edition)小型版</span>\r\n\r\n<span style=\"font-size:18px\"> 是为开发电子消费产品和[嵌入式](http://lib.csdn.net/base/embeddeddevelopment \"嵌入式开发知识库\")设备提供的解决方案。</span>\r\n\r\n<span style=\"font-size:18px\"> JavaEE(Java 2 Platform Enterprise Edition)企业版</span>\r\n\r\n<span style=\"font-size:18px\"> 是为开发企业环境下的应用程序提供的一套解决方案。</span><span style=\"font-size:18px\">该技术体系中包含的技术如 Servlet、Jsp等，主要针对于</span>\r\n\r\n<span style=\"font-size:18px\">Web应用程序开发。</span>\r\n\r\n# 三Java语言特点\r\n\r\n<span style=\"font-size:18px\"> (1)简单性?</span>\r\n\r\n<span style=\"font-size:18px\"> Java语言是一种面向对象的语言,它通过提供最基本的方法来完成指定的任务,只需理解一些基本的概念,就可以用</span>\r\n\r\n<span style=\"font-size:18px\">它编写出适合于各种情况的应用程序。Java略去了运算符重载、多重继承等模糊的概</span><span style=\"font-size:18px\">念,并且通过实现自动垃圾收集大</span>\r\n\r\n<span style=\"font-size:18px\">大简化了程序设计者的内存管理工作。</span>\r\n\r\n<span style=\"font-size:18px\"> (2)面向对象?</span>\r\n\r\n<span style=\"font-size:18px\"> Java语言的设计集中于对象及其接口,它提供了简单的类机制以及动态的接口模型。对象中封装了它的状态变量以</span>\r\n\r\n<span style=\"font-size:18px\">及相应的方法,实现了模块化和信息隐藏;而类则提供了一类对象的原型,并且通过继承</span><span style=\"font-size:18px\">机制,子类可以使用父类所提供的</span>\r\n\r\n<span style=\"font-size:18px\">方法,实现了代码的复用。?</span>\r\n\r\n<span style=\"font-size:18px\"> (3)分布式处理</span>\r\n\r\n<span style=\"font-size:18px\"> Java是面向网络的语言。通过它提供的类库可以处理TCP/IP协议,用户可以通过URL地址在网络上很方便地访问其</span>\r\n\r\n<span style=\"font-size:18px\">它对象。 ?</span>\r\n\r\n<span style=\"font-size:18px\"> (4)结构中立</span>\r\n\r\n<span style=\"font-size:18px\"> Java解释器生成与体系结构无关的字节码指令,只要安装了Java运行时系统,Java程序就可在任意的处理器上运</span>\r\n\r\n<span style=\"font-size:18px\">行。这些字节码指令对应于Java虚拟机中的表示,Java解释器得到字节码后,对它进行转</span><span style=\"font-size:18px\">换,使之能够在不同的平台运</span>\r\n\r\n<span style=\"font-size:18px\">行。 ??</span>\r\n\r\n<span style=\"font-size:18px\"> <span style=\"color:#ff0000\">(5)开源</span> ?</span>\r\n\r\n<span style=\"font-size:18px\"> Java是一种开源的语言，我们可以看到别人的Java代码。</span>\r\n\r\n<span style=\"font-size:18px\"> <span style=\"color:#ff0000\">(6)跨平台</span></span>\r\n\r\n<span style=\"font-size:18px\"> 与平台无关的特性使Java程序可以方便地被移植到网络上的不同机器。同时,Java的类库中也实现了与不同平台的</span>\r\n\r\n<span style=\"font-size:18px\">接口,使这些类库可以移植。另外,Java编译器是由Java语言实现的,Java运行时系统由标准C实现,这使得Java系统本身</span>\r\n\r\n<span style=\"font-size:18px\">也具有可移植性。</span>\r\n\r\n<span style=\"font-size:18px\"> (7)解释性</span>\r\n\r\n<span style=\"font-size:18px\"> Java解释器直接对Java字节码进行解释执行。字节码本身携带了许多编译时信息,使得连接过程更加简单。\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> (8)高性能</span>\r\n\r\n<span style=\"font-size:18px\"> 和其它解释执行的语言如BASIC、TCL不同,Java字节码的设计使之能很容易地直接转换成对应于特定CPU的机器</span>\r\n\r\n<span style=\"font-size:18px\">码,从而得到较高的性能。</span>\r\n\r\n<span style=\"font-size:18px\"> (9)多线程 ?</span>\r\n\r\n<span style=\"font-size:18px\"> 多线程机制使应用程序能够并行执行,而且同步机制保证了对共享数据的正确操作。通过使用多线程,程序设计者可</span>\r\n\r\n<span style=\"font-size:18px\">以分别用不同的线程完成特定的行为,而不需要采用全局的事件循环机制,这样就很容</span><span style=\"font-size:18px\">易地实现网络上的实时交互行</span>\r\n\r\n<span style=\"font-size:18px\">为。</span>\r\n\r\n<span style=\"font-size:18px\"> (10)动态性</span>\r\n\r\n<span style=\"font-size:18px\"> ava的设计使它适合于一个不断发展的环境。在类库中可以自由地加入新的方法和实例变量而不会影响用户程序的</span>\r\n\r\n<span style=\"font-size:18px\">执行。并且Java通过接口来支持多重继承,使之比严格的类继承具有更灵活的方式和扩</span><span style=\"font-size:18px\">展性。 ?</span>\r\n\r\n<span style=\"font-size:18px\"> (11)安全性</span>\r\n\r\n<span style=\"font-size:18px\"> 用于网络、分布环境下的Java必须要防止病毒的入侵。Java不支持指针,一切对内存的访问都必通过对象的实例变</span>\r\n\r\n<span style=\"font-size:18px\">量来实现,这样就防止程序员使用\"特洛伊\"木马等欺骗手段访问对象的私有成员,同时也避免了指针操作中容易产生的错</span>\r\n\r\n<span style=\"font-size:18px\">误。</span>\r\n\r\n# 四Java语言的跨平台性\r\n\r\n<span style=\"font-size:18px\"> 通过Java语言编写的应用程序在不同的系统平台上都可以运行。只要在需要运行java应用程序的[操作系统](http://lib.csdn.net/base/operatingsystem \"操作系统知识库\")上，先</span>\r\n\r\n<span style=\"font-size:18px\">安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在</span><span style=\"font-size:18px\">该系统中的运行。我们里看一个图</span>\r\n\r\n<span style=\"font-size:18px\">解：</span>\r\n\r\n<span style=\"font-size:18px\"></span>\r\n\r\n<div style=\"text-align:center\">![](http://img.blog.csdn.net/20160118175722329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)</div>\r\n\r\n<span style=\"font-size:18px\">因为有了JVM，所以同一个Java程序在三个不同的操作系统中都可以执行。这样就实现了Java程序的跨平台性。</span>\r\n\r\n<span style=\"font-size:18px\">也称为Java具有良好的可移植性。注意一点：Java语言是跨平台的，而JVM不是跨平台的。</span>\r\n\r\n# 五JDK、JRE、JVM的作用和关系\r\n\r\n<span style=\"font-size:18px\"> JRE(Java Runtime Environment ? Java运行环境)：包括Java虚拟机(JVM Java Virtual?Machine)和Java程序所需的</span>\r\n\r\n<span style=\"font-size:18px\">核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。也就是JRE:JVM+类库。</span>\r\n\r\n<span style=\"font-size:18px\"> JDK(Java Development Kit ? ? Java开发工具包)：JDK是提供给Java开发人员使用的，其中包含了java的开发工</span>\r\n\r\n<span style=\"font-size:18px\">具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具</span><span style=\"font-size:18px\">：编译工具(javac.exe)打包工具</span>\r\n\r\n<span style=\"font-size:18px\">(jar.exe)等。也就是JDK:JRE+JAVA的开发工具。</span>\r\n\r\n<span style=\"font-size:18px\"> 为什么JDK中包含一个JRE呢？</span>\r\n\r\n<span style=\"font-size:18px\"> 其一，开发完的程序，总需要运行一下看看效果。\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> 其二，也是最重要的，JDK中的开发工具其实都是java语言编写的应用程序，为了方便使用才打包成exe文件，如</span>\r\n\r\n<span style=\"font-size:18px\">果没有JRE，那么这些工具是运行不了的。</span>\r\n\r\n<span style=\"font-size:18px\"> <span style=\"color:#ff0000\">三者的关系简单而言就是：使用JDK开发完成的java程序，交给JRE去运行，由JVM保证跨平台。</span></span>\r\n\r\n# 六JDK的下载和安装\r\n\r\n## 下载\r\n\r\n<span style=\"font-size:18px\"> (1)打开[Oracle](http://lib.csdn.net/base/oracle \"Oracle知识库\")官网：http://www.oracle.com</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180131972?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> (2)点击Downloads和选择Java for Developers</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180143894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> (3)选择Downloads和[Java SE](http://lib.csdn.net/base/javase \"Java SE知识库\")</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180150724?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> (4)针对不同操作系统，下载不同的JDK版本识别计算机的操作系统</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180158581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n## 安装\r\n\r\n<span style=\"font-size:18px\"> 安装的过程中记住自己所安装的路径。我的安装路径为：E:\\Java\\develop\\jdk1.8.0_25</span>\r\n\r\n# 七HelloWorld案例\r\n\r\n<span style=\"font-size:18px\"> (1)打开E:\\Java\\develop\\jdk1.8.0_25中的bin目录，我们可以看到很多的应用程序文件，其中有两个我们需要使</span>\r\n\r\n<span style=\"font-size:18px\">用，就</span><span style=\"font-size:18px\">是javac.exe和java.exe。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180320381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> (2)首先编写java源代码程序，扩展名.java。我们在这个文件夹新建一个记事本文件，编写以下的代码，最后将记</span>\r\n\r\n<span style=\"font-size:18px\">事本文件保存为HelloWorld.java格式的文件。因为现在只有当前目录下有javac和java，所以现在将Java源文件保存在</span>\r\n\r\n<span style=\"font-size:18px\">当前目录下。</span>\r\n\r\n<span style=\"font-size:18px\"></span>\r\n\r\n\r\n\r\n1.  <span><span class=\"keyword\">public</span><span>?</span><span class=\"keyword\">class</span><span>?HelloWorld{??</span></span>\r\n2.  <span>????????<span class=\"keyword\">public</span><span>?</span><span class=\"keyword\">static</span><span>?</span><span class=\"keyword\">void</span><span>?main(String[?]?args)??</span></span>\r\n3.  <span>????????????????System.out.println(<span class=\"string\">\"Hello?World\"</span><span>);??</span></span>\r\n4.  <span>????????}??</span>\r\n5.  <span>}??</span>\r\n\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\">[![](http://static.blog.csdn.net/images/save_snippets.png)](javascript:;)</div>\r\n\r\n</div>\r\n\r\n<pre code_snippet_id=\"1558963\" snippet_file_name=\"blog_20160118_1_4533566\" name=\"code\" class=\"java\" style=\"display: none;\">public class HelloWorld{\r\n        public static void main(String[ ] args)\r\n                System.out.println(\"Hello World\");\r\n        }\r\n}</pre>\r\n\r\n<span style=\"font-size:18px\">?![](http://img.blog.csdn.net/20160118180325872?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)</span>\r\n\r\n<span style=\"font-size:18px\">(3)打开DOS，使用cd命令进入到指定的文件夹：E:\\Java\\develop\\jdk1.8.0_25\\bin</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180331723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> (4)在命令行模式中，输入javac命令对源代码进行编译，生成字节码文件</span>\r\n\r\n<span style=\"font-size:18px\"> 格式为：javac HelloWorld.java</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180337217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\"> (5)编译完成后，如果没有报错信息，输入java命令对class字节码文件进行解释运行,执行时不需</span><span style=\"font-size:18px\">要添加.class扩展</span>\r\n\r\n<span style=\"font-size:18px\">名。</span>\r\n\r\n<span style=\"font-size:18px\">格式为：java HelloWorld</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118180343108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">最后我们用图来解释Java程序的运行和工作原理：</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160118181234466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">?</span>\r\n\r\n<span style=\"font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-size:18px\">\r\n</span>');
INSERT INTO `article_info_true` VALUES ('46', 'javascript', '<h1 id=\"h1--javascript-\"><a name=\"一、JavaScript概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、JavaScript概述</h1><h2 id=\"h2-1-1-javascript-\"><a name=\"1.1 JavaScript是什么?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 JavaScript是什么?</h2><ol>\r\n<li>JavaScript主要用于HTML的页面，嵌入在HTML的源码中。</li><li>JavaScript是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。</li><li>JS是弱类型语言,没有类型声明,它的变量不必具有一个明确的类型。</li><li>JS是脚本语言，换句话说，可以用来编程的并且直接执行源代码的语言,就是脚本语言。</li><li>JS也是解释性的语言。何为解释性语言?是在运行的时候将程序直接翻译成机器的语言</li><li>JavaScript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言,可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</li><li>HTML5的出现更是突出了JavaScript的重要性，例如HTML5的绘图支持、本地存储、离线应用、客户端通信等，都大量使用了JavaScript。</li></ol>\r\n<hr>\r\n<h2 id=\"h2-1-2-javascript-\"><a name=\"1.2 JavaScript历史\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 JavaScript历史</h2><ul>\r\n<li>网景公司在上个世纪的1995年，凭借其Navigator浏览器，成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在设计出了JavaScript语言。</li></ul>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/97617638.jpg\" alt=\"\"></p>\r\n<ul>\r\n<li>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。JavaScript</li></ul>\r\n<p><a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>因为互联网而生，紧随着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。</p>\r\n<ul>\r\n<li>1990年底，欧洲核能研究组织（CERN）科学家Tim Berners-Lee（蒂姆 伯纳斯-李），互联网之父</li><li>1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做Mosaic （马赛克） 。</li><li>1994年10月，NCSA的一个主要程序员MarcAndreessen（马克 爱德森）联合风险投资家Jim Clark（ 吉姆·克拉克），成立了Mosaic通信公司（Mosaic Communications），不久后改名为网景Netscape。这家公司的方向，就是在Mosaic的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。</li><li>1994年12月，Navigator发布了1.0版，市场份额一举超过90%。</li><li>1995年，Netscape公司Brendan Eich开发这种网页脚本语言。1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版liveScript。它是一个大杂烩，语法有多个来源：</li></ul>\r\n', '62', '\r\n\r\n# 一、JavaScript概述\r\n\r\n## 1.1 JavaScript是什么?\r\n\r\n1.  JavaScript主要用于HTML的页面，嵌入在HTML的源码中。\r\n2.  JavaScript是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。\r\n3.  JS是弱类型语言,没有类型声明,它的变量不必具有一个明确的类型。\r\n4.  JS是脚本语言，换句话说，可以用来编程的并且直接执行源代码的语言,就是脚本语言。\r\n5.  JS也是解释性的语言。何为解释性语言?是在运行的时候将程序直接翻译成机器的语言\r\n6.  JavaScript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言,可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。\r\n7.  HTML5的出现更是突出了JavaScript的重要性，例如HTML5的绘图支持、本地存储、离线应用、客户端通信等，都大量使用了JavaScript。\r\n\r\n* * *\r\n\r\n## 1.2 JavaScript历史\r\n\r\n*   网景公司在上个世纪的1995年，凭借其Navigator浏览器，成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在设计出了JavaScript语言。\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/97617638.jpg)\r\n\r\n*   为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。JavaScript\r\n\r\n[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")因为互联网而生，紧随着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。\r\n\r\n*   1990年底，欧洲核能研究组织（CERN）科学家Tim Berners-Lee（蒂姆 伯纳斯-李），互联网之父\r\n*   1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做Mosaic （马赛克） 。\r\n*   1994年10月，NCSA的一个主要程序员MarcAndreessen（马克 爱德森）联合风险投资家Jim Clark（ 吉姆·克拉克），成立了Mosaic通信公司（Mosaic Communications），不久后改名为网景Netscape。这家公司的方向，就是在Mosaic的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。\r\n*   1994年12月，Navigator发布了1.0版，市场份额一举超过90%。\r\n*   1995年，Netscape公司Brendan Eich开发这种网页脚本语言。1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版liveScript。它是一个大杂烩，语法有多个来源：\r\n\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('47', 'New node', '<h1 id=\"h1--javascript-\"><a name=\"一、JavaScript概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、JavaScript概述</h1><h2 id=\"h2-1-1-javascript-\"><a name=\"1.1 JavaScript是什么?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 JavaScript是什么?</h2><ol>\r\n<li>JavaScript主要用于HTML的页面，嵌入在HTML的源码中。</li><li>JavaScript是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。</li><li>JS是弱类型语言,没有类型声明,它的变量不必具有一个明确的类型。</li><li>JS是脚本语言，换句话说，可以用来编程的并且直接执行源代码的语言,就是脚本语言。</li><li>JS也是解释性的语言。何为解释性语言?是在运行的时候将程序直接翻译成机器的语言</li><li>JavaScript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言,可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。</li><li>HTML5的出现更是突出了JavaScript的重要性，例如HTML5的绘图支持、本地存储、离线应用、客户端通信等，都大量使用了JavaScript。</li></ol>\r\n<hr>\r\n<h2 id=\"h2-1-2-javascript-\"><a name=\"1.2 JavaScript历史\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 JavaScript历史</h2><ul>\r\n<li>网景公司在上个世纪的1995年，凭借其Navigator浏览器，成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在设计出了JavaScript语言。</li></ul>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/97617638.jpg\" alt=\"\"></p>\r\n<ul>\r\n<li>为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。JavaScript</li></ul>\r\n<p><a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>因为互联网而生，紧随着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。</p>\r\n<ul>\r\n<li>1990年底，欧洲核能研究组织（CERN）科学家Tim Berners-Lee（蒂姆 伯纳斯-李），互联网之父</li><li>1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做Mosaic （马赛克） 。</li><li>1994年10月，NCSA的一个主要程序员MarcAndreessen（马克 爱德森）联合风险投资家Jim Clark（ 吉姆·克拉克），成立了Mosaic通信公司（Mosaic Communications），不久后改名为网景Netscape。这家公司的方向，就是在Mosaic的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。</li><li>1994年12月，Navigator发布了1.0版，市场份额一举超过90%。</li><li>1995年，Netscape公司Brendan Eich开发这种网页脚本语言。1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版liveScript。它是一个大杂烩，语法有多个来源：</li></ul>\r\n<pre><code>基本语法：借鉴C语言和Java语言。\r\n数据结构：借鉴Java语言，包括将值分成原始值和对象两大类。\r\n函数的用法：借鉴Scheme语言和Awk语言，将函数当作第一等公民，并引入闭包。\r\n原型继承模型：借鉴Self语言（Smalltalk的一种变种）。\r\n正则表达式：借鉴Perl语言。\r\n字符串和数组处理：借鉴Python语言。\r\n</code></pre><ul>\r\n<li>1995年12月4日，Netscape公司与Sun公司联合发布了JavaScript语言。</li><li>1996年3月，Navigator 2.0浏览器正式内置了JavaScript脚本语言。</li><li>1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape的注册商标，微软不能用），首先内置于IE 3.0。Netscape公司面临丧失浏览器脚本语言的主导权的局面。</li><li>1997年 IE4与nn4平分天下。网景公司将javaScript交给ECMA(European Computer Manufacturers Association)组织，<strong>以此</strong>来抵制微软的垄断。</li><li>1998年 ECMAScript 2.0</li><li>1999年 ECMAScript 3.0</li><li>2008年 ECMAScript4.0应为升级太大，废弃</li><li>2009年 ECMASript5.0发布</li><li>2011年ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持ECMAScript 5.1版的全部功能。</li><li>2015年 ECMAScript6.0 改名为 ECMAScript2015</li></ul>\r\n<hr>\r\n<h2 id=\"h2-1-3-javascript-\"><a name=\"1.3 JavaScript主要特点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 JavaScript主要特点</h2><p>1) <strong>简单性</strong>：它是基于<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>基本语句和控制流之上的简单而紧凑的设计，但是相比Java来说，它的变量类型是采用<strong>弱类型</strong>，未采用严格的数据类型。</p>\r\n<p>var</p>\r\n<p>2) <strong>安全性：</strong>_JS不允许访问本地硬盘，不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互，从而有效的防止数据的丢失。</p>\r\n<p>3) <strong>动态性：</strong> JS可以直接对用户或客户输入做出响应，无须经过Web程序。它对用户的响应采用以事件驱动的方式进行，即由某种操作动作引起相应的事件响应，如：点击鼠标、移动窗口、选择菜单等。</p>\r\n<p>4) <strong>跨平台性：</strong> JS依赖于浏览器本身，与操作环境无关。只要能运行浏览器的计算机，并安装了支持JS的浏览器就可以正确执行，从而实现了“编写一次，走遍天下”的梦想。</p>\r\n<p>facebook reactNative 用js去写<a href=\"http://lib.csdn.net/base/android\" title=\"Android知识库\">Android</a>和<a href=\"http://lib.csdn.net/base/ios\" title=\"iOS知识库\">iOS</a></p>\r\n<hr>\r\n<h2 id=\"h2-1-4-javascript-\"><a name=\"1.4 JavaScript理论体系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.4 JavaScript理论体系</h2><blockquote>\r\n<p>JavaScript主要有三部分组成：</p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/94447532.jpg\" alt=\"\"></p>\r\n<ol>\r\n<li><strong>ECMAScript</strong> 他是JavaScript的核心，描述了该语言的语法和基本对象。</li><li><strong>BOM(browerobject model 浏览器对象模型)。</strong> 描述了与浏览器进行交互的方法和接口。BOM提供了独立于内容而与浏览器窗口进行交互的对象，例如可以移动，调整浏览器大小的window对象，可以用于导航的location对象与history对象，可以获取浏览器，操作系统与用户屏幕信息的navigator与screen对象，可以使用document作为访问HTML文档的入口，管理框架的frames对象等。</li><li><strong>DOM(document object model 文档对象模型)。</strong> 通过 DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性，可以对其中的内容进行修改和删除，同时也可以创建新的元素。</li></ol>\r\n<hr>\r\n<h2 id=\"h2-1-5-javascript-\"><a name=\"1.5 JavaScript工作原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.5 JavaScript工作原理</h2><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/10837481.jpg\" alt=\"\"></p>\r\n<hr>\r\n<h2 id=\"h2-1-6-javascript-\"><a name=\"1.6 JavaScript常用开发工具\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.6 JavaScript常用开发工具</h2><ol>\r\n<li>记事本</li><li>EditPlus</li><li>Notepad++</li><li><strong>HBuilder</strong> ide 集成开发环境 免费 不难用</li><li><strong>WebStrom</strong> 用的最多 idea基础 收费</li><li><strong>Sublime</strong> emmet</li></ol>\r\n<hr>\r\n<h1 id=\"h1--javascript\"><a name=\"二、使用JavaScript\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、使用JavaScript</h1><h2 id=\"h2-2-1-html-javascript\"><a name=\"2.1 在HTML中使用JavaScript\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 在HTML中使用JavaScript</h2><blockquote>\r\n<p><strong>1、内部添加:</strong> 可以在HTML页面的任何地方添加script标签(只要浏览器可以读取到)，在标签内部添加我们的JS代码。例如：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //js代码\r\n&lt;/script&gt;\r\n\r\n说明：type属性是必选属性，用来指定脚本的类型。Type的值可选：text/javascript、application/javascript、text/vbscript、text/jscript、text/x-javascript。\r\n区别：\r\ntype=&quot;text/javascript&quot;，传统的写法，浏览器支持较好。\r\ntype=&quot;application/javascript&quot;,标准的写法，但不是每种浏览器都支持。\r\ntype=&quot;text/x-javascript&quot;：x前缀表示这是实验性的，不是标准的类型。 \r\n其中x就是experiment的简写，代表实验阶段。\r\n我们以后的代码统一用：type=&quot;text/javascript&quot;\r\n</code></pre><blockquote>\r\n<p>2、 <strong>链接外部js文件。</strong> 为了代码的复用和方便维护，实际开发中会把js代码放入单独的文件中，然后在HTML文件中用script标签链接引入。例如：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot;&gt;\r\n  //注意不要在script标签中再添加代码，即使添加了代码也不会执行\r\n&lt;/script&gt;\r\n说明：\r\nA：src表示要链接的文件的地址。这个地址可以是一个文件，也可以是一个url地址。\r\nB：引入外部js文件的时候，不要再在标签内添加js代码，即使添加了也不会执行。\r\nC：虽然这个时候不再script标签中添加js代码，但是也不能把script标签改成单标签。例如下面的形式是错误的。\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot; /&gt; &lt;!-- 把script写成这种但标签的方式是错误的 --&gt;\r\n</code></pre><blockquote>\r\n<p>3、<strong>在HTML标签中:</strong> 作为某个元素的事件属性值或者是超链接href属性值。</p>\r\n</blockquote>\r\n<pre><code>&lt;a href=&quot;javascript:alert(&#39;欢迎你!&#39;)&quot;&gt;点我啊&lt;/a&gt;\r\n&lt;input name=&quot;btn&quot; type=&quot;button&quot; value=&quot;弹出消息框&quot;  onclick=&quot;javascript:alert(&#39;欢迎你!&#39;);&quot;/&gt;\r\n</code></pre><h2 id=\"h2-2-2-javascript-\"><a name=\"2.2 JavaScript语法基本要求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 JavaScript语法基本要求</h2><ol>\r\n<li>JavaScript的执行顺序：按照HTML文件中出现的顺序依次执行</li><li><strong>JavaScript严格区分大小写，大小写敏感</strong> a A p P</li><li>JavaScript忽略空白符和换行符</li><li>JavaScript通过\\ 对代码进行折行操作</li><li><strong>JavaScript使用 ; 结束语句。分号 ; 可以省略，尽量不要省略。</strong></li><li>JavaScript可以使用{ }括成一个语句组，形成一个块block</li></ol>\r\n<h2 id=\"h2-2-3-javascript-api\"><a name=\"2.3 JavaScript中几个用于调试输出的常用API\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 JavaScript中几个用于调试输出的常用API</h2><blockquote>\r\n<p><strong>警告框：alert(xx);</strong></p>\r\n</blockquote>\r\n<ul>\r\n<li><p>警告框经常用于确保用户可以得到某些信息。</p>\r\n</li><li><p>警告框出现后，用户需要点击确定按钮才能继续进行操作。</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot; &gt;\r\nalert(&quot;你好&quot;);\r\n&lt;/script&gt;\r\n</code></pre></li></ul>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/61443439.jpg\" alt=\"\"></p>\r\n<blockquote>\r\n<p><strong>确认框：confirm(xx);</strong></p>\r\n</blockquote>\r\n<ul>\r\n<li>确认框用于使用户可以验证或者接受某些信息。</li><li>当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。</li><li>如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。</li></ul>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot; &gt;\r\n  confirm(&quot;你好&quot;);\r\n&lt;/script&gt;\r\n</code></pre><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/46300809.jpg\" alt=\"\"></p>\r\n<blockquote>\r\n<p><strong>输入框: prompt(xx,默认值);</strong></p>\r\n</blockquote>\r\n<ul>\r\n<li>提示框经常用于提示用户在进入页面前输入某个值。</li><li>当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。</li><li>如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。<br><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/535880.jpg\" alt=\"\"></li></ul>\r\n<blockquote>\r\n<p><strong>向控制台输出结果:console.log(“xxx”)</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot; &gt;\r\n    console.log(&quot;正在向控制台打印数据: 哈哈哈&quot;);\r\n&lt;/script&gt;\r\n</code></pre><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/91222691.jpg\" alt=\"\"></p>\r\n<blockquote>\r\n<p>直接写入到HTML页面中</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-4-javascript-\"><a name=\"2.4 JavaScript注释\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 JavaScript注释</h2><blockquote>\r\n<p>JavaScript共提供了2中注释：单行注释和多行注释。</p>\r\n</blockquote>\r\n<ol>\r\n<li>单行注释。 //这里是注释，只能写一行</li><li>多行注释。 /<em> 这里的注释可以写多行 </em>/</li></ol>\r\n<h1 id=\"h1--\"><a name=\"三、关键字和保留字\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、关键字和保留字</h1><blockquote>\r\n<p>1、关键字: 在js中具有特殊含义的单词。 <strong>所有的关键字都是小写字母</strong></p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/54738751.jpg\" alt=\"\"></p>\r\n<blockquote>\r\n<p>2、保留字: 现在 js 还没有使用，但是留着以后扩展用。</p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/91792941.jpg\" alt=\"\"><br><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-2/36814468.jpg\" alt=\"\"></p>\r\n<h1 id=\"h1--\"><a name=\"四、标识符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、标识符</h1><blockquote>\r\n<p>所谓 标识符，就是指变量、函数、属性的名字，或者函数的参数名字。</p>\r\n</blockquote>\r\n<p><strong>规则:</strong></p>\r\n<ol>\r\n<li><p>第一个字母必须是字母、下划线(_)、美元符号($)</p>\r\n</li><li><p>其他字母可以是数字、字母、下划线和美元符号</p>\r\n</li><li><p>JavaScript是区分大小写的。即 a和A是完全两个不同的标示符。</p>\r\n</li><li><p>不能是关键字和保留子。</p>\r\n</li><li><p>作为惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写，</p>\r\n<p>例如：</p>\r\n</li></ol>\r\n<pre><code>firstSecond   myCar doSomethingImportant\r\n注意：构造函数的首字母一般使用大写字母开头。\r\n\r\n1. 只用用数字、字母、下划线、$\r\n2. 不能使用数字开头\r\n3. 区分大小写\r\n4. 不能用关键字\r\n5. 驼峰命名法\r\n</code></pre><h1 id=\"h1--\"><a name=\"五、变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、变量</h1><h2 id=\"h2-5-1-\"><a name=\"5.1 概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 概念</h2><blockquote>\r\n<p>JavaScript的变量用于保存<strong>值或表达式</strong> ，顾名思义,变量就是它的值是可以改变。</p>\r\n</blockquote>\r\n<h2 id=\"h2-5-2-\"><a name=\"5.2 声明变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 声明变量</h2><blockquote>\r\n<p>? JavaScript中变量是弱类型或者松散类型，所谓松散类型是指在同一个变量中可以存储任何类型的数据。换句话说，一个变量仅仅是一个占位符而已，为了后面的代码访问比较方便。</p>\r\n<p>? JavaScript的变量声明统一用var关键字来声明。例如：</p>\r\n</blockquote>\r\n<pre><code>var num; //声明了一个变量，这个变量的名字叫num。\r\n</code></pre><h2 id=\"h2-5-3-\"><a name=\"5.3 给变量赋值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 给变量赋值</h2><pre><code>var num;\r\nnum = 5;  //把数字5赋值给变量num。  注意：这里的 = 不是等，应该这样读：把5赋值给变量num，不应该读做num等5。\r\n</code></pre><h2 id=\"h2-5-4-\"><a name=\"5.4 声明变量的同时进行赋值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.4 声明变量的同时进行赋值</h2><pre><code>var num = 5; //声明一个变量num，同时给这个变量赋值为5。\r\n</code></pre><h2 id=\"h2-5-5-\"><a name=\"5.5 声明变量的一些注意点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.5 声明变量的一些注意点</h2><blockquote>\r\n<p>同一个变量，可以声明多次，而且后面的声明也不会让前面已经赋的值丢失。例如：</p>\r\n</blockquote>\r\n<pre><code>var num = 10;\r\nvar num; //重写定义，没有任何的副作用，不会导致前面的值丢失。\r\nalert(num);  //弹出：10\r\nnum = 20; //把变量num的值再次赋值为20，则会覆盖原来的值。这是变量最大的特点：变\r\nalert(num);  //所以此处弹出20\r\n</code></pre><blockquote>\r\n<p>可以在同一行同时声明多个变量，即: 使用一个var声明多个变量，这多个变量之间用<strong>逗号(英文下 , )</strong>隔开。当然声明的时候可以根据需要对变量进行赋值初始化。例如：</p>\r\n</blockquote>\r\n<pre><code>var num1, num2, mun3 = 40, num4; //使用var关键字同时声明4个变量，而且num3的值初始化为40。\r\n</code></pre><h2 id=\"h2-5-5-\"><a name=\"5.5 变量的命名规范\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.5 变量的命名规范</h2><blockquote>\r\n<p>同前面介绍。</p>\r\n</blockquote>\r\n<p></div></p>\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>', '63', '\r\n\r\n# 一、JavaScript概述\r\n\r\n## 1.1 JavaScript是什么?\r\n\r\n1.  JavaScript主要用于HTML的页面，嵌入在HTML的源码中。\r\n2.  JavaScript是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。\r\n3.  JS是弱类型语言,没有类型声明,它的变量不必具有一个明确的类型。\r\n4.  JS是脚本语言，换句话说，可以用来编程的并且直接执行源代码的语言,就是脚本语言。\r\n5.  JS也是解释性的语言。何为解释性语言?是在运行的时候将程序直接翻译成机器的语言\r\n6.  JavaScript是一种基于对象(Object)和事件驱动(Event Driven)并具有安全性能的脚本语言,可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。\r\n7.  HTML5的出现更是突出了JavaScript的重要性，例如HTML5的绘图支持、本地存储、离线应用、客户端通信等，都大量使用了JavaScript。\r\n\r\n* * *\r\n\r\n## 1.2 JavaScript历史\r\n\r\n*   网景公司在上个世纪的1995年，凭借其Navigator浏览器，成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在设计出了JavaScript语言。\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/97617638.jpg)\r\n\r\n*   为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。JavaScript\r\n\r\n[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")因为互联网而生，紧随着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。\r\n\r\n*   1990年底，欧洲核能研究组织（CERN）科学家Tim Berners-Lee（蒂姆 伯纳斯-李），互联网之父\r\n*   1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做Mosaic （马赛克） 。\r\n*   1994年10月，NCSA的一个主要程序员MarcAndreessen（马克 爱德森）联合风险投资家Jim Clark（ 吉姆·克拉克），成立了Mosaic通信公司（Mosaic Communications），不久后改名为网景Netscape。这家公司的方向，就是在Mosaic的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。\r\n*   1994年12月，Navigator发布了1.0版，市场份额一举超过90%。\r\n*   1995年，Netscape公司Brendan Eich开发这种网页脚本语言。1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版liveScript。它是一个大杂烩，语法有多个来源：\r\n\r\n```\r\n基本语法：借鉴C语言和Java语言。\r\n数据结构：借鉴Java语言，包括将值分成原始值和对象两大类。\r\n函数的用法：借鉴Scheme语言和Awk语言，将函数当作第一等公民，并引入闭包。\r\n原型继承模型：借鉴Self语言（Smalltalk的一种变种）。\r\n正则表达式：借鉴Perl语言。\r\n字符串和数组处理：借鉴Python语言。\r\n```\r\n\r\n*   1995年12月4日，Netscape公司与Sun公司联合发布了JavaScript语言。\r\n*   1996年3月，Navigator 2.0浏览器正式内置了JavaScript脚本语言。\r\n*   1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape的注册商标，微软不能用），首先内置于IE 3.0。Netscape公司面临丧失浏览器脚本语言的主导权的局面。\r\n*   1997年 IE4与nn4平分天下。网景公司将javaScript交给ECMA(European Computer Manufacturers Association)组织，**以此**来抵制微软的垄断。\r\n*   1998年 ECMAScript 2.0\r\n*   1999年 ECMAScript 3.0\r\n*   2008年 ECMAScript4.0应为升级太大，废弃\r\n*   2009年 ECMASript5.0发布\r\n*   2011年ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持ECMAScript 5.1版的全部功能。\r\n*   2015年 ECMAScript6.0 改名为 ECMAScript2015\r\n\r\n* * *\r\n\r\n## 1.3 JavaScript主要特点\r\n\r\n1) **简单性**：它是基于[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")基本语句和控制流之上的简单而紧凑的设计，但是相比Java来说，它的变量类型是采用**弱类型**，未采用严格的数据类型。\r\n\r\nvar\r\n\r\n2) **安全性：**_JS不允许访问本地硬盘，不能将数据存入到服务器上，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互，从而有效的防止数据的丢失。\r\n\r\n3) **动态性：** JS可以直接对用户或客户输入做出响应，无须经过Web程序。它对用户的响应采用以事件驱动的方式进行，即由某种操作动作引起相应的事件响应，如：点击鼠标、移动窗口、选择菜单等。\r\n\r\n4) **跨平台性：** JS依赖于浏览器本身，与操作环境无关。只要能运行浏览器的计算机，并安装了支持JS的浏览器就可以正确执行，从而实现了“编写一次，走遍天下”的梦想。\r\n\r\nfacebook reactNative 用js去写[Android](http://lib.csdn.net/base/android \"Android知识库\")和[iOS](http://lib.csdn.net/base/ios \"iOS知识库\")\r\n\r\n* * *\r\n\r\n## 1.4 JavaScript理论体系\r\n\r\n> JavaScript主要有三部分组成：\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/94447532.jpg)\r\n\r\n1.  **ECMAScript** 他是JavaScript的核心，描述了该语言的语法和基本对象。\r\n2.  **BOM(browerobject model 浏览器对象模型)。** 描述了与浏览器进行交互的方法和接口。BOM提供了独立于内容而与浏览器窗口进行交互的对象，例如可以移动，调整浏览器大小的window对象，可以用于导航的location对象与history对象，可以获取浏览器，操作系统与用户屏幕信息的navigator与screen对象，可以使用document作为访问HTML文档的入口，管理框架的frames对象等。\r\n3.  **DOM(document object model 文档对象模型)。** 通过 DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性，可以对其中的内容进行修改和删除，同时也可以创建新的元素。\r\n\r\n* * *\r\n\r\n## 1.5 JavaScript工作原理\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/10837481.jpg)\r\n\r\n* * *\r\n\r\n## 1.6 JavaScript常用开发工具\r\n\r\n1.  记事本\r\n2.  EditPlus\r\n3.  Notepad++\r\n4.  **HBuilder** ide 集成开发环境 免费 不难用\r\n5.  **WebStrom** 用的最多 idea基础 收费\r\n6.  **Sublime** emmet\r\n\r\n* * *\r\n\r\n# 二、使用JavaScript\r\n\r\n## 2.1 在HTML中使用JavaScript\r\n\r\n> **1、内部添加:** 可以在HTML页面的任何地方添加script标签(只要浏览器可以读取到)，在标签内部添加我们的JS代码。例如：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //js代码\r\n</script>\r\n\r\n说明：type属性是必选属性，用来指定脚本的类型。Type的值可选：text/javascript、application/javascript、text/vbscript、text/jscript、text/x-javascript。\r\n区别：\r\ntype=\"text/javascript\"，传统的写法，浏览器支持较好。\r\ntype=\"application/javascript\",标准的写法，但不是每种浏览器都支持。\r\ntype=\"text/x-javascript\"：x前缀表示这是实验性的，不是标准的类型。 \r\n其中x就是experiment的简写，代表实验阶段。\r\n我们以后的代码统一用：type=\"text/javascript\"\r\n```\r\n\r\n> 2、 **链接外部js文件。** 为了代码的复用和方便维护，实际开发中会把js代码放入单独的文件中，然后在HTML文件中用script标签链接引入。例如：\r\n\r\n```\r\n<script type=\"text/javascript\" src=\"a.js\">\r\n  //注意不要在script标签中再添加代码，即使添加了代码也不会执行\r\n</script>\r\n说明：\r\nA：src表示要链接的文件的地址。这个地址可以是一个文件，也可以是一个url地址。\r\nB：引入外部js文件的时候，不要再在标签内添加js代码，即使添加了也不会执行。\r\nC：虽然这个时候不再script标签中添加js代码，但是也不能把script标签改成单标签。例如下面的形式是错误的。\r\n<script type=\"text/javascript\" src=\"a.js\" /> <!-- 把script写成这种但标签的方式是错误的 -->\r\n```\r\n\r\n> 3、**在HTML标签中:** 作为某个元素的事件属性值或者是超链接href属性值。\r\n\r\n```\r\n<a href=\"javascript:alert(\'欢迎你!\')\">点我啊</a>\r\n<input name=\"btn\" type=\"button\" value=\"弹出消息框\"  onclick=\"javascript:alert(\'欢迎你!\');\"/>\r\n```\r\n\r\n## 2.2 JavaScript语法基本要求\r\n\r\n1.  JavaScript的执行顺序：按照HTML文件中出现的顺序依次执行\r\n2.  **JavaScript严格区分大小写，大小写敏感** a A p P\r\n3.  JavaScript忽略空白符和换行符\r\n4.  JavaScript通过\\ 对代码进行折行操作\r\n5.  **JavaScript使用 ; 结束语句。分号 ; 可以省略，尽量不要省略。**\r\n6.  JavaScript可以使用{ }括成一个语句组，形成一个块block\r\n\r\n## 2.3 JavaScript中几个用于调试输出的常用API\r\n\r\n> **警告框：alert(xx);**\r\n\r\n*   警告框经常用于确保用户可以得到某些信息。\r\n\r\n*   警告框出现后，用户需要点击确定按钮才能继续进行操作。\r\n\r\n    ```\r\n    <script type=\"text/javascript\" >\r\n    alert(\"你好\");\r\n    </script>\r\n    ```\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/61443439.jpg)\r\n\r\n> **确认框：confirm(xx);**\r\n\r\n*   确认框用于使用户可以验证或者接受某些信息。\r\n*   当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作。\r\n*   如果用户点击确认，那么返回值为 true。如果用户点击取消，那么返回值为 false。\r\n\r\n```\r\n<script type=\"text/javascript\" >\r\n  confirm(\"你好\");\r\n</script>\r\n```\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/46300809.jpg)\r\n\r\n> **输入框: prompt(xx,默认值);**\r\n\r\n*   提示框经常用于提示用户在进入页面前输入某个值。\r\n*   当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。\r\n*   如果用户点击确认，那么返回值为输入的值。如果用户点击取消，那么返回值为 null。\r\n    ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/535880.jpg)\r\n\r\n> **向控制台输出结果:console.log(“xxx”)**\r\n\r\n```\r\n<script type=\"text/javascript\" >\r\n    console.log(\"正在向控制台打印数据: 哈哈哈\");\r\n</script>\r\n```\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/91222691.jpg)\r\n\r\n> 直接写入到HTML页面中\r\n\r\n## 2.4 JavaScript注释\r\n\r\n> JavaScript共提供了2中注释：单行注释和多行注释。\r\n\r\n1.  单行注释。 //这里是注释，只能写一行\r\n2.  多行注释。 /* 这里的注释可以写多行 */\r\n\r\n# 三、关键字和保留字\r\n\r\n> 1、关键字: 在js中具有特殊含义的单词。 **所有的关键字都是小写字母**\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/54738751.jpg)\r\n\r\n> 2、保留字: 现在 js 还没有使用，但是留着以后扩展用。\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/91792941.jpg)\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-2/36814468.jpg)\r\n\r\n# 四、标识符\r\n\r\n> 所谓 标识符，就是指变量、函数、属性的名字，或者函数的参数名字。\r\n\r\n**规则:**\r\n\r\n1.  第一个字母必须是字母、下划线(_)、美元符号($)\r\n\r\n2.  其他字母可以是数字、字母、下划线和美元符号\r\n\r\n3.  JavaScript是区分大小写的。即 a和A是完全两个不同的标示符。\r\n\r\n4.  不能是关键字和保留子。\r\n\r\n5.  作为惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写，\r\n\r\n    例如：\r\n\r\n```\r\nfirstSecond   myCar doSomethingImportant\r\n注意：构造函数的首字母一般使用大写字母开头。\r\n\r\n1. 只用用数字、字母、下划线、$\r\n2. 不能使用数字开头\r\n3. 区分大小写\r\n4. 不能用关键字\r\n5. 驼峰命名法\r\n\r\n```\r\n\r\n# 五、变量\r\n\r\n## 5.1 概念\r\n\r\n> JavaScript的变量用于保存**值或表达式** ，顾名思义,变量就是它的值是可以改变。\r\n\r\n## 5.2 声明变量\r\n\r\n> ? JavaScript中变量是弱类型或者松散类型，所谓松散类型是指在同一个变量中可以存储任何类型的数据。换句话说，一个变量仅仅是一个占位符而已，为了后面的代码访问比较方便。\r\n> \r\n> ? JavaScript的变量声明统一用var关键字来声明。例如：\r\n\r\n```\r\nvar num; //声明了一个变量，这个变量的名字叫num。\r\n```\r\n\r\n## 5.3 给变量赋值\r\n\r\n```\r\nvar num;\r\nnum = 5;  //把数字5赋值给变量num。  注意：这里的 = 不是等，应该这样读：把5赋值给变量num，不应该读做num等5。\r\n```\r\n\r\n## 5.4 声明变量的同时进行赋值\r\n\r\n```\r\nvar num = 5; //声明一个变量num，同时给这个变量赋值为5。\r\n```\r\n\r\n## 5.5 声明变量的一些注意点\r\n\r\n> 同一个变量，可以声明多次，而且后面的声明也不会让前面已经赋的值丢失。例如：\r\n\r\n```\r\nvar num = 10;\r\nvar num; //重写定义，没有任何的副作用，不会导致前面的值丢失。\r\nalert(num);  //弹出：10\r\nnum = 20; //把变量num的值再次赋值为20，则会覆盖原来的值。这是变量最大的特点：变\r\nalert(num);  //所以此处弹出20\r\n```\r\n\r\n> 可以在同一行同时声明多个变量，即: 使用一个var声明多个变量，这多个变量之间用**逗号(英文下 , )**隔开。当然声明的时候可以根据需要对变量进行赋值初始化。例如：\r\n\r\n```\r\nvar num1, num2, mun3 = 40, num4; //使用var关键字同时声明4个变量，而且num3的值初始化为40。\r\n\r\n```\r\n\r\n## 5.5 变量的命名规范\r\n\r\n> 同前面介绍。\r\n\r\n</div>\r\n\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>');
INSERT INTO `article_info_true` VALUES ('48', 'js数据类型和运算符', '<h1 id=\"h1--\"><a name=\"一、数据类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、数据类型</h1><blockquote>\r\n<p><a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>的数据类型共分两类：<strong>简单数据类型</strong> (也称原始数据类型或基本数据类型)和<strong>复杂数据类型</strong>(也称引用数据类型或对象类型)。</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-1-\"><a name=\"2.1 简单数据类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 简单数据类型</h2><blockquote>\r\n<p>简单数据类型共分5种：<strong>Number、Boolean、String、Null、Undefined</strong> (ECMAScript6新增：Symbol)</p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">数据类型</th>\r\n<th style=\"text-align:left\">数据值</th>\r\n<th style=\"text-align:left\">说明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\">Undefined</td>\r\n<td style=\"text-align:left\">undefined</td>\r\n<td style=\"text-align:left\">当声明一个变量但是并没有赋值时，变量的类型是Undefine类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">Null</td>\r\n<td style=\"text-align:left\">null</td>\r\n<td style=\"text-align:left\">对象指针为空</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">Boolean</td>\r\n<td style=\"text-align:left\">true false</td>\r\n<td style=\"text-align:left\">true\\false两个值都必须小写</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">Number</td>\r\n<td style=\"text-align:left\">10 3.14 3. .5 整数与浮点数</td>\r\n<td style=\"text-align:left\">NaN —- not a number本应该返回数值型数据的函数，如果返回的值不是数值型测返回NaN isNaN()—不是数字返回true 是数字返回false</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">String</td>\r\n<td style=\"text-align:left\">“Hello” ‘Hello’ “a” ’a’</td>\r\n<td style=\"text-align:left\">后续学习</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">Object</td>\r\n<td style=\"text-align:left\">对象</td>\r\n<td style=\"text-align:left\">后续学习</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"h3-2-1-1-number-\"><a name=\"2.1.1 Number类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.1 Number类型</h3><blockquote>\r\n<p>数值类型共分4种值：<strong>整数、浮点数、无穷大、NaN</strong>。<br>对数值来说，最常见的数值字面量是10进制。比如：20, 30, 5.5 这些值都是用10进制表示的。</p>\r\n</blockquote>\r\n<ol>\r\n<li><strong>整数:</strong> 对整数来说，还可以使用8进制和16进制的整数来表示。8进制的范围是(0-7)， 16进制的范围是(0-F)。例如：</li></ol>\r\n<pre><code>var num = 25;  // 10进制的25\r\nalert(num); //弹出：25\r\nvar num1 = 025; // 8进制用0开始。表示一个8进制的25。\r\nalert(num1);   // 弹出：21 注意：弹出显示的时候，总是用10进制的形式。\r\nvar num2 = 0x25; // 0x开始表示这个数是16进制。这是个16进制中的25。 注意：这里的x可以大写X也可以小写x\r\nalert(num2);    //弹出：37\r\nvar num3 = 0XAF;\r\nalert(num3);  //弹出：175\r\n\r\n注意：如果8进制数字超出了进制范围(比如出现8、9)，则自动忽略前导0，把这个数字作为十进制的数字类处理。例如：\r\nvar num4 = 089;\r\nalert(num4);  //弹出：89。 并不会出现错误\r\n</code></pre><ol>\r\n<li><strong>浮点数:</strong> 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。浮点数直接量一般有两种写法：<strong>直接带小数点的</strong>和<strong>使用科学计数法。</strong></li></ol>\r\n<pre><code>var f1 = 3.14;   // 带小数点的直接量写法\r\nvar f2 = 3.158899e5; //科学计数法：  表示 3.158899 * 10^5\r\n</code></pre><ol>\r\n<li><strong>无穷大(Infinity):</strong> ECMAScript并不能储存所有的数，所以能表示的数有个范围。所能表示的数最大值和最小值都保存在Number这个内置对象中(后面会详细介绍什么是对象。)</li></ol>\r\n<pre><code>alert(Number.MAX_VALUE);\r\nalert(Number.MIN_VALUE);\r\n//如果数值超出了最大值和最小值，则用Infinity和-Infinity表示。\r\nalert(1.1 / 0); //弹出：Infinity\r\nalert(-1.1 / 0);    //弹出：-Infinity\r\n</code></pre><ol>\r\n<li><strong>NaN( not a number 不是个数):</strong> 表示不是一个数字，当0/0 的时候不是无穷大，而是NaN。或者把一个非数字形式的字符串转换成数字时都会返回NaN。例如：</li></ol>\r\n<pre><code>alert(0 / 0);  //弹出：NaN\r\nalert(parseInt(&quot;60&quot;));  //弹出：60 说明：parseInt(&quot;&quot;);可以把字符串形式的数字转换成Number\r\nalert(parseInt(&quot;a&quot;));   //弹出：NaN\r\n\r\n//注意：NaN是个非常特别的东东。因为即使他自己和自己都不相等。\r\nvar v = 0 / 0;\r\nalert(v == v);  //弹出false\r\nalert(v != v);  //弹出true。  所以：可以通过这种方式来判断这个数是否为NaN\r\n\r\n/*\r\n  另外：isNaN()函数如果 x 是特殊的非数字值 NaN（或者能被转换为这样的值），返回的值就是 true。如果 x 是其他值,\r\n  则 返回 false。\r\n*/\r\nalert(isNaN(3));//返回false\r\nalert(isNaN(&quot;3&quot;));   //返回false\r\nalert(isNaN(&quot;blue&quot;));//返回true\r\nalert(isNaN(true));//返回false . true可以转换成数字1\r\nalert(isNaN(null));//返回false    null可以转换为数字0\r\nalert(isNaN(undefined));//返回true\r\n</code></pre><h3 id=\"h3-2-1-2-boolean-\"><a name=\"2.1.2 Boolean类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.2 Boolean类型</h3><blockquote>\r\n<p>Boolean类型的值是程序中用的很多的一种类型。它只有两个值：true和false。true表示逻辑上的<strong>对/正确</strong>，false表示逻辑上的<strong>错</strong>。</p>\r\n</blockquote>\r\n<h3 id=\"h3-2-1-3-string-\"><a name=\"2.1.3 String类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.3 String类型</h3><blockquote>\r\n<p>String指的是用 <strong>“”(双引号)</strong> 或 <strong>”(单引号)</strong> 括起来的字符序列。字符序列可以由0个或多个字符组成。<br>例如：”123” “a” ‘name’ ‘blue’ ’nihao’ ’xiaohong‘ ”nihao”。</p>\r\n<p>说明：</p>\r\n<p>1、单引号或双引号要匹配，不能一边用双引号，一边用单引号 ，左右符号要匹配。</p>\r\n<p>2、JavaScript统一每个字符使用Unitcode码来进行编码，每个字符占16位(2个字节)。</p>\r\n<p>3. 在其他语言中多用单引号表示一个字符，双引号表示字节。但是对JavaScript来说，不存在字符类型的数据。</p>\r\n<p>4. 有些字符不可见或有特殊意义，比如换行符，制表符, 双引号等，则 JavaScript 提供了相应的<strong>转意字符</strong>，来表示这些不可见字符。见下表：</p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">代码</th>\r\n<th style=\"text-align:center\">输出</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\"><strong>\\’</strong></td>\r\n<td style=\"text-align:center\"><strong>单引号</strong></td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\"><strong>\\”</strong></td>\r\n<td style=\"text-align:center\"><strong>双引号</strong></td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">\\&amp;</td>\r\n<td style=\"text-align:center\">和号</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">\\</td>\r\n<td style=\"text-align:center\">反斜杠</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\"><strong>\\n</strong></td>\r\n<td style=\"text-align:center\"><strong>换行符</strong></td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">\\r</td>\r\n<td style=\"text-align:center\">回车符</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\"><strong>\\t</strong></td>\r\n<td style=\"text-align:center\"><strong>制表符</strong></td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">\\b</td>\r\n<td style=\"text-align:center\">退格符</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">\\f</td>\r\n<td style=\"text-align:center\">换页符</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"h3-2-1-4-undefined\"><a name=\"2.1.4 Undefined\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.4 Undefined</h3><blockquote>\r\n<p>Undefined 类型只有一个值，即特殊的 undefined 。在使用 var 声明变量但未对其加以初始化时，<br>这个变量的值就是 undefined ，例如：</p>\r\n</blockquote>\r\n<pre><code>var v;\r\nalert(v); //弹出：undefined。  变量v声明但是没有赋值初始化，则为undefined\r\nalert(m);  //m没有定义，直接使用会发生错误。\r\n</code></pre><h3 id=\"h3-2-1-5-null\"><a name=\"2.1.5 Null\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.5 Null</h3><blockquote>\r\n<ol>\r\n<li>Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null ( n是小写)。从逻辑角度来看， null 值表</li></ol>\r\n<p>示一个空对象指针。</p>\r\n<ol>\r\n<li>值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。</li></ol>\r\n<p><em>说明：</em></p>\r\n<p><em>尽管这两个值相等，但它们的含义不同。</em><br><em>undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象。</em><br><em>如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是null。</em></p>\r\n</blockquote>\r\n<pre><code>alert(null == undefined); // 弹出： true。  待讲完面向对象在来理解会更加清晰。大家目前只需要了解即可。\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 复杂数据类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 复杂数据类型</h2><blockquote>\r\n<p>复杂数据类型又称之为引用数据类型。主要包括三种：<strong>对象(object)、函数(function)和数组(array)</strong>。</p>\r\n<p>不过，从本质来看，这三种都属于对象。</p>\r\n<p>关于复杂数据类型，我们在面向对象部分重点详细介绍。</p>\r\n</blockquote>\r\n<h1 id=\"h1--\"><a name=\"二、数据类型转换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、数据类型转换</h1><blockquote>\r\n<p>数据类型转换有两种转换：自动转换和强制转换。</p>\r\n</blockquote>\r\n<h3 id=\"h3-1-\"><a name=\"1. 自动类型转换：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 自动类型转换：</h3><blockquote>\r\n<p>在解释执行的过程中，会根据需要进行相应的自动类型转换。比如：需要一个Boolean类型的值，而现在是一个字符串，则会根据相应的规则把字符串自动转换为Boolean值。</p>\r\n</blockquote>\r\n<pre><code>1、转换成布尔类型\r\nundefined —&gt; false\r\nnull —&gt; false\r\n数值       0,0.0,NaN —&gt; false   其他数值—&gt; true\r\n字符串    &quot;&quot;—&gt;false    &quot;etef&quot; —&gt; true\r\n其他对象—&gt; true\r\n总结：存在的东东，转换成true， 不存在的东东转换成flase\r\n\r\n2、转换成数值类型\r\nundefined —&gt; NaN\r\nnull —&gt; 0\r\n字符串——&gt;数值—&gt;     &quot;34234&quot;—&gt;34234,  &quot;324sdfs3423&quot; —&gt; NaN,  &quot;&quot; —&gt; 0\r\n布尔类型——&gt;数值    true-&gt;1   false-&gt;0\r\n总结：能转成数字的就转成对应的数字。不能转成数字的要么0或1要么NaN\r\n\r\n3、转换成字符串类型\r\nundefined —&gt;&quot;undefined&quot;\r\nnull —&gt;&quot;null&quot;\r\n布尔类型     true —&gt;”true”     false —&gt;&quot;false&quot;\r\n数值类型转成字符串    12321 —&gt;&quot;12321&quot;   NaN —&gt;&quot;NaN&quot;\r\n总结：字面值是什么就转成什么\r\n</code></pre><h3 id=\"h3-2-\"><a name=\"2. 强制类型转换。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 强制类型转换。</h3><pre><code>//1、其他类型转成成字符串。\r\nvar a = 10;\r\nalert(a + &quot;&quot;);  // 直接和一个长度为0的空字符链接\r\nalert(a.toString()); //调用这个变量的toString()方法\r\nalert(String(a));  //使用String转型函数\r\n//2、字符串转数字。\r\nvar s = &quot;123&quot;;\r\nalert(parseInt(s));\r\nalert(parseFloat(s));\r\n/*\r\n    注意：使用parseXxx转换\r\n    1、转换为数字的时候，会忽略前面的空格\r\n    2、如果是数组开头然后是字母，则会只转前面的数字\r\n    3、如果是是字母开头则返回NaN\r\n    4、在使用parseInt的时候，可以传入第二个参数，表示这个数的进制，然后就转换成对应的10进制数返回。\r\n*/\r\nalert(parseInt(&quot;  12&quot;));  //忽略前面的空白字符\r\nalert(ParseInt(&quot;12ab3&quot;);  //弹出：12\\.  从字母后面的统统忽略掉\r\nalert(parseInt(&quot;a123&quot;));  // 弹出：NaN\r\n\r\n//3、使用转型函数互转(暂时先了解)  var为一个变量或常量都可以\r\nString(var);//其他类型转字符串\r\nNumber(var);  //其他类型转数字\r\nBoolean(var);  // 其他类型转布尔\r\n</code></pre><h1 id=\"h1--\"><a name=\"三、表达式和运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、表达式和运算符</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 表达式</h2><blockquote>\r\n<p>表达式是用于JavaScript脚本运行时进行计算的式子，可以包含<strong>常量、变量、运算符</strong>。表达式可以任意复杂。 表达式的值就是经过一系列运算之后的最终值。</p>\r\n</blockquote>\r\n<pre><code>var n = 10;\r\nvar m = 30;\r\nalert(n + m);  // n+m就是一个表达式。\r\n</code></pre><h2 id=\"h2-3-2-\"><a name=\"3.2 运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 运算符</h2><blockquote>\r\n<p>运算符也叫操作符。作用是去操作数据值，然后进行各种计算。<strong>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。(不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或） toString() 方法，以便取得可以操作的值。 <em>暂时了解</em> )</strong></p>\r\n</blockquote>\r\n<h3 id=\"h3-3-2-1-\"><a name=\"3.2.1 算术运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.1 算术运算符</h3><blockquote>\r\n<p>+、-、*、/、%。</p>\r\n<p>这几个运算符都需要两个数据参与运算。</p>\r\n</blockquote>\r\n<ol>\r\n<li><p><strong>+</strong> 运算<strong>符：运算规则</strong></p>\r\n<ul>\r\n<li><p>如果两个都是Number则，则就按照普通的数学加法运算。</p>\r\n</li><li><p>如果有一个是字符串，就按照字符串的串联的方式连接。(如果另外一个不是字符串，则先转换成字符串再连)。</p>\r\n</li><li><p>如果有一个是NaN，则结果就是NaN。</p>\r\n</li><li>如果同时是Infinity或-Infinity，则结果就是Infinity或-Infinity。</li><li>如果一个是Infinity另外一个是-Infinity，则结果为NaN。</li></ul>\r\n</li><li><p><strong>- 运算符：运算符规则</strong></p>\r\n<ul>\r\n<li>如果两个都是Number则，则就按照普通的数学减法运算。</li><li>如果有一个操作数是字符串、布尔值、null 或undefined，则先在后台调用Number()转型函数将其转换为数值，然后再根据正常减法计算。如果转换的结果有一个是NaN,则减法的结果就是NaN</li><li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值<strong>(了解)</strong></li></ul>\r\n</li><li><p><strong>* 运算符：运算符规则。</strong></p>\r\n<ul>\r\n<li>运算规则同减法。</li></ul>\r\n</li><li><p><strong>/ 运算符：运算规则</strong></p>\r\n<ul>\r\n<li>就是普通的除法运算，运算规则同 *</li></ul>\r\n</li><li><p><strong>%运算符：运算规则</strong></p>\r\n<ul>\r\n<li>求余(求模)运算。</li></ul>\r\n</li></ol>\r\n<pre><code>var v = 10 % 2;   // 余0\r\nalert(10 % 3); // 结果 ： 1\r\nalert(-10 % 3); // 结果： -1   说明：求余的时候，符号与被除数保持一致。\r\nalert(10 % -3); // 结果： 1\r\nalert(1 % 0.3);  // 结果：0.1\r\n</code></pre><h3 id=\"h3-3-2-2-\"><a name=\"3.2.2 一元运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.2 一元运算符</h3><ol>\r\n<li>++自增操作: 对要操作的变量进行+1的操作，并把+1之后的结果重写赋值给这个变量。可以在变量前也可以在变量后。任何变量都可以使用，但是对非Number类型的变量操作的时候，需要先按照前面的规则转换成Number然后再自增<strong>1.</strong></li></ol>\r\n<pre><code>var a = 10;\r\nvar b = a++;  //把a的值自增1，a的值变为11\\.  注意：a++表达式的值，仍然是a自增之前的值，所以b的值是是10\r\n\r\nvar c = 10;\r\nvar d = ++a;  //把a的值自增1，a的值变为11\\.  注意：++a表达式的值，是a自增之后的值，所以d的值是11\r\n\r\nvar m = &quot;123&quot;;\r\nm++;  //先把m使new Number(m)之后再转换进行自增的操作。\r\n</code></pre><ol>\r\n<li>–自减操作: 对要操作的变量进行减1的操作，并把-1之后的结果重新赋值给这个变量。 计算方法同++。</li></ol>\r\n<pre><code>var a = 10;\r\nvar b = a--;  //把a的值自减1，a的值变为9\\.  注意：a--表达式的值，仍然是a自减之前的值，所以b的值是是10\r\n\r\nvar c = 10;\r\nvar d = --a;  //把a的值自减1，a的值变为9\\.  注意：--a表达式的值，是a自减之后的值，所以d的值是9\r\n\r\nvar m = &quot;123&quot;;\r\nm--;  //先把m使用转型函数Number(m)之后再转换进行自减的操作。\r\n</code></pre><h3 id=\"h3-3-2-3-\"><a name=\"3.2.3 赋值运算符和复合赋值运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.3 赋值运算符和复合赋值运算符</h3><blockquote>\r\n<p>=、+=、-=、*=、/=、%=</p>\r\n<p><strong>使用赋值操作符的注意目的是简化表达式的书写，并不会带来任何的性能的提示。</strong></p>\r\n</blockquote>\r\n<pre><code>var n = 10;\r\nn += 4;  //等价于 n = n + 4;  运算结束后n的值为14\r\n\r\nvar m = &quot;6&quot;;\r\nm -= 5;   // 会先把m转换成数字之后(m = new Number(m))，再执行  m = m - 5;\r\n</code></pre><h3 id=\"h3-3-2-4-\"><a name=\"3.2.4 比较运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.4 比较运算符</h3><blockquote>\r\n<blockquote>\r\n<p>、&gt;=、&lt;、&lt;=、\\==、\\===、 !=、!\\==</p>\r\n</blockquote>\r\n<p>比较运算符是对运算符的坐标和右边的两个数据进行比较。</p>\r\n</blockquote>\r\n<ul>\r\n<li>如果两个都是数字，就是普通的数字比较。</li><li>如果有一个是数字，就把另外一个不是数字的使用new Number(var)的方式转换为数字再比较</li><li>如果两个都是字符串，则比较的是字符串中的字符在字母表中的顺序。(或者说比较是他们的编码值)</li><li>如果有一个是NaN，则结果一定是false。==但是有一种情况，如果比较特殊NaN != NaN则是true。==</li></ul>\r\n<blockquote>\r\n<p>==<strong>\\== 和 != 是判断两个操作数是否相等。规则：</strong>==</p>\r\n</blockquote>\r\n<ul>\r\n<li>如果两个都是简单类型中的Number类型，直接判断数值是否相等。</li></ul>\r\n<pre><code>alert(10 == 10.0);  //  true\r\n</code></pre><ul>\r\n<li>如果有一个NaN参与比较，则总是不等的。</li><li>null和undefined之间是相等</li><li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为 0，而<br>true 转换为 1；</li><li>如果一个字符串与数值比较，则把字符串转换成数值之后再比较</li><li>如果一个对象和一个基本类型比较，则调用对象的valueOf方法，转变成基本类型之后再比较(暂时先了解)</li><li>如果连个对象比较，则比较两个对象是否为同一个对象。是就相同，不是就不同。(暂时先了解)</li></ul>\r\n<pre><code>alert(NaN == false);  // fasle\r\nalert(NaN == true);  // false\r\nalert(NaN == 1); //false；\r\nalert(NaN == NaN); // fasle\r\nalert(NaN != NaN); // true\r\n\r\nalert(null == null); // true\r\nalert(null == undefined); // true\r\nalert(undefined == undefined); // true\r\n\r\nalert(&quot;1&quot; == 1); //true\r\nalert(&quot;1a&quot; == 1);  //false  “1a&quot;会被转换为NaN\r\n\r\nalert(1 == true); //true  会把true转成1之后再比较\r\nalert(0 == null);  //false  null与任何的非null的都不相等\r\n</code></pre><blockquote>\r\n<p>==<strong>\\=\\== !\\== 全等判断</strong>==</p>\r\n<p>全等在转换前不做任何的转换，如果两个一样就相等，否则就不等。</p>\r\n</blockquote>\r\n<pre><code>alert(&quot;1&quot; === 1);  //false 一个string类型，一个number类型，所以不等\r\nalert(null === undefined);  // false\r\nalert(&quot;abc&quot; === &quot;abc&quot;);  // true\r\n</code></pre><h3 id=\"h3-3-2-5-\"><a name=\"3.2.5 逻辑运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.5 逻辑运算符</h3><blockquote>\r\n<p>只有三种逻辑运算符：&amp;&amp;、||、! 。而且 &amp;&amp; 和|| 都是短路的形式。 <strong>注意：不像其他语言有非短路的&amp;、|,也没有^(异或)</strong></p>\r\n</blockquote>\r\n<ol>\r\n<li><strong>逻辑非 ！</strong> 。注意：这个是运算符只需要一个数据参与运算。<strong>不管参与运算的 是什么数据，最终结果一定是Boolean值</strong>.逻辑非的运算逻辑是，不管什么类型，先转换成Boolean值，再取反得到最终的结果。 取反的意思就是true变false，false变true</li></ol>\r\n<pre><code>alert(!Null);  //true。  因为null会转为fasle，所以取反之后变为true\r\nalert(!0);  // true\r\n</code></pre><ol>\r\n<li><p><strong>逻辑与 &amp;&amp; 。</strong> <strong>只要有一个是false，则返回false。</strong>(只有两个都是true的情况下才返回true)。 ==逻辑与&amp;&amp;的结果不一定是Boolean值 以下为特殊情况：==</p>\r\n<ul>\r\n<li>有短路的特点：如果 <strong>第一个</strong> 是false或者可以转换成false，则 <strong>结果就是第一个</strong> 。</li><li>如果 <strong>第一个</strong> 是true或者可以转换成true，则 <strong>结果就是第二个</strong> 。</li></ul>\r\n</li></ol>\r\n<pre><code>var a = 10;\r\nalert(false &amp;&amp; a++); //第一个操作数是false，所以最终结果是false。由于短路的关系，所以不会再去计算第二个表达式。\r\nalert(a); //  结果：10\r\n\r\nvar b = 20;\r\nalert(null &amp;&amp; b++);  // 第一个操作数是null，结果为null，且不会再去判断第二个。\r\nalert(b);  // 结果：20\r\n\r\nvar c = 30;\r\nalert(new Number(5) &amp;&amp; c++);  //结果 30.第一个操作数是对象，所以直接返回第二个操作数。\r\nalert(c); //结果：31\r\n</code></pre><ol>\r\n<li><p><strong>逻辑或 || 。</strong> ==只要有一个是true，结果就是true。== 与逻辑与一样，结果也不一定是Boolean值。特殊情况如下：</p>\r\n<ul>\r\n<li>也有短路的特点：如果 <strong>第一个</strong> 是true或者能转换成true，则直接返回第一个,不再去判断第二个</li><li>如果 <strong>第一个</strong> 是false或可以转换成false，则直接返回第二个。</li></ul>\r\n</li></ol>\r\n<pre><code>var a = 10;\r\nalert(true || a++);  // 结果true，且不会计算第二个表达式\r\n\r\nvar b = 20;\r\nalert(new Number(5) || b++); //结果为第一个(5)，且不会计算第二个。\r\n\r\nvar c = 30;\r\nalert(null || c++); //结果为30\r\n</code></pre><h3 id=\"h3-3-2-6-\"><a name=\"3.2.6 三元运算符(条件运算符)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.6 三元运算符(条件运算符)</h3><blockquote>\r\n<p>三元运算符的意思是指，需要三个操作数参与运算。</p>\r\n<p>语法：逻辑值(表达式) ? 表达式1 : 表达式2</p>\r\n<p>结果：如果逻辑值是true，则最终返回表达式1的值，如果逻辑值是false，则最终结果返回表达式2的值。</p>\r\n<p>==注意：如果逻辑值不是Boolean值，则先按照转型函数Boolean()的方式转变成Boolean，再进行计算==</p>\r\n</blockquote>\r\n<pre><code>var a = 0 ? 1 : 2;  //结果是2\r\nvar b = null ? 1 : 2; //结果是2\r\nvar c = &quot;a&quot; ? 1 : 2; //结果是1\r\n</code></pre><h3 id=\"h3-3-2-7-typeof-\"><a name=\"3.2.7 typeof操作符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.7 typeof操作符</h3><blockquote>\r\n<p>typeof 操作符用来检测给定的变量的类型。</p>\r\n<p>语法： typeof 变量;</p>\r\n<p><em>注意：typeof是一个操作符，而不是方法，所以typeof后面的操作数完全不需要添加括号。</em></p>\r\n</blockquote>\r\n<pre><code>var a = &quot;abc&quot;;\r\nalert(typeof a);  //弹出：string  注意：s是小写\r\n</code></pre><blockquote>\r\n<p>typeof操作符的计算结果只有一下6种：</p>\r\n</blockquote>\r\n<ol>\r\n<li>“undefined” ——如果这个值未声明，或者声明了但没有赋值</li><li>“boolean” ——如果这个值是布尔值；</li><li>“string” ——如果这个值是字符串；</li><li>“number” ——如果这个值是数值；</li><li>“object” ——如果这个值是对象或 null ；</li><li>“function” ——如果这个值是函数。</li></ol>\r\n<pre><code>var a;\r\nalert(typeof a);  // undefined\r\nalert(typeof b);  // undefined\r\nalert(null);  //object\r\nalert(&quot;abc&quot;); //string\r\nalert(new Object()); //object\r\nalert(new String()); // object\r\n</code></pre><h3 id=\"h3-3-2-8-\"><a name=\"3.2.8 逗号运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.8 逗号运算符</h3><blockquote>\r\n<ul>\r\n<li>使用逗号操作符可以在一条语句中执行多个操作。</li><li>逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项</li></ul>\r\n</blockquote>\r\n<pre><code>//var a, b, c, d;   //使用逗号操作符同时声明了4个变量。\r\nvar a = (1, 2, 3, 4);   // a= 4\\.  逗号操作符返回最后一个值。\r\nalert(a);  //弹出： 4\r\n</code></pre><h2 id=\"h2-3-3-\"><a name=\"3.3 运算符的优先级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 运算符的优先级</h2><blockquote>\r\n<p>运算符的优先级见下表。从上向下，优先级越来越低。</p>\r\n<p><em>注意：优先级不用刻意去记，当把我不准优先级的时候，就添加()就可以了。理论上，在一个表达式中括号是没有任何的限制的。</em></p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-3/25341866.jpg\" alt=\"\"></p>\r\n<p></div></p>\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>', '66', '\r\n# 一、数据类型\r\n\r\n> [JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")的数据类型共分两类：**简单数据类型** (也称原始数据类型或基本数据类型)和**复杂数据类型**(也称引用数据类型或对象类型)。\r\n\r\n## 2.1 简单数据类型\r\n\r\n> 简单数据类型共分5种：**Number、Boolean、String、Null、Undefined** (ECMAScript6新增：Symbol)\r\n\r\n| 数据类型 | 数据值 | 说明 |\r\n| :-: | :-- | :-- |\r\n| Undefined | undefined | 当声明一个变量但是并没有赋值时，变量的类型是Undefine类型 |\r\n| Null | null | 对象指针为空 |\r\n| Boolean | true false | true\\false两个值都必须小写 |\r\n| Number | 10 3.14 3\\. .5 整数与浮点数 | NaN —- not a number本应该返回数值型数据的函数，如果返回的值不是数值型测返回NaN isNaN()—不是数字返回true 是数字返回false |\r\n| String | “Hello” ‘Hello’ “a” ’a’ | 后续学习 |\r\n| Object | 对象 | 后续学习 |\r\n\r\n### 2.1.1 Number类型\r\n\r\n> 数值类型共分4种值：**整数、浮点数、无穷大、NaN**。\r\n> 对数值来说，最常见的数值字面量是10进制。比如：20, 30, 5.5 这些值都是用10进制表示的。\r\n\r\n1.  **整数:** 对整数来说，还可以使用8进制和16进制的整数来表示。8进制的范围是(0-7)， 16进制的范围是(0-F)。例如：\r\n\r\n```\r\nvar num = 25;  // 10进制的25\r\nalert(num); //弹出：25\r\nvar num1 = 025; // 8进制用0开始。表示一个8进制的25。\r\nalert(num1);   // 弹出：21 注意：弹出显示的时候，总是用10进制的形式。\r\nvar num2 = 0x25; // 0x开始表示这个数是16进制。这是个16进制中的25。 注意：这里的x可以大写X也可以小写x\r\nalert(num2);    //弹出：37\r\nvar num3 = 0XAF;\r\nalert(num3);  //弹出：175\r\n\r\n注意：如果8进制数字超出了进制范围(比如出现8、9)，则自动忽略前导0，把这个数字作为十进制的数字类处理。例如：\r\nvar num4 = 089;\r\nalert(num4);  //弹出：89。 并不会出现错误\r\n```\r\n\r\n1.  **浮点数:** 所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。浮点数直接量一般有两种写法：**直接带小数点的**和**使用科学计数法。**\r\n\r\n```\r\nvar f1 = 3.14;   // 带小数点的直接量写法\r\nvar f2 = 3.158899e5; //科学计数法：  表示 3.158899 * 10^5\r\n```\r\n\r\n1.  **无穷大(Infinity):** ECMAScript并不能储存所有的数，所以能表示的数有个范围。所能表示的数最大值和最小值都保存在Number这个内置对象中(后面会详细介绍什么是对象。)\r\n\r\n```\r\nalert(Number.MAX_VALUE);\r\nalert(Number.MIN_VALUE);\r\n//如果数值超出了最大值和最小值，则用Infinity和-Infinity表示。\r\nalert(1.1 / 0); //弹出：Infinity\r\nalert(-1.1 / 0);    //弹出：-Infinity\r\n```\r\n\r\n1.  **NaN( not a number 不是个数):** 表示不是一个数字，当0/0 的时候不是无穷大，而是NaN。或者把一个非数字形式的字符串转换成数字时都会返回NaN。例如：\r\n\r\n```\r\nalert(0 / 0);  //弹出：NaN\r\nalert(parseInt(\"60\"));  //弹出：60 说明：parseInt(\"\");可以把字符串形式的数字转换成Number\r\nalert(parseInt(\"a\"));   //弹出：NaN\r\n\r\n//注意：NaN是个非常特别的东东。因为即使他自己和自己都不相等。\r\nvar v = 0 / 0;\r\nalert(v == v);  //弹出false\r\nalert(v != v);  //弹出true。  所以：可以通过这种方式来判断这个数是否为NaN\r\n\r\n/*\r\n  另外：isNaN()函数如果 x 是特殊的非数字值 NaN（或者能被转换为这样的值），返回的值就是 true。如果 x 是其他值,\r\n  则 返回 false。\r\n*/\r\nalert(isNaN(3));//返回false\r\nalert(isNaN(\"3\"));   //返回false\r\nalert(isNaN(\"blue\"));//返回true\r\nalert(isNaN(true));//返回false . true可以转换成数字1\r\nalert(isNaN(null));//返回false    null可以转换为数字0\r\nalert(isNaN(undefined));//返回true    \r\n```\r\n\r\n### 2.1.2 Boolean类型\r\n\r\n> Boolean类型的值是程序中用的很多的一种类型。它只有两个值：true和false。true表示逻辑上的**对/正确**，false表示逻辑上的**错**。\r\n\r\n### 2.1.3 String类型\r\n\r\n> String指的是用 **“”(双引号)** 或 **”(单引号)** 括起来的字符序列。字符序列可以由0个或多个字符组成。\r\n> 例如：”123” “a” ‘name’ ‘blue’ ’nihao’ ’xiaohong‘ ”nihao”。\r\n> \r\n> 说明：\r\n> \r\n> 1、单引号或双引号要匹配，不能一边用双引号，一边用单引号 ，左右符号要匹配。\r\n> \r\n> 2、JavaScript统一每个字符使用Unitcode码来进行编码，每个字符占16位(2个字节)。\r\n> \r\n> 3\\. 在其他语言中多用单引号表示一个字符，双引号表示字节。但是对JavaScript来说，不存在字符类型的数据。\r\n> \r\n> 4\\. 有些字符不可见或有特殊意义，比如换行符，制表符, 双引号等，则 JavaScript 提供了相应的**转意字符**，来表示这些不可见字符。见下表：\r\n\r\n| 代码 | 输出 |\r\n| :-: | :-: |\r\n| **\\’** | **单引号** |\r\n| **\\”** | **双引号** |\r\n| \\& | 和号 |\r\n| \\\\ | 反斜杠 |\r\n| **\\n** | **换行符** |\r\n| \\r | 回车符 |\r\n| **\\t** | **制表符** |\r\n| \\b | 退格符 |\r\n| \\f | 换页符 |\r\n\r\n### 2.1.4 Undefined\r\n\r\n> Undefined 类型只有一个值，即特殊的 undefined 。在使用 var 声明变量但未对其加以初始化时，\r\n> 这个变量的值就是 undefined ，例如：\r\n\r\n```\r\nvar v;\r\nalert(v); //弹出：undefined。  变量v声明但是没有赋值初始化，则为undefined\r\nalert(m);  //m没有定义，直接使用会发生错误。\r\n```\r\n\r\n### 2.1.5 Null\r\n\r\n> 1.  Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null ( n是小写)。从逻辑角度来看， null 值表\r\n> \r\n> 示一个空对象指针。\r\n> \r\n> 1.  值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。\r\n> \r\n> _说明：_\r\n> \r\n> _尽管这两个值相等，但它们的含义不同。_\r\n> _undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象。_\r\n> _如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是null。_\r\n\r\n```\r\nalert(null == undefined); // 弹出： true。  待讲完面向对象在来理解会更加清晰。大家目前只需要了解即可。\r\n```\r\n\r\n## 2.2 复杂数据类型\r\n\r\n> 复杂数据类型又称之为引用数据类型。主要包括三种：**对象(object)、函数(function)和数组(array)**。\r\n> \r\n> 不过，从本质来看，这三种都属于对象。\r\n> \r\n> 关于复杂数据类型，我们在面向对象部分重点详细介绍。\r\n\r\n# 二、数据类型转换\r\n\r\n> 数据类型转换有两种转换：自动转换和强制转换。\r\n\r\n### 1\\. 自动类型转换：\r\n\r\n> 在解释执行的过程中，会根据需要进行相应的自动类型转换。比如：需要一个Boolean类型的值，而现在是一个字符串，则会根据相应的规则把字符串自动转换为Boolean值。\r\n\r\n```\r\n1、转换成布尔类型\r\nundefined —> false\r\nnull —> false\r\n数值       0,0.0,NaN —> false   其他数值—> true\r\n字符串    \"\"—>false    \"etef\" —> true\r\n其他对象—> true\r\n总结：存在的东东，转换成true， 不存在的东东转换成flase\r\n\r\n2、转换成数值类型\r\nundefined —> NaN\r\nnull —> 0\r\n字符串——>数值—>     \"34234\"—>34234,  \"324sdfs3423\" —> NaN,  \"\" —> 0\r\n布尔类型——>数值    true->1   false->0\r\n总结：能转成数字的就转成对应的数字。不能转成数字的要么0或1要么NaN\r\n\r\n3、转换成字符串类型\r\nundefined —>\"undefined\"\r\nnull —>\"null\"\r\n布尔类型     true —>”true”     false —>\"false\"\r\n数值类型转成字符串    12321 —>\"12321\"   NaN —>\"NaN\"\r\n总结：字面值是什么就转成什么\r\n```\r\n\r\n### 2\\. 强制类型转换。\r\n\r\n```\r\n//1、其他类型转成成字符串。\r\nvar a = 10;\r\nalert(a + \"\");  // 直接和一个长度为0的空字符链接\r\nalert(a.toString()); //调用这个变量的toString()方法\r\nalert(String(a));  //使用String转型函数\r\n//2、字符串转数字。\r\nvar s = \"123\";\r\nalert(parseInt(s));\r\nalert(parseFloat(s));\r\n/*\r\n    注意：使用parseXxx转换\r\n    1、转换为数字的时候，会忽略前面的空格\r\n    2、如果是数组开头然后是字母，则会只转前面的数字\r\n    3、如果是是字母开头则返回NaN\r\n    4、在使用parseInt的时候，可以传入第二个参数，表示这个数的进制，然后就转换成对应的10进制数返回。\r\n*/\r\nalert(parseInt(\"  12\"));  //忽略前面的空白字符\r\nalert(ParseInt(\"12ab3\");  //弹出：12\\.  从字母后面的统统忽略掉\r\nalert(parseInt(\"a123\"));  // 弹出：NaN\r\n\r\n//3、使用转型函数互转(暂时先了解)  var为一个变量或常量都可以\r\nString(var);//其他类型转字符串\r\nNumber(var);  //其他类型转数字\r\nBoolean(var);  // 其他类型转布尔\r\n```\r\n\r\n# 三、表达式和运算符\r\n\r\n## 3.1 表达式\r\n\r\n> 表达式是用于JavaScript脚本运行时进行计算的式子，可以包含**常量、变量、运算符**。表达式可以任意复杂。 表达式的值就是经过一系列运算之后的最终值。\r\n\r\n```\r\nvar n = 10;\r\nvar m = 30;\r\nalert(n + m);  // n+m就是一个表达式。\r\n```\r\n\r\n## 3.2 运算符\r\n\r\n> 运算符也叫操作符。作用是去操作数据值，然后进行各种计算。**ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。(不过，在应用于对象时，相应的操作符通常都会调用对象的 valueOf()和（或） toString() 方法，以便取得可以操作的值。 _暂时了解_ )**\r\n\r\n### 3.2.1 算术运算符\r\n\r\n> +、-、*、/、%。\r\n> \r\n> 这几个运算符都需要两个数据参与运算。\r\n\r\n1.  **+** 运算**符：运算规则**\r\n\r\n    *   如果两个都是Number则，则就按照普通的数学加法运算。\r\n\r\n    *   如果有一个是字符串，就按照字符串的串联的方式连接。(如果另外一个不是字符串，则先转换成字符串再连)。\r\n\r\n    *   如果有一个是NaN，则结果就是NaN。\r\n    *   如果同时是Infinity或-Infinity，则结果就是Infinity或-Infinity。\r\n    *   如果一个是Infinity另外一个是-Infinity，则结果为NaN。\r\n2.  **- 运算符：运算符规则**\r\n\r\n    *   如果两个都是Number则，则就按照普通的数学减法运算。\r\n    *   如果有一个操作数是字符串、布尔值、null 或undefined，则先在后台调用Number()转型函数将其转换为数值，然后再根据正常减法计算。如果转换的结果有一个是NaN,则减法的结果就是NaN\r\n    *   如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值**(了解)**\r\n3.  *** 运算符：运算符规则。**\r\n\r\n    *   运算规则同减法。\r\n4.  **/ 运算符：运算规则**\r\n\r\n    *   就是普通的除法运算，运算规则同 *\r\n5.  **%运算符：运算规则**\r\n\r\n    *   求余(求模)运算。\r\n\r\n```\r\nvar v = 10 % 2;   // 余0\r\nalert(10 % 3); // 结果 ： 1\r\nalert(-10 % 3); // 结果： -1   说明：求余的时候，符号与被除数保持一致。\r\nalert(10 % -3); // 结果： 1\r\nalert(1 % 0.3);  // 结果：0.1\r\n```\r\n\r\n### 3.2.2 一元运算符\r\n\r\n1.  ++自增操作: 对要操作的变量进行+1的操作，并把+1之后的结果重写赋值给这个变量。可以在变量前也可以在变量后。任何变量都可以使用，但是对非Number类型的变量操作的时候，需要先按照前面的规则转换成Number然后再自增**1.**\r\n\r\n```\r\nvar a = 10;\r\nvar b = a++;  //把a的值自增1，a的值变为11\\.  注意：a++表达式的值，仍然是a自增之前的值，所以b的值是是10\r\n\r\nvar c = 10;\r\nvar d = ++a;  //把a的值自增1，a的值变为11\\.  注意：++a表达式的值，是a自增之后的值，所以d的值是11\r\n\r\nvar m = \"123\";\r\nm++;  //先把m使new Number(m)之后再转换进行自增的操作。\r\n```\r\n\r\n1.  –自减操作: 对要操作的变量进行减1的操作，并把-1之后的结果重新赋值给这个变量。 计算方法同++。\r\n\r\n```\r\nvar a = 10;\r\nvar b = a--;  //把a的值自减1，a的值变为9\\.  注意：a--表达式的值，仍然是a自减之前的值，所以b的值是是10\r\n\r\nvar c = 10;\r\nvar d = --a;  //把a的值自减1，a的值变为9\\.  注意：--a表达式的值，是a自减之后的值，所以d的值是9\r\n\r\nvar m = \"123\";\r\nm--;  //先把m使用转型函数Number(m)之后再转换进行自减的操作。\r\n```\r\n\r\n### 3.2.3 赋值运算符和复合赋值运算符\r\n\r\n> =、+=、-=、*=、/=、%=\r\n> \r\n> **使用赋值操作符的注意目的是简化表达式的书写，并不会带来任何的性能的提示。**\r\n\r\n```\r\nvar n = 10;\r\nn += 4;  //等价于 n = n + 4;  运算结束后n的值为14\r\n\r\nvar m = \"6\";\r\nm -= 5;   // 会先把m转换成数字之后(m = new Number(m))，再执行  m = m - 5;\r\n```\r\n\r\n### 3.2.4 比较运算符\r\n\r\n> >、>=、<、<=、\\==、\\===、 !=、!\\==\r\n> \r\n> 比较运算符是对运算符的坐标和右边的两个数据进行比较。\r\n\r\n*   如果两个都是数字，就是普通的数字比较。\r\n*   如果有一个是数字，就把另外一个不是数字的使用new Number(var)的方式转换为数字再比较\r\n*   如果两个都是字符串，则比较的是字符串中的字符在字母表中的顺序。(或者说比较是他们的编码值)\r\n*   如果有一个是NaN，则结果一定是false。==但是有一种情况，如果比较特殊NaN != NaN则是true。==\r\n\r\n> ==**\\== 和 != 是判断两个操作数是否相等。规则：**==\r\n\r\n*   如果两个都是简单类型中的Number类型，直接判断数值是否相等。\r\n\r\n```\r\nalert(10 == 10.0);  //  true\r\n```\r\n\r\n*   如果有一个NaN参与比较，则总是不等的。\r\n*   null和undefined之间是相等\r\n*   如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为 0，而\r\n    true 转换为 1；\r\n*   如果一个字符串与数值比较，则把字符串转换成数值之后再比较\r\n*   如果一个对象和一个基本类型比较，则调用对象的valueOf方法，转变成基本类型之后再比较(暂时先了解)\r\n*   如果连个对象比较，则比较两个对象是否为同一个对象。是就相同，不是就不同。(暂时先了解)\r\n\r\n```\r\nalert(NaN == false);  // fasle\r\nalert(NaN == true);  // false\r\nalert(NaN == 1); //false；\r\nalert(NaN == NaN); // fasle\r\nalert(NaN != NaN); // true\r\n\r\nalert(null == null); // true\r\nalert(null == undefined); // true\r\nalert(undefined == undefined); // true\r\n\r\nalert(\"1\" == 1); //true\r\nalert(\"1a\" == 1);  //false  “1a\"会被转换为NaN\r\n\r\nalert(1 == true); //true  会把true转成1之后再比较\r\nalert(0 == null);  //false  null与任何的非null的都不相等\r\n```\r\n\r\n> ==**\\=\\== !\\== 全等判断**==\r\n> \r\n> 全等在转换前不做任何的转换，如果两个一样就相等，否则就不等。\r\n\r\n```\r\nalert(\"1\" === 1);  //false 一个string类型，一个number类型，所以不等\r\nalert(null === undefined);  // false\r\nalert(\"abc\" === \"abc\");  // true\r\n```\r\n\r\n### 3.2.5 逻辑运算符\r\n\r\n> 只有三种逻辑运算符：&&、||、! 。而且 && 和|| 都是短路的形式。 **注意：不像其他语言有非短路的&、|,也没有^(异或)**\r\n\r\n1.  **逻辑非 ！** 。注意：这个是运算符只需要一个数据参与运算。**不管参与运算的 是什么数据，最终结果一定是Boolean值**.逻辑非的运算逻辑是，不管什么类型，先转换成Boolean值，再取反得到最终的结果。 取反的意思就是true变false，false变true\r\n\r\n```\r\nalert(!Null);  //true。  因为null会转为fasle，所以取反之后变为true\r\nalert(!0);  // true\r\n```\r\n\r\n1.  **逻辑与 && 。** **只要有一个是false，则返回false。**(只有两个都是true的情况下才返回true)。 ==逻辑与&&的结果不一定是Boolean值 以下为特殊情况：==\r\n\r\n    *   有短路的特点：如果 **第一个** 是false或者可以转换成false，则 **结果就是第一个** 。\r\n    *   如果 **第一个** 是true或者可以转换成true，则 **结果就是第二个** 。\r\n\r\n```\r\nvar a = 10;\r\nalert(false && a++); //第一个操作数是false，所以最终结果是false。由于短路的关系，所以不会再去计算第二个表达式。\r\nalert(a); //  结果：10\r\n\r\nvar b = 20;\r\nalert(null && b++);  // 第一个操作数是null，结果为null，且不会再去判断第二个。\r\nalert(b);  // 结果：20\r\n\r\nvar c = 30;\r\nalert(new Number(5) && c++);  //结果 30.第一个操作数是对象，所以直接返回第二个操作数。\r\nalert(c); //结果：31\r\n```\r\n\r\n1.  **逻辑或 || 。** ==只要有一个是true，结果就是true。== 与逻辑与一样，结果也不一定是Boolean值。特殊情况如下：\r\n\r\n    *   也有短路的特点：如果 **第一个** 是true或者能转换成true，则直接返回第一个,不再去判断第二个\r\n    *   如果 **第一个** 是false或可以转换成false，则直接返回第二个。\r\n\r\n```\r\nvar a = 10;\r\nalert(true || a++);  // 结果true，且不会计算第二个表达式\r\n\r\nvar b = 20;\r\nalert(new Number(5) || b++); //结果为第一个(5)，且不会计算第二个。\r\n\r\nvar c = 30;\r\nalert(null || c++); //结果为30\r\n```\r\n\r\n### 3.2.6 三元运算符(条件运算符)\r\n\r\n> 三元运算符的意思是指，需要三个操作数参与运算。\r\n> \r\n> 语法：逻辑值(表达式) ? 表达式1 : 表达式2\r\n> \r\n> 结果：如果逻辑值是true，则最终返回表达式1的值，如果逻辑值是false，则最终结果返回表达式2的值。\r\n> \r\n> ==注意：如果逻辑值不是Boolean值，则先按照转型函数Boolean()的方式转变成Boolean，再进行计算==\r\n\r\n```\r\nvar a = 0 ? 1 : 2;  //结果是2\r\nvar b = null ? 1 : 2; //结果是2\r\nvar c = \"a\" ? 1 : 2; //结果是1\r\n```\r\n\r\n### 3.2.7 typeof操作符\r\n\r\n> typeof 操作符用来检测给定的变量的类型。\r\n> \r\n> 语法： typeof 变量;\r\n> \r\n> _注意：typeof是一个操作符，而不是方法，所以typeof后面的操作数完全不需要添加括号。_\r\n\r\n```\r\nvar a = \"abc\";\r\nalert(typeof a);  //弹出：string  注意：s是小写\r\n```\r\n\r\n> typeof操作符的计算结果只有一下6种：\r\n\r\n1.  “undefined” ——如果这个值未声明，或者声明了但没有赋值\r\n2.  “boolean” ——如果这个值是布尔值；\r\n3.  “string” ——如果这个值是字符串；\r\n4.  “number” ——如果这个值是数值；\r\n5.  “object” ——如果这个值是对象或 null ；\r\n6.  “function” ——如果这个值是函数。\r\n\r\n```\r\nvar a;\r\nalert(typeof a);  // undefined\r\nalert(typeof b);  // undefined\r\nalert(null);  //object\r\nalert(\"abc\"); //string\r\nalert(new Object()); //object\r\nalert(new String()); // object\r\n```\r\n\r\n### 3.2.8 逗号运算符\r\n\r\n> *   使用逗号操作符可以在一条语句中执行多个操作。\r\n> *   逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项\r\n\r\n```\r\n//var a, b, c, d;   //使用逗号操作符同时声明了4个变量。\r\nvar a = (1, 2, 3, 4);   // a= 4\\.  逗号操作符返回最后一个值。\r\nalert(a);  //弹出： 4\r\n```\r\n\r\n## 3.3 运算符的优先级\r\n\r\n> 运算符的优先级见下表。从上向下，优先级越来越低。\r\n> \r\n> _注意：优先级不用刻意去记，当把我不准优先级的时候，就添加()就可以了。理论上，在一个表达式中括号是没有任何的限制的。_\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-3/25341866.jpg)\r\n\r\n</div>\r\n\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>');
INSERT INTO `article_info_true` VALUES ('49', 'js分支选择结构', '<h1 id=\"h1--\"><a name=\"一、 语句和程序结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、 语句和程序结构</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 语句</h2><blockquote>\r\n<p>ECMA-262 规定了一组语句（也称为流控制语句）。从本质上看，语句定义了 ECMAScript 中的主要<br>语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比<br>较复杂，例如指定重复执行某个命令的次数。</p>\r\n<p><strong><em>我们写的任何一行代码其实都是一条语句。一个程序总是由很多的语句来组成</em></strong></p>\r\n</blockquote>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 程序流程控制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 程序流程控制</h2><blockquote>\r\n<p>结构化程序有三种结构。顺序结构、选择结构、循环结构</p>\r\n</blockquote>\r\n<ul>\r\n<li>顺序结构：顺序结构是一种线性、有序的结构，它依次执行各语句模块。</li><li>选择结构：选择结构是根据条件成立与否选择程序执行的通路。需要条件语句。</li><li>循环结构：循环结构是重复执行一个或几个模块，直到满足某一条件为止。 需要循环语句。</li></ul>\r\n<h1 id=\"h1--if-\"><a name=\"二、if 条件语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、if 条件语句</h1><h2 id=\"h2-2-1-if-\"><a name=\"2.1 if 结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 if 结构</h2><blockquote>\r\n<p>语法：</p>\r\n</blockquote>\r\n<pre><code>if(condition){\r\n  //语句1\r\n}\r\n//if结构外面的代码\r\n说明：\r\n1、condition(条件)，可以是任意表达式，表达式的值不要求必须是布尔值。\r\n2、如果condition不是布尔值，则使用转型函数Boolean()转换成布尔值。\r\n3、如果对condition求值后的结果是true则执行 &quot;语句1&quot;。如果是false，则不执行 &quot;语句1&quot;，开始执行if结构外面的代码。\r\n</code></pre><h2 id=\"h2-2-2-if-else-\"><a name=\"2.2 if…else 结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 if…else 结构</h2><blockquote>\r\n<p>语法：</p>\r\n</blockquote>\r\n<pre><code>if(condition){\r\n  //语句1\r\n}else{\r\n  //语句2\r\n}\r\n//if结构外面的代码\r\n说明：\r\n1、condition(条件)，可以是任意表达式，表达式的值不要求必须是布尔值。\r\n2、如果condition不是布尔值，则使用转型函数Boolean()转换成布尔值。\r\n3、如果对condition求值后的结果是true则执行 &quot;语句1&quot;。如果是false，则执行 &quot;语句2&quot;。\r\n注意：从上面的说明可以看出，&quot;语句1&quot;和&quot;语句2&quot;永远不会同时执行，一定会执行其中的一句。\r\n</code></pre><h2 id=\"h2-2-3-if-else-if-elsif-\"><a name=\"2.3 if…else if…elsif… 结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 if…else if…elsif… 结构</h2><blockquote>\r\n<p>语法：</p>\r\n</blockquote>\r\n<pre><code>if(condition1){\r\n  //语句1\r\n}else if(condition2){\r\n  //语句2\r\n}...else if(condition3){\r\n  //语句n\r\n}\r\n说明：\r\n1、首先判断condition1，如果是true，则执行&quot;语句1&quot;。\r\n2、如果condition1是false，则判断condition2，如果是true，则执行&quot;语句2&quot;。以此类推。\r\n3、如果中间碰到任何一个condition是true，则执行相应的语句，执行完毕之后，则整个if结构的语句也结束了。不会再判断后面的condition。\r\n4、如果所有的condition都是fasle，则一个&quot;语句&quot;都不执行，整个if结构语句结束。\r\n注意：这个结构中，有可能一个语句都不执行。\r\n</code></pre><h2 id=\"h2-2-4-if-else-if-else-else-\"><a name=\"2.4 if…else if…else …else结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 if…else if…else …else结构</h2><blockquote>\r\n<p>语法：</p>\r\n</blockquote>\r\n<pre><code>if(condition1){\r\n  //语句1\r\n}else if(condition2){\r\n  //语句2\r\n}...else if(condition3){\r\n  //语句n\r\n}else{\r\n  //else语句\r\n}\r\n说明：\r\n1、首先判断condition1，如果是true，则执行&quot;语句1&quot;。\r\n2、如果condition1是false，则判断condition2，如果是true，则执行&quot;语句2&quot;。以此类推。\r\n3、如果中间碰到任何一个condition是true，则执行相应的语句，执行完毕之后，则整个if结构的语句也结束了。不会再判断后面的condition。\r\n4、如果所有的condition都是fasle，则会自动执行else中的语句。\r\n注意：该结构中，一定会有一个而且仅有一个语句执行。\r\n</code></pre><h1 id=\"h1--switch-\"><a name=\"三、 switch条件语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、 switch条件语句</h1><blockquote>\r\n<p>switch语句也是与if语句一样使用广泛的选择语句。与c、<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>的语法一样，但是使用起来比他们更灵活。</p>\r\n<p>语法:</p>\r\n</blockquote>\r\n<pre><code>switch (expression) {\r\n  case value1: \r\n    //语句1\r\n  break;\r\n  case value2: \r\n    //语句2\r\n  break;\r\n  case value3: \r\n    //语句3\r\n  break;\r\n  case value4: \r\n    //语句4\r\n  break;\r\n  default: \r\n    //fefault语句\r\n}\r\n</code></pre><blockquote>\r\n<p><strong>说明：</strong></p>\r\n</blockquote>\r\n<ol>\r\n<li>switch语句的含义是如果某个case的value与express相等，则执行这个case对应的语句，碰到break语句就结束switch语句。</li><li>如果没有一个case都不匹配，则自动执行default语句。</li><li>可以没有default，如果没有则当所有的case都不匹配的情况下，自动结束switch，一条语句都不执行。</li><li><strong>对JavaScript来说，expression可以是任何类型的(基本类型和引用类型)，而case后面的value可以是变量、常量、对象、表达式。</strong> (其他语言如：java和c则只能是常量，而且expression表达式的类型也有限制)</li><li>注意：在执行的过程中，如果匹配了某个case，则从这个case的语句开始执行，直到碰到break或者switch的结尾才会结束。</li></ol>\r\n<blockquote>\r\n<p>案例1:</p>\r\n</blockquote>\r\n<pre><code>var a = 2;\r\nswitch (a) {\r\n  case 1:\r\n    alert(&quot;1&quot;);\r\n    break;\r\n  case 2: //a的值是2，所以与这个case匹配\r\n    alert(&quot;2&quot;);  // 执行这个段代码\r\n    break; //碰到break，switch语句结束\r\n  case 3:\r\n    alert(&quot;3&quot;);\r\n    break;\r\n  case 4:\r\n    alert(&quot;4&quot;);\r\n    break;\r\n  default:\r\n    alert(&quot;default&quot;)\r\n    break;\r\n}\r\n</code></pre><blockquote>\r\n<p>案例2:</p>\r\n</blockquote>\r\n<pre><code>var a = 10;\r\nswitch (a) {\r\n  case 1:\r\n    alert(&quot;1&quot;);\r\n    break;\r\n  case 2: \r\n    alert(&quot;2&quot;);  \r\n    break; \r\n  case 3:\r\n    alert(&quot;3&quot;);\r\n    break;\r\n  case 4:\r\n    alert(&quot;4&quot;);\r\n    break;\r\n  default: //a 为10，所以与所有的case都不匹配\r\n    alert(&quot;default&quot;); //执行default中的语句\r\n    break;\r\n}\r\n</code></pre><blockquote>\r\n<p>案例3:</p>\r\n</blockquote>\r\n<pre><code>var a = 3;\r\nswitch (a) {\r\n  case 1:\r\n    alert(&quot;1&quot;);\r\n    break;\r\n  case 2: \r\n    alert(&quot;2&quot;);  \r\n    break; \r\n  case 3: //a为3，与这个case匹配\r\n    alert(&quot;3&quot;); //开始执行case3中的语句\r\n  case 4:\r\n    alert(&quot;4&quot;); //没有碰到break语句，继续执行此语句\r\n  default: \r\n    alert(&quot;default&quot;);  //没有碰到break语句，继续执行此语句\r\n    break; //碰到break，switch语句结束。  如果此处没有switch语句，代码也会结束，后面没有代码了。哈哈\r\n}\r\n</code></pre><p></div></p>\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>', '67', '# 一、 语句和程序结构\r\n\r\n## 1.1 语句\r\n\r\n> ECMA-262 规定了一组语句（也称为流控制语句）。从本质上看，语句定义了 ECMAScript 中的主要\r\n> 语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比\r\n> 较复杂，例如指定重复执行某个命令的次数。\r\n> \r\n> **_我们写的任何一行代码其实都是一条语句。一个程序总是由很多的语句来组成_**\r\n\r\n## 1.2 程序流程控制\r\n\r\n> 结构化程序有三种结构。顺序结构、选择结构、循环结构\r\n\r\n*   顺序结构：顺序结构是一种线性、有序的结构，它依次执行各语句模块。\r\n*   选择结构：选择结构是根据条件成立与否选择程序执行的通路。需要条件语句。\r\n*   循环结构：循环结构是重复执行一个或几个模块，直到满足某一条件为止。 需要循环语句。\r\n\r\n# 二、if 条件语句\r\n\r\n## 2.1 if 结构\r\n\r\n> 语法：\r\n\r\n```\r\nif(condition){\r\n  //语句1\r\n}\r\n//if结构外面的代码\r\n说明：\r\n1、condition(条件)，可以是任意表达式，表达式的值不要求必须是布尔值。\r\n2、如果condition不是布尔值，则使用转型函数Boolean()转换成布尔值。\r\n3、如果对condition求值后的结果是true则执行 \"语句1\"。如果是false，则不执行 \"语句1\"，开始执行if结构外面的代码。\r\n```\r\n\r\n## 2.2 if…else 结构\r\n\r\n> 语法：\r\n\r\n```\r\nif(condition){\r\n  //语句1\r\n}else{\r\n  //语句2\r\n}\r\n//if结构外面的代码\r\n说明：\r\n1、condition(条件)，可以是任意表达式，表达式的值不要求必须是布尔值。\r\n2、如果condition不是布尔值，则使用转型函数Boolean()转换成布尔值。\r\n3、如果对condition求值后的结果是true则执行 \"语句1\"。如果是false，则执行 \"语句2\"。\r\n注意：从上面的说明可以看出，\"语句1\"和\"语句2\"永远不会同时执行，一定会执行其中的一句。\r\n```\r\n\r\n## 2.3 if…else if…elsif… 结构\r\n\r\n> 语法：\r\n\r\n```\r\nif(condition1){\r\n  //语句1\r\n}else if(condition2){\r\n  //语句2\r\n}...else if(condition3){\r\n  //语句n\r\n}\r\n说明：\r\n1、首先判断condition1，如果是true，则执行\"语句1\"。\r\n2、如果condition1是false，则判断condition2，如果是true，则执行\"语句2\"。以此类推。\r\n3、如果中间碰到任何一个condition是true，则执行相应的语句，执行完毕之后，则整个if结构的语句也结束了。不会再判断后面的condition。\r\n4、如果所有的condition都是fasle，则一个\"语句\"都不执行，整个if结构语句结束。\r\n注意：这个结构中，有可能一个语句都不执行。\r\n```\r\n\r\n## 2.4 if…else if…else …else结构\r\n\r\n> 语法：\r\n\r\n```\r\nif(condition1){\r\n  //语句1\r\n}else if(condition2){\r\n  //语句2\r\n}...else if(condition3){\r\n  //语句n\r\n}else{\r\n  //else语句\r\n}\r\n说明：\r\n1、首先判断condition1，如果是true，则执行\"语句1\"。\r\n2、如果condition1是false，则判断condition2，如果是true，则执行\"语句2\"。以此类推。\r\n3、如果中间碰到任何一个condition是true，则执行相应的语句，执行完毕之后，则整个if结构的语句也结束了。不会再判断后面的condition。\r\n4、如果所有的condition都是fasle，则会自动执行else中的语句。\r\n注意：该结构中，一定会有一个而且仅有一个语句执行。\r\n```\r\n\r\n# 三、 switch条件语句\r\n\r\n> switch语句也是与if语句一样使用广泛的选择语句。与c、[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")的语法一样，但是使用起来比他们更灵活。\r\n> \r\n> 语法:\r\n\r\n```\r\nswitch (expression) {\r\n  case value1: \r\n    //语句1\r\n  break;\r\n  case value2: \r\n    //语句2\r\n  break;\r\n  case value3: \r\n    //语句3\r\n  break;\r\n  case value4: \r\n    //语句4\r\n  break;\r\n  default: \r\n    //fefault语句\r\n}\r\n```\r\n\r\n> **说明：**\r\n\r\n1.  switch语句的含义是如果某个case的value与express相等，则执行这个case对应的语句，碰到break语句就结束switch语句。\r\n2.  如果没有一个case都不匹配，则自动执行default语句。\r\n3.  可以没有default，如果没有则当所有的case都不匹配的情况下，自动结束switch，一条语句都不执行。\r\n4.  **对JavaScript来说，expression可以是任何类型的(基本类型和引用类型)，而case后面的value可以是变量、常量、对象、表达式。** (其他语言如：java和c则只能是常量，而且expression表达式的类型也有限制)\r\n5.  注意：在执行的过程中，如果匹配了某个case，则从这个case的语句开始执行，直到碰到break或者switch的结尾才会结束。\r\n\r\n> 案例1:\r\n\r\n```\r\nvar a = 2;\r\nswitch (a) {\r\n  case 1:\r\n    alert(\"1\");\r\n    break;\r\n  case 2: //a的值是2，所以与这个case匹配\r\n    alert(\"2\");  // 执行这个段代码\r\n    break; //碰到break，switch语句结束\r\n  case 3:\r\n    alert(\"3\");\r\n    break;\r\n  case 4:\r\n    alert(\"4\");\r\n    break;\r\n  default:\r\n    alert(\"default\")\r\n    break;\r\n}\r\n```\r\n\r\n> 案例2:\r\n\r\n```\r\nvar a = 10;\r\nswitch (a) {\r\n  case 1:\r\n    alert(\"1\");\r\n    break;\r\n  case 2: \r\n    alert(\"2\");  \r\n    break; \r\n  case 3:\r\n    alert(\"3\");\r\n    break;\r\n  case 4:\r\n    alert(\"4\");\r\n    break;\r\n  default: //a 为10，所以与所有的case都不匹配\r\n    alert(\"default\"); //执行default中的语句\r\n    break;\r\n}\r\n```\r\n\r\n> 案例3:\r\n\r\n```\r\nvar a = 3;\r\nswitch (a) {\r\n  case 1:\r\n    alert(\"1\");\r\n    break;\r\n  case 2: \r\n    alert(\"2\");  \r\n    break; \r\n  case 3: //a为3，与这个case匹配\r\n    alert(\"3\"); //开始执行case3中的语句\r\n  case 4:\r\n    alert(\"4\"); //没有碰到break语句，继续执行此语句\r\n  default: \r\n    alert(\"default\");  //没有碰到break语句，继续执行此语句\r\n    break; //碰到break，switch语句结束。  如果此处没有switch语句，代码也会结束，后面没有代码了。哈哈\r\n}\r\n```\r\n\r\n</div>\r\n\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>');
INSERT INTO `article_info_true` VALUES ('50', 'js循环结构', '<h1 id=\"h1--\"><a name=\"一、为什么需要循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、为什么需要循环</h1><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/blog/20161103/213220081.png\" alt=\"mark\"></p>\r\n<h1 id=\"h1--\"><a name=\"二、三大循环结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、三大循环结构</h1><blockquote>\r\n<p>for循环、while循环、do…while循环。这三大循环在所有的编程语言中几乎都存在。这三种循环本质上是一样的，只是在语法上稍有不同。</p>\r\n<p>另外，<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>为了提高遍历对象的属性和数组元素的性能，增加了for-in循环，待面向对象阶段再细讲。</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-1-for-\"><a name=\"2.1 for循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 for循环</h2><blockquote>\r\n<p>语法：</p>\r\n</blockquote>\r\n<pre><code>for(表达式1; 表达式2; 表达式3){\r\n    //循环体\r\n}\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>for循环开始执行，==首先执行表达式1==，表达式1一般是对循环变量做初始化的操作。表达式1在整个for循环执行期间只会执行一次。</li><li>表达式1执行完毕后==开始执行表达式2==，如果表达式2最终的结果是true(或者可以通过Boolean()转化函数转换为true)，则开始执行循环体。如果表达式2最终的结果是false，则循环语句结束。</li><li>循环执行完毕之后，开始执行表达式3，表达式3一般是对循环做自增或自减的操作。</li><li>表达式3执行完毕后，继续执行表达式2。继续上面第2步的操作。</li></ol>\r\n<blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ul>\r\n<li><strong>3个表达式的都可以省略。</strong></li><li><strong>对表达式1和表达式3省略，对for循环没有任何影响，只是少执行了代码而已。</strong></li><li><strong>如果表达式2省略，表示此处为true，那么这个循环就是死循环。</strong></li><li><strong>如果第一次检查表达式2的时候就是false，则循环体内的代码可能一次也不执行。</strong></li></ul>\r\n<h2 id=\"h2-2-2-while-\"><a name=\"2.2 while循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 while循环</h2><blockquote>\r\n<p>语法：</p>\r\n</blockquote>\r\n<pre><code>while(condition){\r\n  // 循环体\r\n}\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>先判断condition是true还是false，如果是true，则执行循环体，循环体执行完毕，再次判断condition</li><li>如果condition为false，则结束循环。</li></ol>\r\n<blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ul>\r\n<li>condition不能省略。如果省略为语法错误</li><li>while循环也有可能一次也不执行。</li></ul>\r\n<h2 id=\"h2-2-3-do-while-\"><a name=\"2.3 do…while循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 do…while循环</h2><blockquote>\r\n<p>语法：</p>\r\n</blockquote>\r\n<pre><code>do{\r\n  //循环体\r\n}while(condition);\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>先执行循环体。</li><li>循环体执行结束后，去判断condition，如果condition是true，则再次执行循环体，否则循环结束。</li></ol>\r\n<blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ul>\r\n<li>condition条件不能省略，省略语法错误。</li><li>由于先执行在判断，所以，对do…while 循环来说，循环体至少执行一次。</li></ul>\r\n<h2 id=\"h2-2-4-\"><a name=\"2.4 三大循环比较\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 三大循环比较</h2><blockquote>\r\n<p>从本质上来讲，三大循环都可以完成相同的工作。其实一个for循环可以适应所有的需要循环的场景。但是，有些地方用某个可能更方便一些。</p>\r\n<p>从实际情况来看，大部分人更新换用for，比如我。</p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">循环结构</th>\r\n<th style=\"text-align:center\">特点和用途</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\">for</td>\r\n<td style=\"text-align:center\">一般用于精确控制循环次数的场景。</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">while</td>\r\n<td style=\"text-align:center\">不能提前知道循环次数</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">do…while</td>\r\n<td style=\"text-align:center\">不能提前知道循环次数，且循环体的代码至少执行一次的场景</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h1 id=\"h1--\"><a name=\"三、 两个特殊的流程控制语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、 两个特殊的流程控制语句</h1><blockquote>\r\n<p>在循环内部，有的时候需要提前结束循环，或者结束本轮循环进入下一轮循环，就需要用到两个特殊的控制语句：break和continue</p>\r\n</blockquote>\r\n<h2 id=\"h2-3-1-break-\"><a name=\"3.1 break语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 break语句</h2><blockquote>\r\n<p>把break语句放入到循环中，代表提前结束循环。</p>\r\n</blockquote>\r\n<pre><code>for (var i = 0; i &lt; 5; i++) {\r\n  if(i == 3){ \r\n    break;  // 如果i == 3 则直接结束循环(跳出循环)，不会再执行以后的代码。 也不会去执行i++和判断i&lt;5 \r\n  }\r\n  document.write(i + &quot; &quot;);\r\n}\r\n//结果输出：0 1 2\r\n</code></pre><h2 id=\"h2-3-2-continue-\"><a name=\"3.2 continue语句\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 continue语句</h2><blockquote>\r\n<p>把continue语句放在循环中，表示提前结束本轮循环，不在执行循环体内剩下的代码，而是继续执行for中的表达式3或while中的条件。</p>\r\n</blockquote>\r\n<pre><code>for (var i = 0; i &lt; 5; i++) {\r\n  if(i == 3){ \r\n    //如果i == 3，执行conintue语句，则提前结束本轮循环，不再执行循环体剩下的代码。直接去执行i++，然后判断，开启\r\n    //下一轮循环。\r\n    continue;\r\n  }\r\n  document.write(i + &quot; &quot;);\r\n}\r\n</code></pre><p></div></p>\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>', '68', '\r\n\r\n# 一、为什么需要循环\r\n\r\n![mark](http://o7cqr8cfk.bkt.clouddn.com/blog/20161103/213220081.png)\r\n\r\n# 二、三大循环结构\r\n\r\n> for循环、while循环、do…while循环。这三大循环在所有的编程语言中几乎都存在。这三种循环本质上是一样的，只是在语法上稍有不同。\r\n> \r\n> 另外，[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")为了提高遍历对象的属性和数组元素的性能，增加了for-in循环，待面向对象阶段再细讲。\r\n\r\n## 2.1 for循环\r\n\r\n> 语法：\r\n\r\n```\r\nfor(表达式1; 表达式2; 表达式3){\r\n    //循环体\r\n}\r\n```\r\n\r\n> 说明：\r\n\r\n1.  for循环开始执行，==首先执行表达式1==，表达式1一般是对循环变量做初始化的操作。表达式1在整个for循环执行期间只会执行一次。\r\n2.  表达式1执行完毕后==开始执行表达式2==，如果表达式2最终的结果是true(或者可以通过Boolean()转化函数转换为true)，则开始执行循环体。如果表达式2最终的结果是false，则循环语句结束。\r\n3.  循环执行完毕之后，开始执行表达式3，表达式3一般是对循环做自增或自减的操作。\r\n4.  表达式3执行完毕后，继续执行表达式2。继续上面第2步的操作。\r\n\r\n> 注意：\r\n\r\n*   **3个表达式的都可以省略。**\r\n*   **对表达式1和表达式3省略，对for循环没有任何影响，只是少执行了代码而已。**\r\n*   **如果表达式2省略，表示此处为true，那么这个循环就是死循环。**\r\n*   **如果第一次检查表达式2的时候就是false，则循环体内的代码可能一次也不执行。**\r\n\r\n\r\n\r\n## 2.2 while循环\r\n\r\n> 语法：\r\n\r\n```\r\nwhile(condition){\r\n  // 循环体\r\n}\r\n```\r\n\r\n> 说明：\r\n\r\n1.  先判断condition是true还是false，如果是true，则执行循环体，循环体执行完毕，再次判断condition\r\n2.  如果condition为false，则结束循环。\r\n\r\n> 注意：\r\n\r\n*   condition不能省略。如果省略为语法错误\r\n*   while循环也有可能一次也不执行。\r\n\r\n\r\n## 2.3 do…while循环\r\n\r\n> 语法：\r\n\r\n```\r\ndo{\r\n  //循环体\r\n}while(condition);\r\n```\r\n\r\n> 说明：\r\n\r\n1.  先执行循环体。\r\n2.  循环体执行结束后，去判断condition，如果condition是true，则再次执行循环体，否则循环结束。\r\n\r\n> 注意：\r\n\r\n*   condition条件不能省略，省略语法错误。\r\n*   由于先执行在判断，所以，对do…while 循环来说，循环体至少执行一次。\r\n\r\n\r\n## 2.4 三大循环比较\r\n\r\n> 从本质上来讲，三大循环都可以完成相同的工作。其实一个for循环可以适应所有的需要循环的场景。但是，有些地方用某个可能更方便一些。\r\n> \r\n> 从实际情况来看，大部分人更新换用for，比如我。\r\n\r\n| 循环结构 | 特点和用途 |\r\n| :-: | :-: |\r\n| for | 一般用于精确控制循环次数的场景。 |\r\n| while | 不能提前知道循环次数 |\r\n| do…while | 不能提前知道循环次数，且循环体的代码至少执行一次的场景 |\r\n\r\n# 三、 两个特殊的流程控制语句\r\n\r\n> 在循环内部，有的时候需要提前结束循环，或者结束本轮循环进入下一轮循环，就需要用到两个特殊的控制语句：break和continue\r\n\r\n## 3.1 break语句\r\n\r\n> 把break语句放入到循环中，代表提前结束循环。\r\n\r\n```\r\nfor (var i = 0; i < 5; i++) {\r\n  if(i == 3){ \r\n    break;  // 如果i == 3 则直接结束循环(跳出循环)，不会再执行以后的代码。 也不会去执行i++和判断i<5 \r\n  }\r\n  document.write(i + \" \");\r\n}\r\n//结果输出：0 1 2\r\n```\r\n\r\n## 3.2 continue语句\r\n\r\n> 把continue语句放在循环中，表示提前结束本轮循环，不在执行循环体内剩下的代码，而是继续执行for中的表达式3或while中的条件。\r\n\r\n```\r\nfor (var i = 0; i < 5; i++) {\r\n  if(i == 3){ \r\n    //如果i == 3，执行conintue语句，则提前结束本轮循环，不再执行循环体剩下的代码。直接去执行i++，然后判断，开启\r\n    //下一轮循环。\r\n    continue;\r\n  }\r\n  document.write(i + \" \");\r\n}\r\n```\r\n\r\n</div>\r\n\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>');
INSERT INTO `article_info_true` VALUES ('51', 'js函数', '<h1 id=\"h1--\"><a name=\"一、 函数概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、 函数概述</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 函数的概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 函数的概念</h2><blockquote>\r\n<p>函数就是把完成特定功能的一段代码封装起来。给该功能起一个名字（函数名）。</p>\r\n<p>哪里需要实现该功能就在哪里调用该函数。</p>\r\n<p>函数可以在任何时间任何地方调用。</p>\r\n</blockquote>\r\n<ul>\r\n<li><p>函数是完成某一功能的代码段</p>\r\n</li><li><p>函数是可重复执行的代码段</p>\r\n</li><li><p>函数方便管理和维护 便于复用</p>\r\n</li></ul>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 函数的作用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 函数的作用</h2><ul>\r\n<li>使程序变得更简短而清晰</li><li>有利于程序维护</li><li>可以提高程序开发的效率</li><li>提高了代码的重用性(复用性）</li></ul>\r\n<h1 id=\"h1--\"><a name=\"二、自定义函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、自定义函数</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 函数的声明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 函数的声明</h2><blockquote>\r\n<p>函数声明也叫函数定义。</p>\r\n<p>使用函数，必须要先定义。</p>\r\n<p>语法:</p>\r\n</blockquote>\r\n<pre><code>function 函数名(形式参数1, 形式参数2, ...){\r\n   //函数体  \r\n}\r\n</code></pre><blockquote>\r\n<p>说明:</p>\r\n</blockquote>\r\n<ol>\r\n<li>function 是定义函数用到的关键字，必须存在，不能省略。这个单词的所有字母必须小写。</li><li>函数名是为了能让这个函数在别的地方调用。</li><li>函数名的后面必须跟一对圆括号()。</li><li>圆括号内根据需要可以声明形参，定义形参的时候只需要参数名，而不要var来声明。形参的个数不固定，根<br>据需要，可以有多个形参，也可以一个也没有。(圆括号内的形参有时候我们也称之为形参列表)</li><li>圆括号后面跟一对大括号{ },表示函数代码的开始和结束。圆括号内写我们要执行的一系列的代码，这一系列的<br>代码我们称之为函数体。</li><li>函数体内可以根据需要决定是否添加return语句。return语句表示给方法的调用者返回一个值。 总体来说<br>return语句有两个作用：1、给调用者返回值 2、结束函数(只要碰到return语句，不管代码执行到了什么地<br>方，也不管进入了多少层循环，那么方法都会立即执行，并返回)。</li><li>return语句的语法是：return 返回值; 返回值可以省略，表示仅仅结束函数。</li><li><p>如果省略return语句或者有return但是没有返回值，这个时候，返回的是undefined</p>\r\n<blockquote>\r\n<p>注意:</p>\r\n<ul>\r\n<li>如果仅仅声明了函数，而没有在别的任何地方使用这个函数，则这个函数永远不会执行。</li><li>使用函数，我们称之为函数调用。</li><li>永远记住这句话: <strong>函数只有被调用才能被执行</strong><br>函数声明实例：</li></ul>\r\n</blockquote>\r\n</li></ol>\r\n<pre><code>/*\r\n  声明一个函数    \r\n  功能：实现两个数的相加，并返回结果    \r\n  num1：第一个数    \r\n  num2：第二个数    \r\n*/\r\nfunction add(num1, num2){ //add是方法名。  num1和num2是形式参数   \r\n  var sum = num1 + num2; //声明一个变量，来存储num1和num2的相加的值    \r\n  return sum; //使用return语句返回结果   \r\n}\r\n\r\n//其中函数体的代码，也可以简化一行代码\r\nfunction add(num1, num2){\r\n  return num1 + num2;  // 直接返回num1 + num2这个表达式。则会自动计算，并返回计算的结果\r\n}\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 函数的调用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 函数的调用</h2><blockquote>\r\n<p>函数只有被调用才能被执行。所以，如果要让函数内的代码执行，则必须先调用。</p>\r\n<p>函数调用语法：</p>\r\n</blockquote>\r\n<pre><code>方法名(实参1，实参2);\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li><p>调用方法的时候，方法名是必须的。而且方法名是找到已定义的函数的唯一识别。<br>函数调用时，方法名后面的一对圆括号不能省略。</p>\r\n</li><li><p>实参(实际参数)列表，对应着函数声明的形参列表部分。传递的实参，会被形参接受，然后就可以在函数内部<br>使用了。</p>\r\n</li><li><p>可以用一个变量去存储方法执行完毕之后的返回值。</p>\r\n</li></ol>\r\n<blockquote>\r\n<p>函数调用实例:</p>\r\n</blockquote>\r\n<pre><code>//利用方法名 add 去调用。  5 和 10是实参，会传递给方法声明的形参： num1和num2。\r\nvar sum = add(5, 10);  //重新定义一个变量sum来接受方法的返回值。\r\nalert(sum);\r\n//可以多次调用同一个函数，通过传入不同的参数来计算不同的值。我们定义的函数中的代码就完成了复用\r\nalert(add(10, 20));\r\n</code></pre><h2 id=\"h2-2-3-\"><a name=\"2.3 函数的命名规范\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 函数的命名规范</h2><blockquote>\r\n<p>函数名是一个函数非常重要的特征，为了方便调用者调用函数，函数的命名必须遵循一定的规范。</p>\r\n</blockquote>\r\n<ol>\r\n<li><p>不能使用系统的关键字和保留字</p>\r\n</li><li><p>命名要有意义：见名知意。从方法名应该可以大致推测到这个方法的功能。不要起诸如a、b这些没有意义的方<br>法名，</p>\r\n</li><li><p>业界多采用驼峰命名法来给函数命名。驼峰命名法：首字母小写，其余单词的首字母大写。例如：add、<br>onCreate、doSomething。(xxxYyyZzz)</p>\r\n</li><li><p>函数的命名是严格区分大小写的。比如：add和Add是两个完全不同的函数名。</p>\r\n</li><li><p>注意：声明函数时，如果后定义的函数名与前面定义的函数名重复了，则后定义的会覆盖前定义的。</p>\r\n</li></ol>\r\n<h1 id=\"h1--\"><a name=\"三、函数的参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、函数的参数</h1><blockquote>\r\n<p>在大部分编程语言中，函数的参数都分为两种：</p>\r\n<p>1、声明时的参数是形参(用于接收值)</p>\r\n<p>2、调用方法的时候传递的参数是实参(用于把值传递给形参)</p>\r\n<p><strong>==但是，对于<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>这门弱类型语言，对函数参数的处理方面与别的强类型语言有很大不同，且灵活了很多：==</strong></p>\r\n</blockquote>\r\n<ol>\r\n<li>形参声明不需要var。( 因为所有的变量都是用var来声明，所以这个地方省略了没啥问题。添加var会出现语法<br>错误 )</li><li>形参，在函数内部可以作为一个普通的局部变量使用。而且通常情况下，实参已经把值赋值给了形参。例如上<br>面例子中的num1和num2在方法内部就可以作为一个普通的局部变量使用。</li><li>在调用函数的时候，实参的个数可以形参的个数一致，也可以不一致。实参可以比实参的个数多，也可以比实<br>参的个数少。</li><li>形参和实参匹配的时候总是按照顺序匹配。</li><li>函数对传入的实参，既不做类型的检查，也不做个数的检查。如果需要这些检查，需要开发者自行实现代码完<br>成</li></ol>\r\n<blockquote>\r\n<p>示例代码:</p>\r\n</blockquote>\r\n<pre><code>//  声明一个函数，形参的个数2个\r\nfunction doSomething(num1, num2){\r\n  alert(num1 + &quot;:&quot; + num2); //  num1和num2，在方法的内部可以作为普通的局部变量使用。  \r\n}\r\n\r\n//调用函数：把 5 传递给num1， 把 &quot;a&quot; 传递给num2\r\ndoSomething(5, &quot;a&quot;);    // 弹出：5:a\r\n\r\n//调用函数：把 &quot;a&quot; 传递给num1， 把 “b” 传递给num2 .&quot;c&quot;没有形参接受。\r\ndoSomething(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); //虽然比形参的个数多，但是仍然可以正常调用。\r\n\r\n//调用函数：把 &quot;a&quot;传递给num1.\r\ndoSomething(&quot;a&quot;); //虽然比形参的个数少，但是仍然可以正常调用\r\n\r\n1、在通过实参给形参传递参数的时候，如果实参的个数比形参少，则接收不到值的形参的初始化值为 undefined 的。\r\n2、传递的实参比形参多的时候，多余的实参没有形参接受，正常情况下无法访问到传递过来的多余的实参。\r\n3、其实多余的实参并没有丢失，函数帮我们保存在了一个变量(对象)中。这个变量的名字就是 arguments。\r\n4、arguments不需要开发者手动创建，在调用函数的时候，会自动创建，并把传递过来的所有实参的值都保存在这个变量中。\r\n5、可以暂时把arguments当成一个数组来理解，虽然他实际并不是一个数组。(其实是个对象，每个参数都是他的一个属性值)。\r\n</code></pre><blockquote>\r\n<p>arguments使用代码简单实例:</p>\r\n<p>关于数组的详细使用，明天再讲。</p>\r\n</blockquote>\r\n<pre><code>function doSomething (num1, num2) {\r\n  alert(num1 === arguments[0]);  //true \r\n  alert(num2 === arguments[1]); // true\r\n  /*\r\n    只要方法被调用，则一定会自动创建一个arguments对象，这个对象会存储传过来的所有的实参。\r\n  */\r\n  for (var i = 0; i &lt; arguments.length; i++) {\r\n    alert(arguments[i]);\r\n  }\r\n}\r\ndoSomething(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);\r\n</code></pre><h1 id=\"h1--\"><a name=\"四、 变量的作用域\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、 变量的作用域</h1><blockquote>\r\n<p>变量的作用域指的是，变量起作用的范围。也就是能访问到变量的有效范围。</p>\r\n<p>JavaScript的变量依据作用域的范围可以分为：</p>\r\n<ul>\r\n<li>全局变量</li><li>局部变量</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-4-1-\"><a name=\"4.1 全局变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 全局变量</h2><blockquote>\r\n<p><strong>==定义在函数外部的变量都是全局变量。==</strong></p>\r\n<p>全局变量的作用域是<strong>==当前文档==</strong>，也就是当前文档所有的JavaScript脚本都可以访问到这个变量。</p>\r\n<p>下面的代码是书写在同一个HTML文档中的2个JavaScript脚本:</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //定义了一个全局变量。那么这个变量在当前html页面的任何的JS脚本部分都可以访问到。\r\n    var v = 20; \r\n    alert(v); //弹出：20\r\n&lt;/script&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //因为v是全局变量，所以这里仍然可以访问到。\r\n    alert(v);  //弹出：20\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>再看下面一段代码 :</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    alert(a);\r\n    var a = 20;\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>运行这段代码并不会报错， alert(a); 这行代码弹出：undefined。</p>\r\n</blockquote>\r\n<p><strong>为什么在声明 a 之前可以访问变量 a 呢? 能访问 a 为什么输出是undefined而不是20呢？</strong></p>\r\n<p><strong>==声明提前！==</strong></p>\r\n<ul>\r\n<li>所有的全局变量的声明都会提前到JavaScript的前端声明。也就是所有的全局变量都是先声明的，并且早于其他一切代码。</li><li>但是变量的赋值的位置并不会变，仍然在原位置赋值。</li></ul>\r\n<blockquote>\r\n<p>所以上面的代码等效下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var a; //声明提前\r\n    alert(a);\r\n    a = 20; //赋值仍然在原来的位置\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-2-\"><a name=\"4.2 局部变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 局部变量</h2><blockquote>\r\n<p>在函数内声明的变量，叫局部变量！表示形参的变量也是局部变量！</p>\r\n<p>局部变量的作用域是局部变量所在的整个函数的内部。 在函数的外部不能访问局部变量。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function f(){\r\n        alert(v);  //   弹出：undefined\r\n        var v = &quot;abc&quot;;  // 声明局部变量。局部变量也会声明提前到函数的最顶端。\r\n        alert(v);   //  弹出：abc\r\n    }\r\n    alert(v);  //报错。因为变量v没有定义。 方法 f 的外部是不能访问方法内部的局部变量 v 的。\r\n &lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-3-\"><a name=\"4.3 全局变量和局部变量的一些细节\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 全局变量和局部变量的一些细节</h2><blockquote>\r\n<p>看下面一段代码:</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var m = 10;\r\n    function f(){\r\n        var m = 20;\r\n        alert(&quot;方法内部：&quot; + m);  //代码1\r\n    }\r\n    f();\r\n    alert(&quot;方法外部：&quot; + m); //代码2\r\n&lt;/script&gt;\r\n</code></pre><p><em>在方法内部访问m，访问到的是哪个m呢？局部变量的m还是全局变量的m？</em></p>\r\n<h3 id=\"h3-4-3-1-\"><a name=\"4.3.1 全局变量和局部变量重名问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.1 全局变量和局部变量重名问题</h3><ol>\r\n<li>在上面的代码中，当局部变量与全局变量重名时，<strong>局部变量的作用域会覆盖全局变量的作用域。</strong>也就是说在函数内部访问重名变量时，访问的是局部变量。==所以 “代码1” 部分输出的是20。==</li><li>当函数返回离开局部变量的作用域后，又回到全局变量的作用域。==所以代码2输出10。==</li><li>如何在函数访问同名的全局变量呢？==通过：window.全局变量名==</li></ol>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var m = 10;\r\n    function f(){\r\n        var m = 20;\r\n        alert(window.m);  //访问同名的全局变量。其实这个时候相当于在访问window这个对象的属性。\r\n    }\r\n    f();  \r\n&lt;/script&gt;\r\n</code></pre><h3 id=\"h3-4-3-2-javascript-\"><a name=\"4.3.2 JavaScript中有没有块级作用域？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.2 JavaScript中有没有块级作用域？</h3><blockquote>\r\n<p>看下面一段代码:</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  var m = 5;\r\n  if(m == 5){\r\n    var n = 10;\r\n  }\r\n  alert(n); //代码1\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>代码1输出什么？ undefined还是10？还是报错？</p>\r\n<p><strong>==输出10！==</strong></p>\r\n</blockquote>\r\n<ul>\r\n<li><strong>JavaScript的作用域是按照函数来划分的</strong></li><li><strong>==JavaScript没有块级作用域==</strong></li></ul>\r\n<p><em>在上面的代码中，变量 n 虽然是在 if 语句内声明的，但是它仍然是全局变量，而不是局部变量。</em></p>\r\n<p><em>只有定义在方法内部的变量才是局部变量</em></p>\r\n<blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ul>\r\n<li>即使我们把变量的声明放在 if、for等块级语句内，也会进行==声明提前==的操作！</li></ul>\r\n<h1 id=\"h1--\"><a name=\"五、匿名函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、匿名函数</h1><h2 id=\"h2-5-1-\"><a name=\"5.1 声明匿名函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 声明匿名函数</h2><blockquote>\r\n<p>匿名函数是指没有函数名的函数。</p>\r\n<p>看下面一段代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    /*\r\n    //这里定义了一个函数，而且没有函数名。这样写语法是错误的,如果允许这样定义，那么根本就没有办法调用。\r\n    //所以，我们可以用一个变量来存储一下\r\n    function(){ \r\n\r\n    }\r\n    */\r\n  // 声明了一个匿名函数，并把匿名函数赋值给变量f。 注意这个时候这个匿名函数并没有执行。\r\n  var f = function(){\r\n    alert(&quot;哥们我是匿名函数内的代码&quot;);\r\n  }\r\n  //我们可以把变量 f 当做一个函数名来调用\r\n  f();  //调用上面定义的匿名函数\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>匿名函数除了没有函数名之外，其他与普通的函数没有任何区别。</li><li>如果想在别的地方调用匿名函数，则应该声明一个变量，并把匿名函数赋值给这个变量</li><li>可以把这个变量名做为函数名来调用。参数传递，方法返回值和普通的函数一样。</li></ol>\r\n<h2 id=\"h2-5-2-\"><a name=\"5.2 匿名函数的作用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 匿名函数的作用</h2><ol>\r\n<li>函数表达式可以存储在变量中，变量也可以作为一个函数使用。</li><li>可以将匿名函数作为参数传递给其他函数</li></ol>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  //声明一个函数，参数接受一个函数\r\n  function fun1 (fun) {\r\n    if(typeof fun == &quot;function&quot;){   //如果传递的是function类型，则调用这个函数\r\n      fun()\r\n    }\r\n  }\r\n  // 调用函数fun1，并传入一个匿名函数实参\r\n  fun1(function () {\r\n    alert(&quot;这个是匿名函数的代码&quot;)\r\n  });\r\n&lt;/script&gt;\r\n</code></pre><ol>\r\n<li><p>可以通过匿名函数完成某些一次性的任务。</p>\r\n<ul>\r\n<li>如果一个函数不需要重复执行，则可以定义一个匿名函数</li></ul>\r\n</li></ol>\r\n<h2 id=\"h2-5-3-\"><a name=\"5.3 匿名函数立即执行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 匿名函数立即执行</h2><blockquote>\r\n<p>有些场景，我们需要定义完函数之后立即执行，这个时候可以定义一个匿名函数来完成。</p>\r\n</blockquote>\r\n<pre><code>(function () {\r\n    alert(&quot;匿名函数立即执行&quot;)\r\n})();\r\n</code></pre><blockquote>\r\n<p>说明</p>\r\n</blockquote>\r\n<ol>\r\n<li>需要把匿名函数用一对圆括号括起来，把匿名函数作为一个整体来对待</li><li>最后再添加一对圆括号表示调用函数。这样定义的匿名函数就会立即执行</li><li>当然，这个时候即使给这个函数加上方法名，也可以调用。不过这种情况为什么还要加方法名呢?</li></ol>\r\n<h1 id=\"h1--\"><a name=\"六、函数重载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、函数重载</h1><h2 id=\"h2-6-1-javascript-\"><a name=\"6.1 JavaScript支持重载吗?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1 JavaScript支持重载吗?</h2><blockquote>\r\n<p>重载在通常的面向对象语言中这样定义：</p>\r\n<ol>\r\n<li>方法名相同</li><li>参数列表不同</li></ol>\r\n<p>满足这两个条件的函数就构成重载。</p>\r\n<p>在JavaScript中，如果两个函数的名字相同，那么后定义的函数会覆盖先定义的函数。</p>\r\n<p>所以，<strong>==JavaScript不能完成通常意义的重载！JavaScript不支持重载==</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  // 定义一个add函数\r\n  function add (num1, num2) {\r\n    alert(&quot;两个参数的函数...&quot;);\r\n    return num1 + num2;\r\n  }\r\n  //函数名和上面定义的函数名相同，所以会覆盖上面的函数\r\n  function add (num1, num2, num3) {\r\n    alert(&quot;三个参数的函数&quot;);\r\n    return num1 + num2 + num3;\r\n  }\r\n  add(1, 2, 3);  //调用3个参数的函数    返回6\r\n  add(1, 2);    //调用3个参数的函数     返回undefined\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-6-2-\"><a name=\"6.2 模拟重载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2 模拟重载</h2><blockquote>\r\n<p>虽然JavaScript不支持重载，但是我们可以通过一定的手动模拟出重载</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  function add () {\r\n    var sum = 0;\r\n    for (var i = 0; i &lt; arguments.length; i++) {\r\n      sum += arguments[i];\r\n    }\r\n    return sum;\r\n  }\r\n  alert(add(2, 3));\r\n  alert(add(5, 6, 10));\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"七、函数的递归调用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、函数的递归调用</h1><blockquote>\r\n<p>递归调用是指的，在函数的内部调用当前函数。即自己调用自己。</p>\r\n<p>使用递归一定要满足下面条件，否则很容易出现死循环。</p>\r\n</blockquote>\r\n<ol>\r\n<li>一定要有结束条件。</li><li>随着递归的深入，应该逐步靠近结束条件。(结束条件也好收敛)</li></ol>\r\n<blockquote>\r\n<p>递归案例：计算一个数的阶乘</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function jieCheng (num) {\r\n        if(num == 1){\r\n            return 1;\r\n        }\r\n        //递归调用\r\n        return jieCheng(num - 1) * num;\r\n    }\r\n    alert(jieCheng(6));\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"八、几个常用的内置函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>八、几个常用的内置函数</h1><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/blog/20161125/173425927.png\" alt=\"mark\"></p>\r\n<p></div></p>\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>', '69', '\r\n# 一、 函数概述\r\n\r\n## 1.1 函数的概念\r\n\r\n> 函数就是把完成特定功能的一段代码封装起来。给该功能起一个名字（函数名）。\r\n> \r\n> 哪里需要实现该功能就在哪里调用该函数。\r\n> \r\n> 函数可以在任何时间任何地方调用。\r\n\r\n*   函数是完成某一功能的代码段\r\n\r\n*   函数是可重复执行的代码段\r\n\r\n*   函数方便管理和维护 便于复用\r\n\r\n## 1.2 函数的作用\r\n\r\n*   使程序变得更简短而清晰\r\n*   有利于程序维护\r\n*   可以提高程序开发的效率\r\n*   提高了代码的重用性(复用性）\r\n\r\n# 二、自定义函数\r\n\r\n## 2.1 函数的声明\r\n\r\n> 函数声明也叫函数定义。\r\n> \r\n> 使用函数，必须要先定义。\r\n> \r\n> 语法:\r\n\r\n```\r\nfunction 函数名(形式参数1, 形式参数2, ...){\r\n   //函数体  \r\n}\r\n```\r\n\r\n> 说明:\r\n\r\n1.  function 是定义函数用到的关键字，必须存在，不能省略。这个单词的所有字母必须小写。\r\n2.  函数名是为了能让这个函数在别的地方调用。\r\n3.  函数名的后面必须跟一对圆括号()。\r\n4.  圆括号内根据需要可以声明形参，定义形参的时候只需要参数名，而不要var来声明。形参的个数不固定，根\r\n    据需要，可以有多个形参，也可以一个也没有。(圆括号内的形参有时候我们也称之为形参列表)\r\n5.  圆括号后面跟一对大括号{ },表示函数代码的开始和结束。圆括号内写我们要执行的一系列的代码，这一系列的\r\n    代码我们称之为函数体。\r\n6.  函数体内可以根据需要决定是否添加return语句。return语句表示给方法的调用者返回一个值。 总体来说\r\n    return语句有两个作用：1、给调用者返回值 2、结束函数(只要碰到return语句，不管代码执行到了什么地\r\n    方，也不管进入了多少层循环，那么方法都会立即执行，并返回)。\r\n7.  return语句的语法是：return 返回值; 返回值可以省略，表示仅仅结束函数。\r\n8.  如果省略return语句或者有return但是没有返回值，这个时候，返回的是undefined\r\n\r\n    > 注意:\r\n    > \r\n    > *   如果仅仅声明了函数，而没有在别的任何地方使用这个函数，则这个函数永远不会执行。\r\n    > *   使用函数，我们称之为函数调用。\r\n    > *   永远记住这句话: **函数只有被调用才能被执行**\r\n    >     函数声明实例：\r\n\r\n```\r\n/*\r\n  声明一个函数    \r\n  功能：实现两个数的相加，并返回结果    \r\n  num1：第一个数    \r\n  num2：第二个数    \r\n*/\r\nfunction add(num1, num2){ //add是方法名。  num1和num2是形式参数   \r\n  var sum = num1 + num2; //声明一个变量，来存储num1和num2的相加的值    \r\n  return sum; //使用return语句返回结果   \r\n}\r\n\r\n//其中函数体的代码，也可以简化一行代码\r\nfunction add(num1, num2){\r\n  return num1 + num2;  // 直接返回num1 + num2这个表达式。则会自动计算，并返回计算的结果\r\n}\r\n```\r\n\r\n## 2.2 函数的调用\r\n\r\n> 函数只有被调用才能被执行。所以，如果要让函数内的代码执行，则必须先调用。\r\n> \r\n> 函数调用语法：\r\n\r\n```\r\n方法名(实参1，实参2);\r\n```\r\n\r\n> 说明：\r\n\r\n1.  调用方法的时候，方法名是必须的。而且方法名是找到已定义的函数的唯一识别。\r\n    函数调用时，方法名后面的一对圆括号不能省略。\r\n\r\n2.  实参(实际参数)列表，对应着函数声明的形参列表部分。传递的实参，会被形参接受，然后就可以在函数内部\r\n    使用了。\r\n\r\n3.  可以用一个变量去存储方法执行完毕之后的返回值。\r\n\r\n> 函数调用实例:\r\n\r\n```\r\n//利用方法名 add 去调用。  5 和 10是实参，会传递给方法声明的形参： num1和num2。\r\nvar sum = add(5, 10);  //重新定义一个变量sum来接受方法的返回值。\r\nalert(sum);\r\n//可以多次调用同一个函数，通过传入不同的参数来计算不同的值。我们定义的函数中的代码就完成了复用\r\nalert(add(10, 20));\r\n```\r\n\r\n## 2.3 函数的命名规范\r\n\r\n> 函数名是一个函数非常重要的特征，为了方便调用者调用函数，函数的命名必须遵循一定的规范。\r\n\r\n1.  不能使用系统的关键字和保留字\r\n\r\n2.  命名要有意义：见名知意。从方法名应该可以大致推测到这个方法的功能。不要起诸如a、b这些没有意义的方\r\n    法名，\r\n\r\n3.  业界多采用驼峰命名法来给函数命名。驼峰命名法：首字母小写，其余单词的首字母大写。例如：add、\r\n    onCreate、doSomething。(xxxYyyZzz)\r\n\r\n4.  函数的命名是严格区分大小写的。比如：add和Add是两个完全不同的函数名。\r\n\r\n5.  注意：声明函数时，如果后定义的函数名与前面定义的函数名重复了，则后定义的会覆盖前定义的。\r\n\r\n# 三、函数的参数\r\n\r\n> 在大部分编程语言中，函数的参数都分为两种：\r\n> \r\n> 1、声明时的参数是形参(用于接收值)\r\n> \r\n> 2、调用方法的时候传递的参数是实参(用于把值传递给形参)\r\n> \r\n> **==但是，对于[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")这门弱类型语言，对函数参数的处理方面与别的强类型语言有很大不同，且灵活了很多：==**\r\n\r\n1.  形参声明不需要var。( 因为所有的变量都是用var来声明，所以这个地方省略了没啥问题。添加var会出现语法\r\n    错误 )\r\n2.  形参，在函数内部可以作为一个普通的局部变量使用。而且通常情况下，实参已经把值赋值给了形参。例如上\r\n    面例子中的num1和num2在方法内部就可以作为一个普通的局部变量使用。\r\n3.  在调用函数的时候，实参的个数可以形参的个数一致，也可以不一致。实参可以比实参的个数多，也可以比实\r\n    参的个数少。\r\n4.  形参和实参匹配的时候总是按照顺序匹配。\r\n5.  函数对传入的实参，既不做类型的检查，也不做个数的检查。如果需要这些检查，需要开发者自行实现代码完\r\n    成\r\n\r\n> 示例代码:\r\n\r\n```\r\n//  声明一个函数，形参的个数2个\r\nfunction doSomething(num1, num2){\r\n  alert(num1 + \":\" + num2); //  num1和num2，在方法的内部可以作为普通的局部变量使用。  \r\n}\r\n\r\n//调用函数：把 5 传递给num1， 把 \"a\" 传递给num2\r\ndoSomething(5, \"a\");    // 弹出：5:a\r\n\r\n//调用函数：把 \"a\" 传递给num1， 把 “b” 传递给num2 .\"c\"没有形参接受。\r\ndoSomething(\"a\", \"b\", \"c\"); //虽然比形参的个数多，但是仍然可以正常调用。\r\n\r\n//调用函数：把 \"a\"传递给num1.\r\ndoSomething(\"a\"); //虽然比形参的个数少，但是仍然可以正常调用\r\n\r\n1、在通过实参给形参传递参数的时候，如果实参的个数比形参少，则接收不到值的形参的初始化值为 undefined 的。\r\n2、传递的实参比形参多的时候，多余的实参没有形参接受，正常情况下无法访问到传递过来的多余的实参。\r\n3、其实多余的实参并没有丢失，函数帮我们保存在了一个变量(对象)中。这个变量的名字就是 arguments。\r\n4、arguments不需要开发者手动创建，在调用函数的时候，会自动创建，并把传递过来的所有实参的值都保存在这个变量中。\r\n5、可以暂时把arguments当成一个数组来理解，虽然他实际并不是一个数组。(其实是个对象，每个参数都是他的一个属性值)。\r\n```\r\n\r\n> arguments使用代码简单实例:\r\n> \r\n> 关于数组的详细使用，明天再讲。\r\n\r\n```\r\nfunction doSomething (num1, num2) {\r\n  alert(num1 === arguments[0]);  //true \r\n  alert(num2 === arguments[1]); // true\r\n  /*\r\n    只要方法被调用，则一定会自动创建一个arguments对象，这个对象会存储传过来的所有的实参。\r\n  */\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    alert(arguments[i]);\r\n  }\r\n}\r\ndoSomething(\"a\", \"b\", \"c\", \"d\");\r\n```\r\n\r\n# 四、 变量的作用域\r\n\r\n> 变量的作用域指的是，变量起作用的范围。也就是能访问到变量的有效范围。\r\n> \r\n> JavaScript的变量依据作用域的范围可以分为：\r\n> \r\n> *   全局变量\r\n> *   局部变量\r\n\r\n## 4.1 全局变量\r\n\r\n> **==定义在函数外部的变量都是全局变量。==**\r\n> \r\n> 全局变量的作用域是**==当前文档==**，也就是当前文档所有的JavaScript脚本都可以访问到这个变量。\r\n> \r\n> 下面的代码是书写在同一个HTML文档中的2个JavaScript脚本:\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //定义了一个全局变量。那么这个变量在当前html页面的任何的JS脚本部分都可以访问到。\r\n    var v = 20; \r\n    alert(v); //弹出：20\r\n</script>\r\n<script type=\"text/javascript\">\r\n    //因为v是全局变量，所以这里仍然可以访问到。\r\n    alert(v);  //弹出：20\r\n</script>\r\n```\r\n\r\n> 再看下面一段代码 :\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    alert(a);\r\n    var a = 20;\r\n</script>\r\n```\r\n\r\n> 运行这段代码并不会报错， alert(a); 这行代码弹出：undefined。\r\n\r\n**为什么在声明 a 之前可以访问变量 a 呢? 能访问 a 为什么输出是undefined而不是20呢？**\r\n\r\n**==声明提前！==**\r\n\r\n*   所有的全局变量的声明都会提前到JavaScript的前端声明。也就是所有的全局变量都是先声明的，并且早于其他一切代码。\r\n*   但是变量的赋值的位置并不会变，仍然在原位置赋值。\r\n\r\n> 所以上面的代码等效下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var a; //声明提前\r\n    alert(a);\r\n    a = 20; //赋值仍然在原来的位置\r\n</script>\r\n```\r\n\r\n## 4.2 局部变量\r\n\r\n> 在函数内声明的变量，叫局部变量！表示形参的变量也是局部变量！\r\n> \r\n> 局部变量的作用域是局部变量所在的整个函数的内部。 在函数的外部不能访问局部变量。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function f(){\r\n        alert(v);  //   弹出：undefined\r\n        var v = \"abc\";  // 声明局部变量。局部变量也会声明提前到函数的最顶端。\r\n        alert(v);   //  弹出：abc\r\n    }\r\n    alert(v);  //报错。因为变量v没有定义。 方法 f 的外部是不能访问方法内部的局部变量 v 的。\r\n </script>\r\n```\r\n\r\n## 4.3 全局变量和局部变量的一些细节\r\n\r\n> 看下面一段代码:\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var m = 10;\r\n    function f(){\r\n        var m = 20;\r\n        alert(\"方法内部：\" + m);  //代码1\r\n    }\r\n    f();\r\n    alert(\"方法外部：\" + m); //代码2\r\n</script>\r\n```\r\n\r\n_在方法内部访问m，访问到的是哪个m呢？局部变量的m还是全局变量的m？_\r\n\r\n### 4.3.1 全局变量和局部变量重名问题\r\n\r\n1.  在上面的代码中，当局部变量与全局变量重名时，**局部变量的作用域会覆盖全局变量的作用域。**也就是说在函数内部访问重名变量时，访问的是局部变量。==所以 “代码1” 部分输出的是20。==\r\n2.  当函数返回离开局部变量的作用域后，又回到全局变量的作用域。==所以代码2输出10。==\r\n3.  如何在函数访问同名的全局变量呢？==通过：window.全局变量名==\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var m = 10;\r\n    function f(){\r\n        var m = 20;\r\n        alert(window.m);  //访问同名的全局变量。其实这个时候相当于在访问window这个对象的属性。\r\n    }\r\n    f();  \r\n</script>\r\n```\r\n\r\n### 4.3.2 JavaScript中有没有块级作用域？\r\n\r\n> 看下面一段代码:\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  var m = 5;\r\n  if(m == 5){\r\n    var n = 10;\r\n  }\r\n  alert(n); //代码1\r\n</script>\r\n```\r\n\r\n> 代码1输出什么？ undefined还是10？还是报错？\r\n> \r\n> **==输出10！==**\r\n\r\n*   **JavaScript的作用域是按照函数来划分的**\r\n*   **==JavaScript没有块级作用域==**\r\n\r\n_在上面的代码中，变量 n 虽然是在 if 语句内声明的，但是它仍然是全局变量，而不是局部变量。_\r\n\r\n_只有定义在方法内部的变量才是局部变量_\r\n\r\n> 注意：\r\n\r\n*   即使我们把变量的声明放在 if、for等块级语句内，也会进行==声明提前==的操作！\r\n\r\n# 五、匿名函数\r\n\r\n## 5.1 声明匿名函数\r\n\r\n> 匿名函数是指没有函数名的函数。\r\n> \r\n> 看下面一段代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    /*\r\n    //这里定义了一个函数，而且没有函数名。这样写语法是错误的,如果允许这样定义，那么根本就没有办法调用。\r\n    //所以，我们可以用一个变量来存储一下\r\n    function(){ \r\n\r\n    }\r\n    */\r\n  // 声明了一个匿名函数，并把匿名函数赋值给变量f。 注意这个时候这个匿名函数并没有执行。\r\n  var f = function(){\r\n    alert(\"哥们我是匿名函数内的代码\");\r\n  }\r\n  //我们可以把变量 f 当做一个函数名来调用\r\n  f();  //调用上面定义的匿名函数\r\n</script>\r\n```\r\n\r\n> 说明：\r\n\r\n1.  匿名函数除了没有函数名之外，其他与普通的函数没有任何区别。\r\n2.  如果想在别的地方调用匿名函数，则应该声明一个变量，并把匿名函数赋值给这个变量\r\n3.  可以把这个变量名做为函数名来调用。参数传递，方法返回值和普通的函数一样。\r\n\r\n## 5.2 匿名函数的作用\r\n\r\n1.  函数表达式可以存储在变量中，变量也可以作为一个函数使用。\r\n2.  可以将匿名函数作为参数传递给其他函数\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  //声明一个函数，参数接受一个函数\r\n  function fun1 (fun) {\r\n    if(typeof fun == \"function\"){   //如果传递的是function类型，则调用这个函数\r\n      fun()\r\n    }\r\n  }\r\n  // 调用函数fun1，并传入一个匿名函数实参\r\n  fun1(function () {\r\n    alert(\"这个是匿名函数的代码\")\r\n  });\r\n</script>\r\n```\r\n\r\n1.  可以通过匿名函数完成某些一次性的任务。\r\n\r\n    *   如果一个函数不需要重复执行，则可以定义一个匿名函数\r\n\r\n## 5.3 匿名函数立即执行\r\n\r\n> 有些场景，我们需要定义完函数之后立即执行，这个时候可以定义一个匿名函数来完成。\r\n\r\n```\r\n(function () {\r\n    alert(\"匿名函数立即执行\")\r\n})();\r\n```\r\n\r\n> 说明\r\n\r\n1.  需要把匿名函数用一对圆括号括起来，把匿名函数作为一个整体来对待\r\n2.  最后再添加一对圆括号表示调用函数。这样定义的匿名函数就会立即执行\r\n3.  当然，这个时候即使给这个函数加上方法名，也可以调用。不过这种情况为什么还要加方法名呢?\r\n\r\n# 六、函数重载\r\n\r\n## 6.1 JavaScript支持重载吗?\r\n\r\n> 重载在通常的面向对象语言中这样定义：\r\n> \r\n> 1.  方法名相同\r\n> 2.  参数列表不同\r\n> \r\n> 满足这两个条件的函数就构成重载。\r\n> \r\n> 在JavaScript中，如果两个函数的名字相同，那么后定义的函数会覆盖先定义的函数。\r\n> \r\n> 所以，**==JavaScript不能完成通常意义的重载！JavaScript不支持重载==**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  // 定义一个add函数\r\n  function add (num1, num2) {\r\n    alert(\"两个参数的函数...\");\r\n    return num1 + num2;\r\n  }\r\n  //函数名和上面定义的函数名相同，所以会覆盖上面的函数\r\n  function add (num1, num2, num3) {\r\n    alert(\"三个参数的函数\");\r\n    return num1 + num2 + num3;\r\n  }\r\n  add(1, 2, 3);  //调用3个参数的函数    返回6\r\n  add(1, 2);    //调用3个参数的函数     返回undefined\r\n</script>\r\n```\r\n\r\n## 6.2 模拟重载\r\n\r\n> 虽然JavaScript不支持重载，但是我们可以通过一定的手动模拟出重载\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  function add () {\r\n    var sum = 0;\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      sum += arguments[i];\r\n    }\r\n    return sum;\r\n  }\r\n  alert(add(2, 3));\r\n  alert(add(5, 6, 10));\r\n</script>\r\n```\r\n\r\n# 七、函数的递归调用\r\n\r\n> 递归调用是指的，在函数的内部调用当前函数。即自己调用自己。\r\n> \r\n> 使用递归一定要满足下面条件，否则很容易出现死循环。\r\n\r\n1.  一定要有结束条件。\r\n2.  随着递归的深入，应该逐步靠近结束条件。(结束条件也好收敛)\r\n\r\n> 递归案例：计算一个数的阶乘\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function jieCheng (num) {\r\n        if(num == 1){\r\n            return 1;\r\n        }\r\n        //递归调用\r\n        return jieCheng(num - 1) * num;\r\n    }\r\n    alert(jieCheng(6));\r\n</script>\r\n```\r\n\r\n# 八、几个常用的内置函数\r\n\r\n![mark](http://o7cqr8cfk.bkt.clouddn.com/blog/20161125/173425927.png)\r\n\r\n</div>\r\n\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>');
INSERT INTO `article_info_true` VALUES ('52', 'js数组', '<h1 id=\"h1--\"><a name=\"一、 数组的概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、 数组的概念</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 什么是数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 什么是数组</h2><blockquote>\r\n<p>数组是指的数据的有序列表。</p>\r\n</blockquote>\r\n<ol>\r\n<li>数组中每个值称之为数组的一个元素。</li><li>数组中的每个元素都有一个位置，这个位置称之为索引(下标、index)。<strong>数组的索引是从 0 开始的</strong></li><li>同一个数组中，元素的类型不做任何限制。也就是说，同一个数组中可以放Number、String、Boolean、Object对象等等。可以同时放入任何的类型。甚至数组中的元素可以是另外一个数组(构成多维数组)。</li></ol>\r\n<h2 id=\"h2-1-2-javascript-\"><a name=\"1.2 JavaScript中数组的特点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 JavaScript中数组的特点</h2><blockquote>\r\n<p>虽然每种语言都有数组这种<a href=\"http://lib.csdn.net/base/datastructure\" title=\"算法与数据结构知识库\">数据结构</a>，但是<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>的数组相比他们有很大不同。</p>\r\n</blockquote>\r\n<ol>\r\n<li>数组长度可以动态改变。</li><li>同一个数组中可以存储不同的数据类型。</li><li>数据的有序集合</li><li>每个数组都有一个<strong>length</strong>属性，表示的是数组中元素的个数</li></ol>\r\n<h1 id=\"h1--\"><a name=\"二、数组的创建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、数组的创建</h1><blockquote>\r\n<p>数组有两种基本创建方式：字面量方式和构造函数</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-1-\"><a name=\"2.1 字面量的方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 字面量的方式</h2><blockquote>\r\n<p>数组字面量： 所有的元素用方括号括起来，不同的元素之间用逗号分隔。</p>\r\n<p>例如：[“a”, 5, “b”]</p>\r\n</blockquote>\r\n<pre><code>\r\n//创建一个长度为 3 的数组，并初始化了3 个元素：&quot;abc&quot; &quot;b&quot; &quot;d&quot;\r\nvar colors = [&quot;abc&quot;, &quot;b&quot;, &quot;d&quot;];\r\n//创建一个长度为 0 的空数组数组。里面一个值都没有\r\nvar colors = [];\r\n//不要在最后一个元素的后面添加逗号，添加逗号虽然语法没有问题，但是在不同的浏览器可能得到不同的结果\r\nvar colors = [5, 6, 7,]; //这样数组的长度可能为 3 也可能为 4。在不同浏览器会得到不同的结果应避免这种创建方式。\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 构造函数的方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 构造函数的方式</h2><blockquote>\r\n<p>构造函数在创建对象的时候使用。数组的构造函数式 Array()</p>\r\n<p>例如： new Array(数组长度);</p>\r\n</blockquote>\r\n<pre><code>//创建一个长度为 0 的空数组\r\nvar colors = new Array();\r\n//创建一个长度为 5 的数组。注意这个时候，只是这个数组的length属性是5，但是数组是这样的：  []  初始值也不是undefined的。\r\nvar colors = new Array(5);\r\n//创建一个长度为 3 的数组，并且3个元素分别是 &quot;blue&quot; &quot;red&quot; &quot;green&quot;\r\nvar colors = new Array(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;);\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ol>\r\n<li>使用构造函数创建数组对象的时候，最后一个元素后面不要添加括号，否则报错。 这样是错误的：<del>new Array(“a”, )</del></li><li>使用构造函数如果只传入了一个Number值，则这个值必须 &gt;= 0, 否则会报错。</li><li>使用构造函数创建数组对象的时候，new 关键字是可以省略的。 例如：Array(5) 这样是可以的。</li></ol>\r\n<h1 id=\"h1--\"><a name=\"三、访问和修改数组中的元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、访问和修改数组中的元素</h1><blockquote>\r\n<p>利用索引访问数组中的元素。</p>\r\n<p>如果数组的长度为 5，那么数组的索引为 0,1,2,3,4</p>\r\n</blockquote>\r\n<pre><code>//创建一个长度为 5 的数据\r\nvar arr = [10, 20, 60, 5, 7];\r\nalert(arr[0]);  //获取下标为 0 的元素，  即：10\r\nalert(arr[2]);  //获取下标为 2 的元素，  即：60\r\n\r\n//\r\narr[1] = 100;  //把下标为 1 的元素赋值为100。\r\n</code></pre><h1 id=\"h1--\"><a name=\"四、数组的长度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、数组的长度</h1><h2 id=\"h2-4-1-\"><a name=\"4.1 获取数组的长度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 获取数组的长度</h2><blockquote>\r\n<p>每个数组都有一个叫 <strong>length</strong>的属性，表示数组的长度(即：元素的个数)。</p>\r\n</blockquote>\r\n<pre><code>var arr = [10, 20, 60, 5, 7];\r\nalert(arr.length);  //弹出：5\r\n</code></pre><h2 id=\"h2-4-2-\"><a name=\"4.2 修改数组的长度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 修改数组的长度</h2><blockquote>\r\n<p>在一般的强类型语言中，数组的长度是固定的，即：数组一旦创建成功，则不能改变数组的长度。</p>\r\n<p><strong>但是，JavaScript是一种弱类型的动态语言，数组的长度可以在程序运行期间根据需要进行动态的更改</strong></p>\r\n<p>==数组length属性不是只读，而是可以修改的。==</p>\r\n</blockquote>\r\n<ol>\r\n<li>通过设置length的值直接修改数组的长度到指定的数值。</li></ol>\r\n<pre><code>var arr = [&quot;a&quot;, 8, &quot;bc&quot;]; //数组的长度为 3 \r\narr.length = 6; // 修改数组的长度为 6 \r\nalert(arr.length);  //数组的长度已经被修改为了 6 ，所以此处输出6.\r\n// 下标为 3， 4， 5 的元素的值为undefined的。\r\nalert(arr[3]);  //弹出：undefined的。\r\n\r\narr.length = 2; // 修改数组的长度为 2 ，则下标为 &gt;= 的元素被自动从数组移除。\r\n</code></pre><ol>\r\n<li>通过给最后一个元素赋值来动态修改元素的长度。</li></ol>\r\n<pre><code>var arr = [4, 6, 8];\r\n// 给下标为 10 的元素赋值为 100\\.  由于最初长度为 3 ，这个赋值操作完成后，数组的长度会自动增长为11\r\narr[10] = 100;\r\nalert(arr.length);  // 弹出：11\r\n// 没有赋值的元素默认都为 undefined\r\nalert(arr[5]); //弹出：undefined\r\n\r\nalert(arr[20]); //弹出： undefined\r\nalert(arr.length); // 长度仍然为11\\.  上一行代码仅仅去访问元素，而没有赋值操作，则不会引起数组长度的变化\r\n</code></pre><h1 id=\"h1--\"><a name=\"五、数组的遍历\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、数组的遍历</h1><blockquote>\r\n<p>一般有3种方法遍历数组:</p>\r\n<ol>\r\n<li>for循环</li><li>for… in</li><li>for each ( ES5 新增)</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-5-1-for-\"><a name=\"5.1 使用普通for循环遍历数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 使用普通for循环遍历数组</h2><pre><code>var arr = [50, 20, 10, 5, 15, 6];       \r\nfor(var i = 0; i &lt; arr.length; i++){    //数组长度多长，就遍历多少次。  循环变量作为数组的下标\r\n  console.log(arr[i]);\r\n}\r\n</code></pre><h2 id=\"h2-5-2-for-in-\"><a name=\"5.2 使用 for…in 循环遍历数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 使用 for…in 循环遍历数组</h2><blockquote>\r\n<p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性和数组的元素。</p>\r\n<p>示例：</p>\r\n</blockquote>\r\n<pre><code>var arr = [50, 20, 10, 5, 15, 6];\r\n// 每循环一轮，都会把数组的下标赋值给变量index，然后num就拿到了每个元素的下标。 \r\n//注意:这里index是元素的下标,不是与元素\r\n//对数组来说，index从从0开始顺序获取下标\r\nfor (var index in arr) {\r\n  console.log(num);  //循环输出： 0 1 2 3 4 5\r\n}\r\n//这里var 关键字也是可以省略的，但是不建议省略。\r\nfor(i in arr){\r\n  console.log(arr[i]);\r\n}\r\n</code></pre><h2 id=\"h2-5-3-for-each-\"><a name=\"5.3 使用for …each遍历数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 使用for …each遍历数组</h2><blockquote>\r\n<p>ES5为每个数组新增了一个方法 array.forEach(function) ,使用这个方法，可以自动帮我们遍历数组中的所有元素</p>\r\n</blockquote>\r\n<pre><code>var arr = [50, 20, 10, 5, 15, 6];\r\n//调用数组的forEach方法，传入一个匿名函数\r\n//匿名函数接受两个参数：   参数1--迭代遍历的那个元素  参数2：迭代遍历的那个元素的下标\r\n//可以在匿名函数内部书需要的代码\r\narr.forEach( function(element, index) {\r\n  alert(element);\r\n});\r\n</code></pre><h1 id=\"h1--\"><a name=\"六、 数组常用方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、 数组常用方法</h1><h2 id=\"h2-6-1-\"><a name=\"6.1 转换方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1 转换方法</h2><blockquote>\r\n<p>toString()转换方法:</p>\r\n<ul>\r\n<li>返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串</li></ul>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  var arr = [50, 20, 10, 5, 15, 6];\r\n  alert(arr.toString());  //  50,20,10,5,15,6\r\n  alert(arr);  //  50,20,10,5,15,6   当把一个对象直接给alert，则会调用这个对象的toString方法，然后再输出。\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>join() 方法：</p>\r\n<ul>\r\n<li>toString() 方法只能使用逗号连接，而 join() 方法可以使用指定的连接符连接</li></ul>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var arr = [50, 20, 10, 5, 15, 6];\r\n    alert(arr.join(&quot;=&quot;));   //  50=20=10=5=15=6\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-6-2-\"><a name=\"6.2 栈方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2 栈方法</h2><blockquote>\r\n<p><em>栈：一种数据结构。特点：FILO (先进后出)</em></p>\r\n<p><em>向栈中存入元素 称之为 入栈(push)、从栈中移除元素称之为出栈(pop)。先入栈的元素在栈地下，后入栈的元素在栈顶。这两个动作都是对栈顶的元素进行操作。一般栈提供这两个操作足矣。</em></p>\r\n</blockquote>\r\n<ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-5/24708225.jpg\" alt=\"\"></li></ul>\r\n<blockquote>\r\n<p><strong>JavaScript中，支持像操作栈一样去操作数组。</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  var arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];\r\n  //向栈中添加元素(最后添加的元素肯定在栈顶)   数组中的元素：&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;志玲&quot;   \r\n  var len = arr.push(&quot;志玲&quot;);   //push方法返回添加成功后的数组的长度\r\n  alert(len);  // 弹出：4\r\n  arr.push(&quot;a&quot;, &quot;b&quot;);  //也可以向在push方法中传入多个参数，这样每个参数都会添加到数组中。  栈顶元素是  &quot;b&quot;\r\n\r\n  //pop出栈，一次只能出栈一个元素\r\n  var item = arr.pop();  //把栈顶的元素从栈(数组)中移除。并返回移除的这个元素\r\n  alert(item); // 弹出：b\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ul>\r\n<li>入栈其实就是把新的元素添加到数组的后面</li><li><p>出栈其实就是把数组中的最后一个元素从数组中移除</p>\r\n<h2 id=\"h2-6-2-\"><a name=\"6.2队列方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2队列方法</h2></li></ul>\r\n<blockquote>\r\n<p><em>队列也是一种数据结构。 特点：FIFO(先进先出)</em></p>\r\n<p>JavaScript中，对数组的操作也提供了模拟队列的方法。</p>\r\n<ol>\r\n<li>向队列头部添加元素(unshift)、从队列头部移除元素(shift)</li><li>向队列尾部添加元素、从队列尾部移除元素</li></ol>\r\n<p><strong>注意：对队列尾部的操作没有提供新的方法，使用push和pop可以完成相应的操作。</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  //把arr当做队列对待，那么 队列头部元素就是 &quot;张三&quot;, 队尾元素就是 &quot;王五&quot;\r\n  var arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];\r\n  var firstItem = arr.shift();  //把队首元素从队列中移除，并返回移除的这个元素\r\n  alert(firstItem); //张三\r\n  alert(arr);  // 李四, 王五\r\n  var len = arr.unshift(&quot;志玲&quot;);  //向队列头部添加元素，并返回添加成功后队列(数组)的长度\r\n  alert(&quot;数组长度：&quot; + len);  // 数组长度：3\r\n  alert(arr);  // 志玲, 李四, 王五\r\n  arr.unshift(&quot;a&quot;, &quot;b&quot;);\r\n  alert(arr);  // a, b, 志玲, 李四, 王五\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-6-3-\"><a name=\"6.3 数组中元素的倒置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3 数组中元素的倒置</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];\r\n    alert(&quot;数组倒置前：&quot; + arr); \r\n    //对数组元素进行倒置。\r\n    arr.reverse();  \r\n    alert(&quot;数组倒置后：&quot; + arr);  \r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ul>\r\n<li><strong>==倒置操作是对原数组本身做了操作，返回的也是原数组对象，并不是一个新创建的数组。==</strong></li></ul>\r\n<h2 id=\"h2-6-4-\"><a name=\"6.4 查找指定元素在数组中的索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.4 查找指定元素在数组中的索引</h2><blockquote>\r\n<p>indexOf(item): 从前面开始向后查找 item 第一次出现的位置</p>\r\n<p>lastIndexOf(item): 从尾部开始向前查找 item 第一次出现的位置</p>\r\n</blockquote>\r\n<ul>\r\n<li>如果找不到元素，则返回 -1</li></ul>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr = [&quot;张三&quot;, &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];\r\n    alert(arr.indexOf(&quot;张三&quot;));  // 0\r\n    alert(arr.lastIndexOf(&quot;张三&quot;));  // 4\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>indexOf(item, fromBack): 从第二个参数的位置开向后始查找 item 第一次出现的位置</p>\r\n<p>lastIndexOf(item, fromForward): 从第二个参数的位置开始向前查找 item 第一次出现的位置</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr = [&quot;张三&quot;, &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;];\r\n    alert(arr.indexOf(&quot;张三&quot;, 2));  // 4\r\n    alert(arr.lastIndexOf(&quot;张三&quot;, 3));  // 1\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-6-4-\"><a name=\"6.4 获取新的数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.4 获取新的数组</h2><blockquote>\r\n<ol>\r\n<li><strong>arr.concat(arrayX,arrayX,……,arrayX)</strong></li></ol>\r\n<p>该方法用于连接两个或多个数组。至少传入一个参数，参数可以是数组也可以是元素。</p>\r\n<p><strong>==注意：该方法是返回的一个新的数组，原数组没有做任何改变==</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];\r\n    //把参数数组与arr1连接起来，并返回连接后的新数组\r\n    var newArr = arr1.concat([&quot;c&quot;, &quot;d&quot;]);\r\n    //新数组的长度是 5\r\n    alert(newArr.length);\r\n    //原数组的长度还是 3  。原数组中的元素没有做任何变化\r\n    alert(arr1.length);\r\n\r\n    //把两个元素和一个数组与原数组arr1连接起来，并返回新的数组\r\n    var newArr2 = arr1.concat(&quot;e&quot;, &quot;f&quot;, [&quot;g&quot;, &quot;h&quot;]);\r\n    //新数组长度为：7\r\n    alert(newArr2.length);  \r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<ol>\r\n<li><strong>arr.slice(start,end) : 截取数组，并返回截取到的新数组</strong></li></ol>\r\n<pre><code>*   start:必须。从原数组中的start位置开始截取**==(包括下标为start的元素)==**。 如果是负数表示从尾部开始截取： -1表示最后一个元素\r\n*   end: 可选。截取到指定位置==**(不包括下标为end的元素)**==。如果没指定，则指的是截取到最后一个元素\r\n*   end要大于start，否则截取不到元素\r\n</code></pre><p><strong>==注意：该方法是返回的一个新的数组，原数组没有做任何改变==</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];\r\n    // 从下标为0的位置开始截取，截取到下标2，但是不包括下标为2的元素. 原数组没有任何的变化\r\n    var newArr = arr1.slice(0, 2);\r\n    alert(newArr);// a, b\r\n    alert(arr1.slice(1, 4)); // b,c,d\r\n    //从下标为2的元素开始截取，一直到最后一个元素\r\n    alert(arr1.slice(2));  //c,d,e,f\r\n    //从倒数第5个元素，截取到倒数第2个\r\n    alert(arr1.slice(-5, -2)); // b c d\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<ol>\r\n<li><strong>arr.splice(index,howmany,item1,…..,itemX) 方法向/从数组中添加/删除元素，然后</strong>==返回被删除的元素组成的数组。==</li></ol>\r\n<pre><code>*   必需。整数，规定添加/删除元素的位置，使用负数可从数组结尾处规定位置。\r\n*   必需。要删除的元素数量。如果设置为 0，则不会删除元素。 如果添加元素这里应该是0\r\n*   可选。向数组添加的新项目。\r\n</code></pre><p><strong>==注意：这个方法会对原数组做出修改。==</strong></p>\r\n<ul>\r\n<li><strong>删除元素</strong></li></ul>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];\r\n    //因为第2个参数不为0，所以表示删除元素：从小标为1的位置开始删除，共删除2个元素。(2个中包括下标为1的元素)\r\n    var deleted = arr1.splice(1, 2);    //返回值为删除的元素组成的数组\r\n    //原数组\r\n    alert(arr1);  // a,d,e,f\r\n    alert(deleted); // b,c\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<ul>\r\n<li><strong>添加元素</strong></li></ul>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr1 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];\r\n    //因为第2参数为0，所以表示添加元素：从下标为1的位置插入元素。其余的元素会自动向后移动\r\n    var v = arr1.splice(1, 0, &quot;m&quot;, &quot;n&quot;);    // 因为是添加元素，所以返回的数组长度为 0\r\n    alert(v.length);  // 0\r\n    alert(arr1);    // a,m,n,b,c,d,e,f\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"七、 数组排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、 数组排序</h1><p>常用排序<a href=\"http://lib.csdn.net/base/datastructure\" title=\"算法与数据结构知识库\">算法</a>：</p>\r\n<p>冒泡、选择、插入</p>\r\n<blockquote>\r\n<p>JavaScript中，所有的数组对象都提供了一个排序函数。</p>\r\n<p>arr.sort(sortby) 方法用于对数组的元素进行排序。</p>\r\n<ul>\r\n<li><em>sortby</em> 可选。规定排序顺序。必须是函数。</li></ul>\r\n</blockquote>\r\n<ol>\r\n<li>不传入参数的时候，是默认的升序排列。但是做升序排列的时候，是把每个元素转换成string之后，按照编码表中的顺序排序的。</li></ol>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;     \r\n    var arr1 = [&quot;a&quot;, &quot;ab&quot;, &quot;fca&quot;, &quot;cd&quot;, &quot;eb&quot;, &quot;f&quot;];\r\n    arr1.sort();    //默认情况按照编码表中的顺序排列\r\n    alert(arr1);    // a, ab, cd, eb, f, fca\r\n\r\n    var arr2 = [10, 8, 6, 20, 30, 15];\r\n    arr2.sort();\r\n    console.alert(arr2); // 10,15,20,30,6,8\r\n&lt;/script&gt;\r\n</code></pre><ol>\r\n<li>从上面可以看出来，当数组中的元素是Number的时候，按照编码表排序并不太符合我们的预期，我们更想按照数字的大小排序。这时，我们可以传递一个 “比较函数”。</li></ol>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    /*\r\n        sort方法进行排序的时候，会调用这个函数，来确定谁大谁小，从而来确定他们的位置。\r\n        排序函数的规则：\r\n        1、比较函数必须具有两个参数  num1, num2\r\n        2、若返回值 &gt; 0, 则认为num1 &gt; num2, 排序的时候num1在num2之后\r\n        3、若返回值 == 0,则认为num1== num2，排序的时候两个数的顺序就保持不变\r\n        4、若返回值 &lt; 0, 则认为num &lt; num2,  排序的时候num1在num2之前。\r\n\r\n        总结：\r\n        1、若num1 &gt; num2 返回 正数， num1 &lt; num2 返回 负数，则是升序\r\n        2、若num1 &gt; num2 返回 负数， num1 &lt; num2 返回 正数，则是降序\r\n    */\r\n    function sortNumber (num1, num2) {\r\n        //升序\r\n        if(num1 &gt; num2){\r\n            return 1;\r\n        }else if(num1 == num2){\r\n            return 0;\r\n        }else {\r\n            return -1;\r\n        }\r\n    }\r\n    var arr2 = [10, 8, 6, 20, 30, 15];\r\n    arr2.sort(sortNumber);\r\n    console.log(arr2.toString());\r\n&lt;/script&gt;\r\n</code></pre><ul>\r\n<li>纯数字的数组，还有一种更简洁的排序函数。</li></ul>\r\n<pre><code>//升序函数\r\nfunction sortAsc(num1, num2){\r\n    return num1 - num2;   //num1 &gt; num2 就返回正数\r\n}\r\n// 降序函数\r\nfunction sortDesc(num1, num2){\r\n    return num2 - num1; //num1 &gt; num2 就返回负数\r\n}\r\n</code></pre><h1 id=\"h1--\"><a name=\"八、 数组检测\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>八、 数组检测</h1><blockquote>\r\n<p>如何检测一个对象是不是一个Array。</p>\r\n<ol>\r\n<li>使用instanceof运算符。</li><li>使用Array.isArray(arr) 方法。</li></ol>\r\n</blockquote>\r\n<h2 id=\"h2-8-1-instanceof-\"><a name=\"8.1 instanceof运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.1 instanceof运算符</h2><blockquote>\r\n<p>JavaScript中instanceof运算符会返回一个 Boolean 值，指出对象是否是特定构造函数的一个实例。</p>\r\n</blockquote>\r\n<pre><code>var arr = [];\r\nalert(arr instanceof Array); //true\r\n</code></pre><h2 id=\"h2-8-2-array-isarray-arr-\"><a name=\"8.2 Array.isArray(arr) 方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.2 Array.isArray(arr) 方法</h2><blockquote>\r\n<p>Array.isArray(arr) , 如果arr是数组，则返回true，否则返回false</p>\r\n</blockquote>\r\n<pre><code>var arr = [];\r\nalert(Array.isArray(arr));  //true\r\nalert(Array.isArray(&quot;abc&quot;));    // false\r\n</code></pre><h1 id=\"h1--\"><a name=\"九、 二维数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>九、 二维数组</h1><blockquote>\r\n<p>如果数组中的元素存储的是数组，则就构成了二维数组。</p>\r\n</blockquote>\r\n<pre><code>//数组中的每个元素都是数组，则就是一个二维数组\r\nvar towDimArr = [\r\n                  [4, 5], \r\n                  [7, 8],\r\n                  [50, 9, 10],\r\n                  [5]\r\n                ];\r\nalert(towDimArr.length); //数组的长度为 4\r\n\r\n//使用嵌套循环来遍历二维数组。\r\nfor (var i = 0; i &lt; towDimArr.length; i++) {\r\n    for (var j = 0; j &lt; towDimArr[i].length; j++) {\r\n      alert(towDimArr[i][j]);\r\n    }\r\n}\r\n</code></pre><p></div></p>\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>', '70', '# 一、 数组的概念\r\n\r\n## 1.1 什么是数组\r\n\r\n> 数组是指的数据的有序列表。\r\n\r\n1.  数组中每个值称之为数组的一个元素。\r\n2.  数组中的每个元素都有一个位置，这个位置称之为索引(下标、index)。**数组的索引是从 0 开始的**\r\n3.  同一个数组中，元素的类型不做任何限制。也就是说，同一个数组中可以放Number、String、Boolean、Object对象等等。可以同时放入任何的类型。甚至数组中的元素可以是另外一个数组(构成多维数组)。\r\n\r\n## 1.2 JavaScript中数组的特点\r\n\r\n> 虽然每种语言都有数组这种[数据结构](http://lib.csdn.net/base/datastructure \"算法与数据结构知识库\")，但是[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")的数组相比他们有很大不同。\r\n\r\n1.  数组长度可以动态改变。\r\n2.  同一个数组中可以存储不同的数据类型。\r\n3.  数据的有序集合\r\n4.  每个数组都有一个**length**属性，表示的是数组中元素的个数\r\n\r\n# 二、数组的创建\r\n\r\n> 数组有两种基本创建方式：字面量方式和构造函数\r\n\r\n## 2.1 字面量的方式\r\n\r\n> 数组字面量： 所有的元素用方括号括起来，不同的元素之间用逗号分隔。\r\n> \r\n> 例如：[“a”, 5, “b”]\r\n\r\n```\r\n\r\n//创建一个长度为 3 的数组，并初始化了3 个元素：\"abc\" \"b\" \"d\"\r\nvar colors = [\"abc\", \"b\", \"d\"];\r\n//创建一个长度为 0 的空数组数组。里面一个值都没有\r\nvar colors = [];\r\n//不要在最后一个元素的后面添加逗号，添加逗号虽然语法没有问题，但是在不同的浏览器可能得到不同的结果\r\nvar colors = [5, 6, 7,]; //这样数组的长度可能为 3 也可能为 4。在不同浏览器会得到不同的结果应避免这种创建方式。\r\n```\r\n\r\n## 2.2 构造函数的方式\r\n\r\n> 构造函数在创建对象的时候使用。数组的构造函数式 Array()\r\n> \r\n> 例如： new Array(数组长度);\r\n\r\n```\r\n//创建一个长度为 0 的空数组\r\nvar colors = new Array();\r\n//创建一个长度为 5 的数组。注意这个时候，只是这个数组的length属性是5，但是数组是这样的：  []  初始值也不是undefined的。\r\nvar colors = new Array(5);\r\n//创建一个长度为 3 的数组，并且3个元素分别是 \"blue\" \"red\" \"green\"\r\nvar colors = new Array(\"blue\", \"red\", \"green\");\r\n```\r\n\r\n> 注意：\r\n\r\n1.  使用构造函数创建数组对象的时候，最后一个元素后面不要添加括号，否则报错。 这样是错误的：~~new Array(\"a\", )~~\r\n2.  使用构造函数如果只传入了一个Number值，则这个值必须 >= 0, 否则会报错。\r\n3.  使用构造函数创建数组对象的时候，new 关键字是可以省略的。 例如：Array(5) 这样是可以的。\r\n\r\n# 三、访问和修改数组中的元素\r\n\r\n> 利用索引访问数组中的元素。\r\n> \r\n> 如果数组的长度为 5，那么数组的索引为 0,1,2,3,4\r\n\r\n```\r\n//创建一个长度为 5 的数据\r\nvar arr = [10, 20, 60, 5, 7];\r\nalert(arr[0]);  //获取下标为 0 的元素，  即：10\r\nalert(arr[2]);  //获取下标为 2 的元素，  即：60\r\n\r\n//\r\narr[1] = 100;  //把下标为 1 的元素赋值为100。\r\n```\r\n\r\n# 四、数组的长度\r\n\r\n## 4.1 获取数组的长度\r\n\r\n> 每个数组都有一个叫 **length**的属性，表示数组的长度(即：元素的个数)。\r\n\r\n```\r\nvar arr = [10, 20, 60, 5, 7];\r\nalert(arr.length);  //弹出：5\r\n```\r\n\r\n## 4.2 修改数组的长度\r\n\r\n> 在一般的强类型语言中，数组的长度是固定的，即：数组一旦创建成功，则不能改变数组的长度。\r\n> \r\n> **但是，JavaScript是一种弱类型的动态语言，数组的长度可以在程序运行期间根据需要进行动态的更改**\r\n> \r\n> ==数组length属性不是只读，而是可以修改的。==\r\n\r\n1.  通过设置length的值直接修改数组的长度到指定的数值。\r\n\r\n```\r\nvar arr = [\"a\", 8, \"bc\"]; //数组的长度为 3 \r\narr.length = 6; // 修改数组的长度为 6 \r\nalert(arr.length);  //数组的长度已经被修改为了 6 ，所以此处输出6.\r\n// 下标为 3， 4， 5 的元素的值为undefined的。\r\nalert(arr[3]);  //弹出：undefined的。\r\n\r\narr.length = 2; // 修改数组的长度为 2 ，则下标为 >= 的元素被自动从数组移除。\r\n```\r\n\r\n1.  通过给最后一个元素赋值来动态修改元素的长度。\r\n\r\n```\r\nvar arr = [4, 6, 8];\r\n// 给下标为 10 的元素赋值为 100\\.  由于最初长度为 3 ，这个赋值操作完成后，数组的长度会自动增长为11\r\narr[10] = 100;\r\nalert(arr.length);  // 弹出：11\r\n// 没有赋值的元素默认都为 undefined\r\nalert(arr[5]); //弹出：undefined\r\n\r\nalert(arr[20]); //弹出： undefined\r\nalert(arr.length); // 长度仍然为11\\.  上一行代码仅仅去访问元素，而没有赋值操作，则不会引起数组长度的变化\r\n```\r\n\r\n# 五、数组的遍历\r\n\r\n> 一般有3种方法遍历数组:\r\n> \r\n> 1.  for循环\r\n> 2.  for… in\r\n> 3.  for each ( ES5 新增)\r\n\r\n## 5.1 使用普通for循环遍历数组\r\n\r\n```\r\nvar arr = [50, 20, 10, 5, 15, 6];       \r\nfor(var i = 0; i < arr.length; i++){    //数组长度多长，就遍历多少次。  循环变量作为数组的下标\r\n  console.log(arr[i]);\r\n}\r\n```\r\n\r\n## 5.2 使用 for…in 循环遍历数组\r\n\r\n> for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性和数组的元素。\r\n> \r\n> 示例：\r\n\r\n```\r\nvar arr = [50, 20, 10, 5, 15, 6];\r\n// 每循环一轮，都会把数组的下标赋值给变量index，然后num就拿到了每个元素的下标。 \r\n//注意:这里index是元素的下标,不是与元素\r\n//对数组来说，index从从0开始顺序获取下标\r\nfor (var index in arr) {\r\n  console.log(num);  //循环输出： 0 1 2 3 4 5\r\n}\r\n//这里var 关键字也是可以省略的，但是不建议省略。\r\nfor(i in arr){\r\n  console.log(arr[i]);\r\n}\r\n```\r\n\r\n## 5.3 使用for …each遍历数组\r\n\r\n> ES5为每个数组新增了一个方法 array.forEach(function) ,使用这个方法，可以自动帮我们遍历数组中的所有元素\r\n\r\n```\r\nvar arr = [50, 20, 10, 5, 15, 6];\r\n//调用数组的forEach方法，传入一个匿名函数\r\n//匿名函数接受两个参数：   参数1--迭代遍历的那个元素  参数2：迭代遍历的那个元素的下标\r\n//可以在匿名函数内部书需要的代码\r\narr.forEach( function(element, index) {\r\n  alert(element);\r\n});\r\n```\r\n\r\n# 六、 数组常用方法\r\n\r\n## 6.1 转换方法\r\n\r\n> toString()转换方法:\r\n> \r\n> *   返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  var arr = [50, 20, 10, 5, 15, 6];\r\n  alert(arr.toString());  //  50,20,10,5,15,6\r\n  alert(arr);  //  50,20,10,5,15,6   当把一个对象直接给alert，则会调用这个对象的toString方法，然后再输出。\r\n</script>\r\n```\r\n\r\n> join() 方法：\r\n> \r\n> *   toString() 方法只能使用逗号连接，而 join() 方法可以使用指定的连接符连接\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var arr = [50, 20, 10, 5, 15, 6];\r\n    alert(arr.join(\"=\"));   //  50=20=10=5=15=6\r\n</script>\r\n```\r\n\r\n## 6.2 栈方法\r\n\r\n> _栈：一种数据结构。特点：FILO (先进后出)_\r\n> \r\n> _向栈中存入元素 称之为 入栈(push)、从栈中移除元素称之为出栈(pop)。先入栈的元素在栈地下，后入栈的元素在栈顶。这两个动作都是对栈顶的元素进行操作。一般栈提供这两个操作足矣。_\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-5/24708225.jpg)\r\n\r\n> **JavaScript中，支持像操作栈一样去操作数组。**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  var arr = [\"张三\", \"李四\", \"王五\"];\r\n  //向栈中添加元素(最后添加的元素肯定在栈顶)   数组中的元素：\"张三\", \"李四\", \"王五\", \"志玲\"   \r\n  var len = arr.push(\"志玲\");   //push方法返回添加成功后的数组的长度\r\n  alert(len);  // 弹出：4\r\n  arr.push(\"a\", \"b\");  //也可以向在push方法中传入多个参数，这样每个参数都会添加到数组中。  栈顶元素是  \"b\"\r\n\r\n  //pop出栈，一次只能出栈一个元素\r\n  var item = arr.pop();  //把栈顶的元素从栈(数组)中移除。并返回移除的这个元素\r\n  alert(item); // 弹出：b\r\n</script>\r\n```\r\n\r\n> 说明：\r\n\r\n*   入栈其实就是把新的元素添加到数组的后面\r\n*   出栈其实就是把数组中的最后一个元素从数组中移除\r\n\r\n    ## 6.2队列方法\r\n\r\n> _队列也是一种数据结构。 特点：FIFO(先进先出)_\r\n> \r\n> JavaScript中，对数组的操作也提供了模拟队列的方法。\r\n> \r\n> 1.  向队列头部添加元素(unshift)、从队列头部移除元素(shift)\r\n> 2.  向队列尾部添加元素、从队列尾部移除元素\r\n> \r\n> **注意：对队列尾部的操作没有提供新的方法，使用push和pop可以完成相应的操作。**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  //把arr当做队列对待，那么 队列头部元素就是 \"张三\", 队尾元素就是 \"王五\"\r\n  var arr = [\"张三\", \"李四\", \"王五\"];\r\n  var firstItem = arr.shift();  //把队首元素从队列中移除，并返回移除的这个元素\r\n  alert(firstItem); //张三\r\n  alert(arr);  // 李四, 王五\r\n  var len = arr.unshift(\"志玲\");  //向队列头部添加元素，并返回添加成功后队列(数组)的长度\r\n  alert(\"数组长度：\" + len);  // 数组长度：3\r\n  alert(arr);  // 志玲, 李四, 王五\r\n  arr.unshift(\"a\", \"b\");\r\n  alert(arr);  // a, b, 志玲, 李四, 王五\r\n</script>\r\n```\r\n\r\n## 6.3 数组中元素的倒置\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr = [\"张三\", \"李四\", \"王五\"];\r\n    alert(\"数组倒置前：\" + arr); \r\n    //对数组元素进行倒置。\r\n    arr.reverse();  \r\n    alert(\"数组倒置后：\" + arr);  \r\n</script>\r\n```\r\n\r\n> 注意：\r\n\r\n*   **==倒置操作是对原数组本身做了操作，返回的也是原数组对象，并不是一个新创建的数组。==**\r\n\r\n## 6.4 查找指定元素在数组中的索引\r\n\r\n> indexOf(item): 从前面开始向后查找 item 第一次出现的位置\r\n> \r\n> lastIndexOf(item): 从尾部开始向前查找 item 第一次出现的位置\r\n\r\n*   如果找不到元素，则返回 -1\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr = [\"张三\", \"张三\", \"李四\", \"王五\", \"张三\", \"李四\", \"王五\"];\r\n    alert(arr.indexOf(\"张三\"));  // 0\r\n    alert(arr.lastIndexOf(\"张三\"));  // 4\r\n</script>\r\n```\r\n\r\n> indexOf(item, fromBack): 从第二个参数的位置开向后始查找 item 第一次出现的位置\r\n> \r\n> lastIndexOf(item, fromForward): 从第二个参数的位置开始向前查找 item 第一次出现的位置\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr = [\"张三\", \"张三\", \"李四\", \"王五\", \"张三\", \"李四\", \"王五\"];\r\n    alert(arr.indexOf(\"张三\", 2));  // 4\r\n    alert(arr.lastIndexOf(\"张三\", 3));  // 1\r\n</script>\r\n```\r\n\r\n## 6.4 获取新的数组\r\n\r\n> 1.  **arr.concat(arrayX,arrayX,……,arrayX)**\r\n> \r\n> 该方法用于连接两个或多个数组。至少传入一个参数，参数可以是数组也可以是元素。\r\n> \r\n> **==注意：该方法是返回的一个新的数组，原数组没有做任何改变==**\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr1 = [\"a\", \"b\", \"c\"];\r\n    //把参数数组与arr1连接起来，并返回连接后的新数组\r\n    var newArr = arr1.concat([\"c\", \"d\"]);\r\n    //新数组的长度是 5\r\n    alert(newArr.length);\r\n    //原数组的长度还是 3  。原数组中的元素没有做任何变化\r\n    alert(arr1.length);\r\n\r\n    //把两个元素和一个数组与原数组arr1连接起来，并返回新的数组\r\n    var newArr2 = arr1.concat(\"e\", \"f\", [\"g\", \"h\"]);\r\n    //新数组长度为：7\r\n    alert(newArr2.length);  \r\n</script>\r\n```\r\n\r\n> 1.  **arr.slice(start,end) : 截取数组，并返回截取到的新数组**\r\n>     \r\n>     \r\n>     *   start:必须。从原数组中的start位置开始截取**==(包括下标为start的元素)==**。 如果是负数表示从尾部开始截取： -1表示最后一个元素\r\n>     *   end: 可选。截取到指定位置==**(不包括下标为end的元素)**==。如果没指定，则指的是截取到最后一个元素\r\n>     *   end要大于start，否则截取不到元素\r\n> \r\n> **==注意：该方法是返回的一个新的数组，原数组没有做任何改变==**\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr1 = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\r\n    // 从下标为0的位置开始截取，截取到下标2，但是不包括下标为2的元素. 原数组没有任何的变化\r\n    var newArr = arr1.slice(0, 2);\r\n    alert(newArr);// a, b\r\n    alert(arr1.slice(1, 4)); // b,c,d\r\n    //从下标为2的元素开始截取，一直到最后一个元素\r\n    alert(arr1.slice(2));  //c,d,e,f\r\n    //从倒数第5个元素，截取到倒数第2个\r\n    alert(arr1.slice(-5, -2)); // b c d\r\n</script>\r\n```\r\n\r\n> 1.  **arr.splice(index,howmany,item1,…..,itemX) 方法向/从数组中添加/删除元素，然后**==返回被删除的元素组成的数组。==\r\n>     \r\n>     \r\n>     *   必需。整数，规定添加/删除元素的位置，使用负数可从数组结尾处规定位置。\r\n>     *   必需。要删除的元素数量。如果设置为 0，则不会删除元素。 如果添加元素这里应该是0\r\n>     *   可选。向数组添加的新项目。\r\n> \r\n> **==注意：这个方法会对原数组做出修改。==**\r\n> \r\n> *   **删除元素**\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr1 = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\r\n    //因为第2个参数不为0，所以表示删除元素：从小标为1的位置开始删除，共删除2个元素。(2个中包括下标为1的元素)\r\n    var deleted = arr1.splice(1, 2);    //返回值为删除的元素组成的数组\r\n    //原数组\r\n    alert(arr1);  // a,d,e,f\r\n    alert(deleted); // b,c\r\n</script>\r\n```\r\n\r\n> *   **添加元素**\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr1 = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\r\n    //因为第2参数为0，所以表示添加元素：从下标为1的位置插入元素。其余的元素会自动向后移动\r\n    var v = arr1.splice(1, 0, \"m\", \"n\");    // 因为是添加元素，所以返回的数组长度为 0\r\n    alert(v.length);  // 0\r\n    alert(arr1);    // a,m,n,b,c,d,e,f\r\n</script>\r\n```\r\n\r\n# 七、 数组排序\r\n\r\n常用排序[算法](http://lib.csdn.net/base/datastructure \"算法与数据结构知识库\")：\r\n\r\n冒泡、选择、插入\r\n\r\n> JavaScript中，所有的数组对象都提供了一个排序函数。\r\n> \r\n> arr.sort(sortby) 方法用于对数组的元素进行排序。\r\n> \r\n> *   _sortby_ 可选。规定排序顺序。必须是函数。\r\n\r\n1.  不传入参数的时候，是默认的升序排列。但是做升序排列的时候，是把每个元素转换成string之后，按照编码表中的顺序排序的。\r\n\r\n```\r\n<script type=\"text/javascript\">     \r\n    var arr1 = [\"a\", \"ab\", \"fca\", \"cd\", \"eb\", \"f\"];\r\n    arr1.sort();    //默认情况按照编码表中的顺序排列\r\n    alert(arr1);    // a, ab, cd, eb, f, fca\r\n\r\n    var arr2 = [10, 8, 6, 20, 30, 15];\r\n    arr2.sort();\r\n    console.alert(arr2); // 10,15,20,30,6,8\r\n</script>\r\n```\r\n\r\n1.  从上面可以看出来，当数组中的元素是Number的时候，按照编码表排序并不太符合我们的预期，我们更想按照数字的大小排序。这时，我们可以传递一个 “比较函数”。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    /*\r\n        sort方法进行排序的时候，会调用这个函数，来确定谁大谁小，从而来确定他们的位置。\r\n        排序函数的规则：\r\n        1、比较函数必须具有两个参数  num1, num2\r\n        2、若返回值 > 0, 则认为num1 > num2, 排序的时候num1在num2之后\r\n        3、若返回值 == 0,则认为num1== num2，排序的时候两个数的顺序就保持不变\r\n        4、若返回值 < 0, 则认为num < num2,  排序的时候num1在num2之前。\r\n\r\n        总结：\r\n        1、若num1 > num2 返回 正数， num1 < num2 返回 负数，则是升序\r\n        2、若num1 > num2 返回 负数， num1 < num2 返回 正数，则是降序\r\n    */\r\n    function sortNumber (num1, num2) {\r\n        //升序\r\n        if(num1 > num2){\r\n            return 1;\r\n        }else if(num1 == num2){\r\n            return 0;\r\n        }else {\r\n            return -1;\r\n        }\r\n    }\r\n    var arr2 = [10, 8, 6, 20, 30, 15];\r\n    arr2.sort(sortNumber);\r\n    console.log(arr2.toString());\r\n</script>\r\n```\r\n\r\n*   纯数字的数组，还有一种更简洁的排序函数。\r\n\r\n```\r\n//升序函数\r\nfunction sortAsc(num1, num2){\r\n    return num1 - num2;   //num1 > num2 就返回正数\r\n}\r\n// 降序函数\r\nfunction sortDesc(num1, num2){\r\n    return num2 - num1; //num1 > num2 就返回负数\r\n}\r\n```\r\n\r\n# 八、 数组检测\r\n\r\n> 如何检测一个对象是不是一个Array。\r\n> \r\n> 1.  使用instanceof运算符。\r\n> 2.  使用Array.isArray(arr) 方法。\r\n\r\n## 8.1 instanceof运算符\r\n\r\n> JavaScript中instanceof运算符会返回一个 Boolean 值，指出对象是否是特定构造函数的一个实例。\r\n\r\n```\r\nvar arr = [];\r\nalert(arr instanceof Array); //true\r\n```\r\n\r\n## 8.2 Array.isArray(arr) 方法\r\n\r\n> Array.isArray(arr) , 如果arr是数组，则返回true，否则返回false\r\n\r\n```\r\nvar arr = [];\r\nalert(Array.isArray(arr));  //true\r\nalert(Array.isArray(\"abc\"));    // false\r\n```\r\n\r\n# 九、 二维数组\r\n\r\n> 如果数组中的元素存储的是数组，则就构成了二维数组。\r\n\r\n```\r\n//数组中的每个元素都是数组，则就是一个二维数组\r\nvar towDimArr = [\r\n                  [4, 5], \r\n                  [7, 8],\r\n                  [50, 9, 10],\r\n                  [5]\r\n                ];\r\nalert(towDimArr.length); //数组的长度为 4\r\n\r\n//使用嵌套循环来遍历二维数组。\r\nfor (var i = 0; i < towDimArr.length; i++) {\r\n    for (var j = 0; j < towDimArr[i].length; j++) {\r\n      alert(towDimArr[i][j]);\r\n    }\r\n}\r\n```\r\n\r\n</div>\r\n\r\n<script type=\"text/javascript\">$(function () { $(\'pre.prettyprint code\').each(function () { var lines = $(this).text().split(\'\\n\').length; var $numbering = $(\'<ul></ul>\').addClass(\'pre-numbering\').hide(); $(this).addClass(\'has-numbering\').parent().append($numbering); for (i = 1; i <= lines; i++) { $numbering.append($(\'<li></li>\').text(i)); }; $numbering.fadeIn(1700); }); });</script>');
INSERT INTO `article_info_true` VALUES ('53', '数组', '<p><img src=\"http://ww3.sinaimg.cn/large/006pQ25sgw1f59x7se1cej30go08ctai.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1. 声明和使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 声明和使用</h3><p>计算某班级30名学生的平均分，创建30个变量很笨拙：mark1、makr2…、makr30，我们可以使用数组来存储。</p>\r\n<p>数组是相同类型的有序集合，用中括号[ ] 进行标记，下面是使用数组的方式：</p>\r\n<ol>\r\n<li>声明数组需要使用名称和类型。推荐使用复数名称，例如marks、rows、numbers等。数组中所有元素属于同一类型。</li><li>初始化数组：</li></ol>\r\n<pre><code>int[] marks;                               // 声明一个int型名称marks的数组\r\nint marks[];                               // 也可以使用这种声明方式，但是推荐使用上一种方式\r\nmarks = new int[5];                        // 使用&quot;new&quot;操作符号，并设置数组长度。\r\nint[] factors = new int[20];               // 声明数组同时设置数组长度\r\nint[] numbers = {11, 22, 33, 44, 55, 66};  // 声明并直接初始化数组\r\n</code></pre><p>使用“new”操作符创建数组，会使用数据类型的默认值初始化各个元素，例如int:0、double:0.0、boolean:false、object:null。</p>\r\n<p>通过封装在中括号的索引访问数组元素，java索引从0开始，例如长度为5的marks数组元素：marks[0]、marks[1]、marks[2]、marks[3]、marks[4]。</p>\r\n<pre><code>int[] marks = new int[5];\r\nmarks[0] = 95;\r\nmarks[1] = 85;\r\nmarks[2] = 77;\r\nmarks[3] = 69;\r\nmarks[4] = 66;\r\nSystem.out.println(marks[0]);\r\nSystem.out.println(marks[3] + marks[4]);\r\n</code></pre><p>创建一个数组，你需要事先定义数组的长度，数组创建后长度是固定不变的，这也是数组的缺点。</p>\r\n<p>java中数组的length属性表示数组的长度。</p>\r\n<pre><code>int[] factors = new int[5];\r\nint numFactors = factors.length;\r\n</code></pre><p>数组的下标从0到数组长度－1。</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_array.gif\" alt=\"array\"></p>\r\n<h3 id=\"h3-2-\"><a name=\"2. 遍历数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 遍历数组</h3><p>通过使用循环来遍历数组的元素。</p>\r\n<pre><code>\r\npublic class MeanStdArray{\r\n    public static void main(String[] args) {\r\n        int[] marks = {74, 43, 58, 60, 90, 64, 70};\r\n\r\n        int sum = 0;\r\n        int sumSq = 0;\r\n        int count = marks.length;\r\n        double mean, stdDev;\r\n\r\n        for (int i=0; i&lt;count; ++i) {\r\n            sum += marks[i];\r\n            sumSq += marks[i]*marks[i];\r\n        }\r\n\r\n        mean = (double)sum/count;\r\n        System.out.printf(&quot;平均值：%.2f%n&quot;, mean);\r\n\r\n        stdDev = Math.sqrt((double)sumSq/count - mean*mean);\r\n        System.out.printf(&quot;平方根：%.2f%n&quot;, stdDev);\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-3-for-loop-jdk-1-5-\"><a name=\"3. 增强的遍历方式for-loop (JDK 1.5)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 增强的遍历方式for-loop (JDK 1.5)</h3><p>JDK1.5中引入了一个新的增强循环语法for－loop：</p>\r\n<p>| 语法 | 例子 |<br>| </p>\r\n<pre><code>for (type item :anArray) {\r\n   body;\r\n}\r\n</code></pre><p> | </p>\r\n<pre><code>int[] numbers = {8, 2, 6, 4, 3};\r\nint sum = 0;\r\nfor (int number : numbers) {\r\n    sum += number;\r\n}\r\nSystem.out.println(&quot;和为：&quot; + sum);\r\n</code></pre><p> |</p>\r\n<h3 id=\"h3-4-\"><a name=\"4. 多维数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 多维数组</h3><p>在Java中你可以使用数组的数组，举例：</p>\r\n<pre><code>int grid[][] = new int[12][8];        // 一个12×8的数组\r\ngrid[0][0] = 8;\r\ngrid[1][1] = 5;\r\nSystem.out.println(grid.length);      // 12\r\nSystem.out.println(grid[0].length);   // 8\r\nSystem.out.println(grid[11].length);  // 8\r\n</code></pre><p>在上面的例子中，数组grid长度为12，每个元素(grid[0]到grid[11])都是长度为8的数组。</p>\r\n<pre><code>public class Array2DTest {\r\n   public static void main(String[] args) {\r\n      int[][] grid = new int[12][8];\r\n      int numRows = grid.length;       // 12\r\n      int numCols = grid[0].length;    // 8\r\n\r\n      // 填充grid\r\n      for (int row = 0; row &lt; numRows; ++row) {\r\n         for (int col = 0; col &lt; numCols; ++col) {\r\n            grid[row][col] = row*numCols + col + 1;\r\n         }\r\n      }\r\n\r\n      // 输出grid\r\n      for (int row = 0; row &lt; numRows; ++row) {\r\n         for (int col = 0; col &lt; numCols; ++col) {\r\n            System.out.printf(&quot;%3d&quot;, grid[row][col]);\r\n         }\r\n         System.out.println();\r\n      }\r\n   }\r\n}\r\n</code></pre><p>Java不像有的编程语言那样通过使用grid[3,2]来声明多维数组，此外数组中的数组可以有不同的长度。</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Array_MultiDimensional.png\" alt=\"Array_MultiDimensional.png\"></p>\r\n<pre><code>public class Array2DWithDifferentLength {\r\n   public static void main(String[] args) {\r\n      int[][] grid = {\r\n         {1, 2},\r\n         {3, 4, 5},\r\n         {6, 7, 8, 9}\r\n      };\r\n\r\n      for (int y = 0; y &lt; grid.length; ++y) {\r\n         for (int x = 0; x &lt; grid[y].length; ++x) {\r\n            System.out.printf(&quot;%2d&quot;, grid[y][x]);\r\n         }\r\n         System.out.println();\r\n      }\r\n\r\n      int[][] grid1 = new int[3][];\r\n      grid1[0] = new int[2];\r\n      grid1[1] = new int[3];\r\n      grid1[2] = new int[4];\r\n\r\n      for (int y = 0; y &lt; grid1.length; ++y) {\r\n         for (int x = 0; x &lt; grid1[y].length; ++x) {\r\n            System.out.printf(&quot;%2d&quot;, grid1[y][x]);\r\n         }\r\n         System.out.println();\r\n      }\r\n   }\r\n}\r\n</code></pre>', '71', '![](http://ww3.sinaimg.cn/large/006pQ25sgw1f59x7se1cej30go08ctai.jpg)\r\n### 1\\. 声明和使用\r\n\r\n计算某班级30名学生的平均分，创建30个变量很笨拙：mark1、makr2...、makr30，我们可以使用数组来存储。\r\n\r\n数组是相同类型的有序集合，用中括号[ ] 进行标记，下面是使用数组的方式：\r\n\r\n1.  声明数组需要使用名称和类型。推荐使用复数名称，例如marks、rows、numbers等。数组中所有元素属于同一类型。\r\n2.  初始化数组：\r\n\r\n```\r\nint[] marks;                               // 声明一个int型名称marks的数组\r\nint marks[];                               // 也可以使用这种声明方式，但是推荐使用上一种方式\r\nmarks = new int[5];                        // 使用\"new\"操作符号，并设置数组长度。\r\nint[] factors = new int[20];               // 声明数组同时设置数组长度\r\nint[] numbers = {11, 22, 33, 44, 55, 66};  // 声明并直接初始化数组\r\n\r\n```\r\n\r\n使用“new”操作符创建数组，会使用数据类型的默认值初始化各个元素，例如int:0、double:0.0、boolean:false、object:null。\r\n\r\n通过封装在中括号的索引访问数组元素，java索引从0开始，例如长度为5的marks数组元素：marks[0]、marks[1]、marks[2]、marks[3]、marks[4]。\r\n\r\n```\r\nint[] marks = new int[5];\r\nmarks[0] = 95;\r\nmarks[1] = 85;\r\nmarks[2] = 77;\r\nmarks[3] = 69;\r\nmarks[4] = 66;\r\nSystem.out.println(marks[0]);\r\nSystem.out.println(marks[3] + marks[4]);\r\n\r\n```\r\n\r\n创建一个数组，你需要事先定义数组的长度，数组创建后长度是固定不变的，这也是数组的缺点。\r\n\r\njava中数组的length属性表示数组的长度。\r\n\r\n```\r\nint[] factors = new int[5];\r\nint numFactors = factors.length; \r\n```\r\n\r\n数组的下标从0到数组长度－1。\r\n\r\n![array](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_array.gif)\r\n\r\n### 2\\. 遍历数组\r\n\r\n通过使用循环来遍历数组的元素。\r\n\r\n```\r\n\r\npublic class MeanStdArray{\r\n    public static void main(String[] args) {\r\n        int[] marks = {74, 43, 58, 60, 90, 64, 70};\r\n\r\n        int sum = 0;\r\n        int sumSq = 0;\r\n        int count = marks.length;\r\n        double mean, stdDev;\r\n\r\n        for (int i=0; i<count; ++i) {\r\n            sum += marks[i];\r\n            sumSq += marks[i]*marks[i];\r\n        }\r\n\r\n        mean = (double)sum/count;\r\n        System.out.printf(\"平均值：%.2f%n\", mean);\r\n\r\n        stdDev = Math.sqrt((double)sumSq/count - mean*mean);\r\n        System.out.printf(\"平方根：%.2f%n\", stdDev);\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 3\\. 增强的遍历方式for-loop (JDK 1.5)\r\n\r\nJDK1.5中引入了一个新的增强循环语法for－loop：\r\n\r\n\r\n\r\n| 语法 | 例子 |\r\n| \r\n\r\n```\r\nfor (type item :anArray) {\r\n   body;\r\n}\r\n\r\n\r\n```\r\n\r\n | \r\n\r\n```\r\nint[] numbers = {8, 2, 6, 4, 3};\r\nint sum = 0;\r\nfor (int number : numbers) {\r\n    sum += number;\r\n}\r\nSystem.out.println(\"和为：\" + sum);\r\n```\r\n\r\n |\r\n\r\n\r\n\r\n### 4\\. 多维数组\r\n\r\n在Java中你可以使用数组的数组，举例：\r\n\r\n```\r\nint grid[][] = new int[12][8];        // 一个12×8的数组\r\ngrid[0][0] = 8;\r\ngrid[1][1] = 5;\r\nSystem.out.println(grid.length);      // 12\r\nSystem.out.println(grid[0].length);   // 8\r\nSystem.out.println(grid[11].length);  // 8\r\n```\r\n\r\n在上面的例子中，数组grid长度为12，每个元素(grid[0]到grid[11])都是长度为8的数组。\r\n\r\n```\r\npublic class Array2DTest {\r\n   public static void main(String[] args) {\r\n      int[][] grid = new int[12][8];\r\n      int numRows = grid.length;       // 12\r\n      int numCols = grid[0].length;    // 8\r\n\r\n      // 填充grid\r\n      for (int row = 0; row < numRows; ++row) {\r\n         for (int col = 0; col < numCols; ++col) {\r\n            grid[row][col] = row*numCols + col + 1;\r\n         }\r\n      }\r\n\r\n      // 输出grid\r\n      for (int row = 0; row < numRows; ++row) {\r\n         for (int col = 0; col < numCols; ++col) {\r\n            System.out.printf(\"%3d\", grid[row][col]);\r\n         }\r\n         System.out.println();\r\n      }\r\n   }\r\n}\r\n```\r\n\r\nJava不像有的编程语言那样通过使用grid[3,2]来声明多维数组，此外数组中的数组可以有不同的长度。\r\n\r\n![Array_MultiDimensional.png](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Array_MultiDimensional.png)\r\n\r\n```\r\npublic class Array2DWithDifferentLength {\r\n   public static void main(String[] args) {\r\n      int[][] grid = {\r\n         {1, 2},\r\n         {3, 4, 5},\r\n         {6, 7, 8, 9}\r\n      };\r\n\r\n      for (int y = 0; y < grid.length; ++y) {\r\n         for (int x = 0; x < grid[y].length; ++x) {\r\n            System.out.printf(\"%2d\", grid[y][x]);\r\n         }\r\n         System.out.println();\r\n      }\r\n\r\n      int[][] grid1 = new int[3][];\r\n      grid1[0] = new int[2];\r\n      grid1[1] = new int[3];\r\n      grid1[2] = new int[4];\r\n\r\n      for (int y = 0; y < grid1.length; ++y) {\r\n         for (int x = 0; x < grid1[y].length; ++x) {\r\n            System.out.printf(\"%2d\", grid1[y][x]);\r\n         }\r\n         System.out.println();\r\n      }\r\n   }\r\n}\r\n```');
INSERT INTO `article_info_true` VALUES ('54', '基本设置', '<p><span style=\"font-size:18px\">由于之前学习JavaSE，大部分时间所使用的编辑器是Windows<a href=\"http://lib.csdn.net/base/operatingsystem\" title=\"操作系统知识库\">操作系统</a>自带的记事本及从网上下载的</span></p>\r\n<p><span style=\"font-size:18px\">Notepad++编辑器，然后使用命令行工具编译和运行的，因此对<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>的Eclipse开发工具不是很了解，这两天就专门看</span></p>\r\n<p><span style=\"font-size:18px\">了一下Eclipse开发工具的使用以及好多自己不知道的用处。</span></p>\r\n<p><span style=\"font-size:18px\">一直以为Eclipse是专门为Java编程语言开发的IDE，然后自己去<span style=\"font-size:18px\">官网上去下载安装包的时候，发现除了为Java编</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"font-size:18px\">程语言，也可以作为其他的编程语言的IDE，比如C++，<a href=\"http://lib.csdn.net/base/php\" title=\"PHP知识库\">PHP</a>等，只要是你想到的编程语言，基本上都可以使用</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"font-size:18px\">Eclipse做开发，因此对于Eclipse更好的定义应该是一个开源的开发平台。</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"font-size:18px\">那么接下来就简单列出一些关于Eclipse关于开发Java编程语言的技巧。</span></span></p>\r\n<h1 id=\"h1-eclipse-\"><a name=\"Eclipse安装注意的问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Eclipse安装注意的问题</h1><h2 id=\"h2--1-workspace-\"><a name=\"(1)工作空间(Workspace)设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(1)工作空间(Workspace)设置</h2><p><span style=\"font-size:18px\">当安装好Eclipse开发工具或者解压好免安装版的Eclipse后，第一次打开时，弹出一个<span style=\"font-size:18px\">Workspace Launcher</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"font-size:18px\">的对话窗口，这是让Select a workspace(选择一个工作空间)，一般不会使用默认的工作空间，自行设置为自</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"font-size:18px\">己想要存放的路径即可。</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622101804846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></span></p>\r\n<p><span style=\"font-size:18px\">(Workspace)工作空间是项目存放的默认位置，会将相关的设置信息与其关联，如果改变工作空间，那么也会改</span></p>\r\n<p><span style=\"font-size:18px\">变相应的配置信息，每一个工作空间都有自己的相关文件夹和配置文件。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622101736313?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?也可以使用File-&gt;Switch WorkSpace切换工作空间，将更改的工作空间的位置改变为：</span></p>\r\n<p><span style=\"font-size:18px\">E:\\Java\\JavaEE\\Demo。如果想要Copy工作空间的配置只需要在下面的两个复选框中打钩即可，如果想要进行对工作</span></p>\r\n<p><span style=\"font-size:18px\">空间的重新配置也是可以的，会生成新的配置文件。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622102130273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h2 id=\"h2--2-workbench-\"><a name=\"(2)工作台(Workbench)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(2)工作台(Workbench)</h2><p><span style=\"font-size:18px\">? ? ? ?Workbench(工作台)指桌面开发环境，提供一系列工具用于操作，管理与导航工作空间中的资源。每个工作台包</span></p>\r\n<p><span style=\"font-size:18px\">含</span><span style=\"font-size:18px\">一个或多个视景(Perspective)。看一下初始化的工作台，以后会进行相关的配置和更改。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622102415893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h1 id=\"h1--eclipse-\"><a name=\"二Eclipse基本设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二Eclipse基本设置</h1><h2 id=\"h2--1-eclipse-\"><a name=\"(1)Eclipse界面简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(1)Eclipse界面简介</h2><p><span style=\"font-size:18px\">Eclipse开发工具的初始化界面和其他的开发并没有什么特别大的改变和不同之处，也是包含标题栏、菜单栏、</span></p>\r\n<p><span style=\"font-size:18px\">工具栏和</span><span style=\"font-size:18px\">默认的视景与视图，在上面的工作台已经见到过。</span></p>\r\n<h2 id=\"h2--2-\"><a name=\"(2)外观样式设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(2)外观样式设置</h2><p><span style=\"font-size:18px\">Eclipse提供了多种外观样式供选择。</span></p>\r\n<p><span style=\"font-size:18px\">可以这样操作：Window-&gt;preferences，在Theme一般选择默认的winodows主题，置于颜色其他设置</span></p>\r\n<p><span style=\"font-size:18px\">保持默认即可。下面选择的主题是Dark主题，这个或许有人喜欢，但是还是喜欢默认的主题。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622102752517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622105827074?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h2 id=\"h2--3-\"><a name=\"(3)字符编码集的设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(3)字符编码集的设置</h2><p><span style=\"font-size:18px\">开发一个项目时，都需要提前指定字符编码集，建议使用UTF-8。Eclipse默认的是GBK编码。</span></p>\r\n<p><span style=\"font-size:18px\">这样操作：<span style=\"font-size:18px\">Window-&gt;preferences-&gt;General-&gt;Workspace，找到最下面的Text file encoding就可以设置字符</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"font-size:18px\">编码集。</span></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622102959597?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622110053190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h2 id=\"h2--4-\"><a name=\"(4)字体与字号的设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(4)字体与字号的设置</h2><p><span style=\"font-size:18px\">这样操作：Window-&gt;preferences-&gt;General-&gt;Appearance-&gt;Colors and Fonts-&gt;Text Font，然后选择Edit选</span></p>\r\n<p><span style=\"font-size:18px\">择弹出字体设置对话框，选择的字体是微软雅黑，字号是16号。效果可以在下面设置完编辑器背景颜色以后</span></p>\r\n<p><span style=\"font-size:18px\">可以看到字体和字号大小。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622103300710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\">然后<br></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622103311647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h2 id=\"h2--5-\"><a name=\"(5)编辑器背景颜色的设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(5)编辑器背景颜色的设置</h2><p><span style=\"font-size:18px\">这样操作：Window-&gt;preferences-&gt;General-&gt;Editors-&gt;Text Editor，找到下面的Appearance color options</span></p>\r\n<p><span style=\"font-size:18px\">中的Background color，去掉默认设置的对勾，然后选择颜色，出现颜色对话框，进行自定义颜色，</span><span style=\"font-family:SimSun; font-size:18px; color:rgb(51,51,51); line-height:28px; text-align:justify\">把色调调</span></p>\r\n<p><span style=\"font-family:SimSun; font-size:18px; color:rgb(51,51,51); line-height:28px; text-align:justify\">成：85 饱和度调成：123 亮度调成205，即可调成豆沙绿色了 然后点确定，最后应用即可。</span></p>\r\n<p><span style=\"font-size:18px\"></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622103608773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622103613586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622104542497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h2 id=\"h2--6-jre-\"><a name=\"(6)JRE的配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(6)JRE的配置</h2><p><span style=\"font-size:18px\">最开始配置Java开发环境时，安装JDK，同时也安装了JRE，那么JRE的版本对Java的支持会不同的效果，</span></p>\r\n<p><span style=\"font-size:18px\">Eclipse有默认JRE，当然也可以配置其他的JRE。</span></p>\r\n<p><span style=\"font-size:18px\">这样操作：Window-&gt;preferences-&gt;Java-&gt;Installed JREs。可以选择不同JDK版本中的JRE，也可以添</span></p>\r\n<p><span style=\"font-size:18px\">加其他版本的JRE，这里就不再演示，使用默认的即可。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622105055843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">目前的系统中只有一个JRE，而且必须是安装的JDK中的JRE。如果有其它的JDK版本，可以向其中<br></span></p>\r\n<p><span style=\"font-size:18px\">添加JRE。</span></p>\r\n<h2 id=\"h2--7-\"><a name=\"(7)编译级别的设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>(7)编译级别的设置</h2><p><span style=\"font-size:18px\">? ? ? ?既然可以更换KRE，那么也就可以调整Java项目的编译级别，最新的Eclipse支持的版本是JDK1.8。比如一</span></p>\r\n<p><span style=\"font-size:18px\">个类的某个方法是在JDK1.5以后才起作用的。那么JDK1.5以前就会编译出错。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160622105554688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?</span></p>\r\n', '73', '<span style=\"font-size:18px\">由于之前学习JavaSE，大部分时间所使用的编辑器是Windows[操作系统](http://lib.csdn.net/base/operatingsystem \"操作系统知识库\")自带的记事本及从网上下载的</span>\r\n\r\n<span style=\"font-size:18px\">Notepad++编辑器，然后使用命令行工具编译和运行的，因此对[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")的Eclipse开发工具不是很了解，这两天就专门看</span>\r\n\r\n<span style=\"font-size:18px\">了一下Eclipse开发工具的使用以及好多自己不知道的用处。</span>\r\n\r\n<span style=\"font-size:18px\">一直以为Eclipse是专门为Java编程语言开发的IDE，然后自己去<span style=\"font-size:18px\">官网上去下载安装包的时候，发现除了为Java编</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"font-size:18px\">程语言，也可以作为其他的编程语言的IDE，比如C++，[PHP](http://lib.csdn.net/base/php \"PHP知识库\")等，只要是你想到的编程语言，基本上都可以使用</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"font-size:18px\">Eclipse做开发，因此对于Eclipse更好的定义应该是一个开源的开发平台。</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"font-size:18px\">那么接下来就简单列出一些关于Eclipse关于开发Java编程语言的技巧。</span></span>\r\n\r\n# Eclipse安装注意的问题\r\n\r\n## (1)工作空间(Workspace)设置\r\n\r\n<span style=\"font-size:18px\">当安装好Eclipse开发工具或者解压好免安装版的Eclipse后，第一次打开时，弹出一个<span style=\"font-size:18px\">Workspace Launcher</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"font-size:18px\">的对话窗口，这是让Select a workspace(选择一个工作空间)，一般不会使用默认的工作空间，自行设置为自</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"font-size:18px\">己想要存放的路径即可。</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622101804846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span></span>\r\n\r\n<span style=\"font-size:18px\">(Workspace)工作空间是项目存放的默认位置，会将相关的设置信息与其关联，如果改变工作空间，那么也会改</span>\r\n\r\n<span style=\"font-size:18px\">变相应的配置信息，每一个工作空间都有自己的相关文件夹和配置文件。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622101736313?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?也可以使用File->Switch WorkSpace切换工作空间，将更改的工作空间的位置改变为：</span>\r\n\r\n<span style=\"font-size:18px\">E:\\Java\\JavaEE\\Demo。如果想要Copy工作空间的配置只需要在下面的两个复选框中打钩即可，如果想要进行对工作</span>\r\n\r\n<span style=\"font-size:18px\">空间的重新配置也是可以的，会生成新的配置文件。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622102130273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n## (2)工作台(Workbench)\r\n\r\n<span style=\"font-size:18px\">? ? ? ?Workbench(工作台)指桌面开发环境，提供一系列工具用于操作，管理与导航工作空间中的资源。每个工作台包</span>\r\n\r\n<span style=\"font-size:18px\">含</span><span style=\"font-size:18px\">一个或多个视景(Perspective)。看一下初始化的工作台，以后会进行相关的配置和更改。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622102415893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n# 二Eclipse基本设置\r\n\r\n## (1)Eclipse界面简介\r\n\r\n<span style=\"font-size:18px\">Eclipse开发工具的初始化界面和其他的开发并没有什么特别大的改变和不同之处，也是包含标题栏、菜单栏、</span>\r\n\r\n<span style=\"font-size:18px\">工具栏和</span><span style=\"font-size:18px\">默认的视景与视图，在上面的工作台已经见到过。</span>\r\n\r\n## (2)外观样式设置\r\n\r\n<span style=\"font-size:18px\">Eclipse提供了多种外观样式供选择。</span>\r\n\r\n<span style=\"font-size:18px\">可以这样操作：Window->preferences，在Theme一般选择默认的winodows主题，置于颜色其他设置</span>\r\n\r\n<span style=\"font-size:18px\">保持默认即可。下面选择的主题是Dark主题，这个或许有人喜欢，但是还是喜欢默认的主题。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622102752517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622105827074?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n## (3)字符编码集的设置\r\n\r\n<span style=\"font-size:18px\">开发一个项目时，都需要提前指定字符编码集，建议使用UTF-8。Eclipse默认的是GBK编码。</span>\r\n\r\n<span style=\"font-size:18px\">这样操作：<span style=\"font-size:18px\">Window->preferences->General->Workspace，找到最下面的Text file encoding就可以设置字符</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"font-size:18px\">编码集。</span></span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622102959597?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622110053190?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n## (4)字体与字号的设置\r\n\r\n<span style=\"font-size:18px\">这样操作：Window->preferences->General->Appearance->Colors and Fonts->Text Font，然后选择Edit选</span>\r\n\r\n<span style=\"font-size:18px\">择弹出字体设置对话框，选择的字体是微软雅黑，字号是16号。效果可以在下面设置完编辑器背景颜色以后</span>\r\n\r\n<span style=\"font-size:18px\">可以看到字体和字号大小。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622103300710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)然后\r\n</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622103311647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n## (5)编辑器背景颜色的设置\r\n\r\n<span style=\"font-size:18px\">这样操作：Window->preferences->General->Editors->Text Editor，找到下面的Appearance color options</span>\r\n\r\n<span style=\"font-size:18px\">中的Background color，去掉默认设置的对勾，然后选择颜色，出现颜色对话框，进行自定义颜色，</span><span style=\"font-family:SimSun; font-size:18px; color:rgb(51,51,51); line-height:28px; text-align:justify\">把色调调</span>\r\n\r\n<span style=\"font-family:SimSun; font-size:18px; color:rgb(51,51,51); line-height:28px; text-align:justify\">成：85 饱和度调成：123 亮度调成205，即可调成豆沙绿色了 然后点确定，最后应用即可。</span>\r\n\r\n<span style=\"font-size:18px\"></span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622103608773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622103613586?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622104542497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n## (6)JRE的配置\r\n\r\n<span style=\"font-size:18px\">最开始配置Java开发环境时，安装JDK，同时也安装了JRE，那么JRE的版本对Java的支持会不同的效果，</span>\r\n\r\n<span style=\"font-size:18px\">Eclipse有默认JRE，当然也可以配置其他的JRE。</span>\r\n\r\n<span style=\"font-size:18px\">这样操作：Window->preferences->Java->Installed JREs。可以选择不同JDK版本中的JRE，也可以添</span>\r\n\r\n<span style=\"font-size:18px\">加其他版本的JRE，这里就不再演示，使用默认的即可。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622105055843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">目前的系统中只有一个JRE，而且必须是安装的JDK中的JRE。如果有其它的JDK版本，可以向其中\r\n</span>\r\n\r\n<span style=\"font-size:18px\">添加JRE。</span>\r\n\r\n## (7)编译级别的设置\r\n\r\n<span style=\"font-size:18px\">? ? ? ?既然可以更换KRE，那么也就可以调整Java项目的编译级别，最新的Eclipse支持的版本是JDK1.8。比如一</span>\r\n\r\n<span style=\"font-size:18px\">个类的某个方法是在JDK1.5以后才起作用的。那么JDK1.5以前就会编译出错。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160622105554688?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?</span>');
INSERT INTO `article_info_true` VALUES ('55', 'js字符串操作和数学函数', '<h1 id=\"h1--\"><a name=\"一、 字符串操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、 字符串操作</h1><blockquote>\r\n<p>提示：==<strong><a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>中字符串是不可变的。</strong>==<strong>==任何涉及到字符串变化的操作都不会修改源字符串，而是创建了一个新的字符串==</strong></p>\r\n</blockquote>\r\n<h2 id=\"h2-1-1-\"><a name=\"1.1 创建字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 创建字符串</h2><blockquote>\r\n<p>在JavaScript中，有两种字符串，一种是基本类型的字符串，一种是对象类型(引用类型)的字符串。</p>\r\n</blockquote>\r\n<ol>\r\n<li><p>获取基本类型的字符串一般有两种办法：</p>\r\n<ul>\r\n<li>使用字符串直接量。例如： “good”</li></ul>\r\n</li></ol>\r\n<pre><code>var s = &quot;good&quot;; // s为基本类型的字符串\r\nalert(typeof s);  //弹出: string\r\n</code></pre><ul>\r\n<li>使用String()转换函数。 <strong>(注意这个地方是不用new关键字的)</strong></li></ul>\r\n<pre><code>var s = String(123);  //把一个基本类型的Number转换成基本类型的String. (当然参数可以是任意类型。)\r\nalert(typeof s); // 弹出: string\r\n</code></pre><ol>\r\n<li>获取引用类型的字符串。通过关键字new来使用String()构造方法。这时，获取到是一个对象，引用类型</li></ol>\r\n<pre><code>var s = new String(&quot;abc&quot;);\r\nalert(typeof s);  //弹出：object\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ul>\r\n<li>==使用new==关键字获取的是==引用类型(对象类型)==的字符串，==不使用new==的是==基本类型==的字符串</li></ul>\r\n<h2 id=\"h2-1-2-length-\"><a name=\"1.2 字符串的==length属性==\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 字符串的==length属性==</h2><blockquote>\r\n<p>字符串的length属性的值表示的是字符串中字符的个数。</p>\r\n</blockquote>\r\n<pre><code>var s = &quot;abc&quot;;\r\nvar s = &quot;123你好&quot;;\r\n//因为是属性，所以不需要添加括号，只有调用方法或者函数的时候才添加圆括号\r\nalert(s.length);  // 弹出：3\r\nalert(s.length);  // 弹出：5\r\n</code></pre><h2 id=\"h2-1-3-\"><a name=\"1.3 字符串常用方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 字符串常用方法</h2><h3 id=\"h3-1-3-1-\"><a name=\"1.3.1 字符相关方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.1 字符相关方法</h3><blockquote>\r\n<ol>\r\n<li>s.charAt(index)</li></ol>\r\n<p>index 必需。表示字符串中某个位置的数字，即字符在字符串中的下标。</p>\r\n<p>返回值：返回的是指定位置的字符。但是Javascript没有字符类型，其实返回的是长度为 1 的字符串。</p>\r\n<p>说明：可以把字符串想象成一个数组，他的下标也是从0开始，最后一个元素的下标是：s.length - 1</p>\r\n</blockquote>\r\n<pre><code>var s = &quot;a你好bcd&quot;;\r\nalert(s.charAt(0)); // 弹出:  a\r\nalert(s.charAt(2)); // 弹出： 你\r\n//另外，访问字符串中的字符，完全也可以像访问数组一样，s[index]\r\nalert(s[0]);  // 等同与：s.charAt(0)\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.charCodeAt(index)</li></ol>\r\n<p>返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。</p>\r\n</blockquote>\r\n<pre><code>var s = &quot;a你好bcd&quot;;\r\nalert(s.charCodeAt(0)); // 弹出:  97\r\nalert(s.charCodeAt(2)); // 弹出： 22909\r\n</code></pre><h3 id=\"h3-1-3-2-\"><a name=\"1.3.2 字符串连接方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.2 字符串连接方法</h3><blockquote>\r\n<p>s.concat(stringX,stringX,…,stringX) 方法用于连接两个或多个字符串。</p>\r\n<p>注意：</p>\r\n<ol>\r\n<li>并不会改变源字符串</li><li><strong>实际开发中，使用 字符串连接符( + )，更简洁</strong></li></ol>\r\n</blockquote>\r\n<pre><code>var s = &quot;你好&quot;;\r\nalert(s.concat(&quot;啊&quot;, &quot;志玲&quot;)); // 弹出： 你好啊志玲\r\n//如果连接的是长度为 0 的字符串，则返回的是源字符串自己(this).\r\nalert(s.concat(&quot;&quot;) === s);  // 弹出： true\r\n</code></pre><h3 id=\"h3-1-3-3-\"><a name=\"1.3.3 查找子字符串出现的位置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.3 查找子字符串出现的位置</h3><blockquote>\r\n<ol>\r\n<li>s.indexOf(searchvalue,fromindex)方法可返回某个指定的字符串值在字符串中首次出现的位置.</li></ol>\r\n<pre><code>*   searchvalue必需。规定需检索的字符串值。\r\n*   fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 s.length - 1。如省略该参数，则将从字符串的首字符开始检索。\r\n</code></pre></blockquote>\r\n<pre><code>var v = &quot;abcabdefgh&quot;;\r\n//省略第2个参数，表示从字符串开始位置查找\r\nalert(s.indexOf(&quot;ab&quot;));  //弹出： 0\r\n//从下标为 1 的位置开始查找\r\nalert(s.indexOf(&quot;ab&quot;, 1)); //弹出： 3\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.lastIndexOf(searchvalue,fromindex) 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</li></ol>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>searchvalue</th>\r\n<th>必需。规定需检索的字符串值。</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>fromindex</td>\r\n<td>可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 s.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</blockquote>\r\n<pre><code>var s = &quot;abcabcdab&quot;;\r\nalert(s.lastIndexOf(&quot;ab&quot;)); //弹出： 7\r\nalert(s.lastIndexOf(&quot;ab&quot;, 5)) //弹出：3\r\n</code></pre><h3 id=\"h3-1-3-4-\"><a name=\"1.3.4 截取字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.4 截取字符串</h3><blockquote>\r\n<ol>\r\n<li>s.substring(start,stop) 方法用于提取字符串中介于两个指定下标之间的字符。</li></ol>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>参数</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td><em>start</em></td>\r\n<td>必需。一个非负的整数，规定要提取的子串的第一个字符在 s中的位置。</td>\r\n</tr>\r\n<tr>\r\n<td><em>stop</em></td>\r\n<td>可选。一个非负的整数。如果省略该参数，那么返回的子串会一直到字符串的结尾。<strong>==截取到的结果中，不包括stop位置的元素。==</strong></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</blockquote>\r\n<pre><code>var s = &quot;生命诚可贵&quot;;\r\n// 没有传递参数，则从 指定下标开始截取，一直到字符串结尾。返回截取到的字符串\r\nalert(s.substring(1));  // 弹出：命诚可贵\r\n// 参数1：开始截取位置 参数2：截取结束的位置。      注意：前面包括后面不包括\r\nalert(s.substring(1, 3)); // 弹出：命诚\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.substr(start, length) 方法可在字符串中抽取从 <em>start</em> 下标开始的指定数目的字符。</li></ol>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>参数</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td><em>start</em></td>\r\n<td>必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</td>\r\n</tr>\r\n<tr>\r\n<td><em>length</em></td>\r\n<td>可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 <em>stringObject</em> 的开始位置到结尾的字串。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</blockquote>\r\n<pre><code>var s = &quot;生命诚可贵&quot;;\r\n// 没有传递参数，则从 指定下标开始截取，一直到字符串结尾。返回截取到的字符串    \r\nalert(s.substr(1)); // 弹出：命诚可贵。   \r\n// 参数1：开始截取位置 参数2：截取的长度。\r\nalert(s.substr(1, 3)); // 弹出：命诚可\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.slice(start,end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。</li></ol>\r\n<p><strong>注意：这个方法与substring使用方式一样，只是slice允许负值。</strong></p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>参数</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>start</td>\r\n<td>要抽取的片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。</td>\r\n</tr>\r\n<tr>\r\n<td>end</td>\r\n<td>紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</blockquote>\r\n<pre><code>var s = &quot;生命诚可贵&quot;;\r\n//如果是正值，则和substring一样。\r\nalert(s.slice(0, 1))    // 弹出： 生\r\nalert(s.slice(-3, -0))  // 弹出： 诚可\r\n</code></pre><h3 id=\"h3-1-3-4-\"><a name=\"1.3.4 大小写转换方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.4 大小写转换方法</h3><blockquote>\r\n<ol>\r\n<li>s.toUpperCase 字符串中所有的字符转变成为大写</li></ol>\r\n</blockquote>\r\n<pre><code>var s = &quot;abcAbc&quot;;\r\nalert(s.toUpperCase());  // ABCABC\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.toLowerCase 字符串中的所有的字符转变成小写</li></ol>\r\n</blockquote>\r\n<pre><code>var s = &quot;ABcAbc&quot;;\r\nalert(s.toLowerCase());\r\n</code></pre><h3 id=\"h3-1-3-5-\"><a name=\"1.3.5 去除字符串首尾空白字符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.5 去除字符串首尾空白字符</h3><blockquote>\r\n<p>s.trim() : 只是<strong>去除字符串的首尾的所有空白字符</strong>. 字符串内部的空白字符不做任何处理</p>\r\n</blockquote>\r\n<pre><code>var s = &quot; \\n \\t ABc   Abc   \\t \\n \\t&quot;;\r\nalert(s.trim());//ABc   Abc\r\n</code></pre><h3 id=\"h3-1-3-6-\"><a name=\"1.3.6 字符串替换方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.6 字符串替换方法</h3><blockquote>\r\n<ol>\r\n<li>s.replace(regexp/substr,replacement) 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</li></ol>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>参数</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>regexp/substr</td>\r\n<td>必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</td>\r\n</tr>\r\n<tr>\r\n<td>replacement</td>\r\n<td>必需。一个字符串值。规定了替换文本或生成替换文本的函数。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>正则表达式，仅了解。后面再细讲。 /abc/gi</li><li>如果是普通的字符串，则只替换第一个满足要求的。</li></ol>\r\n<pre><code>var s = &quot;abcaba&quot;;\r\n// &quot;ab&quot;是普通的字符串，则只用js去替换第一个 ab\r\nvar newStr = s.replace(&quot;ab&quot;, &quot;js&quot;); // jscaba\r\nalert(newStr); //弹出：jscaba\r\n// 正则表达式格式：   /字符/属性\r\nalert(s.replace(/ab/gi, js));  //替换所有的ab，且忽略大小写\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.match(匹配值) ：在字符串内检索指定的值</li></ol>\r\n<pre><code>*   匹配的参数只有一个，要么正则表达式，要么是字符串项\r\n*   返回值：存放匹配结果的 **数组**\r\n</code></pre></blockquote>\r\n<pre><code>var s = &quot;abcaba&quot;;\r\nvar arr = s.match(&quot;ab&quot;); //因为是 普通字符串， 所以只匹配第一个\r\nalert(arr); // [&quot;ab&quot;]\r\nalert(s.match(/ab/gi)); // [&quot;ab&quot;, &quot;ab&quot;]\r\n\r\nvar s1 = &quot;今天是是2016年11月5日&quot;;\r\n//匹配所有的数字\r\nvar nums = s1.match(/\\d+/gi);\r\nconsole.log(nums.toString()); //输出 : 2016,11,5\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.search(匹配的参数)</li></ol>\r\n<pre><code>*   匹配的参数只有一个，要么是正则表达式，要么是字符串\r\n*   返回值：第一个匹配项的索引，否则返回-1，始终从字符串的头部开始查找，忽略全局g\r\n</code></pre></blockquote>\r\n<pre><code>var s = &quot;abcaba&quot;;\r\nvar arr = s.search(&quot;ab&quot;); //不管是普通字符串，还是正则表达式，只匹配第一个。返回值是索引\r\nalert(arr); // 0\r\nalert(s.search(/ab/gi)); // 0  忽略全局\r\n\r\nvar s1 = &quot;今天是是2016年11月5日&quot;;\r\n//匹配所有的数组\r\nvar nums = s1.search(/\\d+/gi);\r\nconsole.log(nums.toString()); //输出 : 4\r\n</code></pre><h3 id=\"h3-1-3-7-\"><a name=\"1.3.7 字符串比较\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.7 字符串比较</h3><blockquote>\r\n<ol>\r\n<li>== 比较两个字符串的<strong>==内容==</strong>是否相等。只要内容相等就返回true。</li></ol>\r\n</blockquote>\r\n<pre><code>var s = &quot;今天是是2016年11月5日&quot;;\r\nvar s1 = new String(&quot;今天是是2016年11月5日&quot;);\r\n//虽然是一个基本类型的字符串，一个引用类型的对象，但是他们的内容是相等的。所以返回  true\r\nalert(s == s1);\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>=== 恒等 只有类型和内容都相等的时候才返回true</li></ol>\r\n</blockquote>\r\n<pre><code>var s1 = &quot;今天是是2016年11月5日&quot;;\r\nvar s2 = String(&quot;今天是是2016年11月5日&quot;);  //使用转换函数,得到的是基本类型的string\r\nvar s3 = new String(&quot;今天是是2016年11月5日&quot;);\r\nvar s4 = new String(&quot;今天是是2016年11月5日&quot;);\r\n\r\n//内容和类型都相等，算恒等\r\nalert(s1 === s2);   // true\r\n//虽然内容相等，但是类型不等。所以不算恒等\r\nalert(s1 === s3);   //false\r\n//s3 和 s4 类型和内容都相等，但是他们是对象，所以必须是同一个对象才算恒等。 面向对象阶段细讲\r\nalert(s3 === s4);   //false\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>s.localeCompare(other):</li></ol>\r\n<pre><code>*   如果字符串在字母表中应该排在字符串参数之前，则返回一个负值；\r\n*   如果字符串的等于字符串参数，返回0；\r\n*   如果字符串在字母表中应该排在字符串参数之后，则返回一个正数；\r\n</code></pre></blockquote>\r\n<pre><code>var s = &quot;b&quot;;\r\nvar compare = s.localeCompare(&quot;aaa&quot;); //返回正数 其实是 1\r\nalert(compare);\r\n\r\nalert(s.localeCompare(&quot;c&quot;));   //返回负数   其实是 -1\r\n</code></pre><h3 id=\"h3-1-3-8-\"><a name=\"1.3.8 字符串切割方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3.8 字符串切割方法</h3><blockquote>\r\n<p>s.split(separator,howmany) 方法用于把一个字符串分割成字符串数组。</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>参数</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>separator</td>\r\n<td>必需。字符串或正则表达式，从该参数指定的地方分割 s。</td>\r\n</tr>\r\n<tr>\r\n<td>howmany</td>\r\n<td>可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。(一般情况不设定这个参数)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</blockquote>\r\n<pre><code>var s = &quot;How do you do&quot;;\r\nvar arr = s.split(&quot; &quot;); // 使用 &quot; &quot; 空格来切割字符串\r\nalert(arr.length);  // 4\r\nalert(arr); // How,do,you,do\r\n</code></pre><h1 id=\"h1--math-\"><a name=\"二、 Math对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、 Math对象</h1><blockquote>\r\n<p>Math主要做一些数学上的常用运算：比如平方、绝对值、开方、三角函数等。</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-1-\"><a name=\"2.1 常用属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 常用属性</h2><blockquote>\r\n<ol>\r\n<li>Math.PI : π的值</li><li>Math.E: 自然对数的底数：</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.PI);  // 3.141592653589793\r\nconsole.log(Math.E);   // 2.718281828459045\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 常用方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 常用方法</h2><blockquote>\r\n<ol>\r\n<li>Math.abs(x) : 返回x的绝对值</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.abs(5));  // 5\r\nconsole.log(Math.abs(-5));  // 5\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.max(任意个数值) ：返回传入的数值中的最大值</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.max(40, 6, 80));  // 80\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.min(任意个数值) ：返回传入的数值中的最小值</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.min(40, 6, 80));  // 6\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.ceil(number) ： 返回大于等于number的最小整数(向上取整)</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.ceil(13.1));  // 14\r\nconsole.log(Math.ceil(-13.1));  // -13\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.floor(number) ： 返回小于等于number的最大整数(向下取整)</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.floor(13.1));  // 13\r\nconsole.log(Math.floor(-13.1)); // -14\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.round(number): 四舍五入</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.round(13.4));  // 13\r\nconsole.log(Math.round(13.5));  // 14\r\nconsole.log(Math.round(-13.5)); // -13\r\nconsole.log(Math.round(-13.6)); // -14\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.pow(x, y) : 返回<span class=\"MathJax_Preview\"></span></li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.pow(2, 3)); // 8\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.random() : 返回 0-1之间的随机小数。包括0，但是不包括1</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.random());\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.sqrt(x) : 返回x的平方根</li></ol>\r\n</blockquote>\r\n<pre><code>console.log(Math.sqrt(4));  // 2\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>Math.sin(x) 正弦, Math.cos(x) 余弦, Math.tan(x) 正切</li></ol>\r\n<p>注意：三角函数的参数都是弧度。</p>\r\n</blockquote>\r\n<pre><code>console.log(Math.sin(Math.PI / 4));  // 45度的正弦 \r\nconsole.log(Math.cos(Math.PI / 4));  // 45度的余弦  \r\nconsole.log(Math.tan(Math.PI / 4));  // 45度的正切\r\n</code></pre>', '81', '\r\n\r\n# 一、 字符串操作\r\n\r\n> 提示：==**[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")中字符串是不可变的。**==**==任何涉及到字符串变化的操作都不会修改源字符串，而是创建了一个新的字符串==**\r\n\r\n## 1.1 创建字符串\r\n\r\n> 在JavaScript中，有两种字符串，一种是基本类型的字符串，一种是对象类型(引用类型)的字符串。\r\n\r\n1.  获取基本类型的字符串一般有两种办法：\r\n\r\n    *   使用字符串直接量。例如： “good”\r\n\r\n```\r\nvar s = \"good\"; // s为基本类型的字符串\r\nalert(typeof s);  //弹出: string\r\n```\r\n\r\n*   使用String()转换函数。 **(注意这个地方是不用new关键字的)**\r\n\r\n```\r\nvar s = String(123);  //把一个基本类型的Number转换成基本类型的String. (当然参数可以是任意类型。)\r\nalert(typeof s); // 弹出: string\r\n```\r\n\r\n1.  获取引用类型的字符串。通过关键字new来使用String()构造方法。这时，获取到是一个对象，引用类型\r\n\r\n```\r\nvar s = new String(\"abc\");\r\nalert(typeof s);  //弹出：object\r\n```\r\n\r\n> 注意：\r\n\r\n*   ==使用new==关键字获取的是==引用类型(对象类型)==的字符串，==不使用new==的是==基本类型==的字符串\r\n\r\n## 1.2 字符串的==length属性==\r\n\r\n> 字符串的length属性的值表示的是字符串中字符的个数。\r\n\r\n```\r\nvar s = \"abc\";\r\nvar s = \"123你好\";\r\n//因为是属性，所以不需要添加括号，只有调用方法或者函数的时候才添加圆括号\r\nalert(s.length);  // 弹出：3\r\nalert(s.length);  // 弹出：5\r\n```\r\n\r\n## 1.3 字符串常用方法\r\n\r\n### 1.3.1 字符相关方法\r\n\r\n> 1.  s.charAt(index)\r\n> \r\n> index 必需。表示字符串中某个位置的数字，即字符在字符串中的下标。\r\n> \r\n> 返回值：返回的是指定位置的字符。但是Javascript没有字符类型，其实返回的是长度为 1 的字符串。\r\n> \r\n> 说明：可以把字符串想象成一个数组，他的下标也是从0开始，最后一个元素的下标是：s.length - 1\r\n\r\n```\r\nvar s = \"a你好bcd\";\r\nalert(s.charAt(0)); // 弹出:  a\r\nalert(s.charAt(2)); // 弹出： 你\r\n//另外，访问字符串中的字符，完全也可以像访问数组一样，s[index]\r\nalert(s[0]);  // 等同与：s.charAt(0)\r\n```\r\n\r\n> 1.  s.charCodeAt(index)\r\n> \r\n> 返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。\r\n\r\n```\r\nvar s = \"a你好bcd\";\r\nalert(s.charCodeAt(0)); // 弹出:  97\r\nalert(s.charCodeAt(2)); // 弹出： 22909\r\n```\r\n\r\n### 1.3.2 字符串连接方法\r\n\r\n> s.concat(stringX,stringX,…,stringX) 方法用于连接两个或多个字符串。\r\n> \r\n> 注意：\r\n> \r\n> 1.  并不会改变源字符串\r\n> 2.  **实际开发中，使用 字符串连接符( + )，更简洁**\r\n\r\n```\r\nvar s = \"你好\";\r\nalert(s.concat(\"啊\", \"志玲\")); // 弹出： 你好啊志玲\r\n//如果连接的是长度为 0 的字符串，则返回的是源字符串自己(this).\r\nalert(s.concat(\"\") === s);  // 弹出： true\r\n```\r\n\r\n### 1.3.3 查找子字符串出现的位置\r\n\r\n> 1.  s.indexOf(searchvalue,fromindex)方法可返回某个指定的字符串值在字符串中首次出现的位置.\r\n>     \r\n>     \r\n>     *   searchvalue必需。规定需检索的字符串值。\r\n>     *   fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 s.length - 1。如省略该参数，则将从字符串的首字符开始检索。\r\n\r\n```\r\nvar v = \"abcabdefgh\";\r\n//省略第2个参数，表示从字符串开始位置查找\r\nalert(s.indexOf(\"ab\"));  //弹出： 0\r\n//从下标为 1 的位置开始查找\r\nalert(s.indexOf(\"ab\", 1)); //弹出： 3\r\n```\r\n\r\n> 1.  s.lastIndexOf(searchvalue,fromindex) 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。\r\n> \r\n> | searchvalue | 必需。规定需检索的字符串值。 |\r\n> | --- | --- |\r\n> | fromindex | 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 s.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。 |\r\n\r\n```\r\nvar s = \"abcabcdab\";\r\nalert(s.lastIndexOf(\"ab\")); //弹出： 7\r\nalert(s.lastIndexOf(\"ab\", 5)) //弹出：3\r\n```\r\n\r\n### 1.3.4 截取字符串\r\n\r\n> 1.  s.substring(start,stop) 方法用于提取字符串中介于两个指定下标之间的字符。\r\n> \r\n> | 参数 | 描述 |\r\n> | --- | --- |\r\n> | _start_ | 必需。一个非负的整数，规定要提取的子串的第一个字符在 s中的位置。 |\r\n> | _stop_ | 可选。一个非负的整数。如果省略该参数，那么返回的子串会一直到字符串的结尾。**==截取到的结果中，不包括stop位置的元素。==** |\r\n\r\n```\r\nvar s = \"生命诚可贵\";\r\n// 没有传递参数，则从 指定下标开始截取，一直到字符串结尾。返回截取到的字符串\r\nalert(s.substring(1));  // 弹出：命诚可贵\r\n// 参数1：开始截取位置 参数2：截取结束的位置。      注意：前面包括后面不包括\r\nalert(s.substring(1, 3)); // 弹出：命诚\r\n```\r\n\r\n> 1.  s.substr(start, length) 方法可在字符串中抽取从 _start_ 下标开始的指定数目的字符。\r\n> \r\n> | 参数 | 描述 |\r\n> | --- | --- |\r\n> | _start_ | 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 |\r\n> | _length_ | 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 _stringObject_ 的开始位置到结尾的字串。 |\r\n\r\n```\r\nvar s = \"生命诚可贵\";\r\n// 没有传递参数，则从 指定下标开始截取，一直到字符串结尾。返回截取到的字符串    \r\nalert(s.substr(1)); // 弹出：命诚可贵。   \r\n// 参数1：开始截取位置 参数2：截取的长度。\r\nalert(s.substr(1, 3)); // 弹出：命诚可\r\n```\r\n\r\n> 1.  s.slice(start,end) 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。\r\n> \r\n> **注意：这个方法与substring使用方式一样，只是slice允许负值。**\r\n> \r\n> | 参数 | 描述 |\r\n> | --- | --- |\r\n> | start | 要抽取的片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 |\r\n> | end | 紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。 |\r\n\r\n```\r\nvar s = \"生命诚可贵\";\r\n//如果是正值，则和substring一样。\r\nalert(s.slice(0, 1))    // 弹出： 生\r\nalert(s.slice(-3, -0))  // 弹出： 诚可\r\n```\r\n\r\n### 1.3.4 大小写转换方法\r\n\r\n> 1.  s.toUpperCase 字符串中所有的字符转变成为大写\r\n\r\n```\r\nvar s = \"abcAbc\";\r\nalert(s.toUpperCase());  // ABCABC\r\n```\r\n\r\n> 1.  s.toLowerCase 字符串中的所有的字符转变成小写\r\n\r\n```\r\nvar s = \"ABcAbc\";\r\nalert(s.toLowerCase());\r\n```\r\n\r\n### 1.3.5 去除字符串首尾空白字符\r\n\r\n> s.trim() : 只是**去除字符串的首尾的所有空白字符**. 字符串内部的空白字符不做任何处理\r\n\r\n```\r\nvar s = \" \\n \\t ABc   Abc   \\t \\n \\t\";\r\nalert(s.trim());//ABc   Abc\r\n```\r\n\r\n### 1.3.6 字符串替换方法\r\n\r\n> 1.  s.replace(regexp/substr,replacement) 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\r\n> \r\n> | 参数 | 描述 |\r\n> | --- | --- |\r\n> | regexp/substr | 必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 |\r\n> | replacement | 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 |\r\n> \r\n> 说明：\r\n\r\n1.  正则表达式，仅了解。后面再细讲。 /abc/gi\r\n2.  如果是普通的字符串，则只替换第一个满足要求的。\r\n\r\n```\r\nvar s = \"abcaba\";\r\n// \"ab\"是普通的字符串，则只用js去替换第一个 ab\r\nvar newStr = s.replace(\"ab\", \"js\"); // jscaba\r\nalert(newStr); //弹出：jscaba\r\n// 正则表达式格式：   /字符/属性\r\nalert(s.replace(/ab/gi, js));  //替换所有的ab，且忽略大小写\r\n```\r\n\r\n> 1.  s.match(匹配值) ：在字符串内检索指定的值\r\n>     \r\n>     \r\n>     *   匹配的参数只有一个，要么正则表达式，要么是字符串项\r\n>     *   返回值：存放匹配结果的 **数组**\r\n\r\n```\r\nvar s = \"abcaba\";\r\nvar arr = s.match(\"ab\"); //因为是 普通字符串， 所以只匹配第一个\r\nalert(arr); // [\"ab\"]\r\nalert(s.match(/ab/gi)); // [\"ab\", \"ab\"]\r\n\r\nvar s1 = \"今天是是2016年11月5日\";\r\n//匹配所有的数字\r\nvar nums = s1.match(/\\d+/gi);\r\nconsole.log(nums.toString()); //输出 : 2016,11,5\r\n```\r\n\r\n> 1.  s.search(匹配的参数)\r\n>     \r\n>     \r\n>     *   匹配的参数只有一个，要么是正则表达式，要么是字符串\r\n>     *   返回值：第一个匹配项的索引，否则返回-1，始终从字符串的头部开始查找，忽略全局g\r\n\r\n```\r\nvar s = \"abcaba\";\r\nvar arr = s.search(\"ab\"); //不管是普通字符串，还是正则表达式，只匹配第一个。返回值是索引\r\nalert(arr); // 0\r\nalert(s.search(/ab/gi)); // 0  忽略全局\r\n\r\nvar s1 = \"今天是是2016年11月5日\";\r\n//匹配所有的数组\r\nvar nums = s1.search(/\\d+/gi);\r\nconsole.log(nums.toString()); //输出 : 4\r\n```\r\n\r\n### 1.3.7 字符串比较\r\n\r\n> 1.  == 比较两个字符串的**==内容==**是否相等。只要内容相等就返回true。\r\n\r\n```\r\nvar s = \"今天是是2016年11月5日\";\r\nvar s1 = new String(\"今天是是2016年11月5日\");\r\n//虽然是一个基本类型的字符串，一个引用类型的对象，但是他们的内容是相等的。所以返回  true\r\nalert(s == s1);  \r\n```\r\n\r\n> 1.  === 恒等 只有类型和内容都相等的时候才返回true\r\n\r\n```\r\nvar s1 = \"今天是是2016年11月5日\";\r\nvar s2 = String(\"今天是是2016年11月5日\");  //使用转换函数,得到的是基本类型的string\r\nvar s3 = new String(\"今天是是2016年11月5日\");\r\nvar s4 = new String(\"今天是是2016年11月5日\");\r\n\r\n//内容和类型都相等，算恒等\r\nalert(s1 === s2);   // true\r\n//虽然内容相等，但是类型不等。所以不算恒等\r\nalert(s1 === s3);   //false\r\n//s3 和 s4 类型和内容都相等，但是他们是对象，所以必须是同一个对象才算恒等。 面向对象阶段细讲\r\nalert(s3 === s4);   //false\r\n```\r\n\r\n> 1.  s.localeCompare(other):\r\n>     \r\n>     \r\n>     *   如果字符串在字母表中应该排在字符串参数之前，则返回一个负值；\r\n>     *   如果字符串的等于字符串参数，返回0；\r\n>     *   如果字符串在字母表中应该排在字符串参数之后，则返回一个正数；\r\n\r\n```\r\nvar s = \"b\";\r\nvar compare = s.localeCompare(\"aaa\"); //返回正数 其实是 1\r\nalert(compare);\r\n\r\nalert(s.localeCompare(\"c\"));   //返回负数   其实是 -1\r\n```\r\n\r\n### 1.3.8 字符串切割方法\r\n\r\n> s.split(separator,howmany) 方法用于把一个字符串分割成字符串数组。\r\n> \r\n> | 参数 | 描述 |\r\n> | --- | --- |\r\n> | separator | 必需。字符串或正则表达式，从该参数指定的地方分割 s。 |\r\n> | howmany | 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。(一般情况不设定这个参数) |\r\n\r\n```\r\nvar s = \"How do you do\";\r\nvar arr = s.split(\" \"); // 使用 \" \" 空格来切割字符串\r\nalert(arr.length);  // 4\r\nalert(arr); // How,do,you,do\r\n```\r\n\r\n# 二、 Math对象\r\n\r\n> Math主要做一些数学上的常用运算：比如平方、绝对值、开方、三角函数等。\r\n\r\n## 2.1 常用属性\r\n\r\n> 1.  Math.PI : π的值\r\n> 2.  Math.E: 自然对数的底数：\r\n\r\n```\r\nconsole.log(Math.PI);  // 3.141592653589793\r\nconsole.log(Math.E);   // 2.718281828459045\r\n```\r\n\r\n## 2.2 常用方法\r\n\r\n> 1.  Math.abs(x) : 返回x的绝对值\r\n\r\n```\r\nconsole.log(Math.abs(5));  // 5\r\nconsole.log(Math.abs(-5));  // 5\r\n```\r\n\r\n> 1.  Math.max(任意个数值) ：返回传入的数值中的最大值\r\n\r\n```\r\nconsole.log(Math.max(40, 6, 80));  // 80\r\n```\r\n\r\n> 1.  Math.min(任意个数值) ：返回传入的数值中的最小值\r\n\r\n```\r\nconsole.log(Math.min(40, 6, 80));  // 6\r\n```\r\n\r\n> 1.  Math.ceil(number) ： 返回大于等于number的最小整数(向上取整)\r\n\r\n```\r\nconsole.log(Math.ceil(13.1));  // 14\r\nconsole.log(Math.ceil(-13.1));  // -13\r\n```\r\n\r\n> 1.  Math.floor(number) ： 返回小于等于number的最大整数(向下取整)\r\n\r\n```\r\nconsole.log(Math.floor(13.1));  // 13\r\nconsole.log(Math.floor(-13.1)); // -14\r\n```\r\n\r\n> 1.  Math.round(number): 四舍五入\r\n\r\n```\r\nconsole.log(Math.round(13.4));  // 13\r\nconsole.log(Math.round(13.5));  // 14\r\nconsole.log(Math.round(-13.5)); // -13\r\nconsole.log(Math.round(-13.6)); // -14\r\n```\r\n\r\n> 1.  Math.pow(x, y) : 返回<span class=\"MathJax_Preview\"></span>\r\n\r\n```\r\nconsole.log(Math.pow(2, 3)); // 8 \r\n```\r\n\r\n> 1.  Math.random() : 返回 0-1之间的随机小数。包括0，但是不包括1\r\n\r\n```\r\nconsole.log(Math.random());\r\n```\r\n\r\n> 1.  Math.sqrt(x) : 返回x的平方根\r\n\r\n```\r\nconsole.log(Math.sqrt(4));  // 2\r\n```\r\n\r\n> 1.  Math.sin(x) 正弦, Math.cos(x) 余弦, Math.tan(x) 正切\r\n> \r\n> 注意：三角函数的参数都是弧度。\r\n\r\n```\r\nconsole.log(Math.sin(Math.PI / 4));  // 45度的正弦 \r\nconsole.log(Math.cos(Math.PI / 4));  // 45度的余弦  \r\nconsole.log(Math.tan(Math.PI / 4));  // 45度的正切  \r\n```\r\n\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('56', 'js BOM操作', '<h1 id=\"h1--bom-\"><a name=\"一、BOM概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、BOM概述</h1><blockquote>\r\n<p>BOM: Browser Object Model 浏览器对象模型</p>\r\n</blockquote>\r\n<h2 id=\"h2-1-1-bom\"><a name=\"1.1 什么是BOM\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 什么是BOM</h2><blockquote>\r\n<p>浏览器对象模型(BOM)是<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>的组成之一，他提供了独立与内容与浏览器窗口进行交互的对象，使用浏览器对象模型可以实现与HTML的交互。</p>\r\n<p>ECMAScript是 JavaScript的核心，但如果要在 Web中使用 JavaScript，那么 BOM（浏览器对象模<br>型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任<br>何网页内容无关。</p>\r\n</blockquote>\r\n<h2 id=\"h2-1-2-bom-\"><a name=\"1.2 BOM的作用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 BOM的作用</h2><blockquote>\r\n<p>将相关的元素组织包装起来，提供给程序设计人员使用，从而降低开发人员的工作量，提供设计Web页面的能力.BOM是一个分层结构。</p>\r\n</blockquote>\r\n<h1 id=\"h1--bom-window-\"><a name=\"二、BOM核心—window对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、BOM核心—window对象</h1><h2 id=\"h2-2-1-window-\"><a name=\"2.1 window对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 window对象</h2><blockquote>\r\n<p>BOM 的核心对象是 window ，它表示浏览器的一个实例。在浏览器中， window 对象有双重角色，<br>它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。</p>\r\n<p>通过window可以操作整个浏览器。</p>\r\n<p>BOM图谱：</p>\r\n</blockquote>\r\n<ul>\r\n<li><img src=\"http://www.itxueyuan.org/uploads/allimg/121112/1-121112154254459.png\" alt=\"\"></li></ul>\r\n<blockquote>\r\n<p>window对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的，也可以称为window的子对象。</p>\r\n</blockquote>\r\n<h3 id=\"h3-2-1-1-\"><a name=\"2.1.1 全局作用域\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.1 全局作用域</h3><blockquote>\r\n<p>? 由于 window 对象同时扮演着 ECMAScript中 Global 对象的角色，因此所有在全局作用域中声明<br>的变量、函数都会变成 <strong>window 对象的属性和方法</strong>。</p>\r\n<p>注意：有三种获取全局变量的方式。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var age = 29;   //声明一个全局变量\r\n    function sayAge() { //声明一个全局函数\r\n        alert(this.age);//this表示，调用这个函数时使用的对象。将来是通过window调用的，所以this指代的window\r\n    }\r\n    // 全局变量成为了window对象的属性。 所以可以通过window.age访问\r\n    alert(window.age); //29\r\n    sayAge(); //29\r\n    // 全局函数成为了window对象的方法。 所以可以通过window.sagAge() 来访问。\r\n    window.sayAge(); //29\r\n&lt;/script&gt;\r\n//提示：虽然可以通过window对象来调用，但是实际开发的时，一般都省略window。\r\n</code></pre><h3 id=\"h3-2-1-2-window-\"><a name=\"2.1.2 window窗口大小\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.2 window窗口大小</h3><blockquote>\r\n<p>A. 有三种方式获取浏览器的窗口大小：(浏览器的视口，不包括工具栏和滚动条)</p>\r\n</blockquote>\r\n<ol>\r\n<li><p>在Internet Explorer(9+)、Chrome、Firefox、Opera 以及 Safari：</p>\r\n<ul>\r\n<li>window.innerHeight - 浏览器窗口的内部高度</li><li>window.innerWidth - 浏览器窗口的内部宽度</li></ul>\r\n</li></ol>\r\n<pre><code>var msg = &quot;窗口宽度：&quot; + window.innerHeight + &quot;\\n窗口高度：&quot; + window.innerWidth;\r\nalert(msg );\r\n</code></pre><ol>\r\n<li><p>对于 Internet Explorer 8、7、6、5：(<strong>Chrome和Firefox也支持</strong>)</p>\r\n<ul>\r\n<li>document.documentElement.clientHeight</li><li>document.documentElement.clientWidth</li></ul>\r\n</li></ol>\r\n<pre><code>var msg = &quot;窗口宽度：&quot; + document.documentElement.clientWidth + &quot;\\n窗口高度：&quot; + document.documentElement.clientHeight;\r\nalert(msg);\r\n</code></pre><ol>\r\n<li>为了兼容浏览器的版本可以使用下面的代码(可以涵盖所有的浏览器)</li></ol>\r\n<pre><code>var w = window.innerWidth || document.documentElement.clientWidth;\r\nvar h = window.innerHeight || document.documentElement.clientHeight;\r\nalert(&quot;窗口宽度：&quot; + w + &quot;\\n窗口高度：&quot; + h);\r\n</code></pre><blockquote>\r\n<p>B. 调整窗口大小：</p>\r\n<ul>\r\n<li>window.resizeTo(w, h) ：调整到指定的大小</li><li>resizeBy(deltW, deltH) ：增加指定值的窗口的宽和高</li></ul>\r\n<p>一些浏览器已经禁用了这个方法(Chrome和Firfox均禁用了这两个方法, ie可用)</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button onclick=&quot;to();&quot;&gt;调整到指定大小&lt;/button&gt;\r\n    &lt;br/&gt;\r\n    &lt;button onclick=&quot;by();&quot;&gt;宽高增加10个像素&lt;/button&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        function to () {\r\n            alert(&quot;我要变小了&quot;);\r\n            window.resizeTo(200, 300);\r\n        }\r\n        function by () {\r\n             alert(&quot;靠，变大了&quot;);\r\n             window.resizeBy(10, 10);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-2-1-3-\"><a name=\"2.1.3 打开窗口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.3 打开窗口</h3><blockquote>\r\n<p>open(URL,name,features) 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>参数</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>URL</td>\r\n<td>一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。</td>\r\n</tr>\r\n<tr>\r\n<td>name</td>\r\n<td>一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 <a>和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</a></td>\r\n</tr>\r\n<tr>\r\n<td>features</td>\r\n<td>一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在”“窗口特征”“这个表格中，我们对该字符串的格式进行了详细的说明。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>备注：如果不用到frame框架，则只需要传入第1个参数和第3个参数即可</strong></p>\r\n<p>窗口特征(常用)：</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>属性名称</th>\r\n<th>说 明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>height、width</td>\r\n<td>窗口文档显示区的高度、宽度。以像素计。</td>\r\n</tr>\r\n<tr>\r\n<td>left、top</td>\r\n<td>窗口的x坐标、y坐标。以像素计</td>\r\n</tr>\r\n<tr>\r\n<td>toolbar=yes</td>\r\n<td>no</td>\r\n</tr>\r\n<tr>\r\n<td>scrollbars=yes</td>\r\n<td>no</td>\r\n</tr>\r\n<tr>\r\n<td>location=yes</td>\r\n<td>no</td>\r\n</tr>\r\n<tr>\r\n<td>status=yes</td>\r\n<td>no</td>\r\n</tr>\r\n<tr>\r\n<td>menubar=yes</td>\r\n<td>no</td>\r\n</tr>\r\n<tr>\r\n<td>resizable=yes</td>\r\n<td>no</td>\r\n</tr>\r\n<tr>\r\n<td>titlebar=yes</td>\r\n<td>no</td>\r\n</tr>\r\n<tr>\r\n<td>fullscreen=yes</td>\r\n<td>no</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</blockquote>\r\n<ul>\r\n<li>打开新的窗口，窗口特性全部使用默认值</li></ul>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button onclick=&quot;openAnother();&quot;&gt;打开新窗口&lt;/button&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    function openAnother () {\r\n        window.open(&quot;http://www.yztcedu.com&quot;); //打开新窗口，窗口特性全部使用默认值。\r\n    }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><ul>\r\n<li>打开新的窗口，设置窗口特性</li></ul>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button onclick=&quot;openAnother();&quot;&gt;打开新窗口&lt;/button&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n      var win;\r\n      function openAnother () {\r\n          win = window.open(&quot;http://www.yztcedu.com&quot;, &quot;&quot;, &quot;width=400, height=400, toolbar = no, menubar = no,left = 200, right = 200&quot;);\r\n      }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><ul>\r\n<li>open方法返回打开的那个窗口的window对象，可以调用close方法关闭新打开的窗口。</li></ul>\r\n<pre><code>win.close();\r\n\r\n//也可以调整新开窗口的大小位置等，但是大部分浏览器禁用了这个功能。\r\n</code></pre><h3 id=\"h3-2-1-4-window-\"><a name=\"2.1.4 window中的定时器(超时调用和周期调用)(重点)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.4 window中的定时器(超时调用和周期调用)(重点)</h3><blockquote>\r\n<p>window对象提供了两个类似定时器功能的方法：超时调用和周期调用(间隙调用)</p>\r\n<p>JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。<br>前者是在<strong>指定的时间过后执行代码</strong>，而后者则是<strong>每隔指定的时间就执行一次代码</strong>。</p>\r\n</blockquote>\r\n<ol>\r\n<li>window.setTimeout()–超时调用</li></ol>\r\n<pre><code>/*\r\n    setTimeout(code,millisec)\r\n    参数1：要执行代码。一般传入一个函数。(当然也可是字符串形式的代码，但是不建议使用)\r\n    参数2：多长时间后执行参数1中的代码。  单位毫秒\r\n*/\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //传入函数的时，函数名不要加括号。(因为方法不是我们调用，是引擎帮助我们调用)\r\n    // setTimeout方法会返回一个值，表示超时调用的id，可以在任务执行前取消任务。\r\n    var timeOutId = window.setTimeout(go, 3000);  // 3秒中之后执行函数go中的代码\r\n    function go () {\r\n        window.open(&quot;http://www.yztcedu.com&quot;)\r\n    }   \r\n    timeoutId.cancel();  //取消这个超时调用，如果超时调用已经执行完毕，就什么也不会发生。\r\n&lt;/script&gt;\r\n</code></pre><ol>\r\n<li>setInterval–周期调用(间隙调用)</li></ol>\r\n<pre><code>/*\r\n    setInterval(code,millisec)\r\n    参数1：每隔一段时间执行一次的代码。  一般是一个函数\r\n    参数2：周期性执行的时间间隔。  单位毫秒\r\n\r\n*/\r\n&lt;body&gt;\r\n    &lt;h1 id=&quot;time&quot;&gt;&lt;/h1&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //显示时间，每秒钟变化一次。\r\n        window.setInterval(function() {\r\n            var timeElement = document.getElementById(&quot;time&quot;);  //找到h1标签\r\n            var msg = new Date().toLocaleString();\r\n            timeElement.innerHTML = msg;    //设置h1标签中的值\r\n        }, 1000);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n    //清除间隔定时器\r\n    window.clearInterval(id);\r\n</code></pre><h3 id=\"h3-2-1-5-\"><a name=\"2.1.5 系统对话框\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1.5 系统对话框</h3><blockquote>\r\n<ol>\r\n<li>alert()对话框</li></ol>\r\n<ol>\r\n<li>confirm()对话框.</li></ol>\r\n<p>方法用于显示一个带有指定消息和 <strong>确定</strong> 及 <strong>取消</strong> 按钮的对话框。</p>\r\n<p>说明：如果用户点击确定按钮，则 confirm() 返回 true。如果点击取消按钮，则 confirm() 返回 false。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var isOk = window.confirm(&quot;你确定要抛弃我吗？&quot;);\r\n    //根据用户的不同相动作做出不同响应\r\n    if(isOk){   //用户按下  确定\r\n        window.alert(&quot;祝你好运&quot;);\r\n    }else { //用户按下  取消\r\n        window.alert(&quot;我们就再玩会吧&quot;);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>prompt(text, default) 这是一个提示框，用于提示用户输入一些文本。提示框中除了会有 确定和取消，还有一个可以让用户输入文本的文本框。方法的返回值是用户输入的具体的文本。</li></ol>\r\n<pre><code>*   参数1：提示语句\r\n*   参数2：输入文本框默认已经输入的字符，如果没有默认输入，不用传递\r\n*   返回值：如果用户按下 **确定，则返回具体的文本内容**，如果按下 **取消 返回 null**\r\n</code></pre></blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var msg = prompt(&quot;请输入你的姓名：&quot;);\r\n    if(msg != null &amp;&amp; msg.length &gt; 0){\r\n        alert(&quot;欢迎：&quot; + msg);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-2-location-\"><a name=\"2.2 location对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 location对象</h2><blockquote>\r\n<p>location对象其实是window对象的子对象。可以 这样使用：window.location,但是使用的时候一般省略window。</p>\r\n<p>location 是最有用的 BOM对象之一，<strong>它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。</strong></p>\r\n<p>应用：<strong>window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。</strong></p>\r\n</blockquote>\r\n<h3 id=\"h3-2-2-1-location-\"><a name=\"2.2.1 location对象的常用属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.1 location对象的常用属性</h3><table>\r\n<thead>\r\n<tr>\r\n<th>属性</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>host</td>\r\n<td>设置或返回主机名和当前 URL 的端口号。</td>\r\n</tr>\r\n<tr>\r\n<td>hostname</td>\r\n<td>设置或返回当前 URL 的主机名。</td>\r\n</tr>\r\n<tr>\r\n<td>href</td>\r\n<td>设置或返回完整的 URL。</td>\r\n</tr>\r\n<tr>\r\n<td>pathname</td>\r\n<td>设置或返回当前 URL 的路径部分。</td>\r\n</tr>\r\n<tr>\r\n<td>port</td>\r\n<td>设置或返回当前 URL 的端口号。</td>\r\n</tr>\r\n<tr>\r\n<td>protocol</td>\r\n<td>设置或返回当前 URL 的协议。</td>\r\n</tr>\r\n<tr>\r\n<td>search</td>\r\n<td>设置或返回从问号 (?) 开始的 URL（查询部分）。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //  http://192.168.1.100:8080/JsTest/html/demo2.html?user=lisi&amp;pwd=aaa\r\n    document.write(&quot;protocol: &quot; + location.protocol + &quot;&lt;br /&gt;&quot;);    // 协议\r\n    document.write(&quot;hostname: &quot; + location.hostname + &quot;&lt;br /&gt;&quot;);        //主机名\r\n    document.write(&quot;host: &quot; + location.host +　&quot;&lt;br /&gt;&quot;);  //主机和端口\r\n    document.write(&quot;port: &quot; + location.port + &quot;&lt;br /&gt;&quot;);    //端口\r\n    document.write(&quot;pathname: &quot; + location.pathname + &quot;&lt;br /&gt;&quot;);    // 路径名\r\n    document.write(&quot;search: &quot; + location.search + &quot;&lt;br /&gt;&quot;);    // 查询参数\r\n    document.write(&quot;href: &quot; + location.href + &quot;&lt;br /&gt;&quot;);    //完整url \r\n&lt;/script&gt;\r\n</code></pre><ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-6/19190684.jpg\" alt=\"\"></li></ul>\r\n<h3 id=\"h3-2-2-2-location-\"><a name=\"2.2.2 location常用方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.2 location常用方法</h3><table>\r\n<thead>\r\n<tr>\r\n<th>属性</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>assign(url)</td>\r\n<td>加载新的文档。</td>\r\n</tr>\r\n<tr>\r\n<td>reload(reforce)</td>\r\n<td>重新加载当前文档。</td>\r\n</tr>\r\n<tr>\r\n<td>replace(newURL)</td>\r\n<td>用新的文档替换当前文档。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<blockquote>\r\n<ol>\r\n<li>assign(newUrl): 加载新的文档。</li></ol>\r\n</blockquote>\r\n<pre><code>&lt;button onclick=&quot;openNewUrl();&quot;&gt;打开首页&lt;/button&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function openNewUrl () {\r\n        location.assign(&quot;http://www.baidu.com&quot;);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>replace(reforce): 方法不会在 History 对象中生成一个新的记录。当使用该方法时，新的 URL 将覆盖 History 对象中的当前记录。按下回退键的不会返回到刚才的网页。</li></ol>\r\n</blockquote>\r\n<pre><code>&lt;button onclick=&quot;replaceDoc();&quot;&gt;替换当前网页&lt;/button&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function replaceDoc () {\r\n        location.replace(&quot;http://www.yztcedu.com&quot;);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>reload([force]) 方法用于重新加载当前文档。</li></ol>\r\n<pre><code>*   参数force可选，可以为true。如果该方法没有规定参数，或者参数是 false，它就会用 HTTP 头 If-Modified-Since 来检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。如果把该方法的参数设置为true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。\r\n\r\n总结：有参为true时，从服务器重新下载，无参从缓存中重新加载\r\n\r\n\r\n\r\n**注意：reload()调用之后其后的代码有可能执行有可能不执行，所以一般放在最后**\r\n</code></pre></blockquote>\r\n<pre><code>&lt;button onclick=&quot;reloadCurrrent();&quot;&gt;重写加载当前网页&lt;/button&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function reloadCurrrent () {\r\n        location.reload(true);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-3-history-\"><a name=\"2.3 history对象(了解)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 history对象(了解)</h2><blockquote>\r\n<p>History 对象包含用户（在浏览器窗口中）访问过的 URL。</p>\r\n<p>History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。</p>\r\n</blockquote>\r\n<h3 id=\"h3-2-3-1-\"><a name=\"2.3.1 常用属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.1 常用属性</h3><table>\r\n<thead>\r\n<tr>\r\n<th>属性</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>length</td>\r\n<td>返回浏览器历史列表中的 URL 数量。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>&lt;button onclick=&quot;urlCount();&quot;&gt;历史列表中url数量&lt;/button&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function urlCount () {\r\n        alert(&quot;历史列表中url数量：&quot; + history.length);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h3 id=\"h3-2-3-2-\"><a name=\"2.3.2 常用方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3.2 常用方法</h3><table>\r\n<thead>\r\n<tr>\r\n<th>方法</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>back()</td>\r\n<td>加载 history 列表中的前一个 URL。</td>\r\n</tr>\r\n<tr>\r\n<td>forward()</td>\r\n<td>加载 history 列表中的下一个 URL。</td>\r\n</tr>\r\n<tr>\r\n<td>go()</td>\r\n<td>加载 history 列表中的某个具体页面。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>&lt;button onclick=&quot;myForward();&quot;&gt;向前&lt;/button&gt;\r\n&lt;button onclick=&quot;myBack();&quot;&gt;向后&lt;/button&gt;\r\n&lt;button onclick=&quot;myGo(-2);&quot;&gt;后退2个页面&lt;/button&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function myForward () {\r\n        history.forward();\r\n    }\r\n    function myBack () {\r\n        history.back();\r\n    }\r\n    function myGo (index) { // 负代表后退， 正代表前进\r\n        history.go(index);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-4-navigator-\"><a name=\"2.4 navigator对象(了解)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 navigator对象(了解)</h2><blockquote>\r\n<p>Navigator 对象包含有关浏览器的信息。</p>\r\n<p>Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。</p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>属性</th>\r\n<th>说 明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>appCodeName</td>\r\n<td>浏览器代码名的字符串表示</td>\r\n</tr>\r\n<tr>\r\n<td>appName</td>\r\n<td>官方浏览器名的字符串表示</td>\r\n</tr>\r\n<tr>\r\n<td>appVersion</td>\r\n<td>浏览器版本信息的字符串表示</td>\r\n</tr>\r\n<tr>\r\n<td>systemLanguage</td>\r\n<td>操作系统的语音</td>\r\n</tr>\r\n<tr>\r\n<td>language</td>\r\n<td>浏览器的主语言</td>\r\n</tr>\r\n<tr>\r\n<td>onLine</td>\r\n<td>是否联了因特网</td>\r\n</tr>\r\n<tr>\r\n<td>cookieEnabled</td>\r\n<td>如果启用cookie返回true，否则返回false</td>\r\n</tr>\r\n<tr>\r\n<td>platform</td>\r\n<td>浏览器所在计算机平台的字符串表示</td>\r\n</tr>\r\n<tr>\r\n<td>plugins</td>\r\n<td>安装在浏览器中的插件数组</td>\r\n</tr>\r\n<tr>\r\n<td>userAgent</td>\r\n<td>用户代理头的字符串表示</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    document.write(&quot;appCodeName: &quot; + navigator.appCodeName + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;appName: &quot; + navigator.appName + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;appVersion: &quot; + navigator.appVersion + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;systemLanguage : &quot; + navigator.systemLanguage + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;language: &quot; + navigator.language  + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;onLine: &quot; + navigator.onLine     + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;cookieEnabled : &quot; + navigator.cookieEnabled     + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;platform: &quot; + navigator.platform + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;userAgent: &quot; + navigator.userAgent     + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;plugins: &quot; + navigator.plugins     + &quot;&lt;br/&gt;&quot;);\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-5-screen-\"><a name=\"2.5 screen对象(了解)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5 screen对象(了解)</h2><blockquote>\r\n<p>screen对象：包含有关用户屏幕的信息</p>\r\n<p>在JavaScript中用处不大，只是用来表面客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等，各浏览器的screen对象都包含不相同的属性，罗列一些共同的.</p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>属性</th>\r\n<th>说 明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>height</td>\r\n<td>屏幕的像素高度</td>\r\n</tr>\r\n<tr>\r\n<td>width</td>\r\n<td>屏幕的像素宽度</td>\r\n</tr>\r\n<tr>\r\n<td>colorDepth</td>\r\n<td>用于表现颜色的位数</td>\r\n</tr>\r\n<tr>\r\n<td>availWidth</td>\r\n<td>屏幕的像素宽度减系统部件宽度之后的值(减去任务栏之后的宽度)</td>\r\n</tr>\r\n<tr>\r\n<td>availHeight</td>\r\n<td>部屏幕的像素高度减系统件的高度之后的值（减去任务栏之后的高度）</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    document.write(&quot;height : &quot; + screen.height + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;width : &quot; + screen.width + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;colorDepth : &quot; + screen.colorDepth + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;availWidth : &quot; + screen.availWidth + &quot;&lt;br/&gt;&quot;);\r\n    document.write(&quot;availHeight &quot; + screen.availHeight + &quot;&lt;br/&gt;&quot;);\r\n&lt;/script&gt;\r\n</code></pre><ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-6/53675508.jpg\" alt=\"\"></li></ul>\r\n<h1 id=\"h1--window-\"><a name=\"三、window中常用事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、window中常用事件</h1><h2 id=\"h2-3-1-onload-\"><a name=\"3.1 onload—加载事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 onload—加载事件</h2><blockquote>\r\n<p>当整个页面加载完成的时会触发该事件。</p>\r\n<p>语法：window.onload = function(){} 或者 window.onload = 方法名</p>\r\n<p>注意：一般把事件注册的代码放在head中。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    window.onload = function () {\r\n        alert(&quot;页面加载完毕&quot;);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-3-2-onscroll-\"><a name=\"3.2 onscroll—滚动事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 onscroll—滚动事件</h2><blockquote>\r\n<p>当窗口发生滚动会触发该事件</p>\r\n<p>语法：window.onscroll = function(){} 或者 window.onscroll = 方法==名==;</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    window.onscroll = function() {\r\n        console.log(&quot;开始滚动...&quot;)\r\n        //获取滚动距离。\r\n        //document.body.scrollTop: 只支持chorme，火狐和ie不支持， document.documentElement.scrollTop ie和火狐支持 chrome不支持\r\n        //这样就可以跨浏览器了。\r\n        console.log(document.documentElement.scrollTop || document.body.scrollTop);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--javascript-cookie\"><a name=\"四、使用JavaScript操作cookie\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、使用JavaScript操作cookie</h1><h2 id=\"h2-4-1-cookie\"><a name=\"4.1 什么是cookie\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 什么是cookie</h2><p>? Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。</p>\r\n<p>? Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。</p>\r\n<p>? cookie是浏览器提供的一种机制，它将document 对象的cookie属性提供给JavaScript。可以由JavaScript对其进行控制，而并不是JavaScript本身的性质。cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。 而且不同的浏览器之间cookie不能共享。</p>\r\n<blockquote>\r\n<p><strong>==cookie的本质就是用键值对存储在用户本地的一些数据，这些数据不同的网站，不同的浏览器是不能共享的==</strong></p>\r\n</blockquote>\r\n<h2 id=\"h2-4-2-cookie-\"><a name=\"4.2 cookie的用处\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 cookie的用处</h2><p>? cookie机制将信息存储于用户硬盘，因此可以作为全局变量，这是它最大的一个优点。它可以用于以下几种场合。</p>\r\n<ol>\r\n<li>保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</li><li>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。</li><li>定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</li><li>创建购物车。正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。</li></ol>\r\n<h2 id=\"h2-4-3-cookie-\"><a name=\"4.3 cookie的缺陷\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 cookie的缺陷</h2><ol>\r\n<li>cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；</li><li>cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的；</li><li>cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；</li><li>cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。</li></ol>\r\n<h2 id=\"h2-4-4-cookie-\"><a name=\"4.4 cookie的构成\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4 cookie的构成</h2><blockquote>\r\n<p>cookie 由浏览器保存的以下几块信息构成。</p>\r\n</blockquote>\r\n<ol>\r\n<li>名称：一个唯一确定 cookie 的名称。cookie 名称是不区分大小写的，所以 myCookie 和 MyCookie被认为是同一个 cookie。然而，实践中最好将 cookie 名称看作是区分大小写的，因为某些服务器会这样处理 cookie。cookie 的名称必须是经过 URL 编码的。</li><li>值：储存在 cookie 中的字符串值。值必须被 URL 编码。</li><li>域：cookie 对于哪个域是有效的。所有向该域发送的请求中都会包含这个 cookie 信息。这个值可以包含子域（subdomain，如 www.wrox.com ），也可以不包含它（如. wrox.com ，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置 cookie 的那个域。</li><li>路径：对于指定域中的那个路径，应该向服务器发送 cookie。例如，你可以指定 cookie 只有从<br><a href=\"http://www.wrox.com/books/\">http://www.wrox.com/books/</a> 中才能访问，那么 <a href=\"http://www.wrox.com\">http://www.wrox.com</a> 的页面就不会发送 cookie 信息，即使请求都是来自同一个域的。</li><li>失效时间：表示 cookie 何时应该被删除的时间戳（也就是，何时应该停止向服务器发送这个cookie）。默认情况下，浏览器会话结束时即将所有 cookie 删除；不过也可以自己设置删除时间。这个值是个 GMT 格式的日期（Wdy, DD-Mon-YYYY HH<img src=\"http://www.emoji-cheat-sheet.com/graphics/emojis/MM.png\" class=\"emoji\" title=\"&#58;MM&#58;\" alt=\"&#58;MM&#58;\" />SS GMT），用于指定应该删除cookie 的准确时间。因此，cookie 可在浏览器关闭后依然保存在用户的机器上。如果你设置的失效日期是个以前的时间，则 cookie 会被立刻删除。</li><li>安全标志：指定后，cookie 只有在使用 SSL 连接的时候才发送到服务器。例如，cookie 信息只<br>能发送给 <a href=\"https://www.wrox.com\">https://www.wrox.com</a> ，而 <a href=\"http://www.wrox.com\">http://www.wrox.com</a> 的请求则不能发送 cookie。</li></ol>\r\n<h2 id=\"h2-4-5-cookie\"><a name=\"4.5 存储cookie\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5 存储cookie</h2><blockquote>\r\n<p>有2种途径去存储cookie.</p>\r\n</blockquote>\r\n<ol>\r\n<li>服务器端通过http响应头Set-Cookie来通知浏览器存储cookie。例如：(这个暂时不研究，仅了解)。浏览器收到这个头响应头之后会自动存储这个cookie</li></ol>\r\n<pre><code>HTTP/1.1 200 OK\r\nContent-type: text/html\r\nSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com\r\nOther-header: other-header-value\r\n</code></pre><ol>\r\n<li>客户端(浏览器端)通过JavaScript去存储cookie(重点研究)。Javascript操作cookie需要通过document的cookie属性来完成。</li></ol>\r\n<pre><code>//存储cookie，并设置超时时间。  domaim和secure使用默认的情况\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    /*\r\n        在存储cookie的时候，name和value是必须的\r\n        参数1：cookie的name\r\n        参数2：cookie的值\r\n        参数3：存储时间 单位天\r\n\r\n        只要name不同，就可以存储多个cookie\r\n    */\r\n    function saveCookie(name, value, expiredays){\r\n\r\n        var date = new Date();\r\n        alert(date.getDate())\r\n        date.setDate(date.getDate() + expiredays);\r\n        alert(date.toGMTString())\r\n        //cookie的内容其实就是一串纯文本。 对字符最好进行url编码，否则如果有中文就会出现问题。\r\n        var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value) + &quot;; expires=&quot; + date.toGMTString();\r\n        document.cookie = cookieText;\r\n    }\r\n    saveCookie(&quot;name&quot;, &quot;张三&quot;, 1);\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-5-cookie\"><a name=\"4.5 读取cookie\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5 读取cookie</h2><blockquote>\r\n<p>读取cookie仍然是通过document的cookie属性，不过字符串需要我们自己解析。</p>\r\n<p>只能说，JavaScript的这个API设计的真烂</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function getCookie (name) {\r\n        //先拿到cookie字符串\r\n        var cookieText = document.cookie;\r\n        //获取要查找的 cookie的 name所在的下标\r\n        var index = cookieText.indexOf(name + &quot;=&quot;);  // name=李四; ...\r\n        //如果下标不为-1，证明找到了\r\n        if(index != -1){\r\n            var endIndex = cookieText.indexOf(&quot;;&quot;, index);  //查找指定的cookie的结束为止\r\n            // 如果等于-1，证明没有找到;号，则把末尾设置为字符串的末尾\r\n            endIndex = (endIndex == -1 ? cookieText.length : endIndex);\r\n            //把想要的cookie的value截取出来\r\n            var value = cookieText.substring(index + (name + &quot;=&quot;).length, endIndex);\r\n            //因为存储的时候使用了url编码，所以查到的东西需要url解码\r\n            return decodeURIComponent(value);\r\n        }\r\n    }\r\n    var value = getCookie(&quot;name&quot;);\r\n    if(value){\r\n        alert(&quot;欢迎你：&quot; + value);\r\n    }\r\n\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-6-cookie\"><a name=\"4.6 删除cookie\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.6 删除cookie</h2><blockquote>\r\n<p>删除cookie的原理非常简单，只要把超时时间设置为0，就会立即删除了。</p>\r\n</blockquote>\r\n<pre><code>function saveCookie(name, value, expiredays){\r\n\r\n        var date = new Date();\r\n        alert(date.getDate())\r\n        date.setDate(date.getDate() + expiredays);\r\n        alert(date.toGMTString())\r\n        //cookie的内容其实就是一串纯文本。 对字符最好进行url编码，否则如果有中文会出现问题。\r\n        var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value) + &quot;; expires=&quot; + date.toGMTString();\r\n        document.cookie = cookieText;\r\n}\r\n    saveCookie(&quot;name&quot;, &quot;&quot;, 0);\r\n</code></pre>', '82', '\r\n\r\n# 一、BOM概述\r\n\r\n> BOM: Browser Object Model 浏览器对象模型\r\n\r\n## 1.1 什么是BOM\r\n\r\n> 浏览器对象模型(BOM)是[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")的组成之一，他提供了独立与内容与浏览器窗口进行交互的对象，使用浏览器对象模型可以实现与HTML的交互。\r\n> \r\n> ECMAScript是 JavaScript的核心，但如果要在 Web中使用 JavaScript，那么 BOM（浏览器对象模\r\n> 型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任\r\n> 何网页内容无关。\r\n\r\n## 1.2 BOM的作用\r\n\r\n> 将相关的元素组织包装起来，提供给程序设计人员使用，从而降低开发人员的工作量，提供设计Web页面的能力.BOM是一个分层结构。\r\n\r\n# 二、BOM核心—window对象\r\n\r\n## 2.1 window对象\r\n\r\n> BOM 的核心对象是 window ，它表示浏览器的一个实例。在浏览器中， window 对象有双重角色，\r\n> 它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。\r\n> \r\n> 通过window可以操作整个浏览器。\r\n> \r\n> BOM图谱：\r\n\r\n*   ![](http://www.itxueyuan.org/uploads/allimg/121112/1-121112154254459.png)\r\n\r\n> window对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的，也可以称为window的子对象。\r\n\r\n### 2.1.1 全局作用域\r\n\r\n> ? 由于 window 对象同时扮演着 ECMAScript中 Global 对象的角色，因此所有在全局作用域中声明\r\n> 的变量、函数都会变成 **window 对象的属性和方法**。\r\n> \r\n> 注意：有三种获取全局变量的方式。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var age = 29;   //声明一个全局变量\r\n    function sayAge() { //声明一个全局函数\r\n        alert(this.age);//this表示，调用这个函数时使用的对象。将来是通过window调用的，所以this指代的window\r\n    }\r\n    // 全局变量成为了window对象的属性。 所以可以通过window.age访问\r\n    alert(window.age); //29\r\n    sayAge(); //29\r\n    // 全局函数成为了window对象的方法。 所以可以通过window.sagAge() 来访问。\r\n    window.sayAge(); //29\r\n</script>\r\n//提示：虽然可以通过window对象来调用，但是实际开发的时，一般都省略window。\r\n```\r\n\r\n### 2.1.2 window窗口大小\r\n\r\n> A. 有三种方式获取浏览器的窗口大小：(浏览器的视口，不包括工具栏和滚动条)\r\n\r\n1.  在Internet Explorer(9+)、Chrome、Firefox、Opera 以及 Safari：\r\n\r\n    *   window.innerHeight - 浏览器窗口的内部高度\r\n    *   window.innerWidth - 浏览器窗口的内部宽度\r\n\r\n```\r\nvar msg = \"窗口宽度：\" + window.innerHeight + \"\\n窗口高度：\" + window.innerWidth;\r\nalert(msg );\r\n```\r\n\r\n1.  对于 Internet Explorer 8、7、6、5：(**Chrome和Firefox也支持**)\r\n\r\n    *   document.documentElement.clientHeight\r\n    *   document.documentElement.clientWidth\r\n\r\n```\r\nvar msg = \"窗口宽度：\" + document.documentElement.clientWidth + \"\\n窗口高度：\" + document.documentElement.clientHeight;\r\nalert(msg);\r\n```\r\n\r\n1.  为了兼容浏览器的版本可以使用下面的代码(可以涵盖所有的浏览器)\r\n\r\n```\r\nvar w = window.innerWidth || document.documentElement.clientWidth;\r\nvar h = window.innerHeight || document.documentElement.clientHeight;\r\nalert(\"窗口宽度：\" + w + \"\\n窗口高度：\" + h);\r\n```\r\n\r\n> B. 调整窗口大小：\r\n> \r\n> *   window.resizeTo(w, h) ：调整到指定的大小\r\n> *   resizeBy(deltW, deltH) ：增加指定值的窗口的宽和高\r\n> \r\n> 一些浏览器已经禁用了这个方法(Chrome和Firfox均禁用了这两个方法, ie可用)\r\n\r\n```\r\n<body>\r\n    <button onclick=\"to();\">调整到指定大小</button>\r\n    <br/>\r\n    <button onclick=\"by();\">宽高增加10个像素</button>\r\n\r\n    <script type=\"text/javascript\">\r\n        function to () {\r\n            alert(\"我要变小了\");\r\n            window.resizeTo(200, 300);\r\n        }\r\n        function by () {\r\n             alert(\"靠，变大了\");\r\n             window.resizeBy(10, 10);\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 2.1.3 打开窗口\r\n\r\n> open(URL,name,features) 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。\r\n> \r\n> | 参数 | 描述 |\r\n> | --- | --- |\r\n> | URL | 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 |\r\n> | name | 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 <a>和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</a> |\r\n> | features | 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在”“窗口特征”“这个表格中，我们对该字符串的格式进行了详细的说明。 |\r\n> \r\n> **备注：如果不用到frame框架，则只需要传入第1个参数和第3个参数即可**\r\n> \r\n> 窗口特征(常用)：\r\n> \r\n> | 属性名称 | 说 明 |\r\n> | --- | --- |\r\n> | height、width | 窗口文档显示区的高度、宽度。以像素计。 |\r\n> | left、top | 窗口的x坐标、y坐标。以像素计 |\r\n> | toolbar=yes | no |\r\n> | scrollbars=yes | no |\r\n> | location=yes | no |\r\n> | status=yes | no |\r\n> | menubar=yes | no |\r\n> | resizable=yes | no |\r\n> | titlebar=yes | no |\r\n> | fullscreen=yes | no |\r\n\r\n*   打开新的窗口，窗口特性全部使用默认值\r\n\r\n```\r\n<body>\r\n    <button onclick=\"openAnother();\">打开新窗口</button>\r\n\r\n    <script type=\"text/javascript\">\r\n    function openAnother () {\r\n        window.open(\"http://www.yztcedu.com\"); //打开新窗口，窗口特性全部使用默认值。\r\n    }\r\n    </script>\r\n</body>\r\n```\r\n\r\n*   打开新的窗口，设置窗口特性\r\n\r\n```\r\n<body>\r\n    <button onclick=\"openAnother();\">打开新窗口</button>\r\n\r\n    <script type=\"text/javascript\">\r\n      var win;\r\n      function openAnother () {\r\n          win = window.open(\"http://www.yztcedu.com\", \"\", \"width=400, height=400, toolbar = no, menubar = no,left = 200, right = 200\");\r\n      }\r\n    </script>\r\n</body>\r\n```\r\n\r\n*   open方法返回打开的那个窗口的window对象，可以调用close方法关闭新打开的窗口。\r\n\r\n```\r\nwin.close();\r\n\r\n//也可以调整新开窗口的大小位置等，但是大部分浏览器禁用了这个功能。\r\n```\r\n\r\n### 2.1.4 window中的定时器(超时调用和周期调用)(重点)\r\n\r\n> window对象提供了两个类似定时器功能的方法：超时调用和周期调用(间隙调用)\r\n> \r\n> JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。\r\n> 前者是在**指定的时间过后执行代码**，而后者则是**每隔指定的时间就执行一次代码**。\r\n\r\n1.  window.setTimeout()–超时调用\r\n\r\n```\r\n/*\r\n    setTimeout(code,millisec)\r\n    参数1：要执行代码。一般传入一个函数。(当然也可是字符串形式的代码，但是不建议使用)\r\n    参数2：多长时间后执行参数1中的代码。  单位毫秒\r\n*/\r\n<script type=\"text/javascript\">\r\n    //传入函数的时，函数名不要加括号。(因为方法不是我们调用，是引擎帮助我们调用)\r\n    // setTimeout方法会返回一个值，表示超时调用的id，可以在任务执行前取消任务。\r\n    var timeOutId = window.setTimeout(go, 3000);  // 3秒中之后执行函数go中的代码\r\n    function go () {\r\n        window.open(\"http://www.yztcedu.com\")\r\n    }   \r\n    timeoutId.cancel();  //取消这个超时调用，如果超时调用已经执行完毕，就什么也不会发生。\r\n</script>\r\n```\r\n\r\n1.  setInterval–周期调用(间隙调用)\r\n\r\n```\r\n/*\r\n    setInterval(code,millisec)\r\n    参数1：每隔一段时间执行一次的代码。  一般是一个函数\r\n    参数2：周期性执行的时间间隔。  单位毫秒\r\n\r\n*/\r\n<body>\r\n    <h1 id=\"time\"></h1>\r\n    <script type=\"text/javascript\">\r\n        //显示时间，每秒钟变化一次。\r\n        window.setInterval(function() {\r\n            var timeElement = document.getElementById(\"time\");  //找到h1标签\r\n            var msg = new Date().toLocaleString();\r\n            timeElement.innerHTML = msg;    //设置h1标签中的值\r\n        }, 1000);\r\n    </script>\r\n</body>\r\n    //清除间隔定时器\r\n    window.clearInterval(id);\r\n```\r\n\r\n### 2.1.5 系统对话框\r\n\r\n> 1.  alert()对话框\r\n>     \r\n>     \r\n> 2.  confirm()对话框.\r\n>     \r\n>     \r\n> \r\n> 方法用于显示一个带有指定消息和 **确定** 及 **取消** 按钮的对话框。\r\n> \r\n> 说明：如果用户点击确定按钮，则 confirm() 返回 true。如果点击取消按钮，则 confirm() 返回 false。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var isOk = window.confirm(\"你确定要抛弃我吗？\");\r\n    //根据用户的不同相动作做出不同响应\r\n    if(isOk){   //用户按下  确定\r\n        window.alert(\"祝你好运\");\r\n    }else { //用户按下  取消\r\n        window.alert(\"我们就再玩会吧\");\r\n    }\r\n</script>\r\n```\r\n\r\n> 1.  prompt(text, default) 这是一个提示框，用于提示用户输入一些文本。提示框中除了会有 确定和取消，还有一个可以让用户输入文本的文本框。方法的返回值是用户输入的具体的文本。\r\n>     \r\n>     \r\n>     *   参数1：提示语句\r\n>     *   参数2：输入文本框默认已经输入的字符，如果没有默认输入，不用传递\r\n>     *   返回值：如果用户按下 **确定，则返回具体的文本内容**，如果按下 **取消 返回 null**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var msg = prompt(\"请输入你的姓名：\");\r\n    if(msg != null && msg.length > 0){\r\n        alert(\"欢迎：\" + msg);\r\n    }\r\n</script>\r\n```\r\n\r\n## 2.2 location对象\r\n\r\n> location对象其实是window对象的子对象。可以 这样使用：window.location,但是使用的时候一般省略window。\r\n> \r\n> location 是最有用的 BOM对象之一，**它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。**\r\n> \r\n> 应用：**window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。**\r\n\r\n### 2.2.1 location对象的常用属性\r\n\r\n| 属性 | 描述 |\r\n| --- | --- |\r\n| host | 设置或返回主机名和当前 URL 的端口号。 |\r\n| hostname | 设置或返回当前 URL 的主机名。 |\r\n| href | 设置或返回完整的 URL。 |\r\n| pathname | 设置或返回当前 URL 的路径部分。 |\r\n| port | 设置或返回当前 URL 的端口号。 |\r\n| protocol | 设置或返回当前 URL 的协议。 |\r\n| search | 设置或返回从问号 (?) 开始的 URL（查询部分）。 |\r\n\r\n```\r\n\r\n<script type=\"text/javascript\">\r\n    //  http://192.168.1.100:8080/JsTest/html/demo2.html?user=lisi&pwd=aaa\r\n    document.write(\"protocol: \" + location.protocol + \"<br />\");    // 协议\r\n    document.write(\"hostname: \" + location.hostname + \"<br />\");        //主机名\r\n    document.write(\"host: \" + location.host +　\"<br />\");  //主机和端口\r\n    document.write(\"port: \" + location.port + \"<br />\");    //端口\r\n    document.write(\"pathname: \" + location.pathname + \"<br />\");    // 路径名\r\n    document.write(\"search: \" + location.search + \"<br />\");    // 查询参数\r\n    document.write(\"href: \" + location.href + \"<br />\");    //完整url \r\n</script>\r\n```\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-6/19190684.jpg)\r\n\r\n### 2.2.2 location常用方法\r\n\r\n| 属性 | 描述 |\r\n| --- | --- |\r\n| assign(url) | 加载新的文档。 |\r\n| reload(reforce) | 重新加载当前文档。 |\r\n| replace(newURL) | 用新的文档替换当前文档。 |\r\n\r\n> 1.  assign(newUrl): 加载新的文档。\r\n\r\n```\r\n<button onclick=\"openNewUrl();\">打开首页</button>\r\n<script type=\"text/javascript\">\r\n    function openNewUrl () {\r\n        location.assign(\"http://www.baidu.com\");\r\n    }\r\n</script>\r\n```\r\n\r\n> 1.  replace(reforce): 方法不会在 History 对象中生成一个新的记录。当使用该方法时，新的 URL 将覆盖 History 对象中的当前记录。按下回退键的不会返回到刚才的网页。\r\n\r\n```\r\n<button onclick=\"replaceDoc();\">替换当前网页</button>\r\n<script type=\"text/javascript\">\r\n    function replaceDoc () {\r\n        location.replace(\"http://www.yztcedu.com\");\r\n    }\r\n</script>\r\n```\r\n\r\n> 1.  reload([force]) 方法用于重新加载当前文档。\r\n>     \r\n>     \r\n>     *   参数force可选，可以为true。如果该方法没有规定参数，或者参数是 false，它就会用 HTTP 头 If-Modified-Since 来检测服务器上的文档是否已改变。如果文档已改变，reload() 会再次下载该文档。如果文档未改变，则该方法将从缓存中装载文档。如果把该方法的参数设置为true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。\r\n>     \r\n>     总结：有参为true时，从服务器重新下载，无参从缓存中重新加载\r\n>     \r\n>     \r\n>     \r\n>     **注意：reload()调用之后其后的代码有可能执行有可能不执行，所以一般放在最后**\r\n\r\n```\r\n<button onclick=\"reloadCurrrent();\">重写加载当前网页</button>\r\n<script type=\"text/javascript\">\r\n    function reloadCurrrent () {\r\n        location.reload(true);\r\n    }\r\n</script> \r\n```\r\n\r\n## 2.3 history对象(了解)\r\n\r\n> History 对象包含用户（在浏览器窗口中）访问过的 URL。\r\n> \r\n> History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。\r\n\r\n### 2.3.1 常用属性\r\n\r\n| 属性 | 描述 |\r\n| --- | --- |\r\n| length | 返回浏览器历史列表中的 URL 数量。 |\r\n\r\n```\r\n<button onclick=\"urlCount();\">历史列表中url数量</button>\r\n<script type=\"text/javascript\">\r\n    function urlCount () {\r\n        alert(\"历史列表中url数量：\" + history.length);\r\n    }\r\n</script>\r\n```\r\n\r\n### 2.3.2 常用方法\r\n\r\n| 方法 | 描述 |\r\n| --- | --- |\r\n| back() | 加载 history 列表中的前一个 URL。 |\r\n| forward() | 加载 history 列表中的下一个 URL。 |\r\n| go() | 加载 history 列表中的某个具体页面。 |\r\n\r\n```\r\n<button onclick=\"myForward();\">向前</button>\r\n<button onclick=\"myBack();\">向后</button>\r\n<button onclick=\"myGo(-2);\">后退2个页面</button>\r\n<script type=\"text/javascript\">\r\n    function myForward () {\r\n        history.forward();\r\n    }\r\n    function myBack () {\r\n        history.back();\r\n    }\r\n    function myGo (index) { // 负代表后退， 正代表前进\r\n        history.go(index);\r\n    }\r\n</script>\r\n```\r\n\r\n## 2.4 navigator对象(了解)\r\n\r\n> Navigator 对象包含有关浏览器的信息。\r\n> \r\n> Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。\r\n\r\n| 属性 | 说 明 |\r\n| --- | --- |\r\n| appCodeName | 浏览器代码名的字符串表示 |\r\n| appName | 官方浏览器名的字符串表示 |\r\n| appVersion | 浏览器版本信息的字符串表示 |\r\n| systemLanguage | 操作系统的语音 |\r\n| language | 浏览器的主语言 |\r\n| onLine | 是否联了因特网 |\r\n| cookieEnabled | 如果启用cookie返回true，否则返回false |\r\n| platform | 浏览器所在计算机平台的字符串表示 |\r\n| plugins | 安装在浏览器中的插件数组 |\r\n| userAgent | 用户代理头的字符串表示 |\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    document.write(\"appCodeName: \" + navigator.appCodeName + \"<br/>\");\r\n    document.write(\"appName: \" + navigator.appName + \"<br/>\");\r\n    document.write(\"appVersion: \" + navigator.appVersion + \"<br/>\");\r\n    document.write(\"systemLanguage : \" + navigator.systemLanguage + \"<br/>\");\r\n    document.write(\"language: \" + navigator.language  + \"<br/>\");\r\n    document.write(\"onLine: \" + navigator.onLine     + \"<br/>\");\r\n    document.write(\"cookieEnabled : \" + navigator.cookieEnabled     + \"<br/>\");\r\n    document.write(\"platform: \" + navigator.platform + \"<br/>\");\r\n    document.write(\"userAgent: \" + navigator.userAgent     + \"<br/>\");\r\n    document.write(\"plugins: \" + navigator.plugins     + \"<br/>\");\r\n</script>\r\n```\r\n\r\n## 2.5 screen对象(了解)\r\n\r\n> screen对象：包含有关用户屏幕的信息\r\n> \r\n> 在JavaScript中用处不大，只是用来表面客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等，各浏览器的screen对象都包含不相同的属性，罗列一些共同的.\r\n\r\n| 属性 | 说 明 |\r\n| --- | --- |\r\n| height | 屏幕的像素高度 |\r\n| width | 屏幕的像素宽度 |\r\n| colorDepth | 用于表现颜色的位数 |\r\n| availWidth | 屏幕的像素宽度减系统部件宽度之后的值(减去任务栏之后的宽度) |\r\n| availHeight | 部屏幕的像素高度减系统件的高度之后的值（减去任务栏之后的高度） |\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    document.write(\"height : \" + screen.height + \"<br/>\");\r\n    document.write(\"width : \" + screen.width + \"<br/>\");\r\n    document.write(\"colorDepth : \" + screen.colorDepth + \"<br/>\");\r\n    document.write(\"availWidth : \" + screen.availWidth + \"<br/>\");\r\n    document.write(\"availHeight \" + screen.availHeight + \"<br/>\");\r\n</script>\r\n```\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-6/53675508.jpg)\r\n\r\n# 三、window中常用事件\r\n\r\n## 3.1 onload—加载事件\r\n\r\n> 当整个页面加载完成的时会触发该事件。\r\n> \r\n> 语法：window.onload = function(){} 或者 window.onload = 方法名\r\n> \r\n> 注意：一般把事件注册的代码放在head中。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    window.onload = function () {\r\n        alert(\"页面加载完毕\");\r\n    }\r\n</script>\r\n```\r\n\r\n## 3.2 onscroll—滚动事件\r\n\r\n> 当窗口发生滚动会触发该事件\r\n> \r\n> 语法：window.onscroll = function(){} 或者 window.onscroll = 方法==名==;\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    window.onscroll = function() {\r\n        console.log(\"开始滚动...\")\r\n        //获取滚动距离。\r\n        //document.body.scrollTop: 只支持chorme，火狐和ie不支持， document.documentElement.scrollTop ie和火狐支持 chrome不支持\r\n        //这样就可以跨浏览器了。\r\n        console.log(document.documentElement.scrollTop || document.body.scrollTop);\r\n    }\r\n</script>\r\n```\r\n\r\n# 四、使用JavaScript操作cookie\r\n\r\n## 4.1 什么是cookie\r\n\r\n? Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。\r\n\r\n? Cookie 是在 HTTP 协议下，服务器或脚本可以维护客户工作站上信息的一种方式。Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。无论何时用户链接到服务器，Web 站点都可以访问 Cookie 信息。\r\n\r\n? cookie是浏览器提供的一种机制，它将document 对象的cookie属性提供给JavaScript。可以由JavaScript对其进行控制，而并不是JavaScript本身的性质。cookie是存于用户硬盘的一个文件，这个文件通常对应于一个域名，当浏览器再次访问这个域名时，便使这个cookie可用。因此，cookie可以跨越一个域名下的多个网页，但不能跨越多个域名使用。 而且不同的浏览器之间cookie不能共享。\r\n\r\n> **==cookie的本质就是用键值对存储在用户本地的一些数据，这些数据不同的网站，不同的浏览器是不能共享的==**\r\n\r\n## 4.2 cookie的用处\r\n\r\n? cookie机制将信息存储于用户硬盘，因此可以作为全局变量，这是它最大的一个优点。它可以用于以下几种场合。\r\n\r\n1.  保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。\r\n2.  跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便。\r\n3.  定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。\r\n4.  创建购物车。正如在前面的例子中使用cookie来记录用户需要购买的商品一样，在结账的时候可以统一提交。例如淘宝网就使用cookie记录了用户曾经浏览过的商品，方便随时进行比较。\r\n\r\n## 4.3 cookie的缺陷\r\n\r\n1.  cookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；\r\n2.  cookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的；\r\n3.  cookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；\r\n4.  cookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。\r\n\r\n## 4.4 cookie的构成\r\n\r\n> cookie 由浏览器保存的以下几块信息构成。\r\n\r\n1.  名称：一个唯一确定 cookie 的名称。cookie 名称是不区分大小写的，所以 myCookie 和 MyCookie被认为是同一个 cookie。然而，实践中最好将 cookie 名称看作是区分大小写的，因为某些服务器会这样处理 cookie。cookie 的名称必须是经过 URL 编码的。\r\n2.  值：储存在 cookie 中的字符串值。值必须被 URL 编码。\r\n3.  域：cookie 对于哪个域是有效的。所有向该域发送的请求中都会包含这个 cookie 信息。这个值可以包含子域（subdomain，如 www.wrox.com ），也可以不包含它（如. wrox.com ，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置 cookie 的那个域。\r\n4.  路径：对于指定域中的那个路径，应该向服务器发送 cookie。例如，你可以指定 cookie 只有从\r\n    [http://www.wrox.com/books/](http://www.wrox.com/books/) 中才能访问，那么 [http://www.wrox.com](http://www.wrox.com) 的页面就不会发送 cookie 信息，即使请求都是来自同一个域的。\r\n5.  失效时间：表示 cookie 何时应该被删除的时间戳（也就是，何时应该停止向服务器发送这个cookie）。默认情况下，浏览器会话结束时即将所有 cookie 删除；不过也可以自己设置删除时间。这个值是个 GMT 格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除cookie 的准确时间。因此，cookie 可在浏览器关闭后依然保存在用户的机器上。如果你设置的失效日期是个以前的时间，则 cookie 会被立刻删除。\r\n6.  安全标志：指定后，cookie 只有在使用 SSL 连接的时候才发送到服务器。例如，cookie 信息只\r\n    能发送给 [https://www.wrox.com](https://www.wrox.com) ，而 [http://www.wrox.com](http://www.wrox.com) 的请求则不能发送 cookie。\r\n\r\n## 4.5 存储cookie\r\n\r\n> 有2种途径去存储cookie.\r\n\r\n1.  服务器端通过http响应头Set-Cookie来通知浏览器存储cookie。例如：(这个暂时不研究，仅了解)。浏览器收到这个头响应头之后会自动存储这个cookie\r\n\r\n```\r\nHTTP/1.1 200 OK\r\nContent-type: text/html\r\nSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com\r\nOther-header: other-header-value\r\n```\r\n\r\n1.  客户端(浏览器端)通过JavaScript去存储cookie(重点研究)。Javascript操作cookie需要通过document的cookie属性来完成。\r\n\r\n```\r\n//存储cookie，并设置超时时间。  domaim和secure使用默认的情况\r\n<script type=\"text/javascript\">\r\n    /*\r\n        在存储cookie的时候，name和value是必须的\r\n        参数1：cookie的name\r\n        参数2：cookie的值\r\n        参数3：存储时间 单位天\r\n\r\n        只要name不同，就可以存储多个cookie\r\n    */\r\n    function saveCookie(name, value, expiredays){\r\n\r\n        var date = new Date();\r\n        alert(date.getDate())\r\n        date.setDate(date.getDate() + expiredays);\r\n        alert(date.toGMTString())\r\n        //cookie的内容其实就是一串纯文本。 对字符最好进行url编码，否则如果有中文就会出现问题。\r\n        var cookieText = encodeURIComponent(name) + \"=\" + encodeURIComponent(value) + \"; expires=\" + date.toGMTString();\r\n        document.cookie = cookieText;\r\n    }\r\n    saveCookie(\"name\", \"张三\", 1);\r\n</script>\r\n```\r\n\r\n## 4.5 读取cookie\r\n\r\n> 读取cookie仍然是通过document的cookie属性，不过字符串需要我们自己解析。\r\n> \r\n> 只能说，JavaScript的这个API设计的真烂\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function getCookie (name) {\r\n        //先拿到cookie字符串\r\n        var cookieText = document.cookie;\r\n        //获取要查找的 cookie的 name所在的下标\r\n        var index = cookieText.indexOf(name + \"=\");  // name=李四; ...\r\n        //如果下标不为-1，证明找到了\r\n        if(index != -1){\r\n            var endIndex = cookieText.indexOf(\";\", index);  //查找指定的cookie的结束为止\r\n            // 如果等于-1，证明没有找到;号，则把末尾设置为字符串的末尾\r\n            endIndex = (endIndex == -1 ? cookieText.length : endIndex);\r\n            //把想要的cookie的value截取出来\r\n            var value = cookieText.substring(index + (name + \"=\").length, endIndex);\r\n            //因为存储的时候使用了url编码，所以查到的东西需要url解码\r\n            return decodeURIComponent(value);\r\n        }\r\n    }\r\n    var value = getCookie(\"name\");\r\n    if(value){\r\n        alert(\"欢迎你：\" + value);\r\n    }\r\n\r\n</script>\r\n```\r\n\r\n## 4.6 删除cookie\r\n\r\n> 删除cookie的原理非常简单，只要把超时时间设置为0，就会立即删除了。\r\n\r\n```\r\nfunction saveCookie(name, value, expiredays){\r\n\r\n        var date = new Date();\r\n        alert(date.getDate())\r\n        date.setDate(date.getDate() + expiredays);\r\n        alert(date.toGMTString())\r\n        //cookie的内容其实就是一串纯文本。 对字符最好进行url编码，否则如果有中文会出现问题。\r\n        var cookieText = encodeURIComponent(name) + \"=\" + encodeURIComponent(value) + \"; expires=\" + date.toGMTString();\r\n        document.cookie = cookieText;\r\n}\r\n    saveCookie(\"name\", \"\", 0);\r\n```\r\n\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('57', 'js DOM操作', '<h1 id=\"h1--dom-\"><a name=\"一、DOM概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、DOM概述</h1><h2 id=\"h2-1-1-dom-\"><a name=\"1.1 DOM概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 DOM概念</h2><p>? DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描<br>绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p>\r\n<p>W3C DOM标准分为3部分：</p>\r\n<ul>\r\n<li>core DOM - 针对任何结构化文档的标准模型</li><li>XML DOM - 针对 XML 文档的标准模板</li><li>HTML DOM - 针对 HTML 文档的标准模型</li></ul>\r\n<p>备注：HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准，即操作HTML的元素</p>\r\n<p><strong>DOM级别</strong></p>\r\n<p>DOM Level 1:于1998年10月成为W3C的推荐标准。DOM 1级由两个模块组成：DOM核心（DOM Core）和DOM HTML。</p>\r\n<p>DOM Level 2:对DOM level 1做了扩展</p>\r\n<p>DOM Level 3:对DOM level 2做了进一步的扩展</p>\r\n<p>DOM Level 0: 首先我们的确定的是在DOM标准中并没有DOM 0级的。所谓的DOM 0级是DOM历史坐标中的一个参照点而已，具体说呢，DOM 0级指的是IE4和Netscape 4.0这些浏览器最初支持的DHTML。</p>\r\n<h2 id=\"h2-1-2-dom-\"><a name=\"1.2 DOM节点概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 DOM节点概述</h2><blockquote>\r\n<p>看下面的一段HTML：</p>\r\n</blockquote>\r\n<pre><code>\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n    &lt;title&gt;DOM节点分类&lt;/title&gt;\r\n  &lt;/head&gt;\r\n  &lt;body&gt;    \r\n    &lt;p id=&quot;p&quot;&gt;欢迎你!&lt;/p&gt;\r\n  &lt;/body&gt;\r\n  &lt;!-- 注释 --&gt;\r\n&lt;/html&gt;\r\n</code></pre><ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-6/6815318.jpg\" alt=\"\"></li></ul>\r\n<blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>document节点是每个文档的根节点</li><li><p>document节点下面只有一个 html节点，我们称之为<strong>文档元素</strong>。(documentElement)</p>\r\n<ul>\r\n<li>文档元素是文档的最外层元素，其他元素都包含在文档元素中。</li><li>一个文档只能有一个文档元素，在html中文档元素永远是 元素。</li></ul>\r\n</li><li><p>在DOM树中，html文档中每一处标记都可以用树中的一个节点来表示。</p>\r\n<ul>\r\n<li>html(元素)标签，通过元素节点表示</li><li>属性，通过属性节点来表示</li><li>文档类型，通过文档类型节点来表示</li><li>注释，通过注释类型来表示</li></ul>\r\n</li></ol>\r\n<h2 id=\"h2-1-3-dom-\"><a name=\"1.3 DOM节点分类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 DOM节点分类</h2><blockquote>\r\n<p>DOM中，共有12中节点类型，每一个节点，必是这12中类型中的一种。</p>\r\n</blockquote>\r\n<ol>\r\n<li>Node.ELEMENT_NODE (1) //元素</li><li>Node.ATTRIBUTE_NODE (2) //元素的属性</li><li>Node.TEXT_NODE (3) //</li><li>Node.CDATA_SECTION_NODE (4) //子节点一定为TextNode</li><li>Node.ENTITY_REFERENCE_NODE (5) //文档中的实体引用</li><li>Node.ENTITY_NODE (6) //</li><li>Node.PROCESSING_INSTRUCTION_NODE (7) //表示一个文档处理程序使用的特有指令。，无子节点</li><li>Node.COMMENT_NODE (8) //注释</li><li>Node.DOCUMENT_NODE (9) //最外层的Root element,包括所有其它节点 根节点</li><li>Node.DOCUMENT_TYPE_NODE (10) //DTD， 每个文档节点都有一个DocumentType节点，它提供文档类型的定义。</li><li>Node.DOCUMENT_FRAGMENT_NODE (11) //可以将文档片段看作轻量级或者更小型的Document节点。定义这种数据类型是因为通常希望只提取文档的一部分来处理。</li><li>Node.NOTATION_NODE (12) //DTD中的Nation定义 在XML文档中表示一个符号。</li></ol>\r\n<blockquote>\r\n<p>可以通过获取一个节点的nodeType属性来得到节点的类型。</p>\r\n<p>经常用到了比较重要的节点：<strong>(记住每个节点的数字值)</strong></p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>元素类型</th>\r\n<th>NodeType</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td><strong>元素</strong></td>\r\n<td>1</td>\r\n</tr>\r\n<tr>\r\n<td>属性</td>\r\n<td>2</td>\r\n</tr>\r\n<tr>\r\n<td>文本</td>\r\n<td>3</td>\r\n</tr>\r\n<tr>\r\n<td>注释</td>\r\n<td>8</td>\r\n</tr>\r\n<tr>\r\n<td>文档</td>\r\n<td>9</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"h2-1-4-\"><a name=\"1.4 节点属性（特性）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.4 节点属性（特性）</h2><ol>\r\n<li><p><strong>nodeName</strong>：节点名称(nodeName 始终包含 HTML 元素的大写字母标签名) nodeName 是只读的</p>\r\n<ul>\r\n<li>元素节点的 nodeName 与标签名相同</li><li>属性节点的 nodeName 与属性名相同（元素.getAttributeNode(“属性名”)获取属性节点）</li><li>文本节点的 nodeName 始终是 #text（通过元素的子节点获取）</li><li>注释节点的nodeName是#comment（通过元素的子节点获取）</li><li>文档节点的 nodeName 始终是 #document</li></ul>\r\n</li><li><p><strong>nodeValue</strong>：节点值 （设置或返回节点的值）</p>\r\n<ul>\r\n<li>元素节点的 nodeValue 是 undefined 或 null</li><li>属性节点的 nodeValue 是属性值</li><li>文本节点的 nodeValue 是文本本身</li><li>注释节点的nodeValue是注释里面的内容</li><li>文档节点的nodeValue 是null</li></ul>\r\n</li><li><p><strong>nodeType</strong>：节点类型</p>\r\n<ul>\r\n<li>元素 element 1</li><li>属性 attr 2</li><li>文本 text 3</li><li>注释 comments 8</li><li>文档 document 9</li></ul>\r\n</li></ol>\r\n<h1 id=\"h1--dom-document-\"><a name=\"二、DOM核心对象—document对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、DOM核心对象—document对象</h1><p>? <a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a> 通过 Document 类型表示文档。在浏览器中， document 对象是 HTMLDocument （继承<br>自 Document 类型）的一个实例，表示<strong>整个 HTML 页面</strong>。而且， document 对象是 window 对象的一个<br>属性，因此可以将其作为全局对象来访问。</p>\r\n<ul>\r\n<li>nodeType 的值为 9；</li><li>nodeName 的值为 “#document” ；</li><li>nodeValue 的值为 null ；</li><li>parentNode 的值为 null ；</li><li>ownerDocument 的值为 null ；</li><li>其子节点可能是一个 DocumentType （最多一个）、 Element （最多一个）、 ProcessingInstruction</li></ul>\r\n<p>或 Comment</p>\r\n<blockquote>\r\n<p>通过document对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-1-1-getelementbyid-id-\"><a name=\"2.1 获取节点方法1：getElementById(id)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 获取节点方法1：getElementById(id)</h2><blockquote>\r\n<p>在整个文档中，根据元素id来获取元素节点</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;h1 id=&quot;myH1&quot; class=&quot;hTitle&quot;&gt;这个是标题&lt;/h1&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //根据id获取元素\r\n        var h1 = document.getElementById(&quot;myH1&quot;);\r\n        alert(h1.id);  //查看这个元素的id\r\n        alert(h1.className);  //元素的 className\r\n        alert(h1.innerHTML);    //查看元素包含的所有HTML文本\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ul>\r\n<li>如果有多个元素的id相同，则只返回第一个元素。一般情况，不要给多个元素起同名id</li></ul>\r\n<h2 id=\"h2-2-2-2-getelementsbytagname-tagname-\"><a name=\"2.2 获取节点方法2：getElementsByTagName(tagName)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 获取节点方法2：getElementsByTagName(tagName)</h2><blockquote>\r\n<p>根据标签名获取元素节点。因为一个文档中会有多个同名标签，所以这个方法返回的是<strong>多个Element组成的集合</strong></p>\r\n<p>为了提高性能，在开发的时候应该尽量避免使用这种方式去查找元素，应该使用getElementById</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;h1 id=&quot;myH1&quot; class=&quot;hTitle&quot;&gt;这个是标题1&lt;/h1&gt;\r\n    &lt;h1 id=&quot;myH2&quot; class=&quot;hTitle&quot;&gt;这个是标题2&lt;/h1&gt;\r\n    &lt;h1 id=&quot;myH3&quot; class=&quot;hTitle&quot;&gt;这个是标题3&lt;/h1&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var h1s = document.getElementsByTagName(&quot;h1&quot;);\r\n        alert(h1s.length);\r\n        for (var i = 0; i &lt; h1s.length; i++) {\r\n            alert(h1s[i].id);     //可以通过下标访问    ht[i]\r\n            alert(h1s.item(i).id);  //  也可以通过item下标访问 item(i)\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-2-3-3-getelementbyname-name-\"><a name=\"2.3 获取节点方法3：getElementByName(name)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 获取节点方法3：getElementByName(name)</h2><blockquote>\r\n<p>这个是通过标签的name属性的值来获取元素的。由于会出现多个元素name属性的值相等，所以返回的是<strong>多个Element组成的集合</strong>.</p>\r\n<p>注意：不是所有的元素都有name属性，只有 <strong>表单标签</strong> 才有。而且某些低版本浏览器兼容有问题。慎用</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;form action=&quot;&quot;&gt;\r\n        爱好：&lt;br/&gt;\r\n        &lt;input type=&quot;checkbox&quot; name=&quot;lover&quot; value=&quot;swimming&quot;&gt;游泳&lt;br/&gt;        \r\n        &lt;input type=&quot;checkbox&quot; name=&quot;lover&quot; value=&quot;net&quot;&gt;上网\r\n    &lt;/form&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var lovers = document.getElementsByName(&quot;lover&quot;);       \r\n        for (var i = 0; i &lt; lovers.length; i++) {\r\n            alert(lovers[i].value);\r\n            //alert(lovers.item(i).value)\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-2-4-4-queryselector-css-\"><a name=\"2.4 获取节点的方法4：querySelector(css选择器)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 获取节点的方法4：querySelector(css选择器)</h2><p>参数：必须。指定一个或多个匹配元素的 CSS 选择器。 可以使用它们的 id, 类, 类型, 属性, 属性值等来选取元素。</p>\r\n<p>对于多个选择器，使用逗号隔开，返回一个匹配的元素。</p>\r\n<p>返回值：匹配指定 CSS 选择器的 <strong>第一个元素</strong> 。 如果没有找到，返回 null。</p>\r\n<pre><code>&lt;body&gt;\r\n    &lt;p id=&quot;demo&quot;&gt;id=&quot;demo&quot; 的 第一个 p 元素&lt;/p&gt;\r\n    &lt;p id=&quot;demo&quot;&gt;id=&quot;demo&quot; 的 第二个 p 元素&lt;/p&gt;\r\n\r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;点我修改id = demo 的第一个元素内容&lt;/button&gt;\r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            //返回第一个id=demo的元素\r\n            document.querySelector(&quot;#demo&quot;).innerHTML = &quot;Hello World!&quot;;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><pre><code>document.querySelector(&quot;p&quot;);    // 获取文档中第一个p元素(元素选择器)\r\ndocument.querySelector(&quot;p.example&quot;);  //获取文档中 class=&quot;example&quot; 的第一个 &lt;p&gt; 元素:\r\n</code></pre><h2 id=\"h2-2-5-5-queryselectorall-css-\"><a name=\"2.5 获取节点的方法5：querySelectorAll(css选择器)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5 获取节点的方法5：querySelectorAll(css选择器)</h2><blockquote>\r\n<p>querySelector只能获取第一个满足条件的元素，如果想获取所有满足条件的元素，可以使用<a href=\"http://lib.csdn.net/base/html5\" title=\"HTML5知识库\">HTML5</a>引入的新方法qureySelectorAll</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;p id=&quot;demo&quot;&gt;id=&quot;demo&quot; 的 第一个 p 元素&lt;/p&gt;\r\n    &lt;p id=&quot;demo&quot;&gt;id=&quot;demo&quot; 的 第二个 p 元素&lt;/p&gt;\r\n\r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;点我修改id = demo 的所有元素&lt;/button&gt;\r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            var all = document.querySelectorAll(&quot;#demo&quot;);\r\n            for (var i = 0; i &lt; all.length; i++) {\r\n                all[i].innerHTML = &quot;哈哈哈&quot;\r\n            }\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-2-6-documentelement-\"><a name=\"2.6 获取documentElement元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.6 获取documentElement元素</h2><blockquote>\r\n<p>documentElement 属性以一个元素对象返回一个文档的文档元素。HTML 文档返回对象为 <strong>HTML元素</strong>。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        alert(document.documentElement.nodeName);   // html\r\n        alert(document.documentElement.nodeValue);  // null\r\n        alert(document.documentElement.nodeType);   // 1\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--node-\"><a name=\"三、Node关系—获取操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、Node关系—获取操作</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 节点与节点之间的关系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 节点与节点之间的关系</h2><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>父（parent）节点 父节点拥有任意数量的子节点</li><li>子（child）节点 子节点拥有一个父节点</li><li>兄弟（sibling）节点 同级的子节点被称为同胞（兄弟或姐妹）。同胞是拥有相同父节点的节点</li><li><p>根 (root) 节点 一个文档只能有一个根节点。对html文档来说，根节点就是documentElement。根节点不可能有父节点</p>\r\n<ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-6/71336062.jpg\" alt=\"\"></li></ul>\r\n</li></ol>\r\n<h2 id=\"h2-3-2-childnodes-\"><a name=\"3.2 childNodes属性：获取一个元素的所有子节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 childNodes属性：获取一个元素的所有子节点</h2><blockquote>\r\n<p>childNodes：获取所有子节点。<strong>(但是不能获取到子节点的子节点)</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;\r\n        &lt;a href=&quot;&quot;&gt;搜狐&lt;/a&gt;\r\n        &lt;div&gt;\r\n            &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\r\n        &lt;/div&gt;\r\n         &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;\r\n    &lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //通过Element元素的childNodes属性获取到这个元素下面的所有直接子节点\r\n        var nodes = document.getElementById(&quot;div&quot;).childNodes;\r\n        for (var i = 0; i &lt; nodes.length; i++) {\r\n            alert(nodes[i].nodeName)\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-3-firstchild-\"><a name=\"3.3 firstChild属性：获取一个元素的第一个子节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 firstChild属性：获取一个元素的第一个子节点</h2><blockquote>\r\n<p>如果选定的节点没有子节点，则该属性返回 NULL。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;a href=&quot;&quot;&gt;搜狐&lt;/a&gt;\r\n        &lt;div&gt;\r\n            &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\r\n        &lt;/div&gt;\r\n         &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;\r\n    &lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div = document.getElementById(&quot;div&quot;);\r\n        var fistChild = div.firstChild; //第一个子节点\r\n        alert(fistChild.nodeName);  // A\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-4-lastchild-\"><a name=\"3.4 lastChild属性：获取一个元素的最后一个子节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 lastChild属性：获取一个元素的最后一个子节点</h2><blockquote>\r\n<p>lastChild 属性可返回文档的最后一个子节点。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;a href=&quot;&quot;&gt;搜狐&lt;/a&gt;\r\n        &lt;div&gt;\r\n            &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\r\n        &lt;/div&gt;\r\n         &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div = document.getElementById(&quot;div&quot;);\r\n        var lastChild = div.lastChild;  //最后一个节点\r\n        alert(lastChild.nodeName);  // INPUT\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-4-parentnode-\"><a name=\"3.4 parentNode属性：获取一个元素的父节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 parentNode属性：获取一个元素的父节点</h2><pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;a href=&quot;&quot;&gt;搜狐&lt;/a&gt;\r\n        &lt;div&gt;\r\n            &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\r\n        &lt;/div&gt;\r\n         &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div = document.getElementById(&quot;div&quot;);\r\n        var parentNode = div.parentNode;    //父节点\r\n        alert(parentNode.nodeName); // BODY\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-5-previoussibling-\"><a name=\"3.5 previousSibling属性：获取一个元素的上一个兄弟节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5 previousSibling属性：获取一个元素的上一个兄弟节点</h2><pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;a href=&quot;&quot;&gt;搜狐&lt;/a&gt;&lt;div id=&quot;div1&quot;&gt;\r\n            &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\r\n        &lt;/div&gt;\r\n         &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementById(&quot;div1&quot;);\r\n        var preSibling = div1.previousSibling;  //获取div1的父节点\r\n        alert(preSibling.nodeName); // A\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-6-nextsibling-\"><a name=\"3.6 nextSibling属性：获取一个元素的下一个节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.6 nextSibling属性：获取一个元素的下一个节点</h2><pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;a href=&quot;&quot;&gt;搜狐&lt;/a&gt;\r\n        &lt;div id=&quot;div1&quot;&gt;\r\n            &lt;a href=&quot;&quot;&gt;&lt;/a&gt;\r\n        &lt;/div&gt;\r\n        &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;\r\n    &lt;/div&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementById(&quot;div1&quot;);\r\n        var neSibling = div1.nextSibling;   // 下一个兄弟节点\r\n        alert(neSibling.nodeName);  // #text\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><p><strong>==补充：由于上述都是节点操作，所以获取到的节点会包含一些我们并不关心的内容，比如空节点。下面的几个api只获取元素节点。==</strong></p>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-11-30/75636359.jpg\" alt=\"\"></p>\r\n<h1 id=\"h1--node-\"><a name=\"四、Node关系—修改操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、Node关系—修改操作</h1><h2 id=\"h2-4-1-createtextnode-\"><a name=\"4.1 createTextNode()：创建文本节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 createTextNode()：创建文本节点</h2><blockquote>\r\n<p>document.createTextNode(<em>text</em>)</p>\r\n<p>参数：文本</p>\r\n<p>返回值：创建的文本标签</p>\r\n<p><strong><em>注意：这个方法是 document的方法，因为创建元素这么大的事，只能document来干，找某个element来创建不靠谱。</em></strong></p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var textNode = document.createTextNode(&quot;我是一个开心的文本！！！&quot;); //创建一个文本节点\r\n        alert(textNode.nodeName + &quot;\\n&quot; + textNode.nodeValue);   // #text    我是一个开心的文本！！！\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-2-appendchild-child-\"><a name=\"4.2 appendChild() : 给一个元素添加child节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 appendChild() : 给一个元素添加child节点</h2><blockquote>\r\n<p><em>element</em>.appendChild(<em>node</em>)</p>\r\n<p>参数：必须。表示要添加的节点</p>\r\n<p>返回值：参数对象本身</p>\r\n<p><strong><em>注意：append的意思是追加。如果元素已经有child，则追加到别的child之后。也就是说新添加的 child 进去之后一定是 lastChild</em></strong></p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div = document.getElementById(&quot;div&quot;);\r\n        var textNode = document.createTextNode(&quot;我是一个开心的文本！！！&quot;);\r\n        div.appendChild(textNode);  //把刚才创建的文本添加到div标签中。\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-3-createelement-nodename-\"><a name=\"4.3 createElement(nodename): 创建元素节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 createElement(nodename): 创建元素节点</h2><blockquote>\r\n<p>document.createElement(<em>nodename</em>)</p>\r\n<p>参数：必须。要创建的元素的名称</p>\r\n<p>返回：创建的元素节点</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;div&quot;&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div = document.getElementById(&quot;div&quot;);\r\n        var newElement = document.createElement(&quot;a&quot;);   //创建一个a标签\r\n        var textNode = document.createTextNode(&quot;首页&quot;);   // 创建一个文本节点\r\n        newElement.appendChild(textNode); //把 文本节点添加到a标签中\r\n        var v = div.appendChild(newElement);    // 把刚刚创建的a标签，添加为div标签的子标签\r\n        alert(v === newElement) // true 证明参数和返回值确实为同一个对象\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-4-insertbefore-\"><a name=\"4.4 insertBefore() : 在一个节点前插入新节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4 insertBefore() : 在一个节点前插入新节点</h2><blockquote>\r\n<p><em>node</em>.insertBefore(<em>newnode,existingnode</em>)</p>\r\n<p>参数1：要插入的新节点</p>\r\n<p>参数2：目标节点。会把参数1节点插入这个节点之前。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;ul id=&quot;language&quot;&gt;\r\n        &lt;li&gt;java&lt;/li&gt;\r\n        &lt;li&gt;c++&lt;/li&gt;\r\n    &lt;/ul&gt;    \r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;点我在java前插入JavaScript&lt;/button&gt;\r\n\r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            var newItem = document.createElement(&quot;li&quot;)\r\n            var textnode = document.createTextNode(&quot;JavaScript&quot;)\r\n            newItem.appendChild(textnode)\r\n\r\n            var languageList = document.getElementById(&quot;language&quot;)\r\n            //把newItem添加到languageList的第1个子节点之前\r\n            languageList.insertBefore(newItem, list.firstChild);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-5-removechild-\"><a name=\"4.5 removeChild(): 移除子节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5 removeChild(): 移除子节点</h2><blockquote>\r\n<p><em>node</em>.removeChild(<em>node</em>)</p>\r\n<p>参数：必须。要移除的那个子节点</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;ul id=&quot;language&quot;&gt;\r\n        &lt;li&gt;java&lt;/li&gt;\r\n        &lt;li&gt;c++&lt;/li&gt;\r\n        &lt;li&gt;oc&lt;/li&gt;\r\n        &lt;li&gt;php&lt;/li&gt;\r\n        &lt;li&gt;c#&lt;/li&gt;\r\n        &lt;li&gt;JavaScript&lt;/li&gt;       \r\n    &lt;/ul&gt;\r\n\r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;点我移除第1条语言&lt;/button&gt;\r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            var languageList = document.getElementById(&quot;language&quot;);\r\n            //获取到languageList下面的所有的 li 标签\r\n            var liList = languageList.getElementsByTagName(&quot;li&quot;);\r\n            // 移除第一个 li 元素。 如果重复调用，则每次都是移除第1个\r\n            languageList.removeChild(liList[0]);\r\n            alert(liList.length)\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-6-replacechild-\"><a name=\"4.6 replaceChild()：替换子节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.6 replaceChild()：替换子节点</h2><blockquote>\r\n<p><em>node</em>.replaceChild(<em>newnode</em>,<em>oldnode</em>)</p>\r\n<p>参数1：新节点</p>\r\n<p>参数2：旧节点</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;ul id=&quot;language&quot;&gt;\r\n        &lt;li&gt;java&lt;/li&gt;\r\n        &lt;li&gt;c++&lt;/li&gt;\r\n        &lt;li&gt;oc&lt;/li&gt;\r\n        &lt;li&gt;php&lt;/li&gt;\r\n        &lt;li&gt;c#&lt;/li&gt;\r\n        &lt;li&gt;JavaScript&lt;/li&gt;       \r\n    &lt;/ul&gt;\r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;点我替换第一条语言&lt;/button&gt;\r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            var languageList = document.getElementById(&quot;language&quot;);\r\n            var newLi = document.createElement(&quot;li&quot;);\r\n            newLi.innerHTML=&quot;JavaScript&quot;;\r\n            //用新节点去替换旧节点。\r\n            languageList.replaceChild(newLi, languageList.childNodes[1]);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-6-clonenode-\"><a name=\"4.6 cloneNode()：克隆节点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.6 cloneNode()：克隆节点</h2><blockquote>\r\n<p>node.cloneNode(deep):</p>\r\n<p>cloneNode() 方法可创建指定的节点的精确拷贝。拷贝所有属性和值。</p>\r\n<p>该方法将复制并返回调用它的节点的副本。如果传递给它的参数是 <strong>true，它还将递归复制当前节点的所有子孙节点</strong>。否则，它只复制当前节点。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;ul id=&quot;language&quot;&gt;\r\n        &lt;li&gt;java&lt;/li&gt;\r\n        &lt;li&gt;c++&lt;/li&gt;\r\n        &lt;li&gt;oc&lt;/li&gt;\r\n        &lt;li&gt;php&lt;/li&gt;\r\n        &lt;li&gt;c#&lt;/li&gt;\r\n        &lt;li&gt;JavaScript&lt;/li&gt;       \r\n    &lt;/ul&gt;   \r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;点我clone整个列表&lt;/button&gt;\r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            var languageList = document.getElementById(&quot;language&quot;);\r\n            //克隆languageList整个节点，传入true表示深度copy，所有的子节点都copy\r\n            var newList = languageList.cloneNode(true);\r\n            document.getElementsByTagName(&quot;body&quot;)[0].appendChild(newList);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"五、元素属性操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、元素属性操作</h1><blockquote>\r\n<p>在HTML中，一个元素会有很多属性，比如id属性，class属性，title属性等等，如何操作这些呢？</p>\r\n</blockquote>\r\n<h2 id=\"h2-5-1-getattribute-\"><a name=\"5.1 getAttribute():获取属性值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 getAttribute():获取属性值</h2><blockquote>\r\n<p><em>element</em>.getAttribute(<em>attributename</em>)</p>\r\n<p>返回元素的指定属性的值。</p>\r\n<p>参数：元素的某个属性的名 (id, className, title)</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;a id=&quot;id1&quot; href=&quot;http://www.yztcedu.com&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;.\r\n    &lt;br /&gt;\r\n    &lt;p&gt;\r\n        &lt;button onclick=&quot;myFunction()&quot;&gt;点我获取超级链接的 id 属性值，tafget 属性值&lt;/button&gt;\r\n    &lt;/p&gt;\r\n    &lt;script&gt;\r\n    function myFunction() {\r\n        var a1 = document.getElementById(&quot;id1&quot;);\r\n        alert(&quot;id = &quot; + a1.getAttribute(&quot;id&quot;) + &quot;\\ntarget = &quot; + a1.getAttribute(&quot;target&quot;));\r\n    }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-5-2-setattribute-\"><a name=\"5.2 setAttribute(): 设置属性值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 setAttribute(): 设置属性值</h2><blockquote>\r\n<p><em>element</em>.setAttribute(<em>attributename</em>,<em>attributevalue</em>)</p>\r\n<p>作用：创建建或改变某个新属性。如果指定属性已经存在,则只设置该值。如果属性不存在，则创建该属性并设置属性值。</p>\r\n<p>参数1：属性名</p>\r\n<p>参数2：新的属性值</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;input value=&quot;OK&quot; &gt;\r\n      &lt;br/&gt;\r\n    &lt;button onclick=&quot;myFunction()&quot;&gt;点我把上述文本框的 type 属性设置为 button 样式&lt;/button&gt;\r\n    &lt;script&gt;\r\n        function myFunction() {\r\n            var inputs = document.getElementsByTagName(&quot;input&quot;);\r\n            //把input的 type属性设置为button\r\n            inputs[0].setAttribute(&quot;type&quot;, &quot;button&quot;);\r\n        };\r\n    &lt;/script&gt;   \r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-5-2-removeattribute-\"><a name=\"5.2 removeAttribute() : 移除属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 removeAttribute() : 移除属性</h2><blockquote>\r\n<p><em>element</em>.removeAttribute(<em>attributename</em>)</p>\r\n<p>参数：必需。规定要删除的属性的名称。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;  \r\n    &lt;input id=&quot;input1&quot; type=&quot;button&quot; value=&quot;点我可以转换我的状态&quot; onclick=&quot;myFunction();&quot;&gt;\r\n    &lt;script&gt;\r\n        function myFunction() {         \r\n            var input1 = document.getElementById(&quot;input1&quot;);\r\n            var typeValue = input1.getAttribute(&quot;type&quot;);\r\n            if(typeValue){\r\n                input1.removeAttribute(&quot;type&quot;); //如果type属性有值就把这个属性去掉\r\n            }else {\r\n                input1.setAttribute(&quot;type&quot;, &quot;button&quot;);  //如果type属性不存就添加属性。\r\n            }\r\n        };\r\n    &lt;/script&gt;   \r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"六、元素节点的常用属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、元素节点的常用属性</h1><blockquote>\r\n<p>元素节点除了有所有的节点都有的属性比如：nodeName、nodeValue、nodeType外，还有一些特有的属性，来方便操作标签元素。</p>\r\n</blockquote>\r\n<h2 id=\"h2-6-1-tagname-\"><a name=\"6.1 tagName属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1 tagName属性</h2><blockquote>\r\n<p>tagName属性是nodeName的另一中写法。注意区别是：tagName只在标签节点中有，而nodeName在所有类型的(12种)节点中都存在。</p>\r\n<p>它的值表示的就是标签的名字。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;  \r\n    &lt;p id=&quot;p1&quot;&gt;我是一个p标签&lt;/p&gt; \r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var p1 = document.getElementById(&quot;p1&quot;);\r\n        alert(p1.tagName);  // p\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-6-2-innerhtml-\"><a name=\"6.2 innerHTML属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2 innerHTML属性</h2><blockquote>\r\n<p>innerHTML 属性设置或返回标签的开始和结束标签之间的 HTML。</p>\r\n<p>值为为文本</p>\r\n<p>注意：这个属性的值是这个标签的开始和结束部分之间的所有内容，但是</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;p id=&quot;p1&quot;&gt;&lt;a href=&quot;http://www.yztcedu.com&quot;&gt;点我进入官网&lt;/a&gt;&lt;/p&gt;\r\n\r\n    &lt;P&gt;&lt;button onclick=&quot;getHTML();&quot;&gt;点我获取超级链接的所有内容&lt;/button&gt;&lt;/P&gt;\r\n\r\n    &lt;p&gt;&lt;button onclick=&quot;setHTML();&quot;&gt;点我更改整个超级链接&lt;/button&gt;&lt;/p&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var p1 = document.getElementById(&quot;p1&quot;);\r\n        function getHTML () {\r\n            alert(p1.innerHTML);\r\n        }\r\n        function setHTML () {\r\n            p1.innerHTML = &quot;&lt;a href=&#39;https://www.baidu.com&#39;&gt;点我进入百度主页&lt;/a&gt;&quot;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-6-3-innertext-\"><a name=\"6.3 innerText属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3 innerText属性</h2><blockquote>\r\n<p>innerText值获取标签中的文本内容，子标签本身不会获取到。</p>\r\n<p>去修改的时候，即使带有标签也会把标签作为纯文本来对待，而不会解析为标签</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;p id=&quot;p1&quot;&gt;&lt;a href=&quot;http://www.yztcedu.com&quot;&gt;点我进入官网&lt;/a&gt;&lt;/p&gt;\r\n\r\n    &lt;P&gt;&lt;button onclick=&quot;getHTML();&quot;&gt;点我获取超级\r\n      链接的所有内容&lt;/button&gt;&lt;/P&gt;\r\n\r\n    &lt;p&gt;&lt;button onclick=&quot;setHTML();&quot;&gt;点我更改整个超级链接&lt;/button&gt;&lt;/p&gt;\r\n\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var p1 = document.getElementById(&quot;p1&quot;);\r\n        function getHTML () {\r\n            alert(p1.innerText);\r\n        }\r\n        function setHTML () {\r\n            p1.innerText = &quot;&lt;a href=&#39;https://www.baidu.com&#39;&gt;点我进入百度主页&lt;/a&gt;&quot;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n//其实还有一个属性：textContent 和innerText的作用相同。\r\n</code></pre><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-7/80671041.jpg\" alt=\"\"><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-7/78552439.jpg\" alt=\"\"></p>\r\n<h2 id=\"h2-6-4-id-\"><a name=\"6.4 id属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.4 id属性</h2><blockquote>\r\n<p>就是指的元素节点的id属性的值，与getAttribute(“id”)的值是一样的。</p>\r\n</blockquote>\r\n<h2 id=\"h2-6-5-classname-\"><a name=\"6.5 className属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.5 className属性</h2><blockquote>\r\n<p>className 属性设置或返回元素的 class 属性。(因为class在js中是关键字，所以这个地方把属性名字改成了className)</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;p class=&quot;p1&quot;&gt;这是一个段落&lt;/p&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var p1 = document.querySelector(&quot;.p1&quot;);\r\n        alert(p1.className);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-6-7-value-\"><a name=\"6.7 value属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.7 value属性</h2><blockquote>\r\n<p>如果一个标签可以拥有value值，则可以可以通过element.value来获取。</p>\r\n<p>一般表单数据才具有vlaue：input、textarea、select</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n     &lt;input id=&quot;in1&quot; type=&quot;text&quot; value=&quot;abc&quot; /&gt;\r\n     &lt;p&gt;\r\n        &lt;button id=&quot;btn&quot; onclick=&quot;getValue();&quot; value=&quot;abc&quot;&gt;获取上面输入框的value属性&lt;/button&gt;\r\n     &lt;/p&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var in1 = document.getElementById(&quot;in1&quot;);\r\n        function getValue () {\r\n            alert(in1.value);   // 获取标签的value值\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--css-\"><a name=\"七、样式表的属性—css脚本化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、样式表的属性—css脚本化</h1><blockquote>\r\n<p>可以通过JavaScript访问css的属性，并修改css属性</p>\r\n</blockquote>\r\n<h2 id=\"h2-7-1-\"><a name=\"7.1 获取和修改行间样式表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.1 获取和修改行间样式表</h2><blockquote>\r\n<p>有2中方式访访问到行间样式表</p>\r\n<ol>\r\n<li>element.style.css属性名</li><li>element.style[“属性名”]</li></ol>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var box1 = document.getElementById(&quot;box1&quot;);\r\n        box1.style.width = &quot;100px&quot;; //设置css属性.   设置所有属性都要使用引号括起来。\r\n        box1.style[&quot;height&quot;] = &quot;100px&quot;;\r\n        box1.style.backgroundColor = &quot;blue&quot;;\r\n        alert(box1.style[&quot;width&quot;]);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-7-2-\"><a name=\"7.2 获取内部样式表和外部样式表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2 获取内部样式表和外部样式表</h2><blockquote>\r\n<ol>\r\n<li>对ie浏览器：对象.currentSytle[“属性名”]</li><li>其他浏览器：window.getComputedStyle(对象，null)[“属性名”]</li></ol>\r\n<p><strong><em>注意：内部样式表中的属性和外部样式表中的属性只能获取不能修改。如果想修改需要通过行间样式表修改，行间样式表的优先级最高，会覆盖内部样式表和外部样式表。</em></strong></p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var box1 = document.getElementById(&quot;box1&quot;);\r\n        // alert(box1.currentStyle[&quot;width&quot;]); //只支持IE浏览器\r\n        // alert(window.getComputedStyle(box1, null)[&quot;height&quot;]); //支持浏览器外的其他浏览器\r\n        alert(getStyle(box1, &quot;backgroundColor&quot;));\r\n        /*\r\n            为了简化书写和兼容浏览器，一般封装一个方法出来\r\n        */\r\n        function getStyle (obj, attributeName) {    \r\n            if(obj.currentStyle){   //如果存在对象，则是在ie浏览器\r\n                return obj.currentStyle[attributeName];\r\n            }else { //其他浏览器\r\n                return window.getComputedStyle(obj, null)[attributeName];\r\n            }\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><p><strong>补充：</strong></p>\r\n<blockquote>\r\n<p><strong><em>offsetWidth、offsetHeight 可以获取宽和高，包括 border 和 padding，其实是这个元素的实际占据的空间。但是只能获取不能修改</em></strong></p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-12-7/73018201.jpg\" alt=\"\"></p>\r\n', '83', '\r\n# 一、DOM概述\r\n\r\n## 1.1 DOM概念\r\n\r\n? DOM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。DOM 描\r\n绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。\r\n\r\nW3C DOM标准分为3部分：\r\n\r\n*   core DOM - 针对任何结构化文档的标准模型\r\n*   XML DOM - 针对 XML 文档的标准模板\r\n*   HTML DOM - 针对 HTML 文档的标准模型\r\n\r\n备注：HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准，即操作HTML的元素\r\n\r\n**DOM级别**\r\n\r\nDOM Level 1:于1998年10月成为W3C的推荐标准。DOM 1级由两个模块组成：DOM核心（DOM Core）和DOM HTML。\r\n\r\nDOM Level 2:对DOM level 1做了扩展\r\n\r\nDOM Level 3:对DOM level 2做了进一步的扩展\r\n\r\nDOM Level 0: 首先我们的确定的是在DOM标准中并没有DOM 0级的。所谓的DOM 0级是DOM历史坐标中的一个参照点而已，具体说呢，DOM 0级指的是IE4和Netscape 4.0这些浏览器最初支持的DHTML。\r\n\r\n## 1.2 DOM节点概述\r\n\r\n> 看下面的一段HTML：\r\n\r\n```\r\n\r\n<html>\r\n  <head>\r\n    <title>DOM节点分类</title>\r\n  </head>\r\n  <body>    \r\n    <p id=\"p\">欢迎你!</p>\r\n  </body>\r\n  <!-- 注释 -->\r\n</html>\r\n```\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-6/6815318.jpg)\r\n\r\n> 说明：\r\n\r\n1.  document节点是每个文档的根节点\r\n2.  document节点下面只有一个 html节点，我们称之为**文档元素**。(documentElement)\r\n\r\n    *   文档元素是文档的最外层元素，其他元素都包含在文档元素中。\r\n    *   一个文档只能有一个文档元素，在html中文档元素永远是 元素。\r\n3.  在DOM树中，html文档中每一处标记都可以用树中的一个节点来表示。\r\n\r\n    *   html(元素)标签，通过元素节点表示\r\n    *   属性，通过属性节点来表示\r\n    *   文档类型，通过文档类型节点来表示\r\n    *   注释，通过注释类型来表示\r\n\r\n## 1.3 DOM节点分类\r\n\r\n> DOM中，共有12中节点类型，每一个节点，必是这12中类型中的一种。\r\n\r\n1.  Node.ELEMENT_NODE (1) //元素\r\n2.  Node.ATTRIBUTE_NODE (2) //元素的属性\r\n3.  Node.TEXT_NODE (3) //\r\n4.  Node.CDATA_SECTION_NODE (4) //子节点一定为TextNode\r\n5.  Node.ENTITY_REFERENCE_NODE (5) //文档中的实体引用\r\n6.  Node.ENTITY_NODE (6) //\r\n7.  Node.PROCESSING_INSTRUCTION_NODE (7) //表示一个文档处理程序使用的特有指令。，无子节点\r\n8.  Node.COMMENT_NODE (8) //注释\r\n9.  Node.DOCUMENT_NODE (9) //最外层的Root element,包括所有其它节点 根节点\r\n10.  Node.DOCUMENT_TYPE_NODE (10) //DTD， 每个文档节点都有一个DocumentType节点，它提供文档类型的定义。\r\n11.  Node.DOCUMENT_FRAGMENT_NODE (11) //可以将文档片段看作轻量级或者更小型的Document节点。定义这种数据类型是因为通常希望只提取文档的一部分来处理。\r\n12.  Node.NOTATION_NODE (12) //DTD中的Nation定义 在XML文档中表示一个符号。\r\n\r\n> 可以通过获取一个节点的nodeType属性来得到节点的类型。\r\n> \r\n> 经常用到了比较重要的节点：**(记住每个节点的数字值)**\r\n\r\n| 元素类型 | NodeType |\r\n| --- | --- |\r\n| **元素** | 1 |\r\n| 属性 | 2 |\r\n| 文本 | 3 |\r\n| 注释 | 8 |\r\n| 文档 | 9 |\r\n\r\n## 1.4 节点属性（特性）\r\n\r\n1.  **nodeName**：节点名称(nodeName 始终包含 HTML 元素的大写字母标签名) nodeName 是只读的\r\n\r\n    *   元素节点的 nodeName 与标签名相同\r\n    *   属性节点的 nodeName 与属性名相同（元素.getAttributeNode(“属性名”)获取属性节点）\r\n    *   文本节点的 nodeName 始终是 #text（通过元素的子节点获取）\r\n    *   注释节点的nodeName是#comment（通过元素的子节点获取）\r\n    *   文档节点的 nodeName 始终是 #document\r\n2.  **nodeValue**：节点值 （设置或返回节点的值）\r\n\r\n    *   元素节点的 nodeValue 是 undefined 或 null\r\n    *   属性节点的 nodeValue 是属性值\r\n    *   文本节点的 nodeValue 是文本本身\r\n    *   注释节点的nodeValue是注释里面的内容\r\n    *   文档节点的nodeValue 是null\r\n3.  **nodeType**：节点类型\r\n\r\n    *   元素 element 1\r\n    *   属性 attr 2\r\n    *   文本 text 3\r\n    *   注释 comments 8\r\n    *   文档 document 9\r\n\r\n# 二、DOM核心对象—document对象\r\n\r\n? [JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\") 通过 Document 类型表示文档。在浏览器中， document 对象是 HTMLDocument （继承\r\n自 Document 类型）的一个实例，表示**整个 HTML 页面**。而且， document 对象是 window 对象的一个\r\n属性，因此可以将其作为全局对象来访问。\r\n\r\n*   nodeType 的值为 9；\r\n*   nodeName 的值为 “#document” ；\r\n*   nodeValue 的值为 null ；\r\n*   parentNode 的值为 null ；\r\n*   ownerDocument 的值为 null ；\r\n*   其子节点可能是一个 DocumentType （最多一个）、 Element （最多一个）、 ProcessingInstruction\r\n\r\n或 Comment\r\n\r\n> 通过document对象，不仅可以取得与页面有关的信息，而且还能操作页面的外观及其底层结构。\r\n\r\n## 2.1 获取节点方法1：getElementById(id)\r\n\r\n> 在整个文档中，根据元素id来获取元素节点\r\n\r\n```\r\n<body>\r\n    <h1 id=\"myH1\" class=\"hTitle\">这个是标题</h1>\r\n    <script type=\"text/javascript\">\r\n        //根据id获取元素\r\n        var h1 = document.getElementById(\"myH1\");\r\n        alert(h1.id);  //查看这个元素的id\r\n        alert(h1.className);  //元素的 className\r\n        alert(h1.innerHTML);    //查看元素包含的所有HTML文本\r\n    </script>\r\n</body>\r\n```\r\n\r\n> 注意：\r\n\r\n*   如果有多个元素的id相同，则只返回第一个元素。一般情况，不要给多个元素起同名id\r\n\r\n## 2.2 获取节点方法2：getElementsByTagName(tagName)\r\n\r\n> 根据标签名获取元素节点。因为一个文档中会有多个同名标签，所以这个方法返回的是**多个Element组成的集合**\r\n> \r\n> 为了提高性能，在开发的时候应该尽量避免使用这种方式去查找元素，应该使用getElementById\r\n\r\n```\r\n<body>\r\n    <h1 id=\"myH1\" class=\"hTitle\">这个是标题1</h1>\r\n    <h1 id=\"myH2\" class=\"hTitle\">这个是标题2</h1>\r\n    <h1 id=\"myH3\" class=\"hTitle\">这个是标题3</h1>\r\n    <script type=\"text/javascript\">\r\n        var h1s = document.getElementsByTagName(\"h1\");\r\n        alert(h1s.length);\r\n        for (var i = 0; i < h1s.length; i++) {\r\n            alert(h1s[i].id);     //可以通过下标访问    ht[i]\r\n            alert(h1s.item(i).id);  //  也可以通过item下标访问 item(i)\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 2.3 获取节点方法3：getElementByName(name)\r\n\r\n> 这个是通过标签的name属性的值来获取元素的。由于会出现多个元素name属性的值相等，所以返回的是**多个Element组成的集合**.\r\n> \r\n> 注意：不是所有的元素都有name属性，只有 **表单标签** 才有。而且某些低版本浏览器兼容有问题。慎用\r\n\r\n```\r\n<body>\r\n    <form action=\"\">\r\n        爱好：<br/>\r\n        <input type=\"checkbox\" name=\"lover\" value=\"swimming\">游泳<br/>        \r\n        <input type=\"checkbox\" name=\"lover\" value=\"net\">上网\r\n    </form>\r\n    <script type=\"text/javascript\">\r\n        var lovers = document.getElementsByName(\"lover\");       \r\n        for (var i = 0; i < lovers.length; i++) {\r\n            alert(lovers[i].value);\r\n            //alert(lovers.item(i).value)\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 2.4 获取节点的方法4：querySelector(css选择器)\r\n\r\n参数：必须。指定一个或多个匹配元素的 CSS 选择器。 可以使用它们的 id, 类, 类型, 属性, 属性值等来选取元素。\r\n\r\n对于多个选择器，使用逗号隔开，返回一个匹配的元素。\r\n\r\n返回值：匹配指定 CSS 选择器的 **第一个元素** 。 如果没有找到，返回 null。\r\n\r\n```\r\n<body>\r\n    <p id=\"demo\">id=\"demo\" 的 第一个 p 元素</p>\r\n    <p id=\"demo\">id=\"demo\" 的 第二个 p 元素</p>\r\n\r\n    <button onclick=\"myFunction()\">点我修改id = demo 的第一个元素内容</button>\r\n    <script>\r\n        function myFunction() {\r\n            //返回第一个id=demo的元素\r\n            document.querySelector(\"#demo\").innerHTML = \"Hello World!\";\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n```\r\ndocument.querySelector(\"p\");    // 获取文档中第一个p元素(元素选择器)\r\ndocument.querySelector(\"p.example\");  //获取文档中 class=\"example\" 的第一个 <p> 元素:\r\n```\r\n\r\n## 2.5 获取节点的方法5：querySelectorAll(css选择器)\r\n\r\n> querySelector只能获取第一个满足条件的元素，如果想获取所有满足条件的元素，可以使用[HTML5](http://lib.csdn.net/base/html5 \"HTML5知识库\")引入的新方法qureySelectorAll\r\n\r\n```\r\n<body>\r\n    <p id=\"demo\">id=\"demo\" 的 第一个 p 元素</p>\r\n    <p id=\"demo\">id=\"demo\" 的 第二个 p 元素</p>\r\n\r\n    <button onclick=\"myFunction()\">点我修改id = demo 的所有元素</button>\r\n    <script>\r\n        function myFunction() {\r\n            var all = document.querySelectorAll(\"#demo\");\r\n            for (var i = 0; i < all.length; i++) {\r\n                all[i].innerHTML = \"哈哈哈\"\r\n            }\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 2.6 获取documentElement元素\r\n\r\n> documentElement 属性以一个元素对象返回一个文档的文档元素。HTML 文档返回对象为 **HTML元素**。\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        alert(document.documentElement.nodeName);   // html\r\n        alert(document.documentElement.nodeValue);  // null\r\n        alert(document.documentElement.nodeType);   // 1\r\n    </script>\r\n</body>\r\n```\r\n\r\n# 三、Node关系—获取操作\r\n\r\n## 3.1 节点与节点之间的关系\r\n\r\n> 说明：\r\n\r\n1.  父（parent）节点 父节点拥有任意数量的子节点\r\n2.  子（child）节点 子节点拥有一个父节点\r\n3.  兄弟（sibling）节点 同级的子节点被称为同胞（兄弟或姐妹）。同胞是拥有相同父节点的节点\r\n4.  根 (root) 节点 一个文档只能有一个根节点。对html文档来说，根节点就是documentElement。根节点不可能有父节点\r\n\r\n    *   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-6/71336062.jpg)\r\n\r\n## 3.2 childNodes属性：获取一个元素的所有子节点\r\n\r\n> childNodes：获取所有子节点。**(但是不能获取到子节点的子节点)**\r\n\r\n```\r\n<body>\r\n    <div id=\"div\">\r\n        <a href=\"\">搜狐</a>\r\n        <div>\r\n            <a href=\"\"></a>\r\n        </div>\r\n         <input type=\"text\" name=\"user\" />\r\n    </div>\r\n    <script type=\"text/javascript\">\r\n        //通过Element元素的childNodes属性获取到这个元素下面的所有直接子节点\r\n        var nodes = document.getElementById(\"div\").childNodes;\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            alert(nodes[i].nodeName)\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.3 firstChild属性：获取一个元素的第一个子节点\r\n\r\n> 如果选定的节点没有子节点，则该属性返回 NULL。\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"><a href=\"\">搜狐</a>\r\n        <div>\r\n            <a href=\"\"></a>\r\n        </div>\r\n         <input type=\"text\" name=\"user\" />\r\n    </div>\r\n    <script type=\"text/javascript\">\r\n        var div = document.getElementById(\"div\");\r\n        var fistChild = div.firstChild; //第一个子节点\r\n        alert(fistChild.nodeName);  // A\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.4 lastChild属性：获取一个元素的最后一个子节点\r\n\r\n> lastChild 属性可返回文档的最后一个子节点。\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"><a href=\"\">搜狐</a>\r\n        <div>\r\n            <a href=\"\"></a>\r\n        </div>\r\n         <input type=\"text\" name=\"user\" /></div>\r\n    <script type=\"text/javascript\">\r\n        var div = document.getElementById(\"div\");\r\n        var lastChild = div.lastChild;  //最后一个节点\r\n        alert(lastChild.nodeName);  // INPUT\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.4 parentNode属性：获取一个元素的父节点\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"><a href=\"\">搜狐</a>\r\n        <div>\r\n            <a href=\"\"></a>\r\n        </div>\r\n         <input type=\"text\" name=\"user\" /></div>\r\n    <script type=\"text/javascript\">\r\n        var div = document.getElementById(\"div\");\r\n        var parentNode = div.parentNode;    //父节点\r\n        alert(parentNode.nodeName); // BODY\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.5 previousSibling属性：获取一个元素的上一个兄弟节点\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"><a href=\"\">搜狐</a><div id=\"div1\">\r\n            <a href=\"\"></a>\r\n        </div>\r\n         <input type=\"text\" name=\"user\" /></div>\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementById(\"div1\");\r\n        var preSibling = div1.previousSibling;  //获取div1的父节点\r\n        alert(preSibling.nodeName); // A\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.6 nextSibling属性：获取一个元素的下一个节点\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"><a href=\"\">搜狐</a>\r\n        <div id=\"div1\">\r\n            <a href=\"\"></a>\r\n        </div>\r\n        <input type=\"text\" name=\"user\" />\r\n    </div>\r\n\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementById(\"div1\");\r\n        var neSibling = div1.nextSibling;   // 下一个兄弟节点\r\n        alert(neSibling.nodeName);  // #text\r\n    </script>\r\n</body>\r\n```\r\n\r\n**==补充：由于上述都是节点操作，所以获取到的节点会包含一些我们并不关心的内容，比如空节点。下面的几个api只获取元素节点。==**\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-11-30/75636359.jpg)\r\n\r\n# 四、Node关系—修改操作\r\n\r\n## 4.1 createTextNode()：创建文本节点\r\n\r\n> document.createTextNode(_text_)\r\n> \r\n> 参数：文本\r\n> \r\n> 返回值：创建的文本标签\r\n> \r\n> **_注意：这个方法是 document的方法，因为创建元素这么大的事，只能document来干，找某个element来创建不靠谱。_**\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"></div>\r\n    <script type=\"text/javascript\">\r\n        var textNode = document.createTextNode(\"我是一个开心的文本！！！\"); //创建一个文本节点\r\n        alert(textNode.nodeName + \"\\n\" + textNode.nodeValue);   // #text    我是一个开心的文本！！！\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.2 appendChild() : 给一个元素添加child节点\r\n\r\n> _element_.appendChild(_node_)\r\n> \r\n> 参数：必须。表示要添加的节点\r\n> \r\n> 返回值：参数对象本身\r\n> \r\n> **_注意：append的意思是追加。如果元素已经有child，则追加到别的child之后。也就是说新添加的 child 进去之后一定是 lastChild_**\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"></div>\r\n    <script type=\"text/javascript\">\r\n        var div = document.getElementById(\"div\");\r\n        var textNode = document.createTextNode(\"我是一个开心的文本！！！\");\r\n        div.appendChild(textNode);  //把刚才创建的文本添加到div标签中。\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.3 createElement(nodename): 创建元素节点\r\n\r\n> document.createElement(_nodename_)\r\n> \r\n> 参数：必须。要创建的元素的名称\r\n> \r\n> 返回：创建的元素节点\r\n\r\n```\r\n<body>\r\n    <div id=\"div\"></div>\r\n    <script type=\"text/javascript\">\r\n        var div = document.getElementById(\"div\");\r\n        var newElement = document.createElement(\"a\");   //创建一个a标签\r\n        var textNode = document.createTextNode(\"首页\");   // 创建一个文本节点\r\n        newElement.appendChild(textNode); //把 文本节点添加到a标签中\r\n        var v = div.appendChild(newElement);    // 把刚刚创建的a标签，添加为div标签的子标签\r\n        alert(v === newElement) // true 证明参数和返回值确实为同一个对象\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.4 insertBefore() : 在一个节点前插入新节点\r\n\r\n> _node_.insertBefore(_newnode,existingnode_)\r\n> \r\n> 参数1：要插入的新节点\r\n> \r\n> 参数2：目标节点。会把参数1节点插入这个节点之前。\r\n\r\n```\r\n<body>\r\n    <ul id=\"language\">\r\n        <li>java</li>\r\n        <li>c++</li>\r\n    </ul>    \r\n    <button onclick=\"myFunction()\">点我在java前插入JavaScript</button>\r\n\r\n    <script>\r\n        function myFunction() {\r\n            var newItem = document.createElement(\"li\")\r\n            var textnode = document.createTextNode(\"JavaScript\")\r\n            newItem.appendChild(textnode)\r\n\r\n            var languageList = document.getElementById(\"language\")\r\n            //把newItem添加到languageList的第1个子节点之前\r\n            languageList.insertBefore(newItem, list.firstChild);\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.5 removeChild(): 移除子节点\r\n\r\n> _node_.removeChild(_node_)\r\n> \r\n> 参数：必须。要移除的那个子节点\r\n\r\n```\r\n<body>\r\n    <ul id=\"language\">\r\n        <li>java</li>\r\n        <li>c++</li>\r\n        <li>oc</li>\r\n        <li>php</li>\r\n        <li>c#</li>\r\n        <li>JavaScript</li>       \r\n    </ul>\r\n\r\n    <button onclick=\"myFunction()\">点我移除第1条语言</button>\r\n    <script>\r\n        function myFunction() {\r\n            var languageList = document.getElementById(\"language\");\r\n            //获取到languageList下面的所有的 li 标签\r\n            var liList = languageList.getElementsByTagName(\"li\");\r\n            // 移除第一个 li 元素。 如果重复调用，则每次都是移除第1个\r\n            languageList.removeChild(liList[0]);\r\n            alert(liList.length)\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.6 replaceChild()：替换子节点\r\n\r\n> _node_.replaceChild(_newnode_,_oldnode_)\r\n> \r\n> 参数1：新节点\r\n> \r\n> 参数2：旧节点\r\n\r\n```\r\n<body>\r\n    <ul id=\"language\">\r\n        <li>java</li>\r\n        <li>c++</li>\r\n        <li>oc</li>\r\n        <li>php</li>\r\n        <li>c#</li>\r\n        <li>JavaScript</li>       \r\n    </ul>\r\n    <button onclick=\"myFunction()\">点我替换第一条语言</button>\r\n    <script>\r\n        function myFunction() {\r\n            var languageList = document.getElementById(\"language\");\r\n            var newLi = document.createElement(\"li\");\r\n            newLi.innerHTML=\"JavaScript\";\r\n            //用新节点去替换旧节点。\r\n            languageList.replaceChild(newLi, languageList.childNodes[1]);\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.6 cloneNode()：克隆节点\r\n\r\n> node.cloneNode(deep):\r\n> \r\n> cloneNode() 方法可创建指定的节点的精确拷贝。拷贝所有属性和值。\r\n> \r\n> 该方法将复制并返回调用它的节点的副本。如果传递给它的参数是 **true，它还将递归复制当前节点的所有子孙节点**。否则，它只复制当前节点。\r\n\r\n```\r\n<body>\r\n    <ul id=\"language\">\r\n        <li>java</li>\r\n        <li>c++</li>\r\n        <li>oc</li>\r\n        <li>php</li>\r\n        <li>c#</li>\r\n        <li>JavaScript</li>       \r\n    </ul>   \r\n    <button onclick=\"myFunction()\">点我clone整个列表</button>\r\n    <script>\r\n        function myFunction() {\r\n            var languageList = document.getElementById(\"language\");\r\n            //克隆languageList整个节点，传入true表示深度copy，所有的子节点都copy\r\n            var newList = languageList.cloneNode(true);\r\n            document.getElementsByTagName(\"body\")[0].appendChild(newList);\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n# 五、元素属性操作\r\n\r\n> 在HTML中，一个元素会有很多属性，比如id属性，class属性，title属性等等，如何操作这些呢？\r\n\r\n## 5.1 getAttribute():获取属性值\r\n\r\n> _element_.getAttribute(_attributename_)\r\n> \r\n> 返回元素的指定属性的值。\r\n> \r\n> 参数：元素的某个属性的名 (id, className, title)\r\n\r\n```\r\n<body>\r\n    <a id=\"id1\" href=\"http://www.yztcedu.com\" target=\"_blank\">官网</a>.\r\n    <br />\r\n    <p>\r\n        <button onclick=\"myFunction()\">点我获取超级链接的 id 属性值，tafget 属性值</button>\r\n    </p>\r\n    <script>\r\n    function myFunction() {\r\n        var a1 = document.getElementById(\"id1\");\r\n        alert(\"id = \" + a1.getAttribute(\"id\") + \"\\ntarget = \" + a1.getAttribute(\"target\"));\r\n    }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 5.2 setAttribute(): 设置属性值\r\n\r\n> _element_.setAttribute(_attributename_,_attributevalue_)\r\n> \r\n> 作用：创建建或改变某个新属性。如果指定属性已经存在,则只设置该值。如果属性不存在，则创建该属性并设置属性值。\r\n> \r\n> 参数1：属性名\r\n> \r\n> 参数2：新的属性值\r\n\r\n```\r\n<body>\r\n    <input value=\"OK\" >\r\n      <br/>\r\n    <button onclick=\"myFunction()\">点我把上述文本框的 type 属性设置为 button 样式</button>\r\n    <script>\r\n        function myFunction() {\r\n            var inputs = document.getElementsByTagName(\"input\");\r\n            //把input的 type属性设置为button\r\n            inputs[0].setAttribute(\"type\", \"button\");\r\n        };\r\n    </script>   \r\n</body>\r\n```\r\n\r\n## 5.2 removeAttribute() : 移除属性\r\n\r\n> _element_.removeAttribute(_attributename_)\r\n> \r\n> 参数：必需。规定要删除的属性的名称。\r\n\r\n```\r\n<body>  \r\n    <input id=\"input1\" type=\"button\" value=\"点我可以转换我的状态\" onclick=\"myFunction();\">\r\n    <script>\r\n        function myFunction() {         \r\n            var input1 = document.getElementById(\"input1\");\r\n            var typeValue = input1.getAttribute(\"type\");\r\n            if(typeValue){\r\n                input1.removeAttribute(\"type\"); //如果type属性有值就把这个属性去掉\r\n            }else {\r\n                input1.setAttribute(\"type\", \"button\");  //如果type属性不存就添加属性。\r\n            }\r\n        };\r\n    </script>   \r\n</body>\r\n```\r\n\r\n# 六、元素节点的常用属性\r\n\r\n> 元素节点除了有所有的节点都有的属性比如：nodeName、nodeValue、nodeType外，还有一些特有的属性，来方便操作标签元素。\r\n\r\n## 6.1 tagName属性\r\n\r\n> tagName属性是nodeName的另一中写法。注意区别是：tagName只在标签节点中有，而nodeName在所有类型的(12种)节点中都存在。\r\n> \r\n> 它的值表示的就是标签的名字。\r\n\r\n```\r\n<body>  \r\n    <p id=\"p1\">我是一个p标签</p> \r\n    <script type=\"text/javascript\">\r\n        var p1 = document.getElementById(\"p1\");\r\n        alert(p1.tagName);  // p\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 6.2 innerHTML属性\r\n\r\n> innerHTML 属性设置或返回标签的开始和结束标签之间的 HTML。\r\n> \r\n> 值为为文本\r\n> \r\n> 注意：这个属性的值是这个标签的开始和结束部分之间的所有内容，但是\r\n\r\n```\r\n<body>\r\n    <p id=\"p1\"><a href=\"http://www.yztcedu.com\">点我进入官网</a></p>\r\n\r\n    <P><button onclick=\"getHTML();\">点我获取超级链接的所有内容</button></P>\r\n\r\n    <p><button onclick=\"setHTML();\">点我更改整个超级链接</button></p>\r\n\r\n    <script type=\"text/javascript\">\r\n        var p1 = document.getElementById(\"p1\");\r\n        function getHTML () {\r\n            alert(p1.innerHTML);\r\n        }\r\n        function setHTML () {\r\n            p1.innerHTML = \"<a href=\'https://www.baidu.com\'>点我进入百度主页</a>\"\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 6.3 innerText属性\r\n\r\n> innerText值获取标签中的文本内容，子标签本身不会获取到。\r\n> \r\n> 去修改的时候，即使带有标签也会把标签作为纯文本来对待，而不会解析为标签\r\n\r\n```\r\n<body>\r\n    <p id=\"p1\"><a href=\"http://www.yztcedu.com\">点我进入官网</a></p>\r\n\r\n    <P><button onclick=\"getHTML();\">点我获取超级\r\n      链接的所有内容</button></P>\r\n\r\n    <p><button onclick=\"setHTML();\">点我更改整个超级链接</button></p>\r\n\r\n    <script type=\"text/javascript\">\r\n        var p1 = document.getElementById(\"p1\");\r\n        function getHTML () {\r\n            alert(p1.innerText);\r\n        }\r\n        function setHTML () {\r\n            p1.innerText = \"<a href=\'https://www.baidu.com\'>点我进入百度主页</a>\"\r\n        }\r\n    </script>\r\n</body>\r\n//其实还有一个属性：textContent 和innerText的作用相同。\r\n```\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-7/80671041.jpg)![](http://o7cqr8cfk.bkt.clouddn.com/16-11-7/78552439.jpg)\r\n\r\n## 6.4 id属性\r\n\r\n> 就是指的元素节点的id属性的值，与getAttribute(“id”)的值是一样的。\r\n\r\n## 6.5 className属性\r\n\r\n> className 属性设置或返回元素的 class 属性。(因为class在js中是关键字，所以这个地方把属性名字改成了className)\r\n\r\n```\r\n<body>\r\n    <p class=\"p1\">这是一个段落</p>\r\n    <script type=\"text/javascript\">\r\n        var p1 = document.querySelector(\".p1\");\r\n        alert(p1.className);\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 6.7 value属性\r\n\r\n> 如果一个标签可以拥有value值，则可以可以通过element.value来获取。\r\n> \r\n> 一般表单数据才具有vlaue：input、textarea、select\r\n\r\n```\r\n<body>\r\n     <input id=\"in1\" type=\"text\" value=\"abc\" />\r\n     <p>\r\n        <button id=\"btn\" onclick=\"getValue();\" value=\"abc\">获取上面输入框的value属性</button>\r\n     </p>\r\n    <script type=\"text/javascript\">\r\n        var in1 = document.getElementById(\"in1\");\r\n        function getValue () {\r\n            alert(in1.value);   // 获取标签的value值\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n# 七、样式表的属性—css脚本化\r\n\r\n> 可以通过JavaScript访问css的属性，并修改css属性\r\n\r\n## 7.1 获取和修改行间样式表\r\n\r\n> 有2中方式访访问到行间样式表\r\n> \r\n> 1.  element.style.css属性名\r\n> 2.  element.style[“属性名”]\r\n\r\n```\r\n<body>\r\n    <div id=\"box1\"></div>\r\n    <script type=\"text/javascript\">\r\n        var box1 = document.getElementById(\"box1\");\r\n        box1.style.width = \"100px\"; //设置css属性.   设置所有属性都要使用引号括起来。\r\n        box1.style[\"height\"] = \"100px\";\r\n        box1.style.backgroundColor = \"blue\";\r\n        alert(box1.style[\"width\"]);\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 7.2 获取内部样式表和外部样式表\r\n\r\n> 1.  对ie浏览器：对象.currentSytle[“属性名”]\r\n> 2.  其他浏览器：window.getComputedStyle(对象，null)[“属性名”]\r\n> \r\n> **_注意：内部样式表中的属性和外部样式表中的属性只能获取不能修改。如果想修改需要通过行间样式表修改，行间样式表的优先级最高，会覆盖内部样式表和外部样式表。_**\r\n\r\n```\r\n<body>\r\n    <div id=\"box1\"></div>\r\n    <script type=\"text/javascript\">\r\n        var box1 = document.getElementById(\"box1\");\r\n        // alert(box1.currentStyle[\"width\"]); //只支持IE浏览器\r\n        // alert(window.getComputedStyle(box1, null)[\"height\"]); //支持浏览器外的其他浏览器\r\n        alert(getStyle(box1, \"backgroundColor\"));\r\n        /*\r\n            为了简化书写和兼容浏览器，一般封装一个方法出来\r\n        */\r\n        function getStyle (obj, attributeName) {    \r\n            if(obj.currentStyle){   //如果存在对象，则是在ie浏览器\r\n                return obj.currentStyle[attributeName];\r\n            }else { //其他浏览器\r\n                return window.getComputedStyle(obj, null)[attributeName];\r\n            }\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n**补充：**\r\n\r\n> **_offsetWidth、offsetHeight 可以获取宽和高，包括 border 和 padding，其实是这个元素的实际占据的空间。但是只能获取不能修改_**\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-12-7/73018201.jpg)\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('58', 'js事件', '<h1 id=\"h1--\"><a name=\"一、事件和事件流(了解)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、事件和事件流(了解)</h1><p>? <a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>是一种基于对象(Object)和 <strong>事件驱动(Event Driven)</strong> 并具有安全性能的脚本语言。JavaScript和HTML之间的交互就是通过一系列的事件来实现的。</p>\r\n<h2 id=\"h2-1-1-\"><a name=\"1.1 什么是事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 什么是事件</h2><p>? JavaScript和HTML之间的交互是通过事件实现的，事件就是文档或浏览器窗口中发生的一些特点的交互瞬间，可以使用侦听器或处理程序来预订事件，以便事件发生时执行相应的代码.</p>\r\n<p>? <strong><em>事件，就是用户或者是浏览器执行的某种动作。</em></strong></p>\r\n<p>? 比如：click、load等都是事件的名字。</p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 事件流\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 事件流</h2><p>? 事件流描述的是从页面中接收事件的顺序。</p>\r\n<p>? 有两种事件流：冒泡流和捕获流</p>\r\n<h3 id=\"h3-1-2-1-\"><a name=\"1.2.1 冒泡流\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2.1 冒泡流</h3><p>? <strong>IE 的事件流</strong> 叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深<br>的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p>\r\n<pre><code>&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n    &lt;title&gt;Event Bubbling Example&lt;/title&gt;\r\n  &lt;/head&gt;\r\n  &lt;body&gt;\r\n     &lt;div id=&quot;myDiv&quot;&gt;Click Me&lt;/div&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p>? 现在点击div元素，则事件的传播顺序是冒泡的<strong>方式从底层向上传播</strong>。</p>\r\n<ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-8/25478140.jpg\" alt=\"\"></li></ul>\r\n<h3 id=\"h3-1-2-2-\"><a name=\"1.2.2 捕获流\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2.2 捕获流</h3><p>? Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。</p>\r\n<ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-8/71693236.jpg\" alt=\"\"></li></ul>\r\n<h2 id=\"h2-1-3-dom-\"><a name=\"1.3 DOM事件流\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 DOM事件流</h2><p>? “DOM2级事件”规定的事件流包括三个阶段：<strong>事件捕获阶段、处于目标阶段 和 事件冒泡阶段。</strong></p>\r\n<p>? 首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶<br>段，可以在这个阶段对事件做出响应。</p>\r\n<ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-8/22722694.jpg\" alt=\"\"></li></ul>\r\n<p><strong>注意：IE9、Opera、Firefox、Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。</strong></p>\r\n<h1 id=\"h1--\"><a name=\"二、事件处理程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、事件处理程序</h1><p>? 事件处理程序，就是响应事件的函数。事件处理程序的名字是以“on”开头的。<br>? 例如：事件click —&gt;事件处理程序 onclick</p>\r\n<p>? 提示：事件处理程序都是==小写字母==。</p>\r\n<h2 id=\"h2-2-1-html-\"><a name=\"2.1 HTML事件处理程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 HTML事件处理程序</h2><p>? 每一个HTML标签所支持的每种事件，都可以使用与事件处理程序同名的属性来指定。这个属性的属性值是可以执行的js代码。</p>\r\n<p>? 可以把代码直接写到onclick属性的值中:</p>\r\n<pre><code>&lt;!-- 当点击button按钮时候，就会执行onclick属性值中的JavaScript的代码 --&gt;\r\n&lt;button onclick=&quot;alert(&#39;hello world&#39;)&quot;&gt;点我可以给整个世界问好&lt;/button&gt;\r\n</code></pre><p>? 更建议把代码封装在一个函数中，然后在onclick的属性值中调用封装的函数：</p>\r\n<pre><code>&lt;!--注意：在onclick的属性中调用方法的时候，一定要添加( ),表示调用方法--&gt;\r\n&lt;button onclick=&quot;showMsg();&quot;&gt;点我可以给整个世界问好&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        function showMsg () {\r\n            alert(&quot;hello world&quot;);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>在HTML中指定事件处理程序有两个缺点:</p>\r\n<ol>\r\n<li>存在时差问题，比如函数定义在文档尾部，在未解析函数之前就点击了按钮，则会出现错误</li><li>HTML代码和JavaScript代码紧密耦合，如果要更换事件的处理程序，要同时改动html代码和js代码</li></ol>\r\n<p>这正是许多开发人员摒弃 HTML 事件处理程序，转而使用 JavaScript 指定事件处理程序的原因所在。</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-2-dom0-\"><a name=\"2.2 DOM0 级别事件处理程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 DOM0 级别事件处理程序</h2><p>? 为了遵循HTML 与JavaScript代码层次分离的原则，我们可以在JavaScript 中处理事件。这种处理方式也称为 脚本模型。</p>\r\n<p>? 所谓的DOM0级事件处理程序就是将一个<strong>函数赋值给事件处理程序</strong>。这时事件处理程序可以看成是元素对象的方法，事件处理程序就是在元素的作用域中运行。(<strong>this就指代这个元素对象</strong>)</p>\r\n<blockquote>\r\n<p>优点：写法简单，跨浏览器</p>\r\n</blockquote>\r\n<ol>\r\n<li>匿名函数的写法。</li></ol>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot;&gt;点我可以给整个世界问好&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        // 匿名函数的写法\r\n        document.getElementById(&quot;btn&quot;).onclick = function () {\r\n            alert(&quot;世界你好&quot;);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><ol>\r\n<li>通过方法名给事件属性赋值。</li></ol>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot;&gt;点我可以给整个世界问好&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //通过方法名赋值.  注意此处不能添加括号：因为方法的调用是在将来点击的时候，而不是现在\r\n        document.getElementById(&quot;btn&quot;).onclick = showMsg;\r\n        function showMsg () {\r\n            alert(&quot;世界你再好&quot;);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-2-3-\"><a name=\"2.3 删除事件处理程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 删除事件处理程序</h2><p>? 如果想让事件以后不再执行，则可以删除事件处理程序。</p>\r\n<p>? ocument.getElementById(id).onclick = null; 使用这种方法可以删除HTML事件和DOM0事件。</p>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot; onclick=&quot;alert(&#39;你好世界&#39;)&quot;&gt;点我可以给整个世界问好&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        document.getElementById(&quot;btn&quot;).onclick = null;\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"三、事件类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、事件类型</h1><p>? JavaScript 可以处理的事件类型有很多，常见的有UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件。还有专门为触摸设备和移动设备准备的触摸事件、手势事件、屏幕方向改变等。</p>\r\n<ul>\r\n<li><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-8/31269653.jpg\" alt=\"\"></li></ul>\r\n<p>重点掌握的事件有：</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>1.load</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>2.scroll</td>\r\n</tr>\r\n<tr>\r\n<td>3.resize</td>\r\n</tr>\r\n<tr>\r\n<td>4.click</td>\r\n</tr>\r\n<tr>\r\n<td>5.mouseover</td>\r\n</tr>\r\n<tr>\r\n<td>6.mouseout</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"h2-3-1-ui-\"><a name=\"3.1 UI事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 UI事件</h2><h3 id=\"h3-3-1-1-onload-\"><a name=\"3.1.1 onload事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.1 onload事件</h3><blockquote>\r\n<p>load事件会在页面或图像加载完成立即执行。</p>\r\n</blockquote>\r\n<pre><code>&lt;!DOCTYPE html&gt;\r\n&lt;html lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n    &lt;title&gt;Document&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //方法1：给window的onload属性设置函数。建议使用这种\r\n        window.onload = function () {   // 函数在页面执行完毕之后自动执行。\r\n            alert(&quot;页面加载完毕&quot;)\r\n        };\r\n    &lt;/script&gt;\r\n&lt;/head &gt;\r\n&lt;!--方法2： HTML事件处理： 给body 的onload属性直接设置 JavaScript代码， 也可以调用函数--&gt;\r\n&lt;body onload=&quot;alert(&#39;你好&#39;)&quot;&gt;:\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><h3 id=\"h3-3-1-2-onunload-\"><a name=\"3.1.2 onunload事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.2 onunload事件</h3><blockquote>\r\n<ul>\r\n<li>onunload事件在用户退出页面时发生，当页面完全卸载后在window上面触发，或当框架集卸载后在框架集上触发。</li><li>只要用户从一个页面切换到另一个页面就会触发该事件</li><li>仅IE支持。所以实际较少使用。</li></ul>\r\n</blockquote>\r\n<pre><code>&lt;head&gt;\r\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n    &lt;title&gt;Document&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        window.onunload = function () { //像这种事件注册性质的代码一般写在head中比较好。\r\n            alert(&quot;你要抛弃我了么？&quot;);\r\n        }\r\n    &lt;/script&gt;   \r\n    &lt;body&gt;\r\n        &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度一下吧&lt;/a&gt;\r\n    &lt;/body&gt;\r\n&lt;/head &gt;\r\n</code></pre><h3 id=\"h3-3-1-3-onresize-\"><a name=\"3.1.3 onresize事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.3 onresize事件</h3><blockquote>\r\n<p>? 当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件。这个事件在 window （窗<br>口）上面触发。所以也可以在body元素中使用 onresize 属性来指定事件处理程序</p>\r\n</blockquote>\r\n<pre><code>&lt;head&gt;\r\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n    &lt;title&gt;Document&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n         window.onresize = function () {\r\n            alert(&quot;窗口发生了变化&quot;)\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n</code></pre><blockquote>\r\n<p>当窗口发生变化的时候，可以获取浏览器新的可视宽和高</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    window.onresize = function () {\r\n    //获取兼容模式下的可视宽和高\r\n    var width = window.innerWidth || document.documentElement.clientWidth ;\r\n    var height = window.innerHeight || document.documentElement.clientHeight;\r\n    alert(&quot;窗口发生了变化\\n&quot; + &quot;宽：&quot; + width + &quot;\\n高：&quot; + height);\r\n  }\r\n&lt;/script&gt;\r\n</code></pre><h3 id=\"h3-3-1-4-onscroll-\"><a name=\"3.1.4 onscroll事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1.4 onscroll事件</h3><blockquote>\r\n<p>? onscroll事件，当滚动条滚动式触发。事件在window上面触发。由于滚动过程中，会重复多次调用，所以，处理逻辑和代码不能过于复杂，否则会影响用户滚动效果。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n     window.onscroll = function () {\r\n        console.log(&quot;开始滚动...&quot;);\r\n       //获取滚动距离。\r\n       //document.body.scrollTop: 只支持chorme，火狐和ie不支持， document.documentElement.scrollTop ie和火狐支持 chrome不支持\r\n        //跨浏览器获得滚动的距离\r\n        console.log(document.documentElement.scrollTop || document.body.scrollTop);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-3-2-\"><a name=\"3.2 焦点事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 焦点事件</h2><blockquote>\r\n<p>? 焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus() 方法及<br>document.activeElement 属性配合，可以知晓用户在页面上的行踪。主要有4常用焦点事件。</p>\r\n</blockquote>\r\n<h3 id=\"h3-3-2-1-onfucs-\"><a name=\"3.2.1 onfucs(获得焦点)事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.1 onfucs(获得焦点)事件</h3><blockquote>\r\n<p>当元素获得焦点时触发。这个事件可以发生在任何的元素上。而且这个事件 不会冒泡( <strong>也就是不会再往上层传递</strong> )</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;\r\n        &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;\r\n    &lt;/div&gt;\r\n    &lt;p&gt;上面的文本框获得焦点后会我会变成红色&lt;/p&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var p1 = document.getElementsByTagName(&quot;p&quot;)[0];\r\n        var textInput = document.getElementsByTagName(&quot;input&quot;)[0];\r\n        textInput.onfocus = function () {\r\n            p1.style.color = &quot;red&quot;;\r\n        }\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        //当div中input获取焦点后，并会冒泡到上层div，所以这个函数不会执行。\r\n        div1.onfocus = function () {\r\n            div1.style.backgroundColor = &quot;#000&quot;;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-3-2-2-onblur-\"><a name=\"3.2.2 onblur(失去焦点)事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2.2 onblur(失去焦点)事件</h3><blockquote>\r\n<p>当元素失去焦点是触发。和onfucs对应。这个事件也不冒泡</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;\r\n        &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;\r\n    &lt;/div&gt;\r\n    &lt;p&gt;上面的文本框获得焦点后会我会变成红色,失去焦点会变成蓝色&lt;/p&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var p1 = document.getElementsByTagName(&quot;p&quot;)[0];\r\n        var textInput = document.getElementsByTagName(&quot;input&quot;)[0];\r\n        textInput.onfocus = function () {\r\n            p1.style.color = &quot;red&quot;;\r\n        }\r\n        //失去焦点事件\r\n        textInput.onblur = function () {\r\n            p1.style.color = &quot;blue&quot;;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-3-3-3-onfocusin-onfocusout\"><a name=\"3.3.3 onfocusin和onfocusout\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.3 onfocusin和onfocusout</h3><blockquote>\r\n<p>onfocusin是onfoucs的冒泡版本，onfocusout是onblur的冒泡版本。</p>\r\n<p><strong>这两个方法在chrome和firfox上面均不支持。</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;\r\n        &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;\r\n    &lt;/div&gt;\r\n    &lt;p&gt;上面的文本框获得焦点后会我会变成红色,失去焦点会变成蓝色&lt;/p&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var p1 = document.getElementsByTagName(&quot;p&quot;)[0];\r\n        var textInput = document.getElementsByTagName(&quot;input&quot;)[0];\r\n        //input获取焦点\r\n        textInput.onfocusin = function () {\r\n            // alert(&quot;获取焦点&quot;)\r\n            p1.style.color = &quot;red&quot;;\r\n        }\r\n        //input失去焦点\r\n        textInput.onfocusout = function () {\r\n            p1.style.color = &quot;blue&quot;;\r\n        }\r\n\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        //给div1设置设置获取焦点事件\r\n        div1.onfocusin = function () {  //当div中input获取焦点后，并会冒泡到上层div，所以这个函数不会执行。    \r\n            div1.style.backgroundColor = &quot;#000&quot;;\r\n        }\r\n        // 给div2设置失去焦点事件\r\n        div1.onfocusout = function () {\r\n            div1.style.backgroundColor = &quot;#f00&quot;;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-3-\"><a name=\"3.3 鼠标事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 鼠标事件</h2><h3 id=\"h3-3-3-1-onclick-\"><a name=\"3.3.1 onclick事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.1 onclick事件</h3><blockquote>\r\n<p>鼠标单击事件，一般是鼠标左键。单按下鼠标左键或按下回车后触发</p>\r\n</blockquote>\r\n<h3 id=\"h3-3-3-2-ondblclick-\"><a name=\"3.3.2 ondblclick事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.2 ondblclick事件</h3><blockquote>\r\n<p>鼠标双击事件</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;点我们啊&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        div1.ondblclick = function () {\r\n            alert(&quot;你双击了我，我很开心&quot;);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-3-3-3-onmousedown-\"><a name=\"3.3.3 onmousedown事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.3 onmousedown事件</h3><blockquote>\r\n<p>当用户 <strong>按下任意鼠标按钮</strong> 时触发。不能通过键盘触发</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;点我们啊&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        div1.onmousedown = function () {\r\n            alert(&quot;你按下鼠标键，你想干吗&quot;);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-3-3-4-onmouseup-\"><a name=\"3.3.4 onmouseup事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.4 onmouseup事件</h3><blockquote>\r\n<p>用户<strong>释放鼠标按钮</strong>时触发</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;点我啊&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        div1.onmouseup = function () {\r\n            alert(&quot;你松开了鼠标键，你想干吗&quot;);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-3-3-5-onmouseover-onmouseout-\"><a name=\"3.3.5 onmouseover和onmouseout事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.5 onmouseover和onmouseout事件</h3><blockquote>\r\n<p>onmouseover当鼠标移动到一个元素的上方时触发。</p>\r\n<p>onmouseout当鼠标从一个元素的上方移走的时候触发</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;鼠标放上来我要变色&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        //当鼠标移动到div的上方\r\n        div1.onmouseover = function () {\r\n            div1.style.backgroundColor = &quot;blue&quot;;\r\n        }\r\n        //当鼠标从div的上方移走\r\n        div1.onmouseout = function () {\r\n            div1.style.backgroundColor = &quot;white&quot;;\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-3-3-6-onmouseenter-onmouseleave-\"><a name=\"3.3.6 onmouseenter和onmouseleave事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.6 onmouseenter和onmouseleave事件</h3><blockquote>\r\n<ul>\r\n<li>onmouseenter：这个事件不冒泡。效果同onmouseover</li><li>onmouseleave ：这个事件不冒泡，效果同onmouseout</li></ul>\r\n</blockquote>\r\n<h3 id=\"h3-3-3-7-onmousemove-\"><a name=\"3.3.7 onmousemove事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3.7 onmousemove事件</h3><blockquote>\r\n<p>当鼠标在元素内部移动时触发，这个事件会重复触发</p>\r\n</blockquote>\r\n<h2 id=\"h2-3-4-\"><a name=\"3.4 键盘事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 键盘事件</h2><blockquote>\r\n<p>有三个键盘事件：</p>\r\n<p>keydown：当用户按下键盘上的==任意键时触发==，而且如果按住不放的话，会重复触发此事件。</p>\r\n<p>keypress：当用户按下键盘上的==字符键时==触发，而且如果按住不放的话，会重复触发此事件。</p>\r\n<p>keyup：当用户==释放键盘上的键==时触发。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;&lt;input type=&quot;text&quot; value=&quot;鼠标放上来我要变色&quot;&gt;&lt;/input&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        /*div1.onkeydown = function () {\r\n            console.log(&quot;你按下了任意键&quot;);\r\n        }*/\r\n        div1.onkeypress = function () {\r\n            console.log(&quot;你按下了字符键&quot;);\r\n        }\r\n        div1.onkeyup = function () {\r\n            console.log(&#39;你松开了键盘&#39;);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>获取按下的具体键：</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;\r\n        &lt;input type=&quot;text&quot; value=&quot;鼠标放上来我要变色&quot;&gt;&lt;/input&gt;\r\n    &lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div1 = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        //在键盘上每个键都有一个keyCode,可以通过如下方法获取每个键对应的keyCode\r\n        div1.onkeypress = function(e) {\r\n            alert(e.keyCode);\r\n        }\r\n        // 判断是否按下alt键、shift键、ctrl键\r\n        /*div1.onkeydown = function (e) {\r\n            if(e.altKey){\r\n                alert(&quot;alt&quot;);\r\n            }else if(e.shiftKey){\r\n                alert(&quot;shift&quot;);\r\n            }else if(e.ctrlKey){\r\n                alert(&quot;ctrl&quot;)\r\n            }\r\n        }*/\r\n        //判断是否同时按下了alt和ctrl键\r\n        div1.onkeydown= function(e){\r\n            if(e.altKey&amp;&amp; e.ctrlKey)\r\n                {alert(&quot;alt和ctrl同时按下&quot;);\r\n            }\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-5-load-ready-\"><a name=\"3.5 load和ready事件的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5 load和ready事件的区别</h2><blockquote>\r\n<p>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；</p>\r\n<p>load，表示页面包含图片等文件在内的所有元素都加载完成。</p>\r\n</blockquote>\r\n<pre><code>\r\n\r\n</code></pre><h1 id=\"h1--offsetparent-\"><a name=\"四、参照物父元素(offsetParent)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、参照物父元素(offsetParent)</h1><p>element.offsetParent：返回元素的偏移容器。 会一直在父级容器中找，直到找到定位的父容器，否则这个就是body</p>\r\n<p>element.offsetHeight：返回元素的高度 width+padding+border。</p>\r\n<p>element.offsetWidth：返回元素的宽度 height+padding+border</p>\r\n<p>element.offsetLeft：返回元素的水平偏移位置。 <strong>是相对于参照物父容器的偏移量</strong></p>\r\n<p>element.offsetTop：返回元素的垂直偏移位置。 <strong>是相对于参照物父容器的偏移量</strong></p>\r\n<p><strong>注意：上面的这些值都是只读的，不能修改！</strong></p>\r\n<pre><code>\r\n\r\n</code></pre>', '84', '\r\n# 一、事件和事件流(了解)\r\n\r\n? [JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")是一种基于对象(Object)和 **事件驱动(Event Driven)** 并具有安全性能的脚本语言。JavaScript和HTML之间的交互就是通过一系列的事件来实现的。\r\n\r\n## 1.1 什么是事件\r\n\r\n? JavaScript和HTML之间的交互是通过事件实现的，事件就是文档或浏览器窗口中发生的一些特点的交互瞬间，可以使用侦听器或处理程序来预订事件，以便事件发生时执行相应的代码.\r\n\r\n? **_事件，就是用户或者是浏览器执行的某种动作。_**\r\n\r\n? 比如：click、load等都是事件的名字。\r\n\r\n## 1.2 事件流\r\n\r\n? 事件流描述的是从页面中接收事件的顺序。\r\n\r\n? 有两种事件流：冒泡流和捕获流\r\n\r\n### 1.2.1 冒泡流\r\n\r\n? **IE 的事件流** 叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深\r\n的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <title>Event Bubbling Example</title>\r\n  </head>\r\n  <body>\r\n     <div id=\"myDiv\">Click Me</div>\r\n  </body>\r\n</html>\r\n```\r\n\r\n? 现在点击div元素，则事件的传播顺序是冒泡的**方式从底层向上传播**。\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-8/25478140.jpg)\r\n\r\n### 1.2.2 捕获流\r\n\r\n? Netscape Communicator团队提出的另一种事件流叫做事件捕获（event capturing）。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-8/71693236.jpg)\r\n\r\n## 1.3 DOM事件流\r\n\r\n? “DOM2级事件”规定的事件流包括三个阶段：**事件捕获阶段、处于目标阶段 和 事件冒泡阶段。**\r\n\r\n? 首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶\r\n段，可以在这个阶段对事件做出响应。\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-8/22722694.jpg)\r\n\r\n**注意：IE9、Opera、Firefox、Chrome 和 Safari 都支持 DOM 事件流；IE8 及更早版本不支持 DOM 事件流。**\r\n\r\n# 二、事件处理程序\r\n\r\n? 事件处理程序，就是响应事件的函数。事件处理程序的名字是以“on”开头的。\r\n? 例如：事件click —>事件处理程序 onclick\r\n\r\n? 提示：事件处理程序都是==小写字母==。\r\n\r\n## 2.1 HTML事件处理程序\r\n\r\n? 每一个HTML标签所支持的每种事件，都可以使用与事件处理程序同名的属性来指定。这个属性的属性值是可以执行的js代码。\r\n\r\n? 可以把代码直接写到onclick属性的值中:\r\n\r\n```\r\n<!-- 当点击button按钮时候，就会执行onclick属性值中的JavaScript的代码 -->\r\n<button onclick=\"alert(\'hello world\')\">点我可以给整个世界问好</button>\r\n```\r\n\r\n? 更建议把代码封装在一个函数中，然后在onclick的属性值中调用封装的函数：\r\n\r\n```\r\n<!--注意：在onclick的属性中调用方法的时候，一定要添加( ),表示调用方法-->\r\n<button onclick=\"showMsg();\">点我可以给整个世界问好</button>\r\n    <script type=\"text/javascript\">\r\n        function showMsg () {\r\n            alert(\"hello world\");\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n> 在HTML中指定事件处理程序有两个缺点:\r\n> \r\n> 1.  存在时差问题，比如函数定义在文档尾部，在未解析函数之前就点击了按钮，则会出现错误\r\n> 2.  HTML代码和JavaScript代码紧密耦合，如果要更换事件的处理程序，要同时改动html代码和js代码\r\n> \r\n> 这正是许多开发人员摒弃 HTML 事件处理程序，转而使用 JavaScript 指定事件处理程序的原因所在。\r\n\r\n## 2.2 DOM0 级别事件处理程序\r\n\r\n? 为了遵循HTML 与JavaScript代码层次分离的原则，我们可以在JavaScript 中处理事件。这种处理方式也称为 脚本模型。\r\n\r\n? 所谓的DOM0级事件处理程序就是将一个**函数赋值给事件处理程序**。这时事件处理程序可以看成是元素对象的方法，事件处理程序就是在元素的作用域中运行。(**this就指代这个元素对象**)\r\n\r\n> 优点：写法简单，跨浏览器\r\n\r\n1.  匿名函数的写法。\r\n\r\n```\r\n<body>\r\n    <button id=\"btn\">点我可以给整个世界问好</button>\r\n    <script type=\"text/javascript\">\r\n        // 匿名函数的写法\r\n        document.getElementById(\"btn\").onclick = function () {\r\n            alert(\"世界你好\");\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n1.  通过方法名给事件属性赋值。\r\n\r\n```\r\n<body>\r\n    <button id=\"btn\">点我可以给整个世界问好</button>\r\n    <script type=\"text/javascript\">\r\n        //通过方法名赋值.  注意此处不能添加括号：因为方法的调用是在将来点击的时候，而不是现在\r\n        document.getElementById(\"btn\").onclick = showMsg;\r\n        function showMsg () {\r\n            alert(\"世界你再好\");\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 2.3 删除事件处理程序\r\n\r\n? 如果想让事件以后不再执行，则可以删除事件处理程序。\r\n\r\n? ocument.getElementById(id).onclick = null; 使用这种方法可以删除HTML事件和DOM0事件。\r\n\r\n```\r\n<body>\r\n    <button id=\"btn\" onclick=\"alert(\'你好世界\')\">点我可以给整个世界问好</button>\r\n    <script type=\"text/javascript\">\r\n        document.getElementById(\"btn\").onclick = null;\r\n    </script>\r\n</body>\r\n```\r\n\r\n# 三、事件类型\r\n\r\n? JavaScript 可以处理的事件类型有很多，常见的有UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件。还有专门为触摸设备和移动设备准备的触摸事件、手势事件、屏幕方向改变等。\r\n\r\n*   ![](http://o7cqr8cfk.bkt.clouddn.com/16-11-8/31269653.jpg)\r\n\r\n重点掌握的事件有：\r\n\r\n| 1.load |\r\n| --- |\r\n| 2.scroll |\r\n| 3.resize |\r\n| 4.click |\r\n| 5.mouseover |\r\n| 6.mouseout |\r\n\r\n## 3.1 UI事件\r\n\r\n### 3.1.1 onload事件\r\n\r\n> load事件会在页面或图像加载完成立即执行。\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <script type=\"text/javascript\">\r\n        //方法1：给window的onload属性设置函数。建议使用这种\r\n        window.onload = function () {   // 函数在页面执行完毕之后自动执行。\r\n            alert(\"页面加载完毕\")\r\n        };\r\n    </script>\r\n</head >\r\n<!--方法2： HTML事件处理： 给body 的onload属性直接设置 JavaScript代码， 也可以调用函数-->\r\n<body onload=\"alert(\'你好\')\">:\r\n</body>\r\n</html>\r\n```\r\n\r\n### 3.1.2 onunload事件\r\n\r\n> *   onunload事件在用户退出页面时发生，当页面完全卸载后在window上面触发，或当框架集卸载后在框架集上触发。\r\n> *   只要用户从一个页面切换到另一个页面就会触发该事件\r\n> *   仅IE支持。所以实际较少使用。\r\n\r\n```\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <script type=\"text/javascript\">\r\n        window.onunload = function () { //像这种事件注册性质的代码一般写在head中比较好。\r\n            alert(\"你要抛弃我了么？\");\r\n        }\r\n    </script>   \r\n    <body>\r\n        <a href=\"http://www.baidu.com\">百度一下吧</a>\r\n    </body>\r\n</head >\r\n```\r\n\r\n### 3.1.3 onresize事件\r\n\r\n> ? 当浏览器窗口被调整到一个新的高度或宽度时，就会触发 resize 事件。这个事件在 window （窗\r\n> 口）上面触发。所以也可以在body元素中使用 onresize 属性来指定事件处理程序\r\n\r\n```\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <script type=\"text/javascript\">\r\n         window.onresize = function () {\r\n            alert(\"窗口发生了变化\")\r\n        }\r\n    </script>\r\n</head>\r\n```\r\n\r\n> 当窗口发生变化的时候，可以获取浏览器新的可视宽和高\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    window.onresize = function () {\r\n    //获取兼容模式下的可视宽和高\r\n    var width = window.innerWidth || document.documentElement.clientWidth ;\r\n    var height = window.innerHeight || document.documentElement.clientHeight;\r\n    alert(\"窗口发生了变化\\n\" + \"宽：\" + width + \"\\n高：\" + height);\r\n  }\r\n</script>\r\n```\r\n\r\n### 3.1.4 onscroll事件\r\n\r\n> ? onscroll事件，当滚动条滚动式触发。事件在window上面触发。由于滚动过程中，会重复多次调用，所以，处理逻辑和代码不能过于复杂，否则会影响用户滚动效果。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n     window.onscroll = function () {\r\n        console.log(\"开始滚动...\");\r\n       //获取滚动距离。\r\n       //document.body.scrollTop: 只支持chorme，火狐和ie不支持， document.documentElement.scrollTop ie和火狐支持 chrome不支持\r\n        //跨浏览器获得滚动的距离\r\n        console.log(document.documentElement.scrollTop || document.body.scrollTop);\r\n    }\r\n</script>\r\n```\r\n\r\n## 3.2 焦点事件\r\n\r\n> ? 焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与 document.hasFocus() 方法及\r\n> document.activeElement 属性配合，可以知晓用户在页面上的行踪。主要有4常用焦点事件。\r\n\r\n### 3.2.1 onfucs(获得焦点)事件\r\n\r\n> 当元素获得焦点时触发。这个事件可以发生在任何的元素上。而且这个事件 不会冒泡( **也就是不会再往上层传递** )\r\n\r\n```\r\n<body>\r\n    <div>\r\n        <input type=\"text\" name=\"user\">\r\n    </div>\r\n    <p>上面的文本框获得焦点后会我会变成红色</p>\r\n    <script type=\"text/javascript\">\r\n        var p1 = document.getElementsByTagName(\"p\")[0];\r\n        var textInput = document.getElementsByTagName(\"input\")[0];\r\n        textInput.onfocus = function () {\r\n            p1.style.color = \"red\";\r\n        }\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        //当div中input获取焦点后，并会冒泡到上层div，所以这个函数不会执行。\r\n        div1.onfocus = function () {\r\n            div1.style.backgroundColor = \"#000\";\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 3.2.2 onblur(失去焦点)事件\r\n\r\n> 当元素失去焦点是触发。和onfucs对应。这个事件也不冒泡\r\n\r\n```\r\n<body>\r\n    <div>\r\n        <input type=\"text\" name=\"user\">\r\n    </div>\r\n    <p>上面的文本框获得焦点后会我会变成红色,失去焦点会变成蓝色</p>\r\n    <script type=\"text/javascript\">\r\n        var p1 = document.getElementsByTagName(\"p\")[0];\r\n        var textInput = document.getElementsByTagName(\"input\")[0];\r\n        textInput.onfocus = function () {\r\n            p1.style.color = \"red\";\r\n        }\r\n        //失去焦点事件\r\n        textInput.onblur = function () {\r\n            p1.style.color = \"blue\";\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 3.3.3 onfocusin和onfocusout\r\n\r\n> onfocusin是onfoucs的冒泡版本，onfocusout是onblur的冒泡版本。\r\n> \r\n> **这两个方法在chrome和firfox上面均不支持。**\r\n\r\n```\r\n<body>\r\n    <div>\r\n        <input type=\"text\" name=\"user\">\r\n    </div>\r\n    <p>上面的文本框获得焦点后会我会变成红色,失去焦点会变成蓝色</p>\r\n    <script type=\"text/javascript\">\r\n        var p1 = document.getElementsByTagName(\"p\")[0];\r\n        var textInput = document.getElementsByTagName(\"input\")[0];\r\n        //input获取焦点\r\n        textInput.onfocusin = function () {\r\n            // alert(\"获取焦点\")\r\n            p1.style.color = \"red\";\r\n        }\r\n        //input失去焦点\r\n        textInput.onfocusout = function () {\r\n            p1.style.color = \"blue\";\r\n        }\r\n\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        //给div1设置设置获取焦点事件\r\n        div1.onfocusin = function () {  //当div中input获取焦点后，并会冒泡到上层div，所以这个函数不会执行。    \r\n            div1.style.backgroundColor = \"#000\";\r\n        }\r\n        // 给div2设置失去焦点事件\r\n        div1.onfocusout = function () {\r\n            div1.style.backgroundColor = \"#f00\";\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.3 鼠标事件\r\n\r\n### 3.3.1 onclick事件\r\n\r\n> 鼠标单击事件，一般是鼠标左键。单按下鼠标左键或按下回车后触发\r\n\r\n### 3.3.2 ondblclick事件\r\n\r\n> 鼠标双击事件\r\n\r\n```\r\n<body>\r\n    <div>点我们啊</div>\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        div1.ondblclick = function () {\r\n            alert(\"你双击了我，我很开心\");\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 3.3.3 onmousedown事件\r\n\r\n> 当用户 **按下任意鼠标按钮** 时触发。不能通过键盘触发\r\n\r\n```\r\n<body>\r\n    <div>点我们啊</div>\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        div1.onmousedown = function () {\r\n            alert(\"你按下鼠标键，你想干吗\");\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 3.3.4 onmouseup事件\r\n\r\n> 用户**释放鼠标按钮**时触发\r\n\r\n```\r\n<body>\r\n    <div>点我啊</div>\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        div1.onmouseup = function () {\r\n            alert(\"你松开了鼠标键，你想干吗\");\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 3.3.5 onmouseover和onmouseout事件\r\n\r\n> onmouseover当鼠标移动到一个元素的上方时触发。\r\n> \r\n> onmouseout当鼠标从一个元素的上方移走的时候触发\r\n\r\n```\r\n<body>\r\n    <div>鼠标放上来我要变色</div>\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        //当鼠标移动到div的上方\r\n        div1.onmouseover = function () {\r\n            div1.style.backgroundColor = \"blue\";\r\n        }\r\n        //当鼠标从div的上方移走\r\n        div1.onmouseout = function () {\r\n            div1.style.backgroundColor = \"white\";\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 3.3.6 onmouseenter和onmouseleave事件\r\n\r\n> *   onmouseenter：这个事件不冒泡。效果同onmouseover\r\n> *   onmouseleave ：这个事件不冒泡，效果同onmouseout\r\n\r\n### 3.3.7 onmousemove事件\r\n\r\n> 当鼠标在元素内部移动时触发，这个事件会重复触发\r\n\r\n## 3.4 键盘事件\r\n\r\n> 有三个键盘事件：\r\n> \r\n> keydown：当用户按下键盘上的==任意键时触发==，而且如果按住不放的话，会重复触发此事件。\r\n> \r\n> keypress：当用户按下键盘上的==字符键时==触发，而且如果按住不放的话，会重复触发此事件。\r\n> \r\n> keyup：当用户==释放键盘上的键==时触发。\r\n\r\n```\r\n<body>\r\n    <div><input type=\"text\" value=\"鼠标放上来我要变色\"></input></div>\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        /*div1.onkeydown = function () {\r\n            console.log(\"你按下了任意键\");\r\n        }*/\r\n        div1.onkeypress = function () {\r\n            console.log(\"你按下了字符键\");\r\n        }\r\n        div1.onkeyup = function () {\r\n            console.log(\'你松开了键盘\');\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n> 获取按下的具体键：\r\n\r\n```\r\n<body>\r\n    <div>\r\n        <input type=\"text\" value=\"鼠标放上来我要变色\"></input>\r\n    </div>\r\n    <script type=\"text/javascript\">\r\n        var div1 = document.getElementsByTagName(\"div\")[0];\r\n        //在键盘上每个键都有一个keyCode,可以通过如下方法获取每个键对应的keyCode\r\n        div1.onkeypress = function(e) {\r\n            alert(e.keyCode);\r\n        }\r\n        // 判断是否按下alt键、shift键、ctrl键\r\n        /*div1.onkeydown = function (e) {\r\n            if(e.altKey){\r\n                alert(\"alt\");\r\n            }else if(e.shiftKey){\r\n                alert(\"shift\");\r\n            }else if(e.ctrlKey){\r\n                alert(\"ctrl\")\r\n            }\r\n        }*/\r\n        //判断是否同时按下了alt和ctrl键\r\n        div1.onkeydown= function(e){\r\n            if(e.altKey&& e.ctrlKey)\r\n                {alert(\"alt和ctrl同时按下\");\r\n            }\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.5 load和ready事件的区别\r\n\r\n> ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；\r\n> \r\n> load，表示页面包含图片等文件在内的所有元素都加载完成。\r\n\r\n```\r\n\r\n```\r\n\r\n# 四、参照物父元素(offsetParent)\r\n\r\nelement.offsetParent：返回元素的偏移容器。 会一直在父级容器中找，直到找到定位的父容器，否则这个就是body\r\n\r\nelement.offsetHeight：返回元素的高度 width+padding+border。\r\n\r\nelement.offsetWidth：返回元素的宽度 height+padding+border\r\n\r\nelement.offsetLeft：返回元素的水平偏移位置。 **是相对于参照物父容器的偏移量**\r\n\r\nelement.offsetTop：返回元素的垂直偏移位置。 **是相对于参照物父容器的偏移量**\r\n\r\n**注意：上面的这些值都是只读的，不能修改！**\r\n\r\n```\r\n\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('59', 'js事件对象', '<h1 id=\"h1--event\"><a name=\"一、事件对象event\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、事件对象event</h1><p>? 在触发 DOM 上的某个事件时，会产生一个事件对象 event ，这个对象中包含着所有与事件有关的<br>信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件<br>对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。==所有==<br>==浏览器都支持 event 对象，==但支持方式不同。</p>\r\n<ol>\r\n<li>无论哪种事件处理程序，都会有一个event的参数，包含着事件的基本信息。</li></ol>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot;&gt;点我获取点击的click事件的事件类型&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var btn = document.getElementById(&quot;btn&quot;);\r\n        //当点击事件发生的时候，浏览器会把发生的这次点击封装成一个事件对象，通过时间处理程序的参数传进来。\r\n        //在处理程序内部就可以使用这个事件对象了。\r\n        btn.onclick = function (event) {\r\n            alert(event.type);  // click\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body\r\n</code></pre><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/16-11-8/22647444.jpg\" alt=\"\"></p>\r\n<ol>\r\n<li>事件类型不一样，event可用的属性与方法也不一样。不过不管哪种类型的事件，都具有下面的属性和方法。j</li></ol>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:left\">属性 / 方法</th>\r\n<th style=\"text-align:left\">类 型</th>\r\n<th>读 / 写</th>\r\n<th style=\"text-align:left\">说 明</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:left\">bubbles</td>\r\n<td style=\"text-align:left\">Boolean</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">表明事件是否冒泡</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">cancelable</td>\r\n<td style=\"text-align:left\">Boolean</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">表明是否可以取消事件的默认行为</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">currentTarget</td>\r\n<td style=\"text-align:left\">Element</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">其事件处理程序当前正在处理事件的那个元素(注册事件处理程序的元素)</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">defaultPrevented</td>\r\n<td style=\"text-align:left\">Boolean</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">为 true 表 示 已 经 调 用 了 preventDefault(DOM3级事件中新增)</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">detail</td>\r\n<td style=\"text-align:left\">Integer</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">与事件相关的细节信息</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">eventPhase</td>\r\n<td style=\"text-align:left\">Integer</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">stopPropagation()</td>\r\n<td style=\"text-align:left\">Function</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">取消事件的进一步捕获或冒泡。如果 bubbles为 true ，则可以使用这个方法</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\"><strong>preventDefault()</strong></td>\r\n<td style=\"text-align:left\">Function</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">取消事件的默认行为。如果 cancelable 是true ，则可以使用这个方法</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">stopImmediatePropagation()</td>\r\n<td style=\"text-align:left\">Function</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增）</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">target</td>\r\n<td style=\"text-align:left\">Element</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">事件的目标(事件发生的目标元素)</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">trusted</td>\r\n<td style=\"text-align:left\">Boolean</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">为 true 表示事件是浏览器生成的。为 false 表示 事 件 是 由 开 发 人 员 通 过 JavaScript 创 建 的（DOM3级事件中新增）</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">type</td>\r\n<td style=\"text-align:left\">String</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">被触发的事件的类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:left\">view</td>\r\n<td style=\"text-align:left\">AbstractView</td>\r\n<td>只读</td>\r\n<td style=\"text-align:left\">与事件关联的抽象视图。等同于发生事件的window 对象</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h1 id=\"h1--dom2-\"><a name=\"二、DOM2 级事件处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、DOM2 级事件处理</h1><pre><code>“DOM2级事件”定义了**两个方法，用于处理指定和删除事件处理程序的操作**：**addEventListener()和 removeEventListener() 。**\r\n</code></pre><h2 id=\"h2-2-1-addeventlistener-removeeventlistener-\"><a name=\"2.1 addEventListener()和removeEventListener()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 addEventListener()和removeEventListener()</h2><blockquote>\r\n<p>所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：</p>\r\n<ol>\r\n<li>要处理的事件名(例如：click、focus等。 如意这里写事件名字的时候 <strong>不能带on</strong> )</li><li>作为事件处理程序的函数</li><li>一个布尔值。最后这个布尔值参数如果是 true ，表示在捕获阶段调用事件处理程序；如果是 false ，表示在冒泡阶段调用事件处理程序。</li></ol>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot;&gt;点我或双击我&lt;/button&gt;\r\n    &lt;br/&gt;&lt;/br/&gt;\r\n    &lt;button id=&quot;cacelBtn1&quot;&gt;点我取消单击事件&lt;/button&gt;\r\n     &lt;br/&gt;&lt;/br/&gt;\r\n    &lt;button id=&quot;cacelBtn2&quot;&gt;点我取消双击事件&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var btn = document.getElementById(&quot;btn&quot;);\r\n        //定义事件处理程序。\r\n        function handler (event) {\r\n            if(event.type == &quot;click&quot;){ // 根据事件的类型不同，进行不同的处理\r\n                console.log(&quot;你单击了我&quot;);\r\n            }else if(event.type = &quot;dbclick&quot;){\r\n                console.log(&quot;你双击我了我&quot;);\r\n            }\r\n        }\r\n        //给click事件注册监听器\r\n        btn.addEventListener(&quot;click&quot;, handler, false);\r\n        //给dblclick事件注册监听器\r\n        btn.addEventListener(&quot;dblclick&quot;, handler, false);\r\n\r\n        var cancelBtn1 = document.getElementById(&quot;cacelBtn1&quot;);\r\n        var cancelBtn2 = document.getElementById(&quot;cacelBtn2&quot;);\r\n\r\n        //点击这个按钮把第一个按钮的单击事件移除\r\n        cancelBtn1.onclick = function () {\r\n            btn.removeEventListener(&quot;click&quot;, handler, false);\r\n        }\r\n        //点击这个按钮把第一个按钮的双击事件移除\r\n        cancelBtn2.onclick = function () {\r\n            btn.removeEventListener(&quot;dblclick&quot;, handler, false);\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-2-2-\"><a name=\"2.2 一些注意点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 一些注意点</h2><blockquote>\r\n<p>可以给一个元素多次添加同一个事件的多个处理程序，那么浏览器会按照添加的顺序顺序执行。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot;&gt;点我或双击我&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var btn = document.getElementById(&quot;btn&quot;);\r\n        //使用匿名函数给click事件添加第一个处理程序\r\n        btn.addEventListener(&quot;click&quot;, function () { //先注册先执行\r\n            alert(&quot;第一次hell&quot;);\r\n        }, false);\r\n        //使用匿名函数给click事件添加第二个处理程序\r\n        btn.addEventListener(&quot;click&quot;, function () { //后注册后执行\r\n            alert(&quot;第二次hello&quot;);\r\n        }, false);\r\n        //这两个事件处理程序都会执行，顺序为添加(注册)顺序:\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>移除监听器(处理程序)的时候，必须和注册时使用的是同一个函数。否则移除失败</p>\r\n<p>比如：如果注册和移除都是使用的匿名函数，那么一定会移除不起作用</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot;&gt;点我或双击我&lt;/button&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var btn = document.getElementById(&quot;btn&quot;);\r\n        //使用匿名函数添加事件处理程序\r\n        btn.addEventListener(&quot;click&quot;, function () {\r\n            alert(&quot;欢迎来到育知同创&quot;);\r\n        }, false);\r\n        // 移除使用的处理程序虽然和注册的处理程序代码一样，但是因为两次都是用的匿名函数，所以\r\n        // 两次用的肯定不是同一个函数。所以移除不起作用。\r\n        btn.removeEventListener(&quot;click&quot;, function () {\r\n            alert(&quot;欢迎来到育知同创&quot;);\r\n        }, false);\r\n    &lt;/script&gt;\r\n\r\n&lt;/body&gt;\r\n</code></pre><p><strong>注意：</strong></p>\r\n<ol>\r\n<li><strong>大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。==如果不是特别需要，不建议在事件捕获阶段注册事件处理程序==。</strong></li><li><strong><em>IE9、Firefox、Safari、Chrome和 Opera 支持 DOM2 级事件处理程序。</em></strong>( <strong>ie9以前不支持</strong> )</li></ol>\r\n<h1 id=\"h1--event-\"><a name=\"三、event对象的高级属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、event对象的高级属性</h1><h2 id=\"h2-3-1-offsetx-offsety\"><a name=\"3.1 offsetX和offsetY\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 offsetX和offsetY</h2><blockquote>\r\n<p>光标相对于触发元素边界的X、Y坐标</p>\r\n<p>其实是光标相对于触发元素的<strong>==左上角==</strong>的坐标。(把左上角的位置看做0，0)</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        div.addEventListener(&quot;mousemove&quot;, function (event) {\r\n            console.log(&#39;offsetX:&#39; + event.offsetX + &quot;, offsetY:&quot; + event.offsetY);\r\n        }, false);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-2-screenx-screeny\"><a name=\"3.2 screenX和screenY\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 screenX和screenY</h2><blockquote>\r\n<p>当前光标相对于屏幕边缘的x、y坐标</p>\r\n<p>其实就是相对于屏幕左上角的坐标。(可以看出是绝对坐标)</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div&gt;&lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var div = document.getElementsByTagName(&quot;div&quot;)[0];\r\n        document.documentElement.addEventListener(&quot;mousemove&quot;, function (event) {\r\n            // console.log(&#39;offsetX:&#39; + event.offsetX + &quot;, offsetY:&quot; + event.offsetY);\r\n            console.log(&quot;scrrenX:&quot; + event.screenX + &quot;, scrrenY:&quot; + event.screenY);\r\n        }, false);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-3-clientx-clienty\"><a name=\"3.3 clientX和clientY\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 clientX和clientY</h2><blockquote>\r\n<p>当前光标相对于浏览器浏览器窗口客户区域左上角的坐标(客户区域不包括状态栏、菜单栏等。)</p>\r\n<p>三种坐标的图示如下：</p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-11-8/37625339.jpg\" alt=\"\"></p>\r\n<h2 id=\"h2-3-4-stoppropagation-\"><a name=\"3.4 stopPropagation()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 stopPropagation()</h2><blockquote>\r\n<p>如果bubbles是true(允许冒泡)，则stopPropagation可以阻止事件进一步捕获或冒泡</p>\r\n</blockquote>\r\n<ul>\r\n<li>正常情况当把鼠标放在外部div和内部div重合的区域的时候，连个div都可以收到事件。当在内部div的处理程序添加stopPropagation()方法后,则鼠标放在重合区域的上方是外部div就收不到冒泡事件了</li></ul>\r\n<pre><code>&lt;body&gt;\r\n    &lt;div id=&quot;outer&quot;&gt;\r\n         &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;\r\n    &lt;/div&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var outer = document.getElementById(&quot;outer&quot;);\r\n        var inner = document.getElementById(&quot;inner&quot;);\r\n        outer.addEventListener(&quot;mouseover&quot;, function (event) {\r\n            console.log(&quot;外部的div....&quot;)\r\n        }, false);\r\n        inner.addEventListener(&quot;mouseover&quot;, function (event) {\r\n            console.log(&quot;内部的div&quot;);\r\n            event.stopPropagation();\r\n        }, false);      \r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-5-preventdefault-\"><a name=\"3.5 preventDefault()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5 preventDefault()</h2><blockquote>\r\n<p>取消事件的默认行为：</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;form  id=&quot;form&quot; action=&quot;&quot;&gt;\r\n        &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br/&gt;&lt;br/&gt;\r\n        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\r\n        &lt;p&gt;本演示可以阻止提交按钮默认提交表单的动作&lt;/p&gt;\r\n    &lt;/form&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var form = document.getElementById(&quot;form&quot;);\r\n        form.addEventListener(&quot;submit&quot;, function (event) {\r\n            //阻止表单的默认提交事件\r\n            event.preventDefault();\r\n        }, false);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-6-pagex-pagey\"><a name=\"3.6 补充：pageX和pageY\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.6 补充：pageX和pageY</h2><blockquote>\r\n<p>获取光标在文档中的位置。注意：这个之和整个页面的左上角有关，与元素的位置无关。如果页面进行的滚动，即使光标没有任何移动，那么pageY也会变化。而这种情况下clientY是没有变化的。</p>\r\n</blockquote>\r\n<h1 id=\"h1--\"><a name=\"四、事件代理(事件委托)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、事件代理(事件委托)</h1><p>? 当一个页面中需要给比较多的元素添加时间处理程序的时候，以前的做法是通过找到每个元素，然后逐一的去添加。这样做有一些缺点：</p>\r\n<ul>\r\n<li><p>多次去dom树中查找元素，比较耗费时间。</p>\r\n</li><li><p>太多事件处理程序，比较占资源。特别个别浏览器(如ie)对垃圾回收这块又做的不够好。</p>\r\n</li><li><p>程序中过多的事件处理，代码后期不好管理。</p>\r\n<p>这时我们可以用一种叫做事件委托的方式去解决。</p>\r\n</li></ul>\r\n<blockquote>\r\n<p>事件委托的原理：</p>\r\n</blockquote>\r\n<p>? 假设现在要处理多个具有并列关系元素的click事件，当我点击这些元素中的任何一个元素，则事件一定会通过冒泡的方式，冒泡到他的上层的父节点元素然后一直冒到window，所以这个时候我们就可以在他的上层元素中添加事件处理程序，来统一处理这些事件，在处理的过程中可以通过获取target的id来知道是点击的哪个具体的元素。这种方式就称之为事件委托。</p>\r\n<pre><code>&lt;body&gt;\r\n    &lt;ul id=&quot;myGirls&quot;&gt;\r\n        &lt;li id=&quot;zhiling&quot;&gt;志玲&lt;/li&gt;\r\n        &lt;li id=&quot;baizhi&quot;&gt;柏芝&lt;/li&gt;\r\n        &lt;li id=&quot;fengjie&quot;&gt;凤姐&lt;/li&gt;\r\n        &lt;li id=&quot;yifei&quot;&gt;亦非&lt;/li&gt;\r\n    &lt;/ul&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var myGirls = document.getElementById(&quot;myGirls&quot;);\r\n        myGirls.addEventListener(&quot;click&quot;, function(event) {\r\n            var tagetId = event.target.id;\r\n            // alert(tagetId);\r\n            switch (tagetId) {\r\n                case &quot;zhiling&quot;:\r\n                    alert(&quot;我是志玲，哥哥你要干吗&quot;);\r\n                    break;\r\n                case &quot;baizhi&quot;:\r\n                    alert(&quot;我是柏芝，我以后再也不找冠希了&quot;);\r\n                    break;\r\n                case &quot;fengjie&quot;:\r\n                    alert(&quot;我是凤姐，我已经整容了，没有以前那么丑了&quot;);  \r\n                    break;\r\n                case &quot;yifei&quot;:\r\n                    alert(&quot;我是亦非，我干爹是富豪&quot;);\r\n                    break;\r\n                default:\r\n                    alert(&quot;你一个都不点是啥意思&quot;);\r\n                    break;\r\n            }\r\n        }, false);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>完全可以考虑给document添加一个事件处理程序，用来处理页面上发生的某种特定类型的事件。</li><li>比较适合事件委托的事件：click 、 mousedown 、 mouseup 、 keydown 、 keyup 和 keypress。</li></ol>\r\n', '85', '\r\n# 一、事件对象event\r\n\r\n? 在触发 DOM 上的某个事件时，会产生一个事件对象 event ，这个对象中包含着所有与事件有关的\r\n信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件\r\n对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。==所有==\r\n==浏览器都支持 event 对象，==但支持方式不同。\r\n\r\n1.  无论哪种事件处理程序，都会有一个event的参数，包含着事件的基本信息。\r\n\r\n```\r\n<body>\r\n    <button id=\"btn\">点我获取点击的click事件的事件类型</button>\r\n    <script type=\"text/javascript\">\r\n        var btn = document.getElementById(\"btn\");\r\n        //当点击事件发生的时候，浏览器会把发生的这次点击封装成一个事件对象，通过时间处理程序的参数传进来。\r\n        //在处理程序内部就可以使用这个事件对象了。\r\n        btn.onclick = function (event) {\r\n            alert(event.type);  // click\r\n        }\r\n    </script>\r\n</body\r\n```\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/16-11-8/22647444.jpg)\r\n\r\n1.  事件类型不一样，event可用的属性与方法也不一样。不过不管哪种类型的事件，都具有下面的属性和方法。j\r\n\r\n| 属性 / 方法 | 类 型 | 读 / 写 | 说 明 |\r\n| :-- | :-- | --- | :-- |\r\n| bubbles | Boolean | 只读 | 表明事件是否冒泡 |\r\n| cancelable | Boolean | 只读 | 表明是否可以取消事件的默认行为 |\r\n| currentTarget | Element | 只读 | 其事件处理程序当前正在处理事件的那个元素(注册事件处理程序的元素) |\r\n| defaultPrevented | Boolean | 只读 | 为 true 表 示 已 经 调 用 了 preventDefault(DOM3级事件中新增) |\r\n| detail | Integer | 只读 | 与事件相关的细节信息 |\r\n| eventPhase | Integer | 只读 | 调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段 |\r\n| stopPropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡。如果 bubbles为 true ，则可以使用这个方法 |\r\n| **preventDefault()** | Function | 只读 | 取消事件的默认行为。如果 cancelable 是true ，则可以使用这个方法 |\r\n| stopImmediatePropagation() | Function | 只读 | 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增） |\r\n| target | Element | 只读 | 事件的目标(事件发生的目标元素) |\r\n| trusted | Boolean | 只读 | 为 true 表示事件是浏览器生成的。为 false 表示 事 件 是 由 开 发 人 员 通 过 JavaScript 创 建 的（DOM3级事件中新增） |\r\n| type | String | 只读 | 被触发的事件的类型 |\r\n| view | AbstractView | 只读 | 与事件关联的抽象视图。等同于发生事件的window 对象 |\r\n\r\n# 二、DOM2 级事件处理\r\n\r\n```\r\n“DOM2级事件”定义了**两个方法，用于处理指定和删除事件处理程序的操作**：**addEventListener()和 removeEventListener() 。**\r\n\r\n```\r\n\r\n## 2.1 addEventListener()和removeEventListener()\r\n\r\n> 所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：\r\n> \r\n> 1.  要处理的事件名(例如：click、focus等。 如意这里写事件名字的时候 **不能带on** )\r\n> 2.  作为事件处理程序的函数\r\n> 3.  一个布尔值。最后这个布尔值参数如果是 true ，表示在捕获阶段调用事件处理程序；如果是 false ，表示在冒泡阶段调用事件处理程序。\r\n\r\n```\r\n<body>\r\n    <button id=\"btn\">点我或双击我</button>\r\n    <br/></br/>\r\n    <button id=\"cacelBtn1\">点我取消单击事件</button>\r\n     <br/></br/>\r\n    <button id=\"cacelBtn2\">点我取消双击事件</button>\r\n    <script type=\"text/javascript\">\r\n        var btn = document.getElementById(\"btn\");\r\n        //定义事件处理程序。\r\n        function handler (event) {\r\n            if(event.type == \"click\"){ // 根据事件的类型不同，进行不同的处理\r\n                console.log(\"你单击了我\");\r\n            }else if(event.type = \"dbclick\"){\r\n                console.log(\"你双击我了我\");\r\n            }\r\n        }\r\n        //给click事件注册监听器\r\n        btn.addEventListener(\"click\", handler, false);\r\n        //给dblclick事件注册监听器\r\n        btn.addEventListener(\"dblclick\", handler, false);\r\n\r\n        var cancelBtn1 = document.getElementById(\"cacelBtn1\");\r\n        var cancelBtn2 = document.getElementById(\"cacelBtn2\");\r\n\r\n        //点击这个按钮把第一个按钮的单击事件移除\r\n        cancelBtn1.onclick = function () {\r\n            btn.removeEventListener(\"click\", handler, false);\r\n        }\r\n        //点击这个按钮把第一个按钮的双击事件移除\r\n        cancelBtn2.onclick = function () {\r\n            btn.removeEventListener(\"dblclick\", handler, false);\r\n        }\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 2.2 一些注意点\r\n\r\n> 可以给一个元素多次添加同一个事件的多个处理程序，那么浏览器会按照添加的顺序顺序执行。\r\n\r\n```\r\n<body>\r\n    <button id=\"btn\">点我或双击我</button>\r\n    <script type=\"text/javascript\">\r\n        var btn = document.getElementById(\"btn\");\r\n        //使用匿名函数给click事件添加第一个处理程序\r\n        btn.addEventListener(\"click\", function () { //先注册先执行\r\n            alert(\"第一次hell\");\r\n        }, false);\r\n        //使用匿名函数给click事件添加第二个处理程序\r\n        btn.addEventListener(\"click\", function () { //后注册后执行\r\n            alert(\"第二次hello\");\r\n        }, false);\r\n        //这两个事件处理程序都会执行，顺序为添加(注册)顺序:\r\n    </script>\r\n</body>\r\n```\r\n\r\n> 移除监听器(处理程序)的时候，必须和注册时使用的是同一个函数。否则移除失败\r\n> \r\n> 比如：如果注册和移除都是使用的匿名函数，那么一定会移除不起作用\r\n\r\n```\r\n<body>\r\n    <button id=\"btn\">点我或双击我</button>\r\n    <script type=\"text/javascript\">\r\n        var btn = document.getElementById(\"btn\");\r\n        //使用匿名函数添加事件处理程序\r\n        btn.addEventListener(\"click\", function () {\r\n            alert(\"欢迎来到育知同创\");\r\n        }, false);\r\n        // 移除使用的处理程序虽然和注册的处理程序代码一样，但是因为两次都是用的匿名函数，所以\r\n        // 两次用的肯定不是同一个函数。所以移除不起作用。\r\n        btn.removeEventListener(\"click\", function () {\r\n            alert(\"欢迎来到育知同创\");\r\n        }, false);\r\n    </script>\r\n\r\n</body>\r\n```\r\n\r\n**注意：**\r\n\r\n1.  **大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器。最好只在需要在事件到达目标之前截获它的时候将事件处理程序添加到捕获阶段。==如果不是特别需要，不建议在事件捕获阶段注册事件处理程序==。**\r\n2.  **_IE9、Firefox、Safari、Chrome和 Opera 支持 DOM2 级事件处理程序。_**( **ie9以前不支持** )\r\n\r\n# 三、event对象的高级属性\r\n\r\n## 3.1 offsetX和offsetY\r\n\r\n> 光标相对于触发元素边界的X、Y坐标\r\n> \r\n> 其实是光标相对于触发元素的**==左上角==**的坐标。(把左上角的位置看做0，0)\r\n\r\n```\r\n<body>\r\n    <div></div>\r\n    <script type=\"text/javascript\">\r\n        var div = document.getElementsByTagName(\"div\")[0];\r\n        div.addEventListener(\"mousemove\", function (event) {\r\n            console.log(\'offsetX:\' + event.offsetX + \", offsetY:\" + event.offsetY);\r\n        }, false);\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.2 screenX和screenY\r\n\r\n> 当前光标相对于屏幕边缘的x、y坐标\r\n> \r\n> 其实就是相对于屏幕左上角的坐标。(可以看出是绝对坐标)\r\n\r\n```\r\n<body>\r\n    <div></div>\r\n    <script type=\"text/javascript\">\r\n        var div = document.getElementsByTagName(\"div\")[0];\r\n        document.documentElement.addEventListener(\"mousemove\", function (event) {\r\n            // console.log(\'offsetX:\' + event.offsetX + \", offsetY:\" + event.offsetY);\r\n            console.log(\"scrrenX:\" + event.screenX + \", scrrenY:\" + event.screenY);\r\n        }, false);\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.3 clientX和clientY\r\n\r\n> 当前光标相对于浏览器浏览器窗口客户区域左上角的坐标(客户区域不包括状态栏、菜单栏等。)\r\n> \r\n> 三种坐标的图示如下：\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-11-8/37625339.jpg)\r\n\r\n## 3.4 stopPropagation()\r\n\r\n> 如果bubbles是true(允许冒泡)，则stopPropagation可以阻止事件进一步捕获或冒泡\r\n\r\n*   正常情况当把鼠标放在外部div和内部div重合的区域的时候，连个div都可以收到事件。当在内部div的处理程序添加stopPropagation()方法后,则鼠标放在重合区域的上方是外部div就收不到冒泡事件了\r\n\r\n```\r\n<body>\r\n    <div id=\"outer\">\r\n         <div id=\"inner\"></div>\r\n    </div>\r\n    <script type=\"text/javascript\">\r\n        var outer = document.getElementById(\"outer\");\r\n        var inner = document.getElementById(\"inner\");\r\n        outer.addEventListener(\"mouseover\", function (event) {\r\n            console.log(\"外部的div....\")\r\n        }, false);\r\n        inner.addEventListener(\"mouseover\", function (event) {\r\n            console.log(\"内部的div\");\r\n            event.stopPropagation();\r\n        }, false);      \r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.5 preventDefault()\r\n\r\n> 取消事件的默认行为：\r\n\r\n```\r\n<body>\r\n    <form  id=\"form\" action=\"\">\r\n        <input type=\"text\" name=\"user\"><br/><br/>\r\n        <input type=\"submit\" value=\"提交\">\r\n        <p>本演示可以阻止提交按钮默认提交表单的动作</p>\r\n    </form>\r\n    <script type=\"text/javascript\">\r\n        var form = document.getElementById(\"form\");\r\n        form.addEventListener(\"submit\", function (event) {\r\n            //阻止表单的默认提交事件\r\n            event.preventDefault();\r\n        }, false);\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.6 补充：pageX和pageY\r\n\r\n> 获取光标在文档中的位置。注意：这个之和整个页面的左上角有关，与元素的位置无关。如果页面进行的滚动，即使光标没有任何移动，那么pageY也会变化。而这种情况下clientY是没有变化的。\r\n\r\n# 四、事件代理(事件委托)\r\n\r\n? 当一个页面中需要给比较多的元素添加时间处理程序的时候，以前的做法是通过找到每个元素，然后逐一的去添加。这样做有一些缺点：\r\n\r\n*   多次去dom树中查找元素，比较耗费时间。\r\n\r\n*   太多事件处理程序，比较占资源。特别个别浏览器(如ie)对垃圾回收这块又做的不够好。\r\n\r\n*   程序中过多的事件处理，代码后期不好管理。\r\n\r\n    这时我们可以用一种叫做事件委托的方式去解决。\r\n\r\n> 事件委托的原理：\r\n\r\n? 假设现在要处理多个具有并列关系元素的click事件，当我点击这些元素中的任何一个元素，则事件一定会通过冒泡的方式，冒泡到他的上层的父节点元素然后一直冒到window，所以这个时候我们就可以在他的上层元素中添加事件处理程序，来统一处理这些事件，在处理的过程中可以通过获取target的id来知道是点击的哪个具体的元素。这种方式就称之为事件委托。\r\n\r\n```\r\n<body>\r\n    <ul id=\"myGirls\">\r\n        <li id=\"zhiling\">志玲</li>\r\n        <li id=\"baizhi\">柏芝</li>\r\n        <li id=\"fengjie\">凤姐</li>\r\n        <li id=\"yifei\">亦非</li>\r\n    </ul>\r\n    <script type=\"text/javascript\">\r\n        var myGirls = document.getElementById(\"myGirls\");\r\n        myGirls.addEventListener(\"click\", function(event) {\r\n            var tagetId = event.target.id;\r\n            // alert(tagetId);\r\n            switch (tagetId) {\r\n                case \"zhiling\":\r\n                    alert(\"我是志玲，哥哥你要干吗\");\r\n                    break;\r\n                case \"baizhi\":\r\n                    alert(\"我是柏芝，我以后再也不找冠希了\");\r\n                    break;\r\n                case \"fengjie\":\r\n                    alert(\"我是凤姐，我已经整容了，没有以前那么丑了\");  \r\n                    break;\r\n                case \"yifei\":\r\n                    alert(\"我是亦非，我干爹是富豪\");\r\n                    break;\r\n                default:\r\n                    alert(\"你一个都不点是啥意思\");\r\n                    break;\r\n            }\r\n        }, false);\r\n    </script>\r\n</body>\r\n```\r\n\r\n> 说明：\r\n\r\n1.  完全可以考虑给document添加一个事件处理程序，用来处理页面上发生的某种特定类型的事件。\r\n2.  比较适合事件委托的事件：click 、 mousedown 、 mouseup 、 keydown 、 keyup 和 keypress。\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('60', 'js日期和时间', '<h1 id=\"h1--\"><a name=\"一、了解日期和时间的一些概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、了解日期和时间的一些概念</h1><h2 id=\"h2-1-1-gmt-\"><a name=\"1.1 GMT时间\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 GMT时间</h2><p>? GMT(Greenwich mean time 格林尼治标准时间，格林威治标准时间，格林尼治平均时间)：是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息。世界上发生的重大时间都是以格林尼治时间时间为标准的。</p>\r\n<p>比如：我们用的北京时间，因为北京是东八区，所以我们的事件比GMT事件早八个小时。我们这里是8点早上，格林威治还是夜里0点呢。</p>\r\n<h2 id=\"h2-1-2-utc-\"><a name=\"1.2 UTC时间\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 UTC时间</h2><p>? UTC(<strong>C</strong>oordinated <strong>U</strong>niversal <strong>T</strong>ime 协调世界时间) 协调世界时是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。</p>\r\n<p>? 原子时与以往的计时系统不同，它非常精确并且不以某地的平均太阳时为基准，但是遇有地球自转速度不均匀，原子时与世界时之间的时差便日积月累，因 此，UTC 会在一段时期后加上正或负的闰秒来补偿。因此协调世界时与国际原子时(TAI) 之间会出现若干整数秒的差别。位于巴黎的国际地球自转事务中央局(ERS)负责决定何时加入闰秒。</p>\r\n<h1 id=\"h1--120-\"><a name=\"二、创建日期对象==(120)==\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、创建日期对象==(120)==</h1><blockquote>\r\n<p><a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>中的 Date 类型是在早期 <a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a> 中的 java.util.Date 类基础上构建的。为此， Date类型使用自 UTC 1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1月 1 日之前或之后的 285 616 年。</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-1-\"><a name=\"2.1 获取当前日期字符串形式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 获取当前日期字符串形式</h2><blockquote>\r\n<p>直接调用Date()函数(注意首字母大写)。返回的是表示当前日期和时间的字符串。传参数无效，所以不需要传入参数。</p>\r\n<p><strong>注意：得到的仅仅是个String类型的字符串</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = Date();\r\n        alert(date);\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-11-9/10866706.jpg\" alt=\"\"></p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 创建日期对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 创建日期对象</h2><h3 id=\"h3-2-2-1-\"><a name=\"2.2.1 创建表示当前表示当前日期的对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.1 创建表示当前表示当前日期的对象</h3><blockquote>\r\n<p>new Date()</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //使用关键字new 调用Date()构造函数，创建的对象表示当前日期\r\n        var now = new Date();\r\n        alert(now);  \r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-2-2-2-\"><a name=\"2.2.2 创建指定字符串日期对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.2 创建指定字符串日期对象</h3><blockquote>\r\n<p>new Date(“字符串格式日期”)</p>\r\n<p>支持格式1：英文月 日,年 时:分:秒 例如：May 23, 2016 09&#58;00&#58;00</p>\r\n<p>支持格式2：年-月-日 例如：2016-11-11</p>\r\n<p>支持格式3：年/月/日 例如：2016/11/11</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var d1 = new Date(&quot;May 31, 2016 09:00:00&quot;); \r\n        console.log(d1);    //Tue May 31 2016 09:00:00 GMT+0800 (中国标准时间)\r\n        var d2 = new Date(&quot;2016-11-12&quot;);\r\n        console.log(d2);    //Sat Nov 12 2016 08:00:00 GMT+0800 (中国标准时间)\r\n        var d3 = new Date(&quot;2016/11/12&quot;);\r\n        console.log(d3);    //Sat Nov 12 2016 08:00:00 GMT+0800 (中国标准时间)\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-2-2-3-\"><a name=\"2.2.3 创建指定毫秒值的日期对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.3 创建指定毫秒值的日期对象</h3><blockquote>\r\n<p>new Date(指定的毫秒值)</p>\r\n<p>这个毫秒值是指的从1970年1月1日0<img src=\"http://www.emoji-cheat-sheet.com/graphics/emojis/0.png\" class=\"emoji\" title=\"&#58;0&#58;\" alt=\"&#58;0&#58;\" />0开始算的毫秒值</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var d1 = new Date(1646464646646);\r\n        console.log(d1);    // Sat Mar 05 2022 15:17:26 GMT+0800 (中国标准时间)\r\n        var d2 = new Date(1000 * 60 * 60 * 72);\r\n        console.log(d2);    //Sun Jan 04 1970 08:00:00 GMT+0800 (中国标准时间)\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h3 id=\"h3-2-2-4-\"><a name=\"2.2.4 通过参数传入年月日时分秒来创建日期对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2.4 通过参数传入年月日时分秒来创建日期对象</h3><blockquote>\r\n<p>newDate(年, 月[, 日, 时, 分, 秒])</p>\r\n<p>注意：</p>\r\n<ul>\r\n<li>年月必须有，日时分秒可以省略。(1日，0分，0秒)</li><li>月份的范围是0-11. 0表示1月份。</li><li>如果设置的月日分秒超过了范围，则自动进行增减操作。例如：如果一个月只有31天，你如果传入32，则自动调整为下个月的1号。</li></ul>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var d1 = new Date(2016, 11, 31);\r\n        console.log(d1);    //Sat Dec 31 2016 00:00:00 GMT+0800 (中国标准时间)\r\n        var d2 = new Date(2016, 11, 33);\r\n        console.log(d2);    //Mon Jan 02 2017 00:00:00 GMT+0800 (中国标准时间)\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--3-121-\"><a name=\"三、日期继承的3个方法==(121)==\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、日期继承的3个方法==(121)==</h1><h2 id=\"h2-3-1-tostring-\"><a name=\"3.1 toString()方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 toString()方法</h2><blockquote>\r\n<p>toString()方法一般返回带有时区信息的日期和时间。</p>\r\n<p>备注：我们直接输出一个日期对象的时候，就相当于调用了toString()方法再输出</p>\r\n</blockquote>\r\n<h2 id=\"h2-3-2-tolocalstring-\"><a name=\"3.2 toLocalString() 方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 toLocalString() 方法</h2><blockquote>\r\n<p>toLocalString()返回符合本地习惯的日期和时间格式</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.toLocaleString()); //  2016/11/9 上午11:28:01   注意：不同的浏览器有差异\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-3-3-valueof-\"><a name=\"3.3 valueOf()方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 valueOf()方法</h2><blockquote>\r\n<p>valueOf()方法不返回字符串，而是返回的代表这个时间的毫秒值。</p>\r\n<p>一般用用来比较两个日期的大小，就知道谁在前谁在后了。</p>\r\n<p>==日期早的小于日期晚的。==</p>\r\n<p>例如：2016年11年11日是小于2016年11月12日的</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var d1 = new Date(&quot;2016-11-20&quot;);\r\n        var d2 = new Date(&quot;2016-11-22&quot;);\r\n        console.log(d1 &lt; d2); //true\r\n        console.log(d1 &gt; d2); //false\r\n        console.log(d1 - d2);  // 间隔的毫秒值：-172800000\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--date-122-\"><a name=\"四、Date对象的常用方法==(122)==\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、Date对象的常用方法==(122)==</h1><h2 id=\"h2-4-1-gettime-settime-\"><a name=\"4.1 getTime()和setTime(毫秒值)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 getTime()和setTime(毫秒值)</h2><blockquote>\r\n<p>getTime()返回表示日期的毫秒值，与valueOf()一样</p>\r\n<p>setTime(毫秒值) 以毫秒数设置日期，会改变整个日期</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getTime());    //1478667185681\r\n        date.setTime(979797979879879);\r\n        console.log(date.toLocaleString());//33018/7/25 下午5:31:19\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-2-getfullyear-setfullyear-\"><a name=\"4.2 getFullYear()和setFullYear(年份)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 getFullYear()和setFullYear(年份)</h2><blockquote>\r\n<p>getFullYear() 取得4位数的年份</p>\r\n<p>setFullYear()设置日期的年份，必须是4为数字的年份,否则将来获取的年份是不对的。</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getFullYear());    \r\n        date.setFullYear(2018);\r\n        console.log(date.toLocaleString());\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-3-getmonth-setmonth-\"><a name=\"4.3 getMonth()和setMonth(月份)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 getMonth()和setMonth(月份)</h2><blockquote>\r\n<p>getMonth()取得月份。 范围：0-11</p>\r\n<p>setMonth(月份) 设置月份</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getMonth());   //如果是11月份则返回 10\r\n        date.setMonth(2);   // 设置月份为3月\r\n        console.log(date.toLocaleString()); \r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-4-getdate-setdate-\"><a name=\"4.4 getDate()和setDate(日)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4 getDate()和setDate(日)</h2><blockquote>\r\n<p>getDate() 获取一个月中的第几天(1-31)</p>\r\n<p>setDate(日) 设置一个月中的第几天</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getDate());\r\n        date.setDate(11);\r\n        console.log(date.toLocaleString());\r\n    &lt;/script&gt;\r\n&lt;/body\r\n</code></pre><h2 id=\"h2-4-5-getday-\"><a name=\"4.5 getDay()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.5 getDay()</h2><blockquote>\r\n<p>getDay() 获取是星期几 0代表星期日 6代表星期6</p>\r\n<p><strong>注意：没有setDay()的方法</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getDay());\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-6-gethours-sethours-\"><a name=\"4.6 getHours()和setHours(小时)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.6 getHours()和setHours(小时)</h2><blockquote>\r\n<p>getHours() 获取小时数(0-23)</p>\r\n<p>setHours(小时) 设置小时数 如果设置的值超过23则更改月份中的日期，小于0则减少日期数</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getHours());\r\n        date.setHours(10);\r\n        console.log(date.toLocaleString());\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-7-getminutes-setminutes-\"><a name=\"4.7 getMinutes() 和setMinutes(分钟)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.7 getMinutes() 和setMinutes(分钟)</h2><blockquote>\r\n<p>getMinutes() 获取分钟数(0-59)</p>\r\n<p>setMinutes(分钟) 设置分钟数 如果超过60或小于0则自动增加小时</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getMinutes());\r\n        date.setMinutes(62);\r\n        console.log(date.toLocaleString());\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-8-getseconds-setseconds-\"><a name=\"4.8 getSeconds()和setSeconds(秒)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.8 getSeconds()和setSeconds(秒)</h2><blockquote>\r\n<p>getSeconds() 获取秒数 0-59</p>\r\n<p>setSeconds(秒数) 设置秒数 如果超过60或小于0，则自动增减分钟数</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getSeconds());\r\n        date.setSeconds(62);\r\n        console.log(date.toLocaleString());\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h2 id=\"h2-4-9-getmilliseconds-setmilliseconds-\"><a name=\"4.9 getMilliSeconds()和setMilliSeconds(毫秒值)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.9 getMilliSeconds()和setMilliSeconds(毫秒值)</h2><blockquote>\r\n<p>getMilliSeconds() 获取毫秒值 0-999</p>\r\n<p>setMilliSeconds(毫秒值) 设置毫秒值</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        var date = new Date();\r\n        console.log(date.getMilliseconds());\r\n        date.setMilliseconds(999);\r\n        console.log(date.toLocaleString());\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"五、 日期格式化方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、 日期格式化方法</h1><ol>\r\n<li>toDateString() ——以特定于实现的格式显示星期几、月、日和年；</li><li>toTimeString() ——以特定于实现的格式显示时、分、秒和时区；</li><li>toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；</li><li>toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；</li><li>toUTCString() ——以特定于实现的格式完整的 UTC 日期。</li></ol>\r\n', '86', '\r\n# 一、了解日期和时间的一些概念\r\n\r\n## 1.1 GMT时间\r\n\r\n? GMT(Greenwich mean time 格林尼治标准时间，格林威治标准时间，格林尼治平均时间)：是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息。世界上发生的重大时间都是以格林尼治时间时间为标准的。\r\n\r\n比如：我们用的北京时间，因为北京是东八区，所以我们的事件比GMT事件早八个小时。我们这里是8点早上，格林威治还是夜里0点呢。\r\n\r\n## 1.2 UTC时间\r\n\r\n? UTC(**C**oordinated **U**niversal **T**ime 协调世界时间) 协调世界时是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统。\r\n\r\n? 原子时与以往的计时系统不同，它非常精确并且不以某地的平均太阳时为基准，但是遇有地球自转速度不均匀，原子时与世界时之间的时差便日积月累，因 此，UTC 会在一段时期后加上正或负的闰秒来补偿。因此协调世界时与国际原子时(TAI) 之间会出现若干整数秒的差别。位于巴黎的国际地球自转事务中央局(ERS)负责决定何时加入闰秒。\r\n\r\n# 二、创建日期对象==(120)==\r\n\r\n> [JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")中的 Date 类型是在早期 [Java](http://lib.csdn.net/base/javase \"Java SE知识库\") 中的 java.util.Date 类基础上构建的。为此， Date类型使用自 UTC 1970 年 1 月 1 日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下， Date 类型保存的日期能够精确到 1970 年 1月 1 日之前或之后的 285 616 年。\r\n\r\n## 2.1 获取当前日期字符串形式\r\n\r\n> 直接调用Date()函数(注意首字母大写)。返回的是表示当前日期和时间的字符串。传参数无效，所以不需要传入参数。\r\n> \r\n> **注意：得到的仅仅是个String类型的字符串**\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = Date();\r\n        alert(date);\r\n    </script>\r\n</body>\r\n```\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-11-9/10866706.jpg)\r\n\r\n## 2.2 创建日期对象\r\n\r\n### 2.2.1 创建表示当前表示当前日期的对象\r\n\r\n> new Date()\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        //使用关键字new 调用Date()构造函数，创建的对象表示当前日期\r\n        var now = new Date();\r\n        alert(now);  \r\n    </script>\r\n</body>\r\n```\r\n\r\n### 2.2.2 创建指定字符串日期对象\r\n\r\n> new Date(“字符串格式日期”)\r\n> \r\n> 支持格式1：英文月 日,年 时:分:秒 例如：May 23, 2016 09:00:00\r\n> \r\n> 支持格式2：年-月-日 例如：2016-11-11\r\n> \r\n> 支持格式3：年/月/日 例如：2016/11/11\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var d1 = new Date(\"May 31, 2016 09:00:00\"); \r\n        console.log(d1);    //Tue May 31 2016 09:00:00 GMT+0800 (中国标准时间)\r\n        var d2 = new Date(\"2016-11-12\");\r\n        console.log(d2);    //Sat Nov 12 2016 08:00:00 GMT+0800 (中国标准时间)\r\n        var d3 = new Date(\"2016/11/12\");\r\n        console.log(d3);    //Sat Nov 12 2016 08:00:00 GMT+0800 (中国标准时间)\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 2.2.3 创建指定毫秒值的日期对象\r\n\r\n> new Date(指定的毫秒值)\r\n> \r\n> 这个毫秒值是指的从1970年1月1日0:0:0开始算的毫秒值\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var d1 = new Date(1646464646646);\r\n        console.log(d1);    // Sat Mar 05 2022 15:17:26 GMT+0800 (中国标准时间)\r\n        var d2 = new Date(1000 * 60 * 60 * 72);\r\n        console.log(d2);    //Sun Jan 04 1970 08:00:00 GMT+0800 (中国标准时间)\r\n    </script>\r\n</body>\r\n```\r\n\r\n### 2.2.4 通过参数传入年月日时分秒来创建日期对象\r\n\r\n> newDate(年, 月[, 日, 时, 分, 秒])\r\n> \r\n> 注意：\r\n> \r\n> *   年月必须有，日时分秒可以省略。(1日，0分，0秒)\r\n> *   月份的范围是0-11\\. 0表示1月份。\r\n> *   如果设置的月日分秒超过了范围，则自动进行增减操作。例如：如果一个月只有31天，你如果传入32，则自动调整为下个月的1号。\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var d1 = new Date(2016, 11, 31);\r\n        console.log(d1);    //Sat Dec 31 2016 00:00:00 GMT+0800 (中国标准时间)\r\n        var d2 = new Date(2016, 11, 33);\r\n        console.log(d2);    //Mon Jan 02 2017 00:00:00 GMT+0800 (中国标准时间)\r\n    </script>\r\n</body>\r\n```\r\n\r\n# 三、日期继承的3个方法==(121)==\r\n\r\n## 3.1 toString()方法\r\n\r\n> toString()方法一般返回带有时区信息的日期和时间。\r\n> \r\n> 备注：我们直接输出一个日期对象的时候，就相当于调用了toString()方法再输出\r\n\r\n## 3.2 toLocalString() 方法\r\n\r\n> toLocalString()返回符合本地习惯的日期和时间格式\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.toLocaleString()); //  2016/11/9 上午11:28:01   注意：不同的浏览器有差异\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 3.3 valueOf()方法\r\n\r\n> valueOf()方法不返回字符串，而是返回的代表这个时间的毫秒值。\r\n> \r\n> 一般用用来比较两个日期的大小，就知道谁在前谁在后了。\r\n> \r\n> ==日期早的小于日期晚的。==\r\n> \r\n> 例如：2016年11年11日是小于2016年11月12日的\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var d1 = new Date(\"2016-11-20\");\r\n        var d2 = new Date(\"2016-11-22\");\r\n        console.log(d1 < d2); //true\r\n        console.log(d1 > d2); //false\r\n        console.log(d1 - d2);  // 间隔的毫秒值：-172800000\r\n    </script>\r\n</body>\r\n```\r\n\r\n# 四、Date对象的常用方法==(122)==\r\n\r\n## 4.1 getTime()和setTime(毫秒值)\r\n\r\n> getTime()返回表示日期的毫秒值，与valueOf()一样\r\n> \r\n> setTime(毫秒值) 以毫秒数设置日期，会改变整个日期\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getTime());    //1478667185681\r\n        date.setTime(979797979879879);\r\n        console.log(date.toLocaleString());//33018/7/25 下午5:31:19\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.2 getFullYear()和setFullYear(年份)\r\n\r\n> getFullYear() 取得4位数的年份\r\n> \r\n> setFullYear()设置日期的年份，必须是4为数字的年份,否则将来获取的年份是不对的。\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getFullYear());    \r\n        date.setFullYear(2018);\r\n        console.log(date.toLocaleString());\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.3 getMonth()和setMonth(月份)\r\n\r\n> getMonth()取得月份。 范围：0-11\r\n> \r\n> setMonth(月份) 设置月份\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getMonth());   //如果是11月份则返回 10\r\n        date.setMonth(2);   // 设置月份为3月\r\n        console.log(date.toLocaleString()); \r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.4 getDate()和setDate(日)\r\n\r\n> getDate() 获取一个月中的第几天(1-31)\r\n> \r\n> setDate(日) 设置一个月中的第几天\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getDate());\r\n        date.setDate(11);\r\n        console.log(date.toLocaleString());\r\n    </script>\r\n</body\r\n```\r\n\r\n## 4.5 getDay()\r\n\r\n> getDay() 获取是星期几 0代表星期日 6代表星期6\r\n> \r\n> **注意：没有setDay()的方法**\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getDay());\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.6 getHours()和setHours(小时)\r\n\r\n> getHours() 获取小时数(0-23)\r\n> \r\n> setHours(小时) 设置小时数 如果设置的值超过23则更改月份中的日期，小于0则减少日期数\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getHours());\r\n        date.setHours(10);\r\n        console.log(date.toLocaleString());\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.7 getMinutes() 和setMinutes(分钟)\r\n\r\n> getMinutes() 获取分钟数(0-59)\r\n> \r\n> setMinutes(分钟) 设置分钟数 如果超过60或小于0则自动增加小时\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getMinutes());\r\n        date.setMinutes(62);\r\n        console.log(date.toLocaleString());\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.8 getSeconds()和setSeconds(秒)\r\n\r\n> getSeconds() 获取秒数 0-59\r\n> \r\n> setSeconds(秒数) 设置秒数 如果超过60或小于0，则自动增减分钟数\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getSeconds());\r\n        date.setSeconds(62);\r\n        console.log(date.toLocaleString());\r\n    </script>\r\n</body>\r\n```\r\n\r\n## 4.9 getMilliSeconds()和setMilliSeconds(毫秒值)\r\n\r\n> getMilliSeconds() 获取毫秒值 0-999\r\n> \r\n> setMilliSeconds(毫秒值) 设置毫秒值\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        var date = new Date();\r\n        console.log(date.getMilliseconds());\r\n        date.setMilliseconds(999);\r\n        console.log(date.toLocaleString());\r\n    </script>\r\n</body>\r\n```\r\n\r\n# 五、 日期格式化方法\r\n\r\n1.  toDateString() ——以特定于实现的格式显示星期几、月、日和年；\r\n2.  toTimeString() ——以特定于实现的格式显示时、分、秒和时区；\r\n3.  toLocaleDateString() ——以特定于地区的格式显示星期几、月、日和年；\r\n4.  toLocaleTimeString() ——以特定于实现的格式显示时、分、秒；\r\n5.  toUTCString() ——以特定于实现的格式完整的 UTC 日期。\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('61', 'js正则表达式', '<h1 id=\"h1--\"><a name=\"一、正则表达式概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、正则表达式概述</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 什么是正则表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 什么是正则表达式</h2><p>? 正则表达式(regular expression)是一个描述字符模式的对象，ECMAScript的RegExp 类表示正则表达式，而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。</p>\r\n<p>? 正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 正则表达式的作用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 正则表达式的作用</h2><p>? 正则表达式主要用来验证客户端的输入数据。</p>\r\n<p>? 用户填写完表单单击按钮之后，表单就会被发送到服务器，在服务器端通常会用<a href=\"http://lib.csdn.net/base/php\" title=\"PHP知识库\">PHP</a>、ASP<a href=\"http://lib.csdn.net/base/dotnet\" title=\".NET知识库\">.NET</a>、JSP等服务器脚本对其进行进一步处理。因为客户端验证，可以节约大量的服务器端的系统资源，并且提供更好的用户体验。</p>\r\n<ol>\r\n<li>提高用户体验</li><li>减轻服务器的压力</li></ol>\r\n<h1 id=\"h1--\"><a name=\"二、创建正则表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、创建正则表达式</h1><blockquote>\r\n<p>要使用正则表达式，必须先创建正则表达式对象，有2种创建对象的方式：</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-1-1-new-\"><a name=\"2.1 方式1：使用关键字new创建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 方式1：使用关键字new创建</h2><blockquote>\r\n<p>var patt = new RegExp(pattern,modifiers);</p>\r\n<p>参数1：正则表达式的模式。字符串形式</p>\r\n<p>参数2：模式修饰符。用于指定全局匹配、区分大小写的匹配和多行匹配</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    /*\r\n        创建了一个正则表达式\r\n        参数1：模式是：girl，意思是说可以匹配 &quot;girl&quot;这样的字符串\r\n        参数2：模式修饰符：gi    g代表全局匹配  i代表不区分大小写\r\n    */\r\n    var pa = new RegExp(&quot;girl&quot;, &quot;gi&quot;);\r\n    //测试参数中的字符串&quot;你好我的girl&quot; 是否与匹配模式匹配。\r\n    var isExist = pa.test(&quot;你好我的girl&quot;);  // 在本例中，是匹配的，这个字符串包含girl，所以返回true\r\n    alert(isExist); //true\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-2-2-\"><a name=\"2.2 方式2：使用正则表达式直接量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 方式2：使用正则表达式直接量</h2><blockquote>\r\n<p>var pa = /pattern/modifiers;</p>\r\n<p>两个/中间的表示正则表达式的模式，最后一个/的后面是模式修饰符</p>\r\n<p>例如：上面的例子可以这样写 var pa = /girl/gi;</p>\r\n<p>注意：这个时候模式和模式修饰符都能再添加双引号或单引号</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var pa = /girl/gi;\r\n    alert(pa.test(&quot;厉害了我的girl&quot;));    //true\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--126-\"><a name=\"三、正则表达式模式修饰符==(126)==\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、正则表达式模式修饰符==(126)==</h1><blockquote>\r\n<p><a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>中共有3种模式修饰符：g i u</p>\r\n<ol>\r\n<li>g：表示全局。意思是说会对一个字符串进行多次匹配。如果不写g则只匹配一次，一旦匹配成功，则不会再次匹配</li><li>i：表示忽略大小写。意思是说在匹配的时候不区分大小写</li><li>u：表示可以多行匹配。</li></ol>\r\n</blockquote>\r\n<h1 id=\"h1--\"><a name=\"四、正则表达式方法详解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、正则表达式方法详解</h1><blockquote>\r\n<p>经常用到的正则表达式方法有两个test() 和 exec()</p>\r\n</blockquote>\r\n<h2 id=\"h2-4-1-test-\"><a name=\"4.1 test()方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 test()方法</h2><blockquote>\r\n<p>正则表达式对象.test(字符串)</p>\r\n<ul>\r\n<li>参数：要匹配的字符串</li><li>返回值：匹配成功返回true，失败返回false</li></ul>\r\n<p>在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此， test() 方法经常被用在 if 语句中。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var pa = /girl/gi;\r\n    if(pa.test(&quot;厉害了我的girl&quot;)){\r\n        alert(&quot;这个女孩和你很配&quot;);\r\n    }else {\r\n        alert(&quot;你注定没有女孩去匹配&quot;);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-2-exec-\"><a name=\"4.2 exec()方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 exec()方法</h2><blockquote>\r\n<p>exec(字符串)：该方法为专门为捕获组而设计的</p>\r\n<ul>\r\n<li>参数：要匹配的字符串</li><li>返回值：返回的是一个数组。如果不匹配则返回null</li></ul>\r\n<pre><code>**关于返回值数组的说明：**\r\n\r\n\r\n1.  它确实是Array的实例。\r\n2.  但是这个数组有两个额外的属性：index和input\r\n</code></pre><ul>\r\n<li>index：表示匹配的字符串在源字符串中的索引</li><li><p>input：表示匹配的源字符串。</p>\r\n<ol>\r\n<li>数组的第一项目是与整个模式匹配的字符串，其他项是与模式中捕获组匹配的字符串</li><li>如果没有捕获组，则数组中只有第一项。关于捕获组的概念以后再说</li></ol>\r\n</li></ul>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var pa = /girl/gi;\r\n    var testStr = &quot;myGirl, yourgirl, hisgIrl&quot;;\r\n    var girls = pa.exec(testStr);  //捕获\r\n    alert(girls.length + &quot;:&quot; + (girls instanceof Array));   //正则表达式没有捕获组，所以数组长度为1\r\n    alert(girls[0]);    //第一次捕获的是 Girl\r\n    //因为我们是用的全局匹配，所以此次匹配的时候从上次匹后的位置开始继续匹配\r\n    alert(pa.exec(testStr)[0]);     // girl\r\n    alert(pa.exec(testStr));    // gIrl\r\n    alert(pa.exec(testStr)); //继续向后没有匹配的字符串，所以返回null\r\n    // 返回null，如果继续再匹配，则会回到字符串的开始，重写开始匹配。\r\n    alert(pa.exec(testStr));    // Girl\r\n    // ...开启新一轮匹配\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>所以我们如果想找到全部匹配的字符串可以时候用循环，结束条件就是匹配结果为null</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var pa = /girl/gi;\r\n    var testStr = &quot;myGirl, yourgirl, hisgIrl&quot;;\r\n    var girls;\r\n    while(girls = pa.exec(testStr)){    //如果等于null,会自动转成 false，结束。\r\n        alert(girls);\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>分组。在正则表达式中用()括起来任务是一组。组可以嵌套。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //()内的内容就是第1组(Girl)，其实我们完整真个表达式可以看出第0组 girl(Girl)\r\n    // 将来对应着匹配结果数组的下标。  \r\n    var pa = /girl(Girl)/gi;    \r\n    var test = &quot;girlGirl abdfjla Girlgirl fal girl&quot;;\r\n    var girls;\r\n    while(girls = pa.exec(test)){\r\n      //匹配之后，数组的第0个元素对应的这第0组的匹配结果，第1个元素对应着第1组的匹配结果\r\n        for (var i = 0; i &lt; girls.length; i++) {\r\n            console.log(girls[i]);\r\n        }\r\n        console.log(&quot;-------------&quot;);\r\n    }\r\n&lt;/script&gt;\r\n//最终运行结果：\r\ngirlGirl\r\nGirl\r\n-------------\r\nGirlgirl\r\ngirl\r\n------------\r\n</code></pre><h1 id=\"h1--124-\"><a name=\"五、正则表达式规则(124)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、正则表达式规则(124)</h1><p><a href=\"http://www.runoob.com/jsref/jsref-obj-regexp.html\">表达式规则</a></p>\r\n<pre><code>正则表达式元字符是包含特殊含义的字符。它们有一些特殊功能，可以控制匹配模式的\r\n方式。反斜杠后的元字符将失去其特殊含义。\r\n字符类：单个字符和数字\r\n[0-9A-Za-z]  \r\n元字符/元符号                 匹配情况\r\n.                       匹配除换行符外的任意字符\r\n[a-z0-9]                    匹配括号中的字符集中的任意字符\r\n[^a-z0-9]                   匹配任意不在括号中的字符集中的字符\r\n\\d ==[0-9]                  匹配数字\r\n\\D ==[^0-9]                     匹配非数字，同[^0-9]相同\r\n\\w  [0-9A-Za-z_]                    匹配字母和数字及_\r\n\\W                      匹配非(字母和数字及_)\r\n\r\n字符类：空白字符\r\n元字符/元符号                 匹配情况\r\n\\0                          匹配null 字符\r\n\\b                          匹配空格字符 \r\n\\n                          匹配换行符\r\n\\r                          匹配回车字符\r\n\\t                          匹配制表符\r\n\\s                          匹配空白字符、空格、制表符和换行符\r\n\\S                          匹配非空白字符\r\n\r\n字符类：锚字符\r\n\r\n元字符/元符号                 匹配情况\r\n^                           行首匹配\r\n$                          行尾匹配\r\n\r\n字符类：重复字符\r\n元字符/元符号                             匹配情况\r\n?  例如（x?）                           匹配0个或1 个x\r\n*  例如（x*）                           匹配0个或任意多个x\r\n+  例如（x+）                           匹配至少一个x\r\n(xyz)+                                  匹配至少一个(xyz)\r\n{m,n} 例如x{m,n}  n&gt;=次数&gt;=m            匹配最少m个、最多n个x\r\n{n}                                     匹配前一项n次     \r\n{n,}                                    匹配前一项n次，或者多次\r\n</code></pre><h1 id=\"h1--\"><a name=\"六、常用正则表示\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、常用正则表示</h1><pre><code>1、检查邮政编码\r\nvar pattern = /[1-9][0-9]{5}/; //共6位数字，第一位不能为0\r\nvar str = &#39;224000&#39;;\r\nalert(pattern.test(str));\r\n2、检查文件压缩包\r\nvar pattern = /[\\w]+\\.zip|rar|gz/; //\\w 表示所有数字和字母加下划线\r\nvar str = &#39;123.zip&#39;; //\\.表示匹配.，后面是一个选择\r\nalert(pattern.test(str));\r\n3、删除多余空格\r\nvar pattern = /\\s/g; //g 必须全局，才能全部匹配\r\nvar reg=new RegExp(&#39;\\\\s+&#39;,&#39;g&#39;);\r\nvar str = &#39;111 222 333&#39;;\r\nvar result = str.replace(pattern,&#39;&#39;); //把空格匹配成无空格\r\nalert(result);\r\n4、删除空格\r\nvar pattern = /^\\s+/; \r\nvar str = &#39; goo gle &#39;;\r\nalert(str+&quot;  &quot;+str.length);\r\nvar result = str.replace(pattern, &#39;&#39;);\r\nalert(result+&quot; &quot;+result.length);\r\npattern = /\\s+$/; \r\nresult = result.replace(pattern, &#39;&#39;);\r\nalert(result+&quot; &quot;+result.length);\r\npattern = /\\s+/g; \r\nresult = result.replace(pattern, &#39;&#39;);\r\nalert(result+&quot; &quot;+result.length);\r\n5、简单的电子邮件验证\r\nvar pattern = /^([a-zA-Z0-9_\\.\\-]+)@([a-zA-Z0-9_\\.\\-]+)\\.([a-zA-Z]{2,4})$/;\r\nvar str = &#39;yc60.com@gmail.com&#39;;\r\nalert(pattern.test(str));\r\nvar pattern = /^([\\w\\.\\-]+)@([\\w\\.\\-]+)\\.([\\w]{2,4})$/;\r\nvar str = &#39;yc60.com@gmail.com&#39;;\r\nalert(pattern.test(str));\r\n</code></pre><h1 id=\"h1--\"><a name=\"七、支持正则表达式的字符串方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、支持正则表达式的字符串方法</h1><table>\r\n<thead>\r\n<tr>\r\n<th>方法</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>search</td>\r\n<td>检索与正则表达式相匹配的第一个匹配项的索引。</td>\r\n</tr>\r\n<tr>\r\n<td>match</td>\r\n<td>找到一个或多个正则表达式的匹配。</td>\r\n</tr>\r\n<tr>\r\n<td>replace</td>\r\n<td>替换与正则表达式匹配的子串。</td>\r\n</tr>\r\n<tr>\r\n<td>split</td>\r\n<td>把字符串分割为字符串数组。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s = &quot;Abc123aBc&quot;;\r\n    alert(s.search(/abc/gi)); \r\n    alert(s.search(/abc/gi)); // 即使设置的全局模式，每次search也是从开始向后查找\r\n\r\n    //match方法和正则表达式的exec()方法的作用是一样的，但是match会一次性把所有的匹配放在一个数组中，全部返回\r\n    alert(s.match(/abc/gi));    // Abc,aBc\r\n\r\n    alert(s.replace(/[ab]/gi, &quot;x&quot;));        //把a或b替换成x\r\n    var ss = s.split(/[0-9]+/gi);   //用1个或多个数字切割。   Abc,aBc\r\n    alert(ss);\r\n&lt;/script&gt;\r\n</code></pre>', '87', '\r\n\r\n# 一、正则表达式概述\r\n\r\n## 1.1 什么是正则表达式\r\n\r\n? 正则表达式(regular expression)是一个描述字符模式的对象，ECMAScript的RegExp 类表示正则表达式，而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。\r\n\r\n? 正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。\r\n\r\n## 1.2 正则表达式的作用\r\n\r\n? 正则表达式主要用来验证客户端的输入数据。\r\n\r\n? 用户填写完表单单击按钮之后，表单就会被发送到服务器，在服务器端通常会用[PHP](http://lib.csdn.net/base/php \"PHP知识库\")、ASP[.NET](http://lib.csdn.net/base/dotnet \".NET知识库\")、JSP等服务器脚本对其进行进一步处理。因为客户端验证，可以节约大量的服务器端的系统资源，并且提供更好的用户体验。\r\n\r\n1.  提高用户体验\r\n2.  减轻服务器的压力\r\n\r\n# 二、创建正则表达式\r\n\r\n> 要使用正则表达式，必须先创建正则表达式对象，有2种创建对象的方式：\r\n\r\n## 2.1 方式1：使用关键字new创建\r\n\r\n> var patt = new RegExp(pattern,modifiers);\r\n> \r\n> 参数1：正则表达式的模式。字符串形式\r\n> \r\n> 参数2：模式修饰符。用于指定全局匹配、区分大小写的匹配和多行匹配\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    /*\r\n        创建了一个正则表达式\r\n        参数1：模式是：girl，意思是说可以匹配 \"girl\"这样的字符串\r\n        参数2：模式修饰符：gi    g代表全局匹配  i代表不区分大小写\r\n    */\r\n    var pa = new RegExp(\"girl\", \"gi\");\r\n    //测试参数中的字符串\"你好我的girl\" 是否与匹配模式匹配。\r\n    var isExist = pa.test(\"你好我的girl\");  // 在本例中，是匹配的，这个字符串包含girl，所以返回true\r\n    alert(isExist); //true\r\n</script>\r\n```\r\n\r\n## 2.2 方式2：使用正则表达式直接量\r\n\r\n> var pa = /pattern/modifiers;\r\n> \r\n> 两个/中间的表示正则表达式的模式，最后一个/的后面是模式修饰符\r\n> \r\n> 例如：上面的例子可以这样写 var pa = /girl/gi;\r\n> \r\n> 注意：这个时候模式和模式修饰符都能再添加双引号或单引号\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var pa = /girl/gi;\r\n    alert(pa.test(\"厉害了我的girl\"));    //true\r\n</script>\r\n```\r\n\r\n# 三、正则表达式模式修饰符==(126)==\r\n\r\n> [JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")中共有3种模式修饰符：g i u\r\n> \r\n> 1.  g：表示全局。意思是说会对一个字符串进行多次匹配。如果不写g则只匹配一次，一旦匹配成功，则不会再次匹配\r\n> 2.  i：表示忽略大小写。意思是说在匹配的时候不区分大小写\r\n> 3.  u：表示可以多行匹配。\r\n\r\n# 四、正则表达式方法详解\r\n\r\n> 经常用到的正则表达式方法有两个test() 和 exec()\r\n\r\n## 4.1 test()方法\r\n\r\n> 正则表达式对象.test(字符串)\r\n> \r\n> *   参数：要匹配的字符串\r\n> *   返回值：匹配成功返回true，失败返回false\r\n> \r\n> 在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此， test() 方法经常被用在 if 语句中。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var pa = /girl/gi;\r\n    if(pa.test(\"厉害了我的girl\")){\r\n        alert(\"这个女孩和你很配\");\r\n    }else {\r\n        alert(\"你注定没有女孩去匹配\");\r\n    }\r\n</script>\r\n```\r\n\r\n## 4.2 exec()方法\r\n\r\n> exec(字符串)：该方法为专门为捕获组而设计的\r\n> \r\n> *   参数：要匹配的字符串\r\n> *   返回值：返回的是一个数组。如果不匹配则返回null\r\n>     \r\n>     \r\n>     \r\n>     **关于返回值数组的说明：**\r\n>     \r\n>     \r\n>     1.  它确实是Array的实例。\r\n>     2.  但是这个数组有两个额外的属性：index和input\r\n> *   index：表示匹配的字符串在源字符串中的索引\r\n> *   input：表示匹配的源字符串。\r\n>     \r\n>     1.  数组的第一项目是与整个模式匹配的字符串，其他项是与模式中捕获组匹配的字符串\r\n>     2.  如果没有捕获组，则数组中只有第一项。关于捕获组的概念以后再说\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var pa = /girl/gi;\r\n    var testStr = \"myGirl, yourgirl, hisgIrl\";\r\n    var girls = pa.exec(testStr);  //捕获\r\n    alert(girls.length + \":\" + (girls instanceof Array));   //正则表达式没有捕获组，所以数组长度为1\r\n    alert(girls[0]);    //第一次捕获的是 Girl\r\n    //因为我们是用的全局匹配，所以此次匹配的时候从上次匹后的位置开始继续匹配\r\n    alert(pa.exec(testStr)[0]);     // girl\r\n    alert(pa.exec(testStr));    // gIrl\r\n    alert(pa.exec(testStr)); //继续向后没有匹配的字符串，所以返回null\r\n    // 返回null，如果继续再匹配，则会回到字符串的开始，重写开始匹配。\r\n    alert(pa.exec(testStr));    // Girl\r\n    // ...开启新一轮匹配\r\n</script>\r\n```\r\n\r\n> 所以我们如果想找到全部匹配的字符串可以时候用循环，结束条件就是匹配结果为null\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var pa = /girl/gi;\r\n    var testStr = \"myGirl, yourgirl, hisgIrl\";\r\n    var girls;\r\n    while(girls = pa.exec(testStr)){    //如果等于null,会自动转成 false，结束。\r\n        alert(girls);\r\n    }\r\n</script>\r\n```\r\n\r\n> 分组。在正则表达式中用()括起来任务是一组。组可以嵌套。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //()内的内容就是第1组(Girl)，其实我们完整真个表达式可以看出第0组 girl(Girl)\r\n    // 将来对应着匹配结果数组的下标。  \r\n    var pa = /girl(Girl)/gi;    \r\n    var test = \"girlGirl abdfjla Girlgirl fal girl\";\r\n    var girls;\r\n    while(girls = pa.exec(test)){\r\n      //匹配之后，数组的第0个元素对应的这第0组的匹配结果，第1个元素对应着第1组的匹配结果\r\n        for (var i = 0; i < girls.length; i++) {\r\n            console.log(girls[i]);\r\n        }\r\n        console.log(\"-------------\");\r\n    }\r\n</script>\r\n//最终运行结果：\r\ngirlGirl\r\nGirl\r\n-------------\r\nGirlgirl\r\ngirl\r\n------------\r\n```\r\n\r\n# 五、正则表达式规则(124)\r\n\r\n[表达式规则](http://www.runoob.com/jsref/jsref-obj-regexp.html)\r\n\r\n```\r\n正则表达式元字符是包含特殊含义的字符。它们有一些特殊功能，可以控制匹配模式的\r\n方式。反斜杠后的元字符将失去其特殊含义。\r\n字符类：单个字符和数字\r\n[0-9A-Za-z]  \r\n元字符/元符号                 匹配情况\r\n.                       匹配除换行符外的任意字符\r\n[a-z0-9]                    匹配括号中的字符集中的任意字符\r\n[^a-z0-9]                   匹配任意不在括号中的字符集中的字符\r\n\\d ==[0-9]                  匹配数字\r\n\\D ==[^0-9]                     匹配非数字，同[^0-9]相同\r\n\\w  [0-9A-Za-z_]                    匹配字母和数字及_\r\n\\W                      匹配非(字母和数字及_)\r\n\r\n字符类：空白字符\r\n元字符/元符号                 匹配情况\r\n\\0                          匹配null 字符\r\n\\b                          匹配空格字符 \r\n\\n                          匹配换行符\r\n\\r                          匹配回车字符\r\n\\t                          匹配制表符\r\n\\s                          匹配空白字符、空格、制表符和换行符\r\n\\S                          匹配非空白字符\r\n\r\n字符类：锚字符\r\n\r\n元字符/元符号                 匹配情况\r\n^                           行首匹配\r\n$                          行尾匹配\r\n\r\n字符类：重复字符\r\n元字符/元符号                             匹配情况\r\n?  例如（x?）                           匹配0个或1 个x\r\n*  例如（x*）                           匹配0个或任意多个x\r\n+  例如（x+）                           匹配至少一个x\r\n(xyz)+                                  匹配至少一个(xyz)\r\n{m,n} 例如x{m,n}  n>=次数>=m            匹配最少m个、最多n个x\r\n{n}                                     匹配前一项n次     \r\n{n,}                                    匹配前一项n次，或者多次 \r\n```\r\n\r\n# 六、常用正则表示\r\n\r\n```\r\n1、检查邮政编码\r\nvar pattern = /[1-9][0-9]{5}/; //共6位数字，第一位不能为0\r\nvar str = \'224000\';\r\nalert(pattern.test(str));\r\n2、检查文件压缩包\r\nvar pattern = /[\\w]+\\.zip|rar|gz/; //\\w 表示所有数字和字母加下划线\r\nvar str = \'123.zip\'; //\\.表示匹配.，后面是一个选择\r\nalert(pattern.test(str));\r\n3、删除多余空格\r\nvar pattern = /\\s/g; //g 必须全局，才能全部匹配\r\nvar reg=new RegExp(\'\\\\s+\',\'g\');\r\nvar str = \'111 222 333\';\r\nvar result = str.replace(pattern,\'\'); //把空格匹配成无空格\r\nalert(result);\r\n4、删除空格\r\nvar pattern = /^\\s+/; \r\nvar str = \' goo gle \';\r\nalert(str+\"  \"+str.length);\r\nvar result = str.replace(pattern, \'\');\r\nalert(result+\" \"+result.length);\r\npattern = /\\s+$/; \r\nresult = result.replace(pattern, \'\');\r\nalert(result+\" \"+result.length);\r\npattern = /\\s+/g; \r\nresult = result.replace(pattern, \'\');\r\nalert(result+\" \"+result.length);\r\n5、简单的电子邮件验证\r\nvar pattern = /^([a-zA-Z0-9_\\.\\-]+)@([a-zA-Z0-9_\\.\\-]+)\\.([a-zA-Z]{2,4})$/;\r\nvar str = \'yc60.com@gmail.com\';\r\nalert(pattern.test(str));\r\nvar pattern = /^([\\w\\.\\-]+)@([\\w\\.\\-]+)\\.([\\w]{2,4})$/;\r\nvar str = \'yc60.com@gmail.com\';\r\nalert(pattern.test(str));\r\n```\r\n\r\n# 七、支持正则表达式的字符串方法\r\n\r\n| 方法 | 描述 |\r\n| --- | --- |\r\n| search | 检索与正则表达式相匹配的第一个匹配项的索引。 |\r\n| match | 找到一个或多个正则表达式的匹配。 |\r\n| replace | 替换与正则表达式匹配的子串。 |\r\n| split | 把字符串分割为字符串数组。 |\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var s = \"Abc123aBc\";\r\n    alert(s.search(/abc/gi)); \r\n    alert(s.search(/abc/gi)); // 即使设置的全局模式，每次search也是从开始向后查找\r\n\r\n    //match方法和正则表达式的exec()方法的作用是一样的，但是match会一次性把所有的匹配放在一个数组中，全部返回\r\n    alert(s.match(/abc/gi));    // Abc,aBc\r\n\r\n    alert(s.replace(/[ab]/gi, \"x\"));        //把a或b替换成x\r\n    var ss = s.split(/[0-9]+/gi);   //用1个或多个数字切割。   Abc,aBc\r\n    alert(ss);\r\n</script>\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('62', 'js面向对象', '<h1 id=\"h1--\"><a name=\"一、面向对象的概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、面向对象的概念</h1><h2 id=\"h2-1-1-\"><a name=\"1.1 什么是面向过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 什么是面向过程</h2><p>? 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>\r\n<p>? 生活中的的例子举例。</p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 什么是面向对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 什么是面向对象</h2><p>? 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>\r\n<ol>\r\n<li><strong>面向对象是一种思维方法</strong></li><li><strong>面向对象是一种编程方法</strong></li><li><strong>面向对象并不只针对某一种编程语言</strong></li></ol>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-11-9/25927086.jpg\" alt=\"\"></p>\r\n<h2 id=\"h2-1-3-\"><a name=\"1.3 面向对象和面向过程的区别和联系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.3 面向对象和面向过程的区别和联系</h2><ol>\r\n<li>面向过程过程侧重整个问题的解决步骤，着眼局部或者具体</li><li>面向对象侧重具体的功能，让某个对象具有这样的功能。更加侧重于整体。</li></ol>\r\n<pre><code>各自的优缺点\r\n\r\n面向过程的优点：\r\n    流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果；\r\n    效率高,面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。。\r\n     流程明确，具体步骤清楚，便于节点分析。\r\n\r\n  缺点是：需要深入的思考，耗费精力，代码重用性低，扩展能力差，维护起来难度比较高，\r\n          对复杂业务来说，面向过程的模块难度较高，耦合度也比较高。\r\n\r\n面向对象的优点：结构清晰，程序便于模块化，结构化，抽象化，更加符合人类的思维方式；\r\n    封装性，将事务高度抽象，从而便于流程中的行为分析，也便于操作和自省； \r\n    容易扩展，代码重用率高，可继承，可覆盖；\r\n    实现简单，可有效地减少程序的维护工作量，软件开发效率高。\r\n\r\n  缺点是：效率低，面向对象在面向过程的基础上高度抽象，从而和代码底层的直接交互非常少机会，\r\n              从而不适合底层开发和游戏甚至多媒体开发；\r\n              复杂性，对于事务开发而言，事务本身是面向过程的，过度的封装导致事务本身的复杂性提高。\r\n</code></pre><h1 id=\"h1--\"><a name=\"二、编程语言中面向对象的实现方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、编程语言中面向对象的实现方式</h1><p>编程语言对对面向对象的实现主流的有两种方式：基于类的面向对象和基于原型的面向对象。</p>\r\n<p>不管以什么方式实现，都具有面向对象的三大特征：</p>\r\n<ul>\r\n<li><p>封装</p>\r\n<p>也就是把客观事物封装成抽象的类或具体的对象，并且类或对象可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>\r\n</li><li><p>继承</p>\r\n<p>可以让某个类型的对象获得另一个类型的对象的属性的方</p>\r\n</li><li><p>多态</p>\r\n<p>不同实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。</p>\r\n</li></ul>\r\n<h2 id=\"h2-2-1-\"><a name=\"2.1基于类的面向对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1基于类的面向对象</h2><blockquote>\r\n<p>典型的语言：<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>、C#</p>\r\n</blockquote>\r\n<p><strong>对象（object）依靠 类（class)来产生</strong></p>\r\n<h2 id=\"h2-2-2-\"><a name=\"2.2 基于原型的面向对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 基于原型的面向对象</h2><blockquote>\r\n<p>典型的语言：<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a></p>\r\n</blockquote>\r\n<p><strong>对象（object）则是依靠 构造器（constructor）利用 原型（prototype）构造出来的</strong></p>\r\n<h1 id=\"h1--a-name-t7-a-javascript-\"><a name=\"<a name=\"t7\"></a>三、对JavaScript对象的进一步认识\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a name=\"t7\"></a>三、对JavaScript对象的进一步认识</h1><p>? ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //用大括号括起来的一系列的键值对，就构成了JavaScript对象。这种对象称之为字面量对象。\r\n    var person = {\r\n        name : &quot;张三&quot;,    // 一个键值对  \r\n        age : 20,\r\n        sex : &quot;男&quot;,\r\n        eat : function () { //属性的值是函数，这个时候我们更喜欢把这样的属性称之为方法。\r\n            alert(&quot;吃东西&quot;);\r\n        }\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>name : “张三” 一个键值对表示JavaScript对象的一个属性。 name是属性名， “张三” 属性值。</li><li>属性可以是任意类型的。可以包括我们以前学的简单数据类型，也可以是函数，也可以是其他的对象。</li><li>当一个属性的值是函数的时候，我们更喜欢说这个属性为方法。(如果函数不和对象关联起来的时候，应该叫函数不应该叫方法。只是一种称呼，你完全可以不用理会)。 我们一般说person对象具有了一个方法eat. 将来访问eat的时候，也和调用一个函数一样一样的。</li></ol>\r\n<h2 id=\"h2-3-1-\"><a name=\"3.1 访问对象的属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 访问对象的属性</h2><blockquote>\r\n<p>访问一个对象的属性，我们可以直接通过 <strong><em>对象.属性名</em></strong> 和 <strong><em>对象[属性名]</em></strong> 来访问。</p>\r\n</blockquote>\r\n<pre><code>alert(person.name);  // 访问person对象的 name属性值\r\nperson.age = 30;  //修改person对象的 age 属性\r\nperson.eat();  //既然是调用方法(函数) 则一定还要添加 ()来表示方法的调用\r\nalert(person[&quot;name&quot;]);  //\r\n</code></pre><blockquote>\r\n<p><strong>两种使用方式有一些不同的地方：</strong></p>\r\n<ol>\r\n<li>对象.属性名的方式，只适合知道了属性的名字，可以直接写。比如： person.age 。如果属性名是个变量，则这种方法无效， 对象.变量名 会出现语法错误。</li><li>对象[属性名]，这种方式使用无限制。如果是字符串常量，则应该用”“引起来，如果是变量，可以直接使用。</li></ol>\r\n</blockquote>\r\n<pre><code>person.age = 100; // ok\r\nvar n = &quot;age&quot;;\r\nperson.a = 101; //  no ok 语法错误\r\nperson[&quot;age&quot;] = 102; // ok\r\nperson[n] = 103;  //ok\r\n</code></pre><h2 id=\"h2-3-2-\"><a name=\"3.2 给对象添加属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 给对象添加属性</h2><blockquote>\r\n<p>JavaScript是一种动态语言，可以在代码执行过程中，动态去添加和修改对象的属性。这是与其他面向对象语言一个很大的不同点。</p>\r\n<p>备注：对那些基于类的语言，属性一旦在类中定义完成，对象是不能去动态添加和删除属性的。</p>\r\n</blockquote>\r\n<pre><code>//给person对象的属性 girlFriend 赋值。在赋值的过程中，首先会判断这个属性在JavaScript中是否存在，如果存在就对这个\r\n//属性重写赋值。如果不存在，就给这个对象添加这个属性，并赋值。\r\nperson.girlFrient = &quot;小丽&quot;;  \r\n\r\n//给对象添加方法\r\nperson.play = funcion(){\r\n    alert(&quot;打击high起来&quot;);\r\n}\r\n</code></pre><h2 id=\"h2-3-3-\"><a name=\"3.3 删除对象属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 删除对象属性</h2><blockquote>\r\n<p>对JavaScript来说，我们不仅可以动态的添加属性，也可以动态的删除属性。</p>\r\n<p>使用操作符：delete</p>\r\n<p>注意：delete是个操作符，不是方法，所以后面没有必要添加括号啊</p>\r\n</blockquote>\r\n<pre><code>// 使用delete操作关键字，删除person对象的属性age\r\ndelete person.age;\r\nalert(person.age);  //弹出undefined。表示这个属性没有定义\r\n</code></pre><h2 id=\"h2-3-4-\"><a name=\"3.4 修改对象属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 修改对象属性</h2><pre><code>// 把person对象的sex属性的值修改为 女\r\nperson.sex = &quot;女&quot;;\r\nperson.eat = funcion(){\r\n    alert(&quot;吃货&quot;);\r\n}\r\nperson.eat();  //吃货\r\n</code></pre><h2 id=\"h2-3-5-for-in-\"><a name=\"3.5 使用for…in遍历对象的属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5 使用for…in遍历对象的属性</h2><blockquote>\r\n<p>for…in可以用来遍历对象的所有属性。</p>\r\n</blockquote>\r\n<pre><code>// 在用for...in遍历的时候， in前面的变量pn指的是属性的名称。\r\nfor (pn in person) {\r\n    alert(pn + &quot; &quot; + person[pn]);\r\n}\r\n</code></pre><h1 id=\"h1--\"><a name=\"四、多种创建对象的方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、多种创建对象的方式</h1><blockquote>\r\n<p>除了上面的使用对象直接量，JavaScript还支持多种方式创建对象</p>\r\n</blockquote>\r\n<h2 id=\"h2-4-1-new-object-\"><a name=\"4.1 使用new Object()创建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 使用new Object()创建</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //使用object创建一个对象    完全等同于 var person = {};\r\n    var person = new Object();\r\n    //给对象添加属性\r\n    person.name = &quot;李四&quot;;\r\n    //给对象添加方法\r\n    person.eat = function () {\r\n        alert(&quot;好好吃&quot;)\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-2-\"><a name=\"4.2 工厂模式创建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 工厂模式创建</h2><blockquote>\r\n<p>虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。</p>\r\n<p>工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function createPerson(name, age, job) {\r\n        var o = new Object();\r\n        o.name = name;\r\n        o.age = age;\r\n        o.job = job;\r\n        o.sayName = function() {\r\n            alert(this.name);\r\n        };\r\n        return o;\r\n    }\r\n    var person1 = createPerson(&quot;张三&quot;, 29, &quot;js开发者&quot;);\r\n    var person2 = createPerson(&quot;李四&quot;, 27, &quot;java开发者&quot;);\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>createPerson()函数可以多次调用，每调用一次这个函数就会返回一个对象，而且对象的类型仍然是Object类型的。虽然解决了多个相似对象的问题，但却没有解决对象类型识别的问题。</p>\r\n</blockquote>\r\n<h2 id=\"h2-4-3-\"><a name=\"4.3 构造函数模式创建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 构造函数模式创建</h2><blockquote>\r\n<p>为了解决对象类型识别问题，又提出了构造函数模式。这种模式，其实在我们创建一些原生对象的时候，比如Array、Object都是调用的他们的构造函数。</p>\r\n<p>看下面的代码</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person (name, age, sex) {\r\n        this.name = name;\r\n\r\n        this.age = age;\r\n        this.sex = sex;\r\n\r\n        this.eat = function () {\r\n            alert(this.name + &quot;在吃东西&quot;);\r\n        }\r\n    }\r\n    var p1 = new Person(&quot;张三&quot;, 20, &quot;男&quot;);\r\n    p1.eat();   //张三在在吃东西\r\n    var p1 = new Person(&quot;李四&quot;, 30, &quot;男&quot;);\r\n    p1.eat();   //李四在在吃东西\r\n    alert(p1 instanceof Person);    //\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>使用构造函数创建对象，必须使用关键字new ，后面跟着构造函数的名，根据需要传入相应的参数。</li><li><p>其实使用 new 构造函数() 的方式创建对象，经历了下面几个步骤。</p>\r\n<ul>\r\n<li>创建出来一个新的对象</li><li>将构造函数的作用域赋给新对象。意味着这个时候 <strong>this就代表了这个新对象</strong>。</li><li>执行构造函数中的代码。 在本例中就是给新对象添加属性，并给属性初始化值。</li><li>构造函数执行完毕之后，默认返回新对象。 所以外面就可以拿到这个刚刚创建的新对象了。</li></ul>\r\n</li></ol>\r\n<h1 id=\"h1--\"><a name=\"五、构造函数与普通函数的关系\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、构造函数与普通函数的关系</h1><ol>\r\n<li>他们都是函数。构造函数也是函数，也可以像普通的函数一样进行调用。 做普通函数调用的时候，因为没有创建新的对象，所以this其实指向了window对象。</li></ol>\r\n<pre><code>function Person(){\r\n    this.name = &quot;张三&quot;;   // 把name属性添加到了window对象上面\r\n    alert(this === window);  //如果不作为构造方法调用，则 是true\r\n}\r\nPerson();  // 把构造函数当做普通方法调用。这个时候内部的this指向了weindow\r\nalert(window.name);  //张三\r\nfunction Human(){\r\n    this.name = &quot;王五&quot;;\r\n    alert(this instanceof window);  // false\r\n    alert(this instanceof Human);  //true\r\n}\r\nvar h = new Human();  //当做构造函数来调用，创建一个对象\r\nalert(h.name);\r\n</code></pre><ol>\r\n<li>构造函数和普通函数仅仅也仅仅是调用方式的不同。也就是说，随便一个函数你如果用new 的方式去使用，那么他就是一个构造函数。</li><li>为了区别，如果一个函数想作为构造函数，作为国际惯例，<strong>最好把这个构造函数的首字母大写。</strong></li></ol>\r\n', '88', '\r\n# 一、面向对象的概念\r\n\r\n## 1.1 什么是面向过程\r\n\r\n? 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。\r\n\r\n? 生活中的的例子举例。\r\n\r\n## 1.2 什么是面向对象\r\n\r\n? 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。\r\n\r\n1.  **面向对象是一种思维方法**\r\n2.  **面向对象是一种编程方法**\r\n3.  **面向对象并不只针对某一种编程语言**\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-11-9/25927086.jpg)\r\n\r\n## 1.3 面向对象和面向过程的区别和联系\r\n\r\n1.  面向过程过程侧重整个问题的解决步骤，着眼局部或者具体\r\n2.  面向对象侧重具体的功能，让某个对象具有这样的功能。更加侧重于整体。\r\n\r\n```\r\n各自的优缺点\r\n\r\n面向过程的优点：\r\n    流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果；\r\n    效率高,面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。。\r\n     流程明确，具体步骤清楚，便于节点分析。\r\n\r\n  缺点是：需要深入的思考，耗费精力，代码重用性低，扩展能力差，维护起来难度比较高，\r\n          对复杂业务来说，面向过程的模块难度较高，耦合度也比较高。\r\n\r\n面向对象的优点：结构清晰，程序便于模块化，结构化，抽象化，更加符合人类的思维方式；\r\n    封装性，将事务高度抽象，从而便于流程中的行为分析，也便于操作和自省； \r\n    容易扩展，代码重用率高，可继承，可覆盖；\r\n    实现简单，可有效地减少程序的维护工作量，软件开发效率高。\r\n\r\n  缺点是：效率低，面向对象在面向过程的基础上高度抽象，从而和代码底层的直接交互非常少机会，\r\n              从而不适合底层开发和游戏甚至多媒体开发；\r\n              复杂性，对于事务开发而言，事务本身是面向过程的，过度的封装导致事务本身的复杂性提高。\r\n```\r\n\r\n# 二、编程语言中面向对象的实现方式\r\n\r\n编程语言对对面向对象的实现主流的有两种方式：基于类的面向对象和基于原型的面向对象。\r\n\r\n不管以什么方式实现，都具有面向对象的三大特征：\r\n\r\n*   封装\r\n\r\n    也就是把客观事物封装成抽象的类或具体的对象，并且类或对象可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\r\n\r\n*   继承\r\n\r\n    可以让某个类型的对象获得另一个类型的对象的属性的方\r\n\r\n*   多态\r\n\r\n    不同实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。\r\n\r\n## 2.1基于类的面向对象\r\n\r\n> 典型的语言：[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")、C#\r\n\r\n**对象（object）依靠 类（class)来产生**\r\n\r\n## 2.2 基于原型的面向对象\r\n\r\n> 典型的语言：[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")\r\n\r\n**对象（object）则是依靠 构造器（constructor）利用 原型（prototype）构造出来的**\r\n\r\n# <a name=\"t7\"></a>三、对JavaScript对象的进一步认识\r\n\r\n? ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //用大括号括起来的一系列的键值对，就构成了JavaScript对象。这种对象称之为字面量对象。\r\n    var person = {\r\n        name : \"张三\",    // 一个键值对  \r\n        age : 20,\r\n        sex : \"男\",\r\n        eat : function () { //属性的值是函数，这个时候我们更喜欢把这样的属性称之为方法。\r\n            alert(\"吃东西\");\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n> 说明：\r\n\r\n1.  name : “张三” 一个键值对表示JavaScript对象的一个属性。 name是属性名， “张三” 属性值。\r\n2.  属性可以是任意类型的。可以包括我们以前学的简单数据类型，也可以是函数，也可以是其他的对象。\r\n3.  当一个属性的值是函数的时候，我们更喜欢说这个属性为方法。(如果函数不和对象关联起来的时候，应该叫函数不应该叫方法。只是一种称呼，你完全可以不用理会)。 我们一般说person对象具有了一个方法eat. 将来访问eat的时候，也和调用一个函数一样一样的。\r\n\r\n## 3.1 访问对象的属性\r\n\r\n> 访问一个对象的属性，我们可以直接通过 **_对象.属性名_** 和 **_对象[属性名]_** 来访问。\r\n\r\n```\r\nalert(person.name);  // 访问person对象的 name属性值\r\nperson.age = 30;  //修改person对象的 age 属性\r\nperson.eat();  //既然是调用方法(函数) 则一定还要添加 ()来表示方法的调用\r\nalert(person[\"name\"]);  //\r\n```\r\n\r\n> **两种使用方式有一些不同的地方：**\r\n> \r\n> 1.  对象.属性名的方式，只适合知道了属性的名字，可以直接写。比如： person.age 。如果属性名是个变量，则这种方法无效， 对象.变量名 会出现语法错误。\r\n> 2.  对象[属性名]，这种方式使用无限制。如果是字符串常量，则应该用”“引起来，如果是变量，可以直接使用。\r\n\r\n```\r\nperson.age = 100; // ok\r\nvar n = \"age\";\r\nperson.a = 101; //  no ok 语法错误\r\nperson[\"age\"] = 102; // ok\r\nperson[n] = 103;  //ok\r\n```\r\n\r\n## 3.2 给对象添加属性\r\n\r\n> JavaScript是一种动态语言，可以在代码执行过程中，动态去添加和修改对象的属性。这是与其他面向对象语言一个很大的不同点。\r\n> \r\n> 备注：对那些基于类的语言，属性一旦在类中定义完成，对象是不能去动态添加和删除属性的。\r\n\r\n```\r\n//给person对象的属性 girlFriend 赋值。在赋值的过程中，首先会判断这个属性在JavaScript中是否存在，如果存在就对这个\r\n//属性重写赋值。如果不存在，就给这个对象添加这个属性，并赋值。\r\nperson.girlFrient = \"小丽\";  \r\n\r\n//给对象添加方法\r\nperson.play = funcion(){\r\n    alert(\"打击high起来\");\r\n}\r\n```\r\n\r\n## 3.3 删除对象属性\r\n\r\n> 对JavaScript来说，我们不仅可以动态的添加属性，也可以动态的删除属性。\r\n> \r\n> 使用操作符：delete\r\n> \r\n> 注意：delete是个操作符，不是方法，所以后面没有必要添加括号啊\r\n\r\n```\r\n// 使用delete操作关键字，删除person对象的属性age\r\ndelete person.age;\r\nalert(person.age);  //弹出undefined。表示这个属性没有定义\r\n```\r\n\r\n## 3.4 修改对象属性\r\n\r\n```\r\n// 把person对象的sex属性的值修改为 女\r\nperson.sex = \"女\";\r\nperson.eat = funcion(){\r\n    alert(\"吃货\");\r\n}\r\nperson.eat();  //吃货\r\n```\r\n\r\n## 3.5 使用for…in遍历对象的属性\r\n\r\n> for…in可以用来遍历对象的所有属性。\r\n\r\n```\r\n// 在用for...in遍历的时候， in前面的变量pn指的是属性的名称。\r\nfor (pn in person) {\r\n    alert(pn + \" \" + person[pn]);\r\n}\r\n```\r\n\r\n# 四、多种创建对象的方式\r\n\r\n> 除了上面的使用对象直接量，JavaScript还支持多种方式创建对象\r\n\r\n## 4.1 使用new Object()创建\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //使用object创建一个对象    完全等同于 var person = {};\r\n    var person = new Object();\r\n    //给对象添加属性\r\n    person.name = \"李四\";\r\n    //给对象添加方法\r\n    person.eat = function () {\r\n        alert(\"好好吃\")\r\n    }\r\n</script>\r\n```\r\n\r\n## 4.2 工厂模式创建\r\n\r\n> 虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。\r\n> \r\n> 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function createPerson(name, age, job) {\r\n        var o = new Object();\r\n        o.name = name;\r\n        o.age = age;\r\n        o.job = job;\r\n        o.sayName = function() {\r\n            alert(this.name);\r\n        };\r\n        return o;\r\n    }\r\n    var person1 = createPerson(\"张三\", 29, \"js开发者\");\r\n    var person2 = createPerson(\"李四\", 27, \"java开发者\");\r\n</script>\r\n```\r\n\r\n> createPerson()函数可以多次调用，每调用一次这个函数就会返回一个对象，而且对象的类型仍然是Object类型的。虽然解决了多个相似对象的问题，但却没有解决对象类型识别的问题。\r\n\r\n## 4.3 构造函数模式创建\r\n\r\n> 为了解决对象类型识别问题，又提出了构造函数模式。这种模式，其实在我们创建一些原生对象的时候，比如Array、Object都是调用的他们的构造函数。\r\n> \r\n> 看下面的代码\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person (name, age, sex) {\r\n        this.name = name;\r\n\r\n        this.age = age;\r\n        this.sex = sex;\r\n\r\n        this.eat = function () {\r\n            alert(this.name + \"在吃东西\");\r\n        }\r\n    }\r\n    var p1 = new Person(\"张三\", 20, \"男\");\r\n    p1.eat();   //张三在在吃东西\r\n    var p1 = new Person(\"李四\", 30, \"男\");\r\n    p1.eat();   //李四在在吃东西\r\n    alert(p1 instanceof Person);    //\r\n</script>\r\n```\r\n\r\n> 说明：\r\n\r\n1.  使用构造函数创建对象，必须使用关键字new ，后面跟着构造函数的名，根据需要传入相应的参数。\r\n2.  其实使用 new 构造函数() 的方式创建对象，经历了下面几个步骤。\r\n\r\n    *   创建出来一个新的对象\r\n    *   将构造函数的作用域赋给新对象。意味着这个时候 **this就代表了这个新对象**。\r\n    *   执行构造函数中的代码。 在本例中就是给新对象添加属性，并给属性初始化值。\r\n    *   构造函数执行完毕之后，默认返回新对象。 所以外面就可以拿到这个刚刚创建的新对象了。\r\n\r\n# 五、构造函数与普通函数的关系\r\n\r\n1.  他们都是函数。构造函数也是函数，也可以像普通的函数一样进行调用。 做普通函数调用的时候，因为没有创建新的对象，所以this其实指向了window对象。\r\n\r\n```\r\nfunction Person(){\r\n    this.name = \"张三\";   // 把name属性添加到了window对象上面\r\n    alert(this === window);  //如果不作为构造方法调用，则 是true\r\n}\r\nPerson();  // 把构造函数当做普通方法调用。这个时候内部的this指向了weindow\r\nalert(window.name);  //张三\r\nfunction Human(){\r\n    this.name = \"王五\";\r\n    alert(this instanceof window);  // false\r\n    alert(this instanceof Human);  //true\r\n}\r\nvar h = new Human();  //当做构造函数来调用，创建一个对象\r\nalert(h.name);\r\n```\r\n\r\n1.  构造函数和普通函数仅仅也仅仅是调用方式的不同。也就是说，随便一个函数你如果用new 的方式去使用，那么他就是一个构造函数。\r\n2.  为了区别，如果一个函数想作为构造函数，作为国际惯例，**最好把这个构造函数的首字母大写。**\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('63', 'js原型', '<h1 id=\"h1--\"><a name=\"一、什么是原型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、什么是原型</h1><blockquote>\r\n<p>原型是<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>中的继承的继承，JavaScript的继承就是基于原型的继承。</p>\r\n</blockquote>\r\n<h2 id=\"h2-1-1-\"><a name=\"1.1 函数的原型对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.1 函数的原型对象</h2><p>? 在JavaScript中，我们创建一个函数A(<strong>就是声明一个函数</strong>), 那么浏览器就会在内存中创建一个对象B，而且每个函数都默认会有一个属性 <strong>prototype</strong> 指向了这个对象( 即：<strong>prototype的属性的值是这个对象</strong> )。这个对象B就是函数A的原型对象，简称函数的原型。这个原型对象B 默认会有一个属性 <strong>constructor</strong> 指向了这个函数A ( 意思就是说：constructor属性的值是函数A )。</p>\r\n<p>? 看下面的代码：</p>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        /*\r\n            声明一个函数，则这个函数默认会有一个属性叫 prototype 。而且浏览器会自动按照一定的规则\r\n            创建一个对象，这个对象就是这个函数的原型对象，prototype属性指向这个原型对象。这个原型对象\r\n            有一个属性叫constructor 指向了这个函数\r\n\r\n            注意：原型对象默认只有属性：constructor。其他都是从Object继承而来，暂且不用考虑。\r\n        */\r\n        function Person () {\r\n\r\n        }       \r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>下面的图描述了声明一个函数之后发生的事情：</p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/43031030.jpg\" alt=\"\"></p>\r\n<h2 id=\"h2-1-2-\"><a name=\"1.2 使用构造函数创建对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.2 使用构造函数创建对象</h2><p>? 当把一个函数作为构造函数 (理论上任何函数都可以作为构造函数) 使用new创建对象的时候，那么这个对象就会存在一个默认的不可见的属性，来指向了构造函数的原型对象。 <strong>这个不可见的属性我们一般用 [[prototype]] 来表示，只是这个属性没有办法直接访问到。</strong></p>\r\n<p>? 看下面的代码：</p>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        function Person () {\r\n\r\n        }   \r\n        /*\r\n            利用构造函数创建一个对象，则这个对象会自动添加一个不可见的属性 [[prototype]], 而且这个属性\r\n            指向了构造函数的原型对象。\r\n        */\r\n        var p1 = new Person();\r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>观察下面的示意图：</p>\r\n</blockquote>\r\n<p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/6663492.jpg\" alt=\"\"></p>\r\n<blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>从上面的图示中可以看到，创建p1对象虽然使用的是Person构造函数，但是对象创建出来之后，这个p1对象其实已经与Person构造函数没有任何关系了，p1对象的[[ prototype ]]属性指向的是Person构造函数的原型对象。</li><li>如果使用new Person()创建多个对象，则多个对象都会同时指向Person构造函数的原型对象。</li><li>我们可以手动给这个原型对象添加属性和方法，那么p1,p2,p3…这些对象就会共享这些在原型中添加的属性和方法。</li><li>如果我们访问p1中的一个属性name，如果在p1对象中找到，则直接返回。如果p1对象中没有找到，则直接去p1对象的[[prototype]]属性指向的原型对象中查找，如果查找到则返回。(如果原型中也没有找到，则继续向上找原型的原型—原型链。 后面再讲)。</li><li>如果通过p1对象添加了一个属性name，则对p1对象来说就屏蔽了原型中的属性name。 换句话说：在p1中就没有办法访问到原型的属性name了。</li><li>通过p1对象只能读取原型中的属性name的值，而不能修改原型中的属性name的值。 p1.name = “李四”; 并不是修改了原型中的值，而是在p1对象中给添加了一个属性name。</li></ol>\r\n<blockquote>\r\n<p>看下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        function Person () {        \r\n        }\r\n        // 可以使用Person.prototype 直接访问到原型对象\r\n        //给Person函数的原型对象中添加一个属性 name并且值是 &quot;张三&quot;\r\n        Person.prototype.name = &quot;张三&quot;;\r\n        Person.prototype.age = 20;\r\n\r\n        var p1 = new Person();\r\n        /*\r\n            访问p1对象的属性name，虽然在p1对象中我们并没有明确的添加属性name，但是\r\n            p1的 [[prototype]] 属性指向的原型中有name属性，所以这个地方可以访问到属性name\r\n            就值。\r\n            注意：这个时候不能通过p1对象删除name属性，因为只能删除在p1中删除的对象。\r\n        */\r\n        alert(p1.name);  // 张三\r\n\r\n        var p2 = new Person();\r\n        alert(p2.name);  // 张三  都是从原型中找到的，所以一样。\r\n\r\n        alert(p1.name === p2.name);  // true\r\n\r\n        // 由于不能修改原型中的值，则这种方法就直接在p1中添加了一个新的属性name，然后在p1中无法再访问到\r\n        //原型中的属性。\r\n        p1.name = &quot;李四&quot;;\r\n        alert(&quot;p1：&quot; + p1.name);\r\n        // 由于p2中没有name属性，则对p2来说仍然是访问的原型中的属性。    \r\n        alert(&quot;p2:&quot; + p2.name);  // 张三  \r\n    &lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><p><img src=\"http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/45010346.jpg\" alt=\"\"></p>\r\n<h1 id=\"h1--\"><a name=\"二、与原型有关的几个属性和方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、与原型有关的几个属性和方法</h1><h2 id=\"h2-2-1-prototype-\"><a name=\"2.1 prototype属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 prototype属性</h2><p>? prototype 存在于构造函数中 (其实任意函数中都有，只不过不是构造函数的时候prototype我们不关注而已) ，他指向了这个构造函数的原型对象。</p>\r\n<p>? 参考前面的示意图。</p>\r\n<h2 id=\"h2-2-2-constructor-\"><a name=\"2.2 constructor属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 constructor属性</h2><p>? constructor属性存在于原型对象中，他指向了构造函数</p>\r\n<p>看下面的代码：</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person () {\r\n    }\r\n    alert(Person.prototype.constructor === Person); // true\r\n    var p1 = new Person();\r\n    //使用instanceof 操作符可以判断一个对象的类型。  \r\n    //typeof一般用来获取简单类型和函数。而引用类型一般使用instanceof，因为引用类型用typeof 总是返回objece。\r\n    alert(p1 instanceof Person);    // true\r\n    alert(typeof p1); // object\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>我们根据需要，可以为Person.prototype 属性指定新的对象，来作为Person的原型对象。</p>\r\n<p>但是这个时候有个问题，新的对象的constructor属性则不再指向Person构造函数了。</p>\r\n</blockquote>\r\n<p>看下面的代码：</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person () {\r\n\r\n    }\r\n    //直接给Person的原型指定对象字面量。则这个对象的constructor属性不在执行Person函数\r\n    Person.prototype = {\r\n        name:&quot;志玲&quot;,\r\n        age:20\r\n    };\r\n    var p1 = new Person();\r\n    alert(p1.name);  // 志玲\r\n    // p1的类型仍然是Person\r\n    alert(p1 instanceof Person); // true\r\n    //constructor不再执行Peson函数\r\n    alert(Person.prototype.constructor === Person); //false\r\n    //如果constructor对你很重要，你应该在Person.prototype中添加一行这样的代码：\r\n    /*\r\n    Person.prototype = {\r\n        constructor : Person    //让constructor重新指向Person函数\r\n    }\r\n    */\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-3-strong-proto-strong-2-\"><a name=\"2.3 <strong>proto</strong> 属性(注意：左右各是2个下划线)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 <strong>proto</strong> 属性(注意：左右各是2个下划线)</h2><p>? 用构造方法创建一个新的对象之后，这个对象中默认会有一个不可访问的属性 [[prototype]] , 这个属性就指向了构造方法的原型对象。</p>\r\n<p>? 但是在个别浏览器中，也提供了对这个属性[[prototype]]的访问(chrome浏览器和火狐浏览器。ie浏览器不支持)。访问方式：p1.<strong>proto</strong></p>\r\n<p>? 但是开发者尽量不要用这种方式去访问，因为操作不慎会改变这个对象的继承原型链。</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person () {\r\n\r\n    }\r\n    //直接给Person的原型指定对象字面量。则这个对象的constructor属性不在执行Person函数\r\n    Person.prototype = {\r\n        constructor : Person,\r\n        name:&quot;志玲&quot;,\r\n        age:20\r\n    };\r\n    var p1 = new Person();\r\n\r\n    alert(p1.__proto__ === Person.prototype);   //true\r\n\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-4-hasownproperty-\"><a name=\"2.4 hasOwnProperty() 方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 hasOwnProperty() 方法</h2><p>? 大家知道，我们用去访问一个对象的属性的时候，这个属性既有可能来自对象本身，也有可能来自这个对象的[[prototype]]属性指向的原型。</p>\r\n<p>? 那么如何判断这个对象的来源呢？</p>\r\n<p>? hasOwnProperty方法，可以判断一个属性是否来自对象本身。</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person () {\r\n\r\n    }\r\n    Person.prototype.name = &quot;志玲&quot;;\r\n    var p1 = new Person();\r\n    p1.sex = &quot;女&quot;;\r\n    //sex属性是直接在p1属性中添加，所以是true\r\n    alert(&quot;sex属性是对象本身的：&quot; + p1.hasOwnProperty(&quot;sex&quot;));\r\n    // name属性是在原型中添加的，所以是false\r\n    alert(&quot;name属性是对象本身的：&quot; + p1.hasOwnProperty(&quot;name&quot;));\r\n    //  age 属性不存在，所以也是false\r\n    alert(&quot;age属性是存在于对象本身：&quot; + p1.hasOwnProperty(&quot;age&quot;));\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>所以，通过hasOwnProperty这个方法可以判断一个对象是否在对象本身添加的，但是不能判断是否存在于原型中，因为有可能这个属性不存在。</p>\r\n<p><strong>也即是说，在原型中的属性和不存在的属性都会返回fasle。</strong></p>\r\n<p><em>这个也是唯一的一个处理属性而不查找原型链的方法！</em></p>\r\n<p>如何判断一个属性是否存在于原型中呢？</p>\r\n</blockquote>\r\n<h2 id=\"h2-2-5-in-\"><a name=\"2.5 in 操作符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.5 in 操作符</h2><p>? in操作符用来判断一个属性是否存在于这个对象中。但是在查找这个属性时候，先在对象本身中找，如果对象找不到再去原型中找。换句话说，只要对象和原型中有一个地方存在这个属性，就返回true</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person () {\r\n\r\n    }\r\n    Person.prototype.name = &quot;志玲&quot;;\r\n    var p1 = new Person();\r\n    p1.sex = &quot;女&quot;;\r\n    alert(&quot;sex&quot; in p1);     // 对象本身添加的，所以true\r\n    alert(&quot;name&quot; in p1);    //原型中存在，所以true\r\n    alert(&quot;age&quot; in p1);     //对象和原型中都不存在，所以false\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>回到前面的问题，如何判断一个属性是否存在于原型中：</p>\r\n<p>如果一个属性存在，但是没有在对象本身中，则一定存在于原型中。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person () {\r\n    }\r\n    Person.prototype.name = &quot;志玲&quot;;\r\n    var p1 = new Person();\r\n    p1.sex = &quot;女&quot;;\r\n\r\n    //定义一个函数去判断原型所在的位置\r\n    function propertyLocation(obj, prop){\r\n        if(!(prop in obj)){\r\n            alert(prop + &quot;属性不存在&quot;);\r\n        }else if(obj.hasOwnProperty(prop)){\r\n            alert(prop + &quot;属性存在于对象中&quot;);\r\n        }else {\r\n            alert(prop + &quot;对象存在于原型中&quot;);\r\n        }\r\n    }\r\n    propertyLocation(p1, &quot;age&quot;);\r\n    propertyLocation(p1, &quot;name&quot;);\r\n    propertyLocation(p1, &quot;sex&quot;);\r\n&lt;/script\r\n</code></pre><h1 id=\"h1--\"><a name=\"三、组合使用原型模型和构造函数模型创建对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、组合使用原型模型和构造函数模型创建对象</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 原型模型创建对象的缺陷\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 原型模型创建对象的缺陷</h2><p>? 原型中的所有的属性都是共享的。也就是说，用同一个构造函数创建的对象去访问原型中的属性的时候，大家都是访问的同一个对象，如果一个对象对原型的属性进行了修改，则会反映到所有的对象上面。</p>\r\n<p>? 但是在实际使用中，每个对象的属性一般是不同的。张三的姓名是张三，李四的姓名是李四。</p>\r\n<p>? <strong>==但是，这个共享特性对方法(属性值是函数的属性)又是非常合适的。==</strong>所有的对象共享方法是最佳状态。这种特性在c#和<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>中是天生存在的。</p>\r\n<h2 id=\"h2-3-2-\"><a name=\"3.2 使用构造函数模型创建对象的缺陷\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 使用构造函数模型创建对象的缺陷</h2><p>? 在构造函数中添加的属性和方法，每个对象都有自己独有的一份，大家不会共享。这个特性对属性比较合适，但是对方法又不太合适。因为对所有对象来说，他们的方法应该是一份就够了，没有必要每人一份，造成内存的浪费和性能的低下。</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person() {\r\n        this.name = &quot;李四&quot;;\r\n        this.age = 20;\r\n        this.eat = function() {\r\n            alert(&quot;吃完东西&quot;);\r\n        }\r\n    }\r\n    var p1 = new Person();\r\n    var p2 = new Person();\r\n    //每个对象都会有不同的方法\r\n    alert(p1.eat === p2.eat); //fasle\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>可以使用下面的方法解决：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Person() {\r\n        this.name = &quot;李四&quot;;\r\n        this.age = 20;\r\n        this.eat = eat;\r\n    }\r\n    function eat() {\r\n        alert(&quot;吃完东西&quot;);\r\n    }\r\n    var p1 = new Person();\r\n    var p2 = new Person();\r\n    //因为eat属性都是赋值的同一个函数，所以是true\r\n    alert(p1.eat === p2.eat); //true\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>但是上面的这种解决方法具有致命的缺陷：封装性太差。使用面向对象，目的之一就是封装代码，这个时候为了性能又要把代码抽出对象之外，这是反人类的设计。</p>\r\n</blockquote>\r\n<h2 id=\"h2-3-3-\"><a name=\"3.3 使用组合模式解决上述两种缺陷\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 使用组合模式解决上述两种缺陷</h2><p>? 原型模式适合封装方法，构造方法模式适合封装属性，综合两种模式的优点就有了组合模式。</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //在构造方法内部封装属性\r\n    function Person(name, age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    //在原型对象内封装方法\r\n    Person.prototype.eat = function (food) {\r\n        alert(this.name + &quot;爱吃&quot; + food);\r\n    }\r\n    Person.prototype.play = function (playName) {\r\n        alert(this.name + &quot;爱玩&quot; + playName);\r\n    }\r\n\r\n    var p1 = new Person(&quot;李四&quot;, 20);\r\n    var p2 = new Person(&quot;张三&quot;, 30);\r\n    p1.eat(&quot;苹果&quot;);\r\n    p2.eat(&quot;香蕉&quot;);\r\n    p1.play(&quot;志玲&quot;);\r\n    p2.play(&quot;凤姐&quot;);\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"四、动态原型模式创建对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、动态原型模式创建对象</h1><p>? 前面讲到的组合模式，也并非完美无缺，有一点也是感觉不是很完美。把构造方法和原型分开写，总让人感觉不舒服，应该想办法把构造方法和原型封装在一起，所以就有了动态原型模式。</p>\r\n<p>? 动态原型模式把所有的属性和方法都封装在构造方法中，而仅仅在需要的时候才去在构造方法中初始化原型，又保持了同时使用构造函数和原型的优点。</p>\r\n<blockquote>\r\n<p>看下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //构造方法内部封装属性\r\n    function Person(name, age) {\r\n        //每个对象都添加自己的属性\r\n        this.name = name;\r\n        this.age = age;\r\n        /*\r\n            判断this.eat这个属性是不是function，如果不是function则证明是第一次创建对象，\r\n            则把这个funcion添加到原型中。\r\n            如果是function，则代表原型中已经有了这个方法，则不需要再添加。\r\n            perfect！完美解决了性能和代码的封装问题。\r\n        */\r\n        if(typeof this.eat !== &quot;function&quot;){\r\n            Person.prototype.eat = function () {\r\n                alert(this.name + &quot; 在吃&quot;);\r\n            }\r\n        }\r\n    }\r\n    var p1 = new Person(&quot;志玲&quot;, 40);\r\n    p1.eat();   \r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ul>\r\n<li>组合模式和动态原型模式是JavaScript中使用比较多的两种创建对象的方式。</li><li>建议以后使用动态原型模式。他解决了组合模式的封装不彻底的缺点。</li></ul>\r\n', '89', '\r\n# 一、什么是原型\r\n\r\n> 原型是[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")中的继承的继承，JavaScript的继承就是基于原型的继承。\r\n\r\n## 1.1 函数的原型对象\r\n\r\n? 在JavaScript中，我们创建一个函数A(**就是声明一个函数**), 那么浏览器就会在内存中创建一个对象B，而且每个函数都默认会有一个属性 **prototype** 指向了这个对象( 即：**prototype的属性的值是这个对象** )。这个对象B就是函数A的原型对象，简称函数的原型。这个原型对象B 默认会有一个属性 **constructor** 指向了这个函数A ( 意思就是说：constructor属性的值是函数A )。\r\n\r\n? 看下面的代码：\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        /*\r\n            声明一个函数，则这个函数默认会有一个属性叫 prototype 。而且浏览器会自动按照一定的规则\r\n            创建一个对象，这个对象就是这个函数的原型对象，prototype属性指向这个原型对象。这个原型对象\r\n            有一个属性叫constructor 指向了这个函数\r\n\r\n            注意：原型对象默认只有属性：constructor。其他都是从Object继承而来，暂且不用考虑。\r\n        */\r\n        function Person () {\r\n\r\n        }       \r\n    </script>\r\n</body>\r\n```\r\n\r\n> 下面的图描述了声明一个函数之后发生的事情：\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/43031030.jpg)\r\n\r\n## 1.2 使用构造函数创建对象\r\n\r\n? 当把一个函数作为构造函数 (理论上任何函数都可以作为构造函数) 使用new创建对象的时候，那么这个对象就会存在一个默认的不可见的属性，来指向了构造函数的原型对象。 **这个不可见的属性我们一般用 [[prototype]] 来表示，只是这个属性没有办法直接访问到。**\r\n\r\n? 看下面的代码：\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        function Person () {\r\n\r\n        }   \r\n        /*\r\n            利用构造函数创建一个对象，则这个对象会自动添加一个不可见的属性 [[prototype]], 而且这个属性\r\n            指向了构造函数的原型对象。\r\n        */\r\n        var p1 = new Person();\r\n    </script>\r\n</body>\r\n```\r\n\r\n> 观察下面的示意图：\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/6663492.jpg)\r\n\r\n> 说明：\r\n\r\n1.  从上面的图示中可以看到，创建p1对象虽然使用的是Person构造函数，但是对象创建出来之后，这个p1对象其实已经与Person构造函数没有任何关系了，p1对象的[[ prototype ]]属性指向的是Person构造函数的原型对象。\r\n2.  如果使用new Person()创建多个对象，则多个对象都会同时指向Person构造函数的原型对象。\r\n3.  我们可以手动给这个原型对象添加属性和方法，那么p1,p2,p3…这些对象就会共享这些在原型中添加的属性和方法。\r\n4.  如果我们访问p1中的一个属性name，如果在p1对象中找到，则直接返回。如果p1对象中没有找到，则直接去p1对象的[[prototype]]属性指向的原型对象中查找，如果查找到则返回。(如果原型中也没有找到，则继续向上找原型的原型—原型链。 后面再讲)。\r\n5.  如果通过p1对象添加了一个属性name，则对p1对象来说就屏蔽了原型中的属性name。 换句话说：在p1中就没有办法访问到原型的属性name了。\r\n6.  通过p1对象只能读取原型中的属性name的值，而不能修改原型中的属性name的值。 p1.name = “李四”; 并不是修改了原型中的值，而是在p1对象中给添加了一个属性name。\r\n\r\n> 看下面的代码：\r\n\r\n```\r\n<body>\r\n    <script type=\"text/javascript\">\r\n        function Person () {        \r\n        }\r\n        // 可以使用Person.prototype 直接访问到原型对象\r\n        //给Person函数的原型对象中添加一个属性 name并且值是 \"张三\"\r\n        Person.prototype.name = \"张三\";\r\n        Person.prototype.age = 20;\r\n\r\n        var p1 = new Person();\r\n        /*\r\n            访问p1对象的属性name，虽然在p1对象中我们并没有明确的添加属性name，但是\r\n            p1的 [[prototype]] 属性指向的原型中有name属性，所以这个地方可以访问到属性name\r\n            就值。\r\n            注意：这个时候不能通过p1对象删除name属性，因为只能删除在p1中删除的对象。\r\n        */\r\n        alert(p1.name);  // 张三\r\n\r\n        var p2 = new Person();\r\n        alert(p2.name);  // 张三  都是从原型中找到的，所以一样。\r\n\r\n        alert(p1.name === p2.name);  // true\r\n\r\n        // 由于不能修改原型中的值，则这种方法就直接在p1中添加了一个新的属性name，然后在p1中无法再访问到\r\n        //原型中的属性。\r\n        p1.name = \"李四\";\r\n        alert(\"p1：\" + p1.name);\r\n        // 由于p2中没有name属性，则对p2来说仍然是访问的原型中的属性。    \r\n        alert(\"p2:\" + p2.name);  // 张三  \r\n    </script>\r\n</body>\r\n```\r\n\r\n![](http://o7cqr8cfk.bkt.clouddn.com/public/16-11-10/45010346.jpg)\r\n\r\n# 二、与原型有关的几个属性和方法\r\n\r\n## 2.1 prototype属性\r\n\r\n? prototype 存在于构造函数中 (其实任意函数中都有，只不过不是构造函数的时候prototype我们不关注而已) ，他指向了这个构造函数的原型对象。\r\n\r\n? 参考前面的示意图。\r\n\r\n## 2.2 constructor属性\r\n\r\n? constructor属性存在于原型对象中，他指向了构造函数\r\n\r\n看下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person () {\r\n    }\r\n    alert(Person.prototype.constructor === Person); // true\r\n    var p1 = new Person();\r\n    //使用instanceof 操作符可以判断一个对象的类型。  \r\n    //typeof一般用来获取简单类型和函数。而引用类型一般使用instanceof，因为引用类型用typeof 总是返回objece。\r\n    alert(p1 instanceof Person);    // true\r\n    alert(typeof p1); // object\r\n</script>\r\n```\r\n\r\n> 我们根据需要，可以为Person.prototype 属性指定新的对象，来作为Person的原型对象。\r\n> \r\n> 但是这个时候有个问题，新的对象的constructor属性则不再指向Person构造函数了。\r\n\r\n看下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person () {\r\n\r\n    }\r\n    //直接给Person的原型指定对象字面量。则这个对象的constructor属性不在执行Person函数\r\n    Person.prototype = {\r\n        name:\"志玲\",\r\n        age:20\r\n    };\r\n    var p1 = new Person();\r\n    alert(p1.name);  // 志玲\r\n    // p1的类型仍然是Person\r\n    alert(p1 instanceof Person); // true\r\n    //constructor不再执行Peson函数\r\n    alert(Person.prototype.constructor === Person); //false\r\n    //如果constructor对你很重要，你应该在Person.prototype中添加一行这样的代码：\r\n    /*\r\n    Person.prototype = {\r\n        constructor : Person    //让constructor重新指向Person函数\r\n    }\r\n    */\r\n</script>\r\n```\r\n\r\n## 2.3 __proto__ 属性(注意：左右各是2个下划线)\r\n\r\n? 用构造方法创建一个新的对象之后，这个对象中默认会有一个不可访问的属性 [[prototype]] , 这个属性就指向了构造方法的原型对象。\r\n\r\n? 但是在个别浏览器中，也提供了对这个属性[[prototype]]的访问(chrome浏览器和火狐浏览器。ie浏览器不支持)。访问方式：p1.__proto__\r\n\r\n? 但是开发者尽量不要用这种方式去访问，因为操作不慎会改变这个对象的继承原型链。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person () {\r\n\r\n    }\r\n    //直接给Person的原型指定对象字面量。则这个对象的constructor属性不在执行Person函数\r\n    Person.prototype = {\r\n        constructor : Person,\r\n        name:\"志玲\",\r\n        age:20\r\n    };\r\n    var p1 = new Person();\r\n\r\n    alert(p1.__proto__ === Person.prototype);   //true\r\n\r\n</script>\r\n```\r\n\r\n## 2.4 hasOwnProperty() 方法\r\n\r\n? 大家知道，我们用去访问一个对象的属性的时候，这个属性既有可能来自对象本身，也有可能来自这个对象的[[prototype]]属性指向的原型。\r\n\r\n? 那么如何判断这个对象的来源呢？\r\n\r\n? hasOwnProperty方法，可以判断一个属性是否来自对象本身。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person () {\r\n\r\n    }\r\n    Person.prototype.name = \"志玲\";\r\n    var p1 = new Person();\r\n    p1.sex = \"女\";\r\n    //sex属性是直接在p1属性中添加，所以是true\r\n    alert(\"sex属性是对象本身的：\" + p1.hasOwnProperty(\"sex\"));\r\n    // name属性是在原型中添加的，所以是false\r\n    alert(\"name属性是对象本身的：\" + p1.hasOwnProperty(\"name\"));\r\n    //  age 属性不存在，所以也是false\r\n    alert(\"age属性是存在于对象本身：\" + p1.hasOwnProperty(\"age\"));\r\n\r\n</script>\r\n```\r\n\r\n> 所以，通过hasOwnProperty这个方法可以判断一个对象是否在对象本身添加的，但是不能判断是否存在于原型中，因为有可能这个属性不存在。\r\n> \r\n> **也即是说，在原型中的属性和不存在的属性都会返回fasle。**\r\n> \r\n> _这个也是唯一的一个处理属性而不查找原型链的方法！_\r\n> \r\n> 如何判断一个属性是否存在于原型中呢？\r\n\r\n## 2.5 in 操作符\r\n\r\n? in操作符用来判断一个属性是否存在于这个对象中。但是在查找这个属性时候，先在对象本身中找，如果对象找不到再去原型中找。换句话说，只要对象和原型中有一个地方存在这个属性，就返回true\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person () {\r\n\r\n    }\r\n    Person.prototype.name = \"志玲\";\r\n    var p1 = new Person();\r\n    p1.sex = \"女\";\r\n    alert(\"sex\" in p1);     // 对象本身添加的，所以true\r\n    alert(\"name\" in p1);    //原型中存在，所以true\r\n    alert(\"age\" in p1);     //对象和原型中都不存在，所以false\r\n\r\n</script>\r\n```\r\n\r\n> 回到前面的问题，如何判断一个属性是否存在于原型中：\r\n> \r\n> 如果一个属性存在，但是没有在对象本身中，则一定存在于原型中。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person () {\r\n    }\r\n    Person.prototype.name = \"志玲\";\r\n    var p1 = new Person();\r\n    p1.sex = \"女\";\r\n\r\n    //定义一个函数去判断原型所在的位置\r\n    function propertyLocation(obj, prop){\r\n        if(!(prop in obj)){\r\n            alert(prop + \"属性不存在\");\r\n        }else if(obj.hasOwnProperty(prop)){\r\n            alert(prop + \"属性存在于对象中\");\r\n        }else {\r\n            alert(prop + \"对象存在于原型中\");\r\n        }\r\n    }\r\n    propertyLocation(p1, \"age\");\r\n    propertyLocation(p1, \"name\");\r\n    propertyLocation(p1, \"sex\");\r\n</script\r\n```\r\n\r\n# 三、组合使用原型模型和构造函数模型创建对象\r\n\r\n## 3.1 原型模型创建对象的缺陷\r\n\r\n? 原型中的所有的属性都是共享的。也就是说，用同一个构造函数创建的对象去访问原型中的属性的时候，大家都是访问的同一个对象，如果一个对象对原型的属性进行了修改，则会反映到所有的对象上面。\r\n\r\n? 但是在实际使用中，每个对象的属性一般是不同的。张三的姓名是张三，李四的姓名是李四。\r\n\r\n? **==但是，这个共享特性对方法(属性值是函数的属性)又是非常合适的。==**所有的对象共享方法是最佳状态。这种特性在c#和[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")中是天生存在的。\r\n\r\n## 3.2 使用构造函数模型创建对象的缺陷\r\n\r\n? 在构造函数中添加的属性和方法，每个对象都有自己独有的一份，大家不会共享。这个特性对属性比较合适，但是对方法又不太合适。因为对所有对象来说，他们的方法应该是一份就够了，没有必要每人一份，造成内存的浪费和性能的低下。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person() {\r\n        this.name = \"李四\";\r\n        this.age = 20;\r\n        this.eat = function() {\r\n            alert(\"吃完东西\");\r\n        }\r\n    }\r\n    var p1 = new Person();\r\n    var p2 = new Person();\r\n    //每个对象都会有不同的方法\r\n    alert(p1.eat === p2.eat); //fasle\r\n</script>\r\n```\r\n\r\n> 可以使用下面的方法解决：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Person() {\r\n        this.name = \"李四\";\r\n        this.age = 20;\r\n        this.eat = eat;\r\n    }\r\n    function eat() {\r\n        alert(\"吃完东西\");\r\n    }\r\n    var p1 = new Person();\r\n    var p2 = new Person();\r\n    //因为eat属性都是赋值的同一个函数，所以是true\r\n    alert(p1.eat === p2.eat); //true\r\n</script>\r\n```\r\n\r\n> 但是上面的这种解决方法具有致命的缺陷：封装性太差。使用面向对象，目的之一就是封装代码，这个时候为了性能又要把代码抽出对象之外，这是反人类的设计。\r\n\r\n## 3.3 使用组合模式解决上述两种缺陷\r\n\r\n? 原型模式适合封装方法，构造方法模式适合封装属性，综合两种模式的优点就有了组合模式。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //在构造方法内部封装属性\r\n    function Person(name, age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    //在原型对象内封装方法\r\n    Person.prototype.eat = function (food) {\r\n        alert(this.name + \"爱吃\" + food);\r\n    }\r\n    Person.prototype.play = function (playName) {\r\n        alert(this.name + \"爱玩\" + playName);\r\n    }\r\n\r\n    var p1 = new Person(\"李四\", 20);\r\n    var p2 = new Person(\"张三\", 30);\r\n    p1.eat(\"苹果\");\r\n    p2.eat(\"香蕉\");\r\n    p1.play(\"志玲\");\r\n    p2.play(\"凤姐\");\r\n</script>\r\n```\r\n\r\n# 四、动态原型模式创建对象\r\n\r\n? 前面讲到的组合模式，也并非完美无缺，有一点也是感觉不是很完美。把构造方法和原型分开写，总让人感觉不舒服，应该想办法把构造方法和原型封装在一起，所以就有了动态原型模式。\r\n\r\n? 动态原型模式把所有的属性和方法都封装在构造方法中，而仅仅在需要的时候才去在构造方法中初始化原型，又保持了同时使用构造函数和原型的优点。\r\n\r\n> 看下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //构造方法内部封装属性\r\n    function Person(name, age) {\r\n        //每个对象都添加自己的属性\r\n        this.name = name;\r\n        this.age = age;\r\n        /*\r\n            判断this.eat这个属性是不是function，如果不是function则证明是第一次创建对象，\r\n            则把这个funcion添加到原型中。\r\n            如果是function，则代表原型中已经有了这个方法，则不需要再添加。\r\n            perfect！完美解决了性能和代码的封装问题。\r\n        */\r\n        if(typeof this.eat !== \"function\"){\r\n            Person.prototype.eat = function () {\r\n                alert(this.name + \" 在吃\");\r\n            }\r\n        }\r\n    }\r\n    var p1 = new Person(\"志玲\", 40);\r\n    p1.eat();   \r\n</script>\r\n```\r\n\r\n> 说明：\r\n\r\n*   组合模式和动态原型模式是JavaScript中使用比较多的两种创建对象的方式。\r\n*   建议以后使用动态原型模式。他解决了组合模式的封装不彻底的缺点。\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('64', 'ES2015新特性', '<h1 id=\"h1-es6-\"><a name=\"ES6 新特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ES6 新特性</h1><h1 id=\"h1--es6-\"><a name=\"一、ES6简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、ES6简介</h1><p>? 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以<strong>新语法</strong>、<strong>新特性</strong>的优越性吸引著众多 <a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a> 开发者，驱使他们积极尝鲜。</p>\r\n<p>? 由于ES6是在2015年发布的，所以也叫ES2015。</p>\r\n<p>? 以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….</p>\r\n<blockquote>\r\n<p>下面开始介绍ES6常用的一些新特性：</p>\r\n</blockquote>\r\n<h1 id=\"h1--\"><a name=\"二、块级作用域绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、块级作用域绑定</h1><blockquote>\r\n<p>在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。</p>\r\n</blockquote>\r\n<p>块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：</p>\r\n<ul>\r\n<li>函数内部</li><li>在代码块（即 { }）内部</li></ul>\r\n<p>块级作用域是很多类<a href=\"http://lib.csdn.net/base/c\" title=\"C语言知识库\">C语言</a>的工作机制，ECMAScript 6 引入块级声明的目的是增强 JavaScript 的灵活性，同时又能与其它编程语言保持一致。</p>\r\n<h2 id=\"h2-2-1-let-\"><a name=\"2.1 let声明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 let声明</h2><blockquote>\r\n<p>使用let声明变量的语法和使用var声明的语法是一样的。<strong>但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别</strong>。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let a = 10;\r\n    if(a &gt; 5){\r\n        console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）\r\n        let b = 20;\r\n        console.log(b);\r\n    }\r\n    console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错）\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ol>\r\n<li>用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问</li><li>用let声明的变量也没有声明提前这一特性。</li><li>在同一个块中，let声明的变量也不能重复声明。</li><li>在声明变量的时候尽量使用let，慢慢的抛弃var</li></ol>\r\n<h2 id=\"h2-2-2-const-constant-declarations-\"><a name=\"2.2 const声明(Constant Declarations)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 const声明(Constant Declarations)</h2><blockquote>\r\n<p>在 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var a = 20;\r\n    if (true) {\r\n        const b = 20;\r\n        b = 30;  //错误! 常量不能重新赋值\r\n        const c; //错误！ 常量声明的同时必须赋值。\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ol>\r\n<li>const的特性除了声明的是常量为，其他与let一样。</li><li>在let和const声明前的这段区域称之为暂存性死区（<strong>The Temporal Dead Zone</strong> —TDZ)。</li><li>使用let和const声明的变量和常量不再是window的属性。 也就是说通过window.a是无法访问到的。</li></ol>\r\n<h2 id=\"h2-2-3-\"><a name=\"2.3 循环中的块级绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 循环中的块级绑定</h2><blockquote>\r\n<p>使用var声明的循环变量在循环结束后仍然可以访问到。 使用let声明的循环变量，在循环结束之后会立即销毁。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    for(let i = 0; i &lt; 3; i++){ // 循环结束之后会立即销毁 i\r\n        console.log(i);\r\n    }\r\n    console.log(i);  //此处无法访问到 i 。\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-2-4-\"><a name=\"2.4 循环中的函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.4 循环中的函数</h2><blockquote>\r\n<p>看下面的代码，是输出10个10，而不是0，1，2，…</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var funcs = [];\r\n    for (var i = 0; i &lt; 10; i++) {\r\n        funcs.push(function () {\r\n            console.log(i);\r\n        });\r\n    }\r\n    funcs.forEach(function (func) {\r\n        func();     // 输出 &quot;10&quot; 共10次\r\n    });\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>解决办法需要使用函数的自执行特性。</p>\r\n</blockquote>\r\n<pre><code>var funcs = [];\r\nfor (var i = 0; i &lt; 10; i++) {\r\n    funcs.push((function(value) {\r\n        return function() {\r\n            console.log(value);\r\n        }\r\n    }(i)));\r\n}\r\nfuncs.forEach(function(func) {\r\n    func();     // 输出 0，1，2 ... 9\r\n});\r\n</code></pre><p><strong>如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用</strong></p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var funcs = [];\r\n    for (let i = 0; i &lt; 10; i++) {\r\n        funcs.push(function () {\r\n            console.log(i);\r\n        });\r\n    }\r\n    funcs.forEach(function (func) {\r\n        func();     // 输出 0，1，2 ... 9\r\n    })\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。</li></ol>\r\n<h1 id=\"h1--\"><a name=\"三、函数的新增特性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三、函数的新增特性</h1><h2 id=\"h2-3-1-\"><a name=\"3.1 带默认参数的函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 带默认参数的函数</h2><blockquote>\r\n<p>JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。</p>\r\n</blockquote>\r\n<pre><code>function makeRequest(url, timeout, callback) {\r\n    timeout = timeout || 2000;\r\n    callback = callback || function() {};\r\n}\r\n</code></pre><p>其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.</p>\r\n<blockquote>\r\n<p>ES6从语言层面面上增加了 <strong>默认值的</strong> 支持。看下面的代码：</p>\r\n</blockquote>\r\n<pre><code>//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。\r\nfunction makeRequest(url, timeout = 2000, callback = function() {}) {\r\n\r\n    // 其余代码\r\n\r\n}\r\n</code></pre><h2 id=\"h2-3-2-arguments-\"><a name=\"3.2 默认参数对 arguments 对象的影响\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 默认参数对 arguments 对象的影响</h2><blockquote>\r\n<p>在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function foo(a, b) {\r\n        //非严格模式\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n        a = 10;\r\n        b = 20;\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n    }\r\n    foo(1, 2);\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p><strong>在ES5的严格模式下</strong>，arguments只反映参数的初始值，而不再反映命名参数的变化！</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n\r\n    function foo(a, b) {\r\n        //严格模式\r\n        &quot;use strict&quot;\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n        a = 10;\r\n        b = 20;\r\n        console.log(arguments[0] === a); //false。  修改a的值不会影响到arguments[0]的值\r\n        console.log(arguments[1] === b); //false\r\n    }\r\n    foo(1, 2);\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n\r\n    function foo(a, b = 30) {\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n        a = 10;\r\n        b = 20;\r\n        console.log(arguments[0]  === a); //false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。\r\n        console.log(arguments[1] === b); //false。  b使用了默认值，所以表现的和严格模式一样。\r\n    }\r\n    foo(1, 2);\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。</p>\r\n</blockquote>\r\n<h2 id=\"h2-3-3-strong-default-parameter-expressions-strong-\"><a name=\"3.3 默认参数表达式 (<strong>Default Parameter Expressions</strong>)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.3 默认参数表达式 (<strong>Default Parameter Expressions</strong>)</h2><blockquote>\r\n<p>参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function getValue() {\r\n        return 5;\r\n    }\r\n\r\n    function add(first, second = getValue()) { //表示使用getValue这个函数的返回值作为second的默认值。\r\n        return first + second;\r\n    }\r\n\r\n    console.log(add(1, 1));     // 2\\.  调用add函数的时候，传入了第二个参数，则以传入的参数为准。\r\n    console.log(add(1));        // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let value = 5;\r\n    function getValue() {\r\n        return value++;\r\n    }\r\n\r\n    function add(first, second = getValue()) {  //\r\n        return first + second;\r\n    }\r\n\r\n    console.log(add(1, 1));     // 2\r\n    console.log(add(1));        // 6。 \r\n    console.log(add(1));        // 7\r\n    console.log(add(1));        // 8\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。</p>\r\n</blockquote>\r\n<pre><code>function add(first, second = first) {  // 使用第一个参数作为第二个参数的默认值\r\n        return first + second;\r\n }\r\n</code></pre><blockquote>\r\n<p>注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。</p>\r\n</blockquote>\r\n<pre><code>function add(first = second, second)) {  // 这种写法是错误的\r\n\r\n        return first + second;\r\n}\r\n</code></pre><h2 id=\"h2-3-4-\"><a name=\"3.4 未命名参数问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.4 未命名参数问题</h2><blockquote>\r\n<p>Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function foo(a) {\r\n        console.log(a);\r\n        console.log(arguments[1])  //取得传入的多余的参数。\r\n    }\r\n    foo(2, 3);\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>ES6，提供了一种更加优雅处理未命名参数的问题：<strong>剩余参数</strong>( <strong>Rest Parameters</strong> )</p>\r\n<p>语法：function a(a, … b){ }</p>\r\n<p>剩余参数使用三个点( … )和变量名来表示。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function foo(a, ...b) {\r\n        console.log(a);\r\n        console.log(b instanceof Array);  //true  .多余的参数都被放入了b中。b其实就是一个数组。\r\n    }\r\n    foo(2, 3, 4, 6);\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ol>\r\n<li>函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。</li><li>虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。</li><li>剩余参数是在函数声明的时候出现的。</li></ol>\r\n<h2 id=\"h2-3-5-\"><a name=\"3.5 函数中的扩展运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.5 函数中的扩展运算符</h2><blockquote>\r\n<p>例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用applay方法。</p>\r\n<p>看下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let values = [25, 50, 75, 100]  \r\n    console.log(Math.max.apply(Math, values));  // 100\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>上面这种方法虽然可行，但是总是不是那么直观。</p>\r\n<p>使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let values = [25, 50, 75, 100]\r\n    console.log(Math.max(...values));  //使用扩展运算符。相当于拆解了数组了。\r\n    console.log(Math.max(...values, 200));  //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p><strong>注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。</strong></p>\r\n<ol>\r\n<li><em>**</em>剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面</li><li>扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。</li></ol>\r\n</blockquote>\r\n<h1 id=\"h1--gt-\"><a name=\"四、全新的函数：箭头函数（=&gt;）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、全新的函数：箭头函数（=&gt;）</h1><blockquote>\r\n<p>ECMAScript 6 最有意思的部分之一就是箭头函数。正如其名，箭头函数由 “箭头”（=&gt;）这种新的语法来定义。</p>\r\n<p>其实在别的语言中早就有了这种语法结构，不过他们叫拉姆达表达式。</p>\r\n</blockquote>\r\n<h2 id=\"h2-4-1-\"><a name=\"4.1 箭头函数语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 箭头函数语法</h2><blockquote>\r\n<p>基本语法如下：</p>\r\n</blockquote>\r\n<pre><code>(形参列表)=&gt;{\r\n  //函数体\r\n}\r\n</code></pre><hr>\r\n<blockquote>\r\n<p>箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。</p>\r\n</blockquote>\r\n<ul>\r\n<li>示例1：</li></ul>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var sum = (num1, num2) =&gt;{\r\n        return num1 + num2;\r\n    }\r\n    console.log(sum(3, 4));\r\n    //前面的箭头函数等同于下面的传统函数\r\n    var add = function (num1, num2) {\r\n        return num1 + num2;\r\n    }\r\n    console.log(add(2, 4))\r\n&lt;/script&gt;\r\n</code></pre><hr>\r\n<blockquote>\r\n<p>如果函数体内只有一行代码，则包裹函数体的 <strong>大括号</strong> ({ })完全可以省略。如果有return，return关键字也可以省略。</p>\r\n<p>如果函数体内有多条语句，则 {} 不能省略。</p>\r\n</blockquote>\r\n<ul>\r\n<li>示例2：</li></ul>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var sum = (num1, num2) =&gt; num1 + num2;\r\n    console.log(sum(5, 4));\r\n    //前面的箭头函数等同于下面的传统函数\r\n    var add = function (num1, num2) {\r\n        return num1 + num2;\r\n    }\r\n    console.log(add(2, 4));\r\n\r\n    //如果这一行代码是没有返回值的，则方法的返回自也是undefined\r\n    var foo = (num1, num2) =&gt; console.log(&quot;aaa&quot;);\r\n    console.log(foo(3,4));  //这个地方的返回值就是undefined\r\n&lt;/script&gt;\r\n</code></pre><hr>\r\n<blockquote>\r\n<p>如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。<strong>当然如果不传入参数也不可以省略</strong></p>\r\n</blockquote>\r\n<ul>\r\n<li>示例3：</li></ul>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var foo = a=&gt; a+3; //因为只有一个参数，所以()可以省略\r\n    console.log(foo(4)); // 7\r\n&lt;/script&gt;\r\n</code></pre><hr>\r\n<blockquote>\r\n<p>如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个<strong>小括号 ()</strong></p>\r\n</blockquote>\r\n<ul>\r\n<li>示例4：</li></ul>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var foo = ()=&gt;({name:&quot;lisi&quot;, age:30});\r\n    console.log(foo());\r\n    //等同于下面的；\r\n    var foo1 = ()=&gt;{\r\n        return {\r\n            name:&quot;lisi&quot;,\r\n            age : 30\r\n        };\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-2-\"><a name=\"4.2 使用箭头函数实现函数自执行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 使用箭头函数实现函数自执行</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var person = (name =&gt; {\r\n            return {\r\n                name: name,\r\n                age: 30\r\n            }\r\n        }\r\n    )(&quot;zs&quot;);\r\n    console.log(person);\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-4-3-this-no-this-binding-\"><a name=\"4.3 箭头函数中无this绑定(No this Binding)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 箭头函数中无this绑定(No this Binding)</h2><blockquote>\r\n<p>在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。</p>\r\n<p><strong>在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式</strong></p>\r\n<p>箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。<strong>如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var PageHandler = {\r\n        id: &quot;123456&quot;,\r\n        init: function () {\r\n            document.addEventListener(&quot;click&quot;,\r\n                event =&gt; this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。\r\n        },\r\n\r\n        doSomething: function (type) {\r\n            console.log(&quot;Handling &quot; + type + &quot; for &quot; + this.id);\r\n        }\r\n    };\r\n    PageHandler.init();\r\n&lt;/script&gt;\r\n</code></pre><p>看下面的一段代码：</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n\r\n    var p = {\r\n        foo:()=&gt;console.log(this)   //此处this为window\r\n    }\r\n    p.foo();  //输出为 window对象。   并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。\r\n//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。</li><li>由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。</li></ol>\r\n<h2 id=\"h2-4-4-arguments-\"><a name=\"4.4 无arguments绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.4 无arguments绑定</h2><blockquote>\r\n<p>虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function foo() {\r\n        //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。\r\n        return ()=&gt;arguments[0]; //箭头函数的返回值是foo函数的第一个参数\r\n    }\r\n    var arrow = foo(4, 5);\r\n    console.log(arrow()); // 4\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"五、对象功能的扩展\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>五、对象功能的扩展</h1><blockquote>\r\n<p>在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。</p>\r\n<p><strong>ECMAScript 6 给对象的各个方面，从简单的语法扩展到操作与交互，都做了改进。</strong></p>\r\n</blockquote>\r\n<h2 id=\"h2-5-1-\"><a name=\"5.1 对象类别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 对象类别</h2><blockquote>\r\n<p>ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括：</p>\r\n</blockquote>\r\n<ul>\r\n<li>普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。</li><li>特异对象（exotic object）的某些内部行为和默认的有所差异。</li><li>标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。</li><li>内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。</li></ul>\r\n<h2 id=\"h2-5-2-\"><a name=\"5.2 对象字面量的语法扩展\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 对象字面量的语法扩展</h2><h3 id=\"h3-5-2-1-\"><a name=\"5.2.1 简写的属性初始化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2.1 简写的属性初始化</h3><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function createPerson(name, age) {\r\n        //返回一个对象：属性名和参数名相同。\r\n        return {\r\n            name:name,\r\n            age:age\r\n        }\r\n    }\r\n    console.log(createPerson(&quot;lisi&quot;, 30)); // {name:&quot;lisi&quot;, age:30}\r\n    //在ES6中，上面的写法可以简化成如下形式\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p><strong>在ES6中，上面的写法可以简化成如下的形式：</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function createPerson(name, age) {\r\n        //返回一个对象：属性名和参数名相同。\r\n        return {\r\n            name,  //当对象属性名和本地变量名相同时，可以省略冒号和值\r\n            age\r\n        }\r\n    }\r\n    console.log(createPerson(&quot;lisi&quot;, 30)); // {name:&quot;lisi&quot;, age:30}\r\n&lt;/script&gt;\r\n</code></pre><p><em>当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。</em></p>\r\n<p><em>该项扩展使得对象字面量的初始化变得简明的同时也消除了命名错误。对象属性被同名变量赋值在 JavaScript 中是一种普遍的编程模式，所以这项扩展的添加非常受欢迎。</em></p>\r\n<h3 id=\"h3-5-2-2-\"><a name=\"5.2.2 简写的方法声明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2.2 简写的方法声明</h3><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var person = {\r\n        name:&#39;lisi&#39;,\r\n        sayHell:function () {\r\n            console.log(&quot;我的名字是：&quot; + this.name);\r\n        }\r\n    }\r\n    person.sayHell()\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>在ES6中，上面的写法可以简化成如下的形式：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var person = {\r\n        name:&#39;李四&#39;,\r\n        sayHell() {\r\n            console.log(&quot;我的名字是：&quot; + this.name);\r\n        }\r\n    }\r\n    person.sayHell()\r\n&lt;/script&gt;\r\n</code></pre><p><em>省略了冒号和function看起来更简洁</em></p>\r\n<h3 id=\"h3-5-2-3-\"><a name=\"5.2.3 在字面量中动态计算属性名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2.3 在字面量中动态计算属性名</h3><blockquote>\r\n<p>在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 <strong>在字面量中</strong> 是无法使用的。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var p = {\r\n        name : &#39;李四&#39;,\r\n        age : 20\r\n    }\r\n    var attName = &#39;name&#39;;\r\n    console.log(p[attName]) //这里 attName表示的是一个变量名。\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>而下面的方式使用时没有办法访问到attName这个变量的。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var attName = &#39;name&#39;;\r\n    var p = {\r\n        attName : &#39;李四&#39;,  // 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。\r\n        age : 20\r\n    }\r\n    console.log(p[attName])  // undefined\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var attName = &#39;name&#39;;\r\n    var p = {\r\n        [attName] : &#39;李四&#39;,  // 引用了变量attName。相当于添加了一个属性名为name的属性\r\n        age : 20\r\n    }\r\n    console.log(p[attName])  // 李四\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-5-3-\"><a name=\"5.3 新增的方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 新增的方法</h2><blockquote>\r\n<p>ECMAScript 从第五版开始避免在 Object.prototype 上添加新的全局函数或方法，转而去考虑具体的对象类型如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。</p>\r\n<p>ECMAScript 6 在全局 Object 上添加了几个新的方法来轻松地完成一些特定任务。</p>\r\n</blockquote>\r\n<h3 id=\"h3-5-3-1-object-is-\"><a name=\"5.3.1 Object.is()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.1 Object.is()</h3><blockquote>\r\n<p>在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（==）或严格比较操作符（===）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。</p>\r\n<p>ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示：</p>\r\n</blockquote>\r\n<pre><code>console.log(+0 == -0);              // true\r\nconsole.log(+0 === -0);             // true\r\nconsole.log(Object.is(+0, -0));     // false\r\n\r\nconsole.log(NaN == NaN);            // false\r\nconsole.log(NaN === NaN);           // false\r\nconsole.log(Object.is(NaN, NaN));   // true\r\n\r\nconsole.log(5 == 5);                // true\r\nconsole.log(5 == &quot;5&quot;);              // true\r\nconsole.log(5 === 5);               // true\r\nconsole.log(5 === &quot;5&quot;);             // false\r\nconsole.log(Object.is(5, 5));       // true\r\nconsole.log(Object.is(5, &quot;5&quot;));     // false\r\n</code></pre><p><em>很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 <strong>认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的</strong>。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况。</em></p>\r\n<h3 id=\"h3-5-3-2-object-assign-\"><a name=\"5.3.2 Object.assign()\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3.2 Object.assign()</h3><blockquote>\r\n<p>使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。</p>\r\n<p>assing可以把一个对象的属性和访问完整的转copy到另外一个对象中。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var p = {\r\n        name : &quot;lisi&quot;,\r\n        age : 20,\r\n        friends : [&#39;张三&#39;, &#39;李四&#39;]\r\n    }\r\n    var p1 = {};\r\n    Object.assign(p1, p); //则p1中就有了与p相同的属性和方法.  p1是接受者，p是提供者\r\n    console.log(p1);\r\n    //这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）\r\n    console.log(p1.friends == p.friends);  //true   p1和p的friends同事指向了同一个数组。\r\n    p.friends.push(&quot;王五&quot;);\r\n    console.log(p1.friends); //[&#39;张三&#39;, &#39;李四&#39;, &#39;王五&#39;]\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>assign方法可以接受任意多的提供者。意味着后面提供者的同名属性和覆盖前面提供者的属性值。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var p = {\r\n        name : &quot;lisi&quot;,\r\n        age : 20,\r\n        friends : [&#39;张三&#39;, &#39;李四&#39;]\r\n    }\r\n    var p1 = {\r\n        name : &#39;zs&#39;,\r\n    }\r\n    var p2 = {};\r\n    Object.assign(p2, p, p1); //p和p1都是提供者\r\n    console.log(p2.name); // zs\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--\"><a name=\"六、字符串功能的增强\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>六、字符串功能的增强</h1><h2 id=\"h2-6-1-\"><a name=\"6.1 查找子字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1 查找子字符串</h2><blockquote>\r\n<p>在以前在字符串中查找字符串的时候，都是使用indexOf方法。</p>\r\n<p>ES6新增了三个方法来查找字符串。</p>\r\n</blockquote>\r\n<ul>\r\n<li>includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。</li><li>startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。</li><li>endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。</li></ul>\r\n<blockquote>\r\n<p>每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 将字符串的长度与参数值相减并将得到的值作为检索的起始点。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示：</p>\r\n</blockquote>\r\n<pre><code>var msg = &quot;Hello world!&quot;;\r\n\r\nconsole.log(msg.startsWith(&quot;Hello&quot;));       // true\r\nconsole.log(msg.endsWith(&quot;!&quot;));             // true\r\nconsole.log(msg.includes(&quot;o&quot;));             // true\r\n\r\nconsole.log(msg.startsWith(&quot;o&quot;));           // false\r\nconsole.log(msg.endsWith(&quot;world!&quot;));        // true\r\nconsole.log(msg.includes(&quot;x&quot;));             // false\r\n\r\nconsole.log(msg.startsWith(&quot;o&quot;, 4));        // true\r\nconsole.log(msg.endsWith(&quot;o&quot;, 8));          // true\r\nconsole.log(msg.includes(&quot;o&quot;, 8));          // false\r\n</code></pre><h2 id=\"h2-6-2-repeat-\"><a name=\"6.2 repeat方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2 repeat方法</h2><blockquote>\r\n<p>ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如：</p>\r\n</blockquote>\r\n<pre><code>console.log(&quot;x&quot;.repeat(3));         // &quot;xxx&quot;\r\nconsole.log(&quot;hello&quot;.repeat(2));     // &quot;hellohello&quot;\r\nconsole.log(&quot;abc&quot;.repeat(4));       // &quot;abcabcabcabc&quot;\r\n</code></pre><h2 id=\"h2--a-name-t30-a-6-3-\"><a name=\"<a name=\"t30\"></a>6.3 字符串模板字面量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a name=\"t30\"></a>6.3 字符串模板字面量</h2><blockquote>\r\n<p>模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应：</p>\r\n<ul>\r\n<li><strong>多行字符串</strong> 针对多行字符串的形式概念（formal concept）。</li><li><strong>基本的字符串格式化</strong> 将字符串中的变量置换为值的能力。</li><li><strong>转义 HTML</strong> 能将字符串进行转义并使其安全地插入到 HTML 的能力。</li></ul>\r\n<p>模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。</p>\r\n</blockquote>\r\n<h3 id=\"h3-6-3-1-\"><a name=\"6.3.1 基本语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3.1 基本语法</h3><blockquote>\r\n<p>使用一对反引号 “(tab正上方的按键)来表示模板字面量。</p>\r\n</blockquote>\r\n<pre><code>let message = `Hello world!`;   //使用模板字面量创建了一个字符串\r\n\r\nconsole.log(message);               // &quot;Hello world!&quot;\r\nconsole.log(typeof message);        // &quot;string&quot;\r\nconsole.log(message.length);        // 12\r\n</code></pre><blockquote>\r\n<p>注意：如果模板字符串中使用到了反引号，则应该转义。但是单双引号不需要转义</p>\r\n</blockquote>\r\n<h3 id=\"h3-6-3-2-\"><a name=\"6.3.2 多行字符串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3.2 多行字符串</h3><blockquote>\r\n<p>在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \\）</p>\r\n</blockquote>\r\n<pre><code>&lt;body&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s = &quot;abc \\\r\n    aaaaaa&quot;;\r\n    console.log(s); //但是输出的结果中不包括换行\r\n&lt;/script&gt;\r\n&lt;/body&gt;\r\n</code></pre><blockquote>\r\n<p>但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s = `abc\r\n    aaaaa\r\n    dsalfja\r\n    dfadfja`;\r\n    console.log(s);\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>但是要注意： 反引号中的所有空格和缩进都是有效字符。</p>\r\n</blockquote>\r\n<h3 id=\"h3-6-3-3-\"><a name=\"6.3.3 字符串置换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3.3 字符串置换</h3><blockquote>\r\n<p>置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。</p>\r\n<p>语法：${变量名、表达式、任意运算、方法调用等}</p>\r\n<p>可以嵌入任何有效的JavaScript代码</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var name = &quot;李四&quot;;\r\n    var msg = `欢迎你${name}同学`;\r\n    console.log(msg)\r\n&lt;/script&gt;\r\n</code></pre><h3 id=\"h3-6-3-4-\"><a name=\"6.3.4 模板标签\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3.4 模板标签</h3><h4 id=\"h4-6-3-4-1-\"><a name=\"6.3.4.1 什么是模板标签\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3.4.1 什么是模板标签</h4><blockquote>\r\n<p>模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示：</p>\r\n</blockquote>\r\n<pre><code>let message = myTag`Hello world`;\r\n</code></pre><blockquote>\r\n<p>在上面的代码中，myTag就是模板标签。</p>\r\n<p>myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。</p>\r\n</blockquote>\r\n<h4 id=\"h4-6-3-4-2-\"><a name=\"6.3.4.2 定义模板标签\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3.4.2 定义模板标签</h4><blockquote>\r\n<p>一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。</p>\r\n<p>标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let name = &#39;张三&#39;,\r\n        age = 20,\r\n        message = show`我来给大家介绍${name}的年龄是${age}.`;\r\n\r\n    /*\r\n        应该定义一个函数show：\r\n        参数1：一个字符串数组。在本例中包含三个元素。\r\n             0:&quot;我来给大家介绍&quot;\r\n             1:&quot;的年龄是&quot;\r\n             2:&quot;.&quot;\r\n        参数2和参数3：表示需要置换的字符串的值。  \r\n     */\r\n    function show(stringArr, value1, value2) {\r\n        console.log(stringArr); //\r\n        console.log(value1);  // 张三\r\n        console.log(value2);  // 20\r\n        return &quot;abc&quot;;\r\n    }\r\n    console.log(message); //abc\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>为了简化书写，一般把Value1和Value2写成剩余字符串的形式</p>\r\n</blockquote>\r\n<pre><code>function show(stringArr, ...values){\r\n\r\n}\r\n</code></pre><h1 id=\"h1--\"><a name=\"七、解构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>七、解构</h1><h2 id=\"h2-7-1-\"><a name=\"7.1 解构的实用性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.1 解构的实用性</h2><blockquote>\r\n<p>在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如：</p>\r\n</blockquote>\r\n<pre><code>let options = {\r\n        repeat: true,\r\n        save: false\r\n   };\r\n\r\n// 从对象中提取数据\r\n\r\nlet repeat = options.repeat,\r\n    save = options.save;\r\n</code></pre><blockquote>\r\n<p>这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个<a href=\"http://lib.csdn.net/base/datastructure\" title=\"算法与数据结构知识库\">数据结构</a>。</p>\r\n<p>这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。</p>\r\n</blockquote>\r\n<h2 id=\"h2-7-2-\"><a name=\"7.2 对象解构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2 对象解构</h2><h3 id=\"h3-7-2-1-\"><a name=\"7.2.1 对象解构的基本形式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2.1 对象解构的基本形式</h3><blockquote>\r\n<p>对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。</p>\r\n</blockquote>\r\n<pre><code>let node = {\r\n        type: &quot;Identifier&quot;,\r\n        name: &quot;foo&quot;\r\n    };\r\n//这里就相当于声明了两个变量： type = node.type;  name:node.name\r\nlet { type, name } = node;\r\n\r\nconsole.log(type);      // &quot;Identifier&quot;\r\nconsole.log(name);      // &quot;foo&quot;\r\n</code></pre><blockquote>\r\n<p>在上面的结构中必须要初始化。否则会出现语法错误。</p>\r\n</blockquote>\r\n<pre><code>// 语法错误！\r\nvar { type, name };\r\n\r\n// 语法错误！\r\nlet { type, name };\r\n\r\n// 语法错误！\r\nconst { type, name };\r\n</code></pre><h3 id=\"h3-7-2-2-\"><a name=\"7.2.2 解构赋值表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2.2 解构赋值表达式</h3><blockquote>\r\n<p>如果声明的变量想改变他们的值，也可以使用解构表达式。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let node = {\r\n      type: &quot;Identifier&quot;,\r\n      name: &quot;foo&quot;\r\n    },\r\n    type = &quot;Literal&quot;,\r\n    name = 5;\r\n\r\n  //注意：此处必须要在圆括号内才能使用解构表达式\r\n  ({type, name} = node);\r\n\r\n  console.log(type);      // &quot;Identifier&quot;\r\n  console.log(name);      // &quot;foo&quot;&quot;\r\n&lt;/script&gt;\r\n</code></pre><h3 id=\"h3-7-2-3-\"><a name=\"7.2.3 对象解构时的默认值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2.3 对象解构时的默认值</h3><blockquote>\r\n<p>如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined</p>\r\n</blockquote>\r\n<pre><code>let node = {\r\n        type: &quot;Identifier&quot;,\r\n        name: &quot;foo&quot;\r\n    };\r\n//因为node中没有叫value的属性，所以valued的值将会是undefined\r\nlet { type, name, value } = node;\r\n\r\nconsole.log(type);      // &quot;Identifier&quot;\r\nconsole.log(name);      // &quot;foo&quot;\r\nconsole.log(value);     // undefined\r\n</code></pre><blockquote>\r\n<p>不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像）</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let node = {\r\n        type: &quot;Identifier&quot;,\r\n        name: &quot;foo&quot;\r\n    };\r\n    //手动添加value的默认值为3\r\n    let { type, name, value = 3} = node;\r\n\r\n    console.log(type);      // &quot;Identifier&quot;\r\n    console.log(name);      // &quot;foo&quot;\r\n    console.log(value);     // 3\r\n&lt;/script&gt;\r\n</code></pre><h3 id=\"h3-7-2-4-\"><a name=\"7.2.4 赋值给不同的变量名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2.4 赋值给不同的变量名</h3><blockquote>\r\n<p>在前面的操作中，都是把对象的属性值，赋值给同名变量。</p>\r\n<p>其实也可以赋值给不同名的变量。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let node = {\r\n        type: &quot;Identifier&quot;,\r\n        name: &quot;foo&quot;\r\n    };\r\n    // localType才是要定义的新的变量。  type是node的属性\r\n    let {type: localType, name: localName} = node;\r\n\r\n    console.log(localType);     // &quot;Identifier&quot;\r\n    console.log(localName);     // &quot;foo&quot;\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：冒号后面才是要定义的新的变量，这个可以我们的对象字面量不太一样！</p>\r\n<p>这个地方也可以使用默认值。</p>\r\n</blockquote>\r\n<pre><code>let node = {\r\n        type: &quot;Identifier&quot;\r\n    };\r\n\r\nlet { type: localType, name: localName = &quot;bar&quot; } = node;\r\n\r\nconsole.log(localType);     // &quot;Identifier&quot;\r\nconsole.log(localName);     // &quot;bar&quot;\r\n</code></pre><h2 id=\"h2-7-3-\"><a name=\"7.3 数组解构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.3 数组解构</h2><h3 id=\"h3-7-3-1-\"><a name=\"7.3.1 数组解构基本语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.3.1 数组解构基本语法</h3><blockquote>\r\n<p>数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：</p>\r\n</blockquote>\r\n<pre><code>let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];\r\nlet [ firstColor, secondColor ] = colors;\r\n\r\nconsole.log(firstColor);        // &quot;red&quot;\r\nconsole.log(secondColor);       // &quot;green&quot;\r\n</code></pre><blockquote>\r\n<p>如果只想取数组中的某一项，则可以不用命名。</p>\r\n</blockquote>\r\n<pre><code>let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];\r\n//只取数组中的第三项。\r\nlet [ , , thirdColor ] = colors;\r\n\r\nconsole.log(thirdColor);        // &quot;blue&quot;\r\n</code></pre><h3 id=\"h3-7-3-2-\"><a name=\"7.3.2 解构表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.3.2 解构表达式</h3><blockquote>\r\n<p>你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如：</p>\r\n</blockquote>\r\n<pre><code>let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],\r\n    firstColor = &quot;black&quot;,\r\n    secondColor = &quot;purple&quot;;\r\n\r\n[ firstColor, secondColor ] = colors;  //可以不用加括号。当然添加也不犯法\r\n\r\nconsole.log(firstColor);        // &quot;red&quot;\r\nconsole.log(secondColor);       // &quot;green&quot;\r\n</code></pre><blockquote>\r\n<p>数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let a = 3,\r\n        b = 4,\r\n        temp;\r\n    temp = a;\r\n    a = b;\r\n    b = temp;\r\n    console.log(a);\r\n    console.log(b)\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let a = 3,\r\n        b = 4;\r\n    //左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。\r\n    [a, b] = [b, a];\r\n    console.log(a);\r\n    console.log(b)\r\n&lt;/script&gt;\r\n</code></pre>', '90', '# ES6 新特性\r\n\r\n# 一、ES6简介\r\n\r\n? 历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以**新语法**、**新特性**的优越性吸引著众多 [JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\") 开发者，驱使他们积极尝鲜。\r\n\r\n? 由于ES6是在2015年发布的，所以也叫ES2015。\r\n\r\n? 以后ESCMAScript标准一年一更新，统一使用年份命名：ES2016、ES2017、….\r\n\r\n> 下面开始介绍ES6常用的一些新特性：\r\n\r\n# 二、块级作用域绑定\r\n\r\n> 在ES5之前，不存在块级作用域，在编程的时候很多时候会带来很多的不便，ES6新增了块级作用域，补足了这方面的缺陷。\r\n\r\n块级声明指的是该声明的变量无法被代码块外部访问。块作用域，又被称为词法作用域（lexical scopes），可以在如下的条件下创建：\r\n\r\n*   函数内部\r\n*   在代码块（即 { }）内部\r\n\r\n块级作用域是很多类[C语言](http://lib.csdn.net/base/c \"C语言知识库\")的工作机制，ECMAScript 6 引入块级声明的目的是增强 JavaScript 的灵活性，同时又能与其它编程语言保持一致。\r\n\r\n## 2.1 let声明\r\n\r\n> 使用let声明变量的语法和使用var声明的语法是一样的。**但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别**。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let a = 10;\r\n    if(a > 5){\r\n        console.log(b); //用let声明的变量没有声明提前这一特性，所以此处也访问不到（报错）\r\n        let b = 20;\r\n        console.log(b);\r\n    }\r\n    console.log(b); //由于b是在if块中使用let声明的，所以此处无法访问到。（报错）\r\n</script>\r\n```\r\n\r\n> 注意：\r\n\r\n1.  用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问\r\n2.  用let声明的变量也没有声明提前这一特性。\r\n3.  在同一个块中，let声明的变量也不能重复声明。\r\n4.  在声明变量的时候尽量使用let，慢慢的抛弃var\r\n\r\n## 2.2 const声明(Constant Declarations)\r\n\r\n> 在 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值。由于这个原因，所有的 const 声明的变量都必须在声明处初始化。const声明的常量和let变量一样也是具有块级作用域的特性。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var a = 20;\r\n    if (true) {\r\n        const b = 20;\r\n        b = 30;  //错误! 常量不能重新赋值\r\n        const c; //错误！ 常量声明的同时必须赋值。\r\n    }\r\n</script>\r\n```\r\n\r\n> 注意：\r\n\r\n1.  const的特性除了声明的是常量为，其他与let一样。\r\n2.  在let和const声明前的这段区域称之为暂存性死区（**The Temporal Dead Zone** —TDZ)。\r\n3.  使用let和const声明的变量和常量不再是window的属性。 也就是说通过window.a是无法访问到的。\r\n\r\n## 2.3 循环中的块级绑定\r\n\r\n> 使用var声明的循环变量在循环结束后仍然可以访问到。 使用let声明的循环变量，在循环结束之后会立即销毁。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    for(let i = 0; i < 3; i++){ // 循环结束之后会立即销毁 i\r\n        console.log(i);\r\n    }\r\n    console.log(i);  //此处无法访问到 i 。\r\n</script>\r\n```\r\n\r\n## 2.4 循环中的函数\r\n\r\n> 看下面的代码，是输出10个10，而不是0，1，2，…\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var funcs = [];\r\n    for (var i = 0; i < 10; i++) {\r\n        funcs.push(function () {\r\n            console.log(i);\r\n        });\r\n    }\r\n    funcs.forEach(function (func) {\r\n        func();     // 输出 \"10\" 共10次\r\n    });\r\n</script>\r\n```\r\n\r\n> 解决办法需要使用函数的自执行特性。\r\n\r\n```\r\nvar funcs = [];\r\nfor (var i = 0; i < 10; i++) {\r\n    funcs.push((function(value) {\r\n        return function() {\r\n            console.log(value);\r\n        }\r\n    }(i)));\r\n}\r\nfuncs.forEach(function(func) {\r\n    func();     // 输出 0，1，2 ... 9\r\n});\r\n```\r\n\r\n**如果使用let声明变量，则完全可以避免前面的问题。 这是ES6规范中专门定义的特性。在for … in和for … of循环中也适用**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var funcs = [];\r\n    for (let i = 0; i < 10; i++) {\r\n        funcs.push(function () {\r\n            console.log(i);\r\n        });\r\n    }\r\n    funcs.forEach(function (func) {\r\n        func();     // 输出 0，1，2 ... 9\r\n    })\r\n</script>\r\n```\r\n\r\n> 说明：\r\n\r\n1.  let 声明使得每次迭代都会创建一个变量 i，所以循环内部创建的函数会获得各自的变量 i 的拷贝。每份拷贝都会在每次迭代的开始被创建并被赋值。\r\n\r\n# 三、函数的新增特性\r\n\r\n## 3.1 带默认参数的函数\r\n\r\n> JavaScript函数的最大的一个特点就是在传递参数的时候，参数的个数不受限制的。为了健壮性考虑，一般在函数内部需要做一些默认值的处理。\r\n\r\n```\r\nfunction makeRequest(url, timeout, callback) {\r\n    timeout = timeout || 2000;\r\n    callback = callback || function() {};\r\n}\r\n```\r\n\r\n其实上面的默认值方法有个bug：当timeout是0的时候也会当做假值来处理，从而给赋值默认值2000.\r\n\r\n> ES6从语言层面面上增加了 **默认值的** 支持。看下面的代码：\r\n\r\n```\r\n//这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。\r\nfunction makeRequest(url, timeout = 2000, callback = function() {}) {\r\n\r\n    // 其余代码\r\n\r\n}\r\n```\r\n\r\n## 3.2 默认参数对 arguments 对象的影响\r\n\r\n> 在非严格模式下，arguments总是能反映出命名参数的变化。看下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function foo(a, b) {\r\n        //非严格模式\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n        a = 10;\r\n        b = 20;\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n    }\r\n    foo(1, 2);\r\n</script>\r\n```\r\n\r\n> **在ES5的严格模式下**，arguments只反映参数的初始值，而不再反映命名参数的变化！\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n\r\n    function foo(a, b) {\r\n        //严格模式\r\n        \"use strict\"\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n        a = 10;\r\n        b = 20;\r\n        console.log(arguments[0] === a); //false。  修改a的值不会影响到arguments[0]的值\r\n        console.log(arguments[1] === b); //false\r\n    }\r\n    foo(1, 2);\r\n</script>\r\n```\r\n\r\n> 当使用ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。看下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n\r\n    function foo(a, b = 30) {\r\n        console.log(arguments[0] === a); //true\r\n        console.log(arguments[1] === b); //true\r\n        a = 10;\r\n        b = 20;\r\n        console.log(arguments[0]  === a); //false。  由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。\r\n        console.log(arguments[1] === b); //false。  b使用了默认值，所以表现的和严格模式一样。\r\n    }\r\n    foo(1, 2);\r\n</script>\r\n```\r\n\r\n> 注意：如果这样调用foo(1),则 a == 1， b == 30， arguments[0] == 1, arguments[1] == undefined。也就是说默认值并不会赋值给arguments参数。\r\n\r\n## 3.3 默认参数表达式 (**Default Parameter Expressions**)\r\n\r\n> 参数的默认值，也可以是一个表达式或者函数调用等。看下面的代码\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function getValue() {\r\n        return 5;\r\n    }\r\n\r\n    function add(first, second = getValue()) { //表示使用getValue这个函数的返回值作为second的默认值。\r\n        return first + second;\r\n    }\r\n\r\n    console.log(add(1, 1));     // 2\\.  调用add函数的时候，传入了第二个参数，则以传入的参数为准。\r\n    console.log(add(1));        // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。\r\n</script>\r\n```\r\n\r\n> 有一点需要要注意：getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let value = 5;\r\n    function getValue() {\r\n        return value++;\r\n    }\r\n\r\n    function add(first, second = getValue()) {  //\r\n        return first + second;\r\n    }\r\n\r\n    console.log(add(1, 1));     // 2\r\n    console.log(add(1));        // 6。 \r\n    console.log(add(1));        // 7\r\n    console.log(add(1));        // 8\r\n</script>\r\n```\r\n\r\n> 由于默认值可以表达式，所以我们甚至可以使用前面的参数作为后面参数的默认值。\r\n\r\n```\r\nfunction add(first, second = first) {  // 使用第一个参数作为第二个参数的默认值\r\n        return first + second;\r\n }\r\n\r\n```\r\n\r\n> 注意：可以把前面的参数作为后面参数的默认值，但是不能把后面的参数作为第一个参数的默认值。这可以前面说的let和const的暂存性死区一个意思。\r\n\r\n```\r\nfunction add(first = second, second)) {  // 这种写法是错误的\r\n\r\n        return first + second;\r\n}\r\n```\r\n\r\n## 3.4 未命名参数问题\r\n\r\n> Javascript并不限制传入的参数的数量。在调用函数的时候，传入的实参的个数超过形参的个数的时候，超过的部分就成为了未命名参数。在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function foo(a) {\r\n        console.log(a);\r\n        console.log(arguments[1])  //取得传入的多余的参数。\r\n    }\r\n    foo(2, 3);\r\n</script>\r\n```\r\n\r\n> ES6，提供了一种更加优雅处理未命名参数的问题：**剩余参数**( **Rest Parameters** )\r\n> \r\n> 语法：function a(a, … b){ }\r\n> \r\n> 剩余参数使用三个点( … )和变量名来表示。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function foo(a, ...b) {\r\n        console.log(a);\r\n        console.log(b instanceof Array);  //true  .多余的参数都被放入了b中。b其实就是一个数组。\r\n    }\r\n    foo(2, 3, 4, 6);\r\n</script>\r\n```\r\n\r\n> 注意：\r\n\r\n1.  函数最多只能有一个剩余参数b。而且这个剩余参数必须位于参数列表的最后位置。\r\n2.  虽然有了剩余参数，但是arguments仍然存在，但是arguments完全无视了剩余参数的存在。\r\n3.  剩余参数是在函数声明的时候出现的。\r\n\r\n## 3.5 函数中的扩展运算符\r\n\r\n> 例如:Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用applay方法。\r\n> \r\n> 看下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let values = [25, 50, 75, 100]  \r\n    console.log(Math.max.apply(Math, values));  // 100\r\n</script>\r\n```\r\n\r\n> 上面这种方法虽然可行，但是总是不是那么直观。\r\n> \r\n> 使用ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let values = [25, 50, 75, 100]\r\n    console.log(Math.max(...values));  //使用扩展运算符。相当于拆解了数组了。\r\n    console.log(Math.max(...values, 200));  //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。\r\n</script>\r\n```\r\n\r\n> **注意：剩余参数和扩展运算符都是 使用三个点作为前缀。但是他们使用的位置是不一样的。**\r\n> \r\n> 1.  _**_剩余参数是用在函数的声明的时候的参数列表中，而且必须在参数列表的后面\r\n> 2.  扩展运算符是用在函数调用的时候作为实参来传递的，在实参中的位置没有限制。\r\n\r\n# 四、全新的函数：箭头函数（=>）\r\n\r\n> ECMAScript 6 最有意思的部分之一就是箭头函数。正如其名，箭头函数由 “箭头”（=>）这种新的语法来定义。\r\n> \r\n> 其实在别的语言中早就有了这种语法结构，不过他们叫拉姆达表达式。\r\n\r\n## 4.1 箭头函数语法\r\n\r\n> 基本语法如下：\r\n\r\n```\r\n(形参列表)=>{\r\n  //函数体\r\n}\r\n```\r\n\r\n* * *\r\n\r\n> 箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递。\r\n\r\n*   示例1：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var sum = (num1, num2) =>{\r\n        return num1 + num2;\r\n    }\r\n    console.log(sum(3, 4));\r\n    //前面的箭头函数等同于下面的传统函数\r\n    var add = function (num1, num2) {\r\n        return num1 + num2;\r\n    }\r\n    console.log(add(2, 4))\r\n</script>\r\n```\r\n\r\n* * *\r\n\r\n> 如果函数体内只有一行代码，则包裹函数体的 **大括号** ({ })完全可以省略。如果有return，return关键字也可以省略。\r\n> \r\n> 如果函数体内有多条语句，则 {} 不能省略。\r\n\r\n*   示例2：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var sum = (num1, num2) => num1 + num2;\r\n    console.log(sum(5, 4));\r\n    //前面的箭头函数等同于下面的传统函数\r\n    var add = function (num1, num2) {\r\n        return num1 + num2;\r\n    }\r\n    console.log(add(2, 4));\r\n\r\n    //如果这一行代码是没有返回值的，则方法的返回自也是undefined\r\n    var foo = (num1, num2) => console.log(\"aaa\");\r\n    console.log(foo(3,4));  //这个地方的返回值就是undefined\r\n</script>\r\n```\r\n\r\n* * *\r\n\r\n> 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。**当然如果不传入参数也不可以省略**\r\n\r\n*   示例3：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var foo = a=> a+3; //因为只有一个参数，所以()可以省略\r\n    console.log(foo(4)); // 7\r\n</script>\r\n```\r\n\r\n* * *\r\n\r\n> 如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个**小括号 ()**\r\n\r\n*   示例4：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var foo = ()=>({name:\"lisi\", age:30});\r\n    console.log(foo());\r\n    //等同于下面的；\r\n    var foo1 = ()=>{\r\n        return {\r\n            name:\"lisi\",\r\n            age : 30\r\n        };\r\n    }\r\n</script>\r\n```\r\n\r\n## 4.2 使用箭头函数实现函数自执行\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var person = (name => {\r\n            return {\r\n                name: name,\r\n                age: 30\r\n            }\r\n        }\r\n    )(\"zs\");\r\n    console.log(person);\r\n</script>\r\n```\r\n\r\n## 4.3 箭头函数中无this绑定(No this Binding)\r\n\r\n> 在ES5之前this的绑定是个比较麻烦的问题，稍不注意就达不到自己想要的效果。因为this的绑定和定义位置无关，只和调用方式有关。\r\n> \r\n> **在箭头函数中则没有这样的问题，在箭头函数中，this和定义时的作用域相关，不用考虑调用方式**\r\n> \r\n> 箭头函数没有 this 绑定，意味着 this 只能通过查找作用域链来确定。**如果箭头函数被另一个不包含箭头函数的函数囊括，那么 this 的值和该函数中的 this 相等，否则 this 的值为 window。**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var PageHandler = {\r\n        id: \"123456\",\r\n        init: function () {\r\n            document.addEventListener(\"click\",\r\n                event => this.doSomething(event.type), false); // 在此处this的和init函数内的this相同。\r\n        },\r\n\r\n        doSomething: function (type) {\r\n            console.log(\"Handling \" + type + \" for \" + this.id);\r\n        }\r\n    };\r\n    PageHandler.init();\r\n</script>\r\n```\r\n\r\n看下面的一段代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n\r\n    var p = {\r\n        foo:()=>console.log(this)   //此处this为window\r\n    }\r\n    p.foo();  //输出为 window对象。   并不是我想要的。所以在定义对象的方法的时候应该避免使用箭头函数。\r\n//箭头函数一般用在传递参数，或者在函数内部声明函数的时候使用。\r\n</script>\r\n```\r\n\r\n> 说明：\r\n\r\n1.  箭头函数作为一个使用完就扔的函数，不能作为构造函数使用。也就是不能使用new 的方式来使用箭头函数。\r\n2.  由于箭头函数中的this与函数的作用域相关，所以不能使用call、apply、bind来重新绑定this。但是虽然this不能重新绑定，但是还是可以使用call和apply方法去执行箭头函数的。\r\n\r\n## 4.4 无arguments绑定\r\n\r\n> 虽然箭头函数没有自己的arguments对象，但是在箭头函数内部还是可以使用它外部函数的arguments对象的。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function foo() {\r\n        //这里的arguments是foo函数的arguments对象。箭头函数自己是没有 arguments 对象的。\r\n        return ()=>arguments[0]; //箭头函数的返回值是foo函数的第一个参数\r\n    }\r\n    var arrow = foo(4, 5);\r\n    console.log(arrow()); // 4\r\n</script>\r\n```\r\n\r\n# 五、对象功能的扩展\r\n\r\n> 在JavaScript中，几乎所有的类型都是对象，所以使用好对象，对提示JavaScript的性能很重要。\r\n> \r\n> **ECMAScript 6 给对象的各个方面，从简单的语法扩展到操作与交互，都做了改进。**\r\n\r\n## 5.1 对象类别\r\n\r\n> ECMAScript 6 规范明确定义了每种对象类别。理解该术语对于从整体上认识该门语言显得十分重要。对象类别包括：\r\n\r\n*   普通对象（ordinary object）拥有 JavaScript 对象所有的默认行为。\r\n*   特异对象（exotic object）的某些内部行为和默认的有所差异。\r\n*   标准对象（standard object）是 ECMAScript 6 中定义的对象，例如 Array, Date 等，它们既可能是普通也可能是特异对象。\r\n*   内置对象（built-in object）指 JavaScript 执行环境开始运行时已存在的对象。标准对象均为内置对象。\r\n\r\n## 5.2 对象字面量的语法扩展\r\n\r\n### 5.2.1 简写的属性初始化\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function createPerson(name, age) {\r\n        //返回一个对象：属性名和参数名相同。\r\n        return {\r\n            name:name,\r\n            age:age\r\n        }\r\n    }\r\n    console.log(createPerson(\"lisi\", 30)); // {name:\"lisi\", age:30}\r\n    //在ES6中，上面的写法可以简化成如下形式\r\n\r\n</script>\r\n```\r\n\r\n> **在ES6中，上面的写法可以简化成如下的形式：**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function createPerson(name, age) {\r\n        //返回一个对象：属性名和参数名相同。\r\n        return {\r\n            name,  //当对象属性名和本地变量名相同时，可以省略冒号和值\r\n            age\r\n        }\r\n    }\r\n    console.log(createPerson(\"lisi\", 30)); // {name:\"lisi\", age:30}\r\n</script>\r\n```\r\n\r\n_当对象字面量中的属性只有属性名的时候，JavaScript 引擎会在该作用域内寻找是否有和属性同名的变量。在本例中，本地变量 name 的值被赋给了对象字面量中的 name 属性。_\r\n\r\n_该项扩展使得对象字面量的初始化变得简明的同时也消除了命名错误。对象属性被同名变量赋值在 JavaScript 中是一种普遍的编程模式，所以这项扩展的添加非常受欢迎。_\r\n\r\n### 5.2.2 简写的方法声明\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var person = {\r\n        name:\'lisi\',\r\n        sayHell:function () {\r\n            console.log(\"我的名字是：\" + this.name);\r\n        }\r\n    }\r\n    person.sayHell()\r\n</script>\r\n```\r\n\r\n> 在ES6中，上面的写法可以简化成如下的形式：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var person = {\r\n        name:\'李四\',\r\n        sayHell() {\r\n            console.log(\"我的名字是：\" + this.name);\r\n        }\r\n    }\r\n    person.sayHell()\r\n</script>\r\n```\r\n\r\n_省略了冒号和function看起来更简洁_\r\n\r\n### 5.2.3 在字面量中动态计算属性名\r\n\r\n> 在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 **在字面量中** 是无法使用的。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var p = {\r\n        name : \'李四\',\r\n        age : 20\r\n    }\r\n    var attName = \'name\';\r\n    console.log(p[attName]) //这里 attName表示的是一个变量名。\r\n</script>\r\n```\r\n\r\n> 而下面的方式使用时没有办法访问到attName这个变量的。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var attName = \'name\';\r\n    var p = {\r\n        attName : \'李四\',  // 这里的attName是属性名，相当于各级p定义了属性名叫 attName的属性。\r\n        age : 20\r\n    }\r\n    console.log(p[attName])  // undefined\r\n</script>\r\n```\r\n\r\n> 在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var attName = \'name\';\r\n    var p = {\r\n        [attName] : \'李四\',  // 引用了变量attName。相当于添加了一个属性名为name的属性\r\n        age : 20\r\n    }\r\n    console.log(p[attName])  // 李四\r\n</script>\r\n```\r\n\r\n## 5.3 新增的方法\r\n\r\n> ECMAScript 从第五版开始避免在 Object.prototype 上添加新的全局函数或方法，转而去考虑具体的对象类型如数组）应该有什么方法。当某些方法不适合这些具体类型时就将它们添加到全局 Object 上 。\r\n> \r\n> ECMAScript 6 在全局 Object 上添加了几个新的方法来轻松地完成一些特定任务。\r\n\r\n### 5.3.1 Object.is()\r\n\r\n> 在 JavaSciprt 中当你想比较两个值时，你极有可能使用比较操作符（==）或严格比较操作符（===）。许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。\r\n> \r\n> ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示：\r\n\r\n```\r\nconsole.log(+0 == -0);              // true\r\nconsole.log(+0 === -0);             // true\r\nconsole.log(Object.is(+0, -0));     // false\r\n\r\nconsole.log(NaN == NaN);            // false\r\nconsole.log(NaN === NaN);           // false\r\nconsole.log(Object.is(NaN, NaN));   // true\r\n\r\nconsole.log(5 == 5);                // true\r\nconsole.log(5 == \"5\");              // true\r\nconsole.log(5 === 5);               // true\r\nconsole.log(5 === \"5\");             // false\r\nconsole.log(Object.is(5, 5));       // true\r\nconsole.log(Object.is(5, \"5\"));     // false\r\n```\r\n\r\n_很多情况下 Object.is() 的表现和 === 是相同的。它们之间的区别是前者 **认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的**。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况。_\r\n\r\n### 5.3.2 Object.assign()\r\n\r\n> 使用assign主要是为了简化对象的混入（mixin）。混入是指的在一个对象中引用另一个对象的属性或方法。\r\n> \r\n> assing可以把一个对象的属性和访问完整的转copy到另外一个对象中。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var p = {\r\n        name : \"lisi\",\r\n        age : 20,\r\n        friends : [\'张三\', \'李四\']\r\n    }\r\n    var p1 = {};\r\n    Object.assign(p1, p); //则p1中就有了与p相同的属性和方法.  p1是接受者，p是提供者\r\n    console.log(p1);\r\n    //这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用）\r\n    console.log(p1.friends == p.friends);  //true   p1和p的friends同事指向了同一个数组。\r\n    p.friends.push(\"王五\");\r\n    console.log(p1.friends); //[\'张三\', \'李四\', \'王五\']\r\n</script>\r\n```\r\n\r\n> assign方法可以接受任意多的提供者。意味着后面提供者的同名属性和覆盖前面提供者的属性值。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var p = {\r\n        name : \"lisi\",\r\n        age : 20,\r\n        friends : [\'张三\', \'李四\']\r\n    }\r\n    var p1 = {\r\n        name : \'zs\',\r\n    }\r\n    var p2 = {};\r\n    Object.assign(p2, p, p1); //p和p1都是提供者\r\n    console.log(p2.name); // zs\r\n</script>\r\n```\r\n\r\n# 六、字符串功能的增强\r\n\r\n## 6.1 查找子字符串\r\n\r\n> 在以前在字符串中查找字符串的时候，都是使用indexOf方法。\r\n> \r\n> ES6新增了三个方法来查找字符串。\r\n\r\n*   includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。\r\n*   startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。\r\n*   endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。\r\n\r\n> 每个方法都接收两个参数：需要搜索的文本和可选的起始索引值。当提供第二个参数后，includes() 和 startsWith() 会以该索引为起始点进行匹配，而 endsWith() 将字符串的长度与参数值相减并将得到的值作为检索的起始点。若第二个参数未提供，includes() 和 startsWith() 会从字符串的起始中开始检索，endsWith() 则是从字符串的末尾。实际上，第二个参数减少了需要检索的字符串的总量。以下是使用这些方法的演示：\r\n\r\n```\r\nvar msg = \"Hello world!\";\r\n\r\nconsole.log(msg.startsWith(\"Hello\"));       // true\r\nconsole.log(msg.endsWith(\"!\"));             // true\r\nconsole.log(msg.includes(\"o\"));             // true\r\n\r\nconsole.log(msg.startsWith(\"o\"));           // false\r\nconsole.log(msg.endsWith(\"world!\"));        // true\r\nconsole.log(msg.includes(\"x\"));             // false\r\n\r\nconsole.log(msg.startsWith(\"o\", 4));        // true\r\nconsole.log(msg.endsWith(\"o\", 8));          // true\r\nconsole.log(msg.includes(\"o\", 8));          // false\r\n```\r\n\r\n## 6.2 repeat方法\r\n\r\n> ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数。例如：\r\n\r\n```\r\nconsole.log(\"x\".repeat(3));         // \"xxx\"\r\nconsole.log(\"hello\".repeat(2));     // \"hellohello\"\r\nconsole.log(\"abc\".repeat(4));       // \"abcabcabcabc\"\r\n```\r\n\r\n## <a name=\"t30\"></a>6.3 字符串模板字面量\r\n\r\n> 模板字面量是 ECMAScript 6 针对 JavaScript 直到 ECMAScript 5 依然缺失的如下功能的回应：\r\n> \r\n> *   **多行字符串** 针对多行字符串的形式概念（formal concept）。\r\n> *   **基本的字符串格式化** 将字符串中的变量置换为值的能力。\r\n> *   **转义 HTML** 能将字符串进行转义并使其安全地插入到 HTML 的能力。\r\n> \r\n> 模板字面量以一种全新的表现形式解决了这些问题而不需要向 JavaScript 已有的字符串添加额外的功能。\r\n\r\n### 6.3.1 基本语法\r\n\r\n> 使用一对反引号 “(tab正上方的按键)来表示模板字面量。\r\n\r\n```\r\nlet message = `Hello world!`;   //使用模板字面量创建了一个字符串\r\n\r\nconsole.log(message);               // \"Hello world!\"\r\nconsole.log(typeof message);        // \"string\"\r\nconsole.log(message.length);        // 12\r\n```\r\n\r\n> 注意：如果模板字符串中使用到了反引号，则应该转义。但是单双引号不需要转义\r\n\r\n### 6.3.2 多行字符串\r\n\r\n> 在ES5之前JavaScript是不支持多行字符串的。（但是在以前的版本中有一个大家都认为是bug的方式可以写出多行字符串，就是在尾部添加一个反斜杠 \\）\r\n\r\n```\r\n<body>\r\n<script type=\"text/javascript\">\r\n    var s = \"abc \\\r\n    aaaaaa\";\r\n    console.log(s); //但是输出的结果中不包括换行\r\n</script>\r\n</body>\r\n```\r\n\r\n> 但是在ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var s = `abc\r\n    aaaaa\r\n    dsalfja\r\n    dfadfja`;\r\n    console.log(s);\r\n</script>   \r\n```\r\n\r\n> 但是要注意： 反引号中的所有空格和缩进都是有效字符。\r\n\r\n### 6.3.3 字符串置换\r\n\r\n> 置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。\r\n> \r\n> 语法：${变量名、表达式、任意运算、方法调用等}\r\n> \r\n> 可以嵌入任何有效的JavaScript代码\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var name = \"李四\";\r\n    var msg = `欢迎你${name}同学`;\r\n    console.log(msg)\r\n</script>\r\n```\r\n\r\n### 6.3.4 模板标签\r\n\r\n#### 6.3.4.1 什么是模板标签\r\n\r\n> 模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示：\r\n\r\n```\r\nlet message = myTag`Hello world`;\r\n```\r\n\r\n> 在上面的代码中，myTag就是模板标签。\r\n> \r\n> myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。\r\n\r\n#### 6.3.4.2 定义模板标签\r\n\r\n> 一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。\r\n> \r\n> 标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let name = \'张三\',\r\n        age = 20,\r\n        message = show`我来给大家介绍${name}的年龄是${age}.`;\r\n\r\n    /*\r\n        应该定义一个函数show：\r\n        参数1：一个字符串数组。在本例中包含三个元素。\r\n             0:\"我来给大家介绍\"\r\n             1:\"的年龄是\"\r\n             2:\".\"\r\n        参数2和参数3：表示需要置换的字符串的值。  \r\n     */\r\n    function show(stringArr, value1, value2) {\r\n        console.log(stringArr); //\r\n        console.log(value1);  // 张三\r\n        console.log(value2);  // 20\r\n        return \"abc\";\r\n    }\r\n    console.log(message); //abc\r\n</script>\r\n\r\n```\r\n\r\n> 为了简化书写，一般把Value1和Value2写成剩余字符串的形式\r\n\r\n```\r\nfunction show(stringArr, ...values){\r\n\r\n}\r\n```\r\n\r\n# 七、解构\r\n\r\n## 7.1 解构的实用性\r\n\r\n> 在 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如：\r\n\r\n```\r\nlet options = {\r\n        repeat: true,\r\n        save: false\r\n   };\r\n\r\n// 从对象中提取数据\r\n\r\nlet repeat = options.repeat,\r\n    save = options.save;\r\n```\r\n\r\n> 这段代码反复地提取在 options 上存储地属性值并将它们传递给同名的本地变量。虽然这些看起来不是那么复杂，不过想象一下如果你的一大批变量有着相同的需求，你就只能一个一个地赋值。而且，如果你需要从对象内部嵌套的结构来查找想要的数据，你极有可能为了一小块数据而访问了整个[数据结构](http://lib.csdn.net/base/datastructure \"算法与数据结构知识库\")。\r\n> \r\n> 这也是 ECMAScript 6 给对象和数组添加解构的原因。当你想要把数据结构分解为更小的部分时，从这些部分中提取数据会更容易些。很多语言都能使用精简的语法来实现解构操作。ECMAScript 6 解构的实际语法或许你已经非常熟悉：对象和数组字面量。\r\n\r\n## 7.2 对象解构\r\n\r\n### 7.2.1 对象解构的基本形式\r\n\r\n> 对象结构的语法就是在赋值语句的左侧使用类似对象字面量的结构。\r\n\r\n```\r\nlet node = {\r\n        type: \"Identifier\",\r\n        name: \"foo\"\r\n    };\r\n//这里就相当于声明了两个变量： type = node.type;  name:node.name\r\nlet { type, name } = node;\r\n\r\nconsole.log(type);      // \"Identifier\"\r\nconsole.log(name);      // \"foo\"\r\n```\r\n\r\n> 在上面的结构中必须要初始化。否则会出现语法错误。\r\n\r\n```\r\n// 语法错误！\r\nvar { type, name };\r\n\r\n// 语法错误！\r\nlet { type, name };\r\n\r\n// 语法错误！\r\nconst { type, name };\r\n```\r\n\r\n### 7.2.2 解构赋值表达式\r\n\r\n> 如果声明的变量想改变他们的值，也可以使用解构表达式。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let node = {\r\n      type: \"Identifier\",\r\n      name: \"foo\"\r\n    },\r\n    type = \"Literal\",\r\n    name = 5;\r\n\r\n  //注意：此处必须要在圆括号内才能使用解构表达式\r\n  ({type, name} = node);\r\n\r\n  console.log(type);      // \"Identifier\"\r\n  console.log(name);      // \"foo\"\"\r\n</script>\r\n```\r\n\r\n### 7.2.3 对象解构时的默认值\r\n\r\n> 如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined\r\n\r\n```\r\nlet node = {\r\n        type: \"Identifier\",\r\n        name: \"foo\"\r\n    };\r\n//因为node中没有叫value的属性，所以valued的值将会是undefined\r\nlet { type, name, value } = node;\r\n\r\nconsole.log(type);      // \"Identifier\"\r\nconsole.log(name);      // \"foo\"\r\nconsole.log(value);     // undefined\r\n```\r\n\r\n> 不过我们也可以手动指定他的默认值。（这个和函数的参数默认值很像）\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let node = {\r\n        type: \"Identifier\",\r\n        name: \"foo\"\r\n    };\r\n    //手动添加value的默认值为3\r\n    let { type, name, value = 3} = node;\r\n\r\n    console.log(type);      // \"Identifier\"\r\n    console.log(name);      // \"foo\"\r\n    console.log(value);     // 3\r\n</script>\r\n```\r\n\r\n### 7.2.4 赋值给不同的变量名\r\n\r\n> 在前面的操作中，都是把对象的属性值，赋值给同名变量。\r\n> \r\n> 其实也可以赋值给不同名的变量。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let node = {\r\n        type: \"Identifier\",\r\n        name: \"foo\"\r\n    };\r\n    // localType才是要定义的新的变量。  type是node的属性\r\n    let {type: localType, name: localName} = node;\r\n\r\n    console.log(localType);     // \"Identifier\"\r\n    console.log(localName);     // \"foo\"\r\n</script>\r\n```\r\n\r\n> 注意：冒号后面才是要定义的新的变量，这个可以我们的对象字面量不太一样！\r\n> \r\n> 这个地方也可以使用默认值。\r\n\r\n```\r\nlet node = {\r\n        type: \"Identifier\"\r\n    };\r\n\r\nlet { type: localType, name: localName = \"bar\" } = node;\r\n\r\nconsole.log(localType);     // \"Identifier\"\r\nconsole.log(localName);     // \"bar\"\r\n```\r\n\r\n## 7.3 数组解构\r\n\r\n### 7.3.1 数组解构基本语法\r\n\r\n> 数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：\r\n\r\n```\r\nlet colors = [ \"red\", \"green\", \"blue\" ];\r\nlet [ firstColor, secondColor ] = colors;\r\n\r\nconsole.log(firstColor);        // \"red\"\r\nconsole.log(secondColor);       // \"green\"\r\n```\r\n\r\n> 如果只想取数组中的某一项，则可以不用命名。\r\n\r\n```\r\nlet colors = [ \"red\", \"green\", \"blue\" ];\r\n//只取数组中的第三项。\r\nlet [ , , thirdColor ] = colors;\r\n\r\nconsole.log(thirdColor);        // \"blue\"\r\n```\r\n\r\n### 7.3.2 解构表达式\r\n\r\n> 你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如：\r\n\r\n```\r\nlet colors = [ \"red\", \"green\", \"blue\" ],\r\n    firstColor = \"black\",\r\n    secondColor = \"purple\";\r\n\r\n[ firstColor, secondColor ] = colors;  //可以不用加括号。当然添加也不犯法\r\n\r\nconsole.log(firstColor);        // \"red\"\r\nconsole.log(secondColor);       // \"green\"\r\n```\r\n\r\n> 数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let a = 3,\r\n        b = 4,\r\n        temp;\r\n    temp = a;\r\n    a = b;\r\n    b = temp;\r\n    console.log(a);\r\n    console.log(b)\r\n</script>\r\n```\r\n\r\n> 那么在ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let a = 3,\r\n        b = 4;\r\n    //左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。\r\n    [a, b] = [b, a];\r\n    console.log(a);\r\n    console.log(b)\r\n</script>\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('65', 'ES2015新特性2', '<h1 id=\"h1--symbol\"><a name=\"八、新的基本类型：Symbol\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>八、新的基本类型：Symbol</h1><blockquote>\r\n<p>以前我们有5种基本数据类型：Number、String、Boolean、Null、Undefined</p>\r\n<p>ES6新增了一种新的数据类型：Symbol</p>\r\n<p>在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。</p>\r\n</blockquote>\r\n<h2 id=\"h2-8-1-symbol\"><a name=\"8.1 创建Symbol\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.1 创建Symbol</h2><blockquote>\r\n<p>Symbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。</p>\r\n<p>我们可以使用symbol全局函数来创建Symbol。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let firstName = Symbol();   //创建一个Symbol\r\n    let person = {};\r\n\r\n    person[firstName] = &quot;张三&quot;;\r\n    console.log(person[firstName]);     // &quot;张三&quot;\r\n&lt;/script&gt;\r\n</code></pre><p>说明：上面的代码中，firstName 作为 symbol 类型被创建并赋值给 person 对象以作其属性。每次访问这个属性时必须使用该 symbol 。</p>\r\n<blockquote>\r\n<p>在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s1 = Symbol(&quot;abc&quot;);\r\n    var s2 = Symbol(&quot;abc&quot;);\r\n    console.log(s1 == s2); //false\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。</p>\r\n</blockquote>\r\n<h2 id=\"h2-8-2-symbol\"><a name=\"8.2 识别Symbol\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.2 识别Symbol</h2><blockquote>\r\n<p>既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如：</p>\r\n</blockquote>\r\n<pre><code>let symbol = Symbol();\r\nconsole.log(typeof symbol);         // &quot;symbol&quot;\r\n</code></pre><h2 id=\"h2-8-3-symbol-\"><a name=\"8.3 Symbol作为属性名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.3 Symbol作为属性名</h2><p>? 由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>\r\n<pre><code>var mySymbol = Symbol();\r\n\r\n// 第一种写法\r\n\r\nvar a = {};\r\n\r\na[mySymbol] = &#39;Hello!&#39;;\r\n\r\n// 第二种写法\r\n\r\nvar a = {\r\n\r\n    [mySymbol]: &#39;Hello!&#39;\r\n}\r\n</code></pre><blockquote>\r\n<p>以上两种写法都是相同的结果</p>\r\n</blockquote>\r\n<p>注意：</p>\r\n<ol>\r\n<li><p>symbol作为对象的属性的时候，只能使用 [ ] 去访问，不能使用点去访问。</p>\r\n</li><li><p>symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of</p>\r\n<p>时无法遍历到这个symbol属性的。</p>\r\n</li></ol>\r\n<h2 id=\"h2-8-4-symbol-\"><a name=\"8.4 Symbol属性名的遍历\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.4 Symbol属性名的遍历</h2><p>? Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>\r\n<blockquote>\r\n<p>看下面的代码</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var obj = {};\r\n    var a = Symbol(&#39;a&#39;);\r\n    var b = Symbol(&#39;b&#39;);\r\n\r\n    obj[a] = &#39;Hello&#39;;\r\n    obj[b] = &#39;World&#39;;\r\n    // 返回obj对象所有Symbol类型的属性名组成的数组。\r\n    var objectSymbols = Object.getOwnPropertySymbols(obj);\r\n    console.log(objectSymbols)  //[Symbol(a), Symbol(b)]\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>看下面的代码</p>\r\n</blockquote>\r\n<pre><code>var obj = {};\r\n\r\nvar foo = Symbol(&quot;foo&quot;);\r\nobj[foo] = &quot;lisi&quot;;\r\nfor (var i in obj) {\r\n  console.log(i); // 无输出 。   因为遍历不到Symbol型的属性 \r\n}\r\n\r\nObject.getOwnPropertyNames(obj);// []   只能拿到非Symbol类型的属性\r\n\r\nObject.getOwnPropertySymbols(obj) //[Symbol(foo)]\r\n</code></pre><blockquote>\r\n<p>还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。</p>\r\n<p>Reflect.ownKeys</p>\r\n</blockquote>\r\n<pre><code>let obj = {\r\n  [Symbol(&#39;my_key&#39;)]: 1,\r\n  enum: 2,\r\n  nonEnum: 3\r\n};\r\n\r\nReflect.ownKeys(obj);//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]\r\n</code></pre><p>说明：</p>\r\n<ol>\r\n<li>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</li></ol>\r\n<h2 id=\"h2-8-5-symbol-for-symbol-keyfor-symbol-\"><a name=\"8.5 Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.5 Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)</h2><blockquote>\r\n<p>一、Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个sybol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。</p>\r\n</blockquote>\r\n<pre><code>    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //第一次搜不到，则新创建一个返回，并在全局环境(window)中注册\r\n        var a = Symbol.for(&quot;foo&quot;);\r\n        //第二次搜到上次创建的\r\n        var b = Symbol.for(&quot;foo&quot;);\r\n        console.log(a === b);  //因为两次搜到的是同一个Symbol，所以此处是true\r\n    &lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>Symbol.for()和Symbol()都可以创建Symbol类型的数据。</p>\r\n<p>二者区别：</p>\r\n<ol>\r\n<li>Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。</li><li>Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。</li></ol>\r\n<p>看下面的代码</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n   var a = Symbol(&quot;foo&quot;);\r\n   var b = Symbol.for(&quot;foo&quot;);\r\n   console.log(a == b); //false\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>二、Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var a = Symbol(&quot;foo&quot;);\r\n    var b = Symbol.for(&quot;foo&quot;);\r\n    console.log(Symbol.keyFor(a)); // undefined.   因为a没有想全局环境中登记，所以是undefinded\r\n    console.log(Symbol.keyFor(b)); // foo\r\n&lt;/script&gt;\r\n</code></pre><h1 id=\"h1--set-\"><a name=\"九、Set数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>九、Set数据结构</h1><p>? JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。</p>\r\n<p>? 因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。</p>\r\n<blockquote>\r\n<p>Set是类似数组的一种结构，可以存储数据，与数组的区别主要是 <strong>Set中的元素不能重复，而数组中的元素可以重复</strong>。</p>\r\n<p>一句话总结：<strong><em>Set类型是一个包含无重复元素的有序列表</em></strong></p>\r\n</blockquote>\r\n<h2 id=\"h2-9-1-set-\"><a name=\"9.1 创建Set和并添加元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9.1 创建Set和并添加元素</h2><blockquote>\r\n<p>Set本身是一个构造函数。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //创建Set数据结构对象。\r\n    var s = new Set();\r\n    //调用set对象的add方法，向set中添加元素\r\n    s.add(&quot;a&quot;);\r\n    s.add(&quot;c&quot;);\r\n    s.add(&quot;b&quot;);\r\n    //set的size属性可以获取set中元素的个数\r\n    console.log(s.size)\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-9-2-set-\"><a name=\"9.2 Set中不能添加重复元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9.2 Set中不能添加重复元素</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s = new Set();\r\n    s.add(&quot;a&quot;);\r\n    s.add(&quot;c&quot;);\r\n    s.add(&quot;b&quot;);\r\n    s.add(&quot;a&quot;);  //重复，所以添加失败。注意这个地方并不会保存。\r\n    console.log(s.size); // 长度是3\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>看下面的代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s = new Set();\r\n    s.add(5);\r\n    s.add(&quot;5&quot;);\r\n    console.log(s.size); // 长度是2\r\n&lt;/script&gt;\r\n</code></pre><p>? 在上面的代码中，数字5和字符串5都会添加成功。为什么呢？</p>\r\n<blockquote>\r\n<p>Set是使用什么机制来判断两个元素是否相等的呢？</p>\r\n<p><strong>是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。</strong></p>\r\n<p>回忆一下：这个方法除了 +0和-0、NaN和NaN认为相等，其余和三个 === 是完全一样的。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s = new Set();\r\n    s.add(+0);\r\n    s.add(-0);  //重复添加不进去\r\n    s.add(NaN);\r\n    s.add(NaN); //重复添加不进去\r\n    s.add([]);\r\n    s.add([]);  //两个空数组不相等，所以可以添加进去\r\n    s.add({});\r\n    s.add({});  // 两个空对象也不重复，所以也可以添加进去\r\n    console.log(s.size); // 长度是6\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-9-3-set\"><a name=\"9.3 使用数组初始化Set\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9.3 使用数组初始化Set</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。\r\n    var s = new Set([2, 3, 2, 2, 4]);\r\n    console.log(s.size)\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-9-4-set-\"><a name=\"9.4 判断一个值是否在Set中\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9.4 判断一个值是否在Set中</h2><blockquote>\r\n<p>使用Set的 has() 方法可以判断一个值是否在这个set中。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let set = new Set();\r\n    set.add(5);\r\n    set.add(&quot;5&quot;);\r\n\r\n    console.log(set.has(5));    // true\r\n    console.log(set.has(6));    // false\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-9-5-set-\"><a name=\"9.5 移除Set中的元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9.5 移除Set中的元素</h2><blockquote>\r\n<p>delete(要删除的值) ：删除单个值</p>\r\n<p>clear()：清空所有的值</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let set = new Set();\r\n    set.add(5);\r\n    set.add(&quot;5&quot;);\r\n\r\n    console.log(set.has(5));    // true\r\n\r\n    set.delete(5);\r\n\r\n    console.log(set.has(5));    // false\r\n    console.log(set.size);      // 1\r\n\r\n    set.clear();\r\n\r\n    console.log(set.has(&quot;5&quot;));  // false\r\n    console.log(set.size);      // 0\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-9-6-set\"><a name=\"9.6 遍历Set\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9.6 遍历Set</h2><blockquote>\r\n<p>数组有个方法forEach可以遍历数组。</p>\r\n<ol>\r\n<li>Set也有forEach可以遍历Set。</li></ol>\r\n<p>使用Set的forEach遍历时的回调函数有三个参数：</p>\r\n<p>function (value, key, ownerSet){</p>\r\n<p>}</p>\r\n<p>参数1：遍历到的元素的值</p>\r\n<p>参数2：对set集合来说，参数2的值和参数1的值是完全一样的。</p>\r\n<p>参数3：这个set自己</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let set = new Set([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, 9]);\r\n    set.forEach(function (v, k, s) {\r\n        console.log(v + &quot;   &quot; + (v === k) + &quot;  &quot; + (s === set));   // 永远是true\r\n    })\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<ol>\r\n<li>for…of也可以遍历set。</li></ol>\r\n</blockquote>\r\n<pre><code>for(var v of set){\r\n    console.log(v)\r\n}\r\n</code></pre><h2 id=\"h2-9-7-set-\"><a name=\"9.7 将Set转换为数组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9.7 将Set转换为数组</h2><blockquote>\r\n<p>将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。</p>\r\n<p><strong>把Set转换为数组使用前面讲到的扩展运算符也很容易</strong></p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let set = new Set([1, 2, 3, 3, 3, 4, 5]),\r\n        arr = [...set];  //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响\r\n\r\n    console.log(arr);             // [1,2,3,4,5]\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>这种情况在需要去数组中重复元素的时候非常好用。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function eliminateDuplicates(items) {\r\n        return [...new Set(items)];\r\n    }\r\n    let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1],\r\n        //返回的是新的没有重复元素的数组。\r\n        noDuplicates = eliminateDuplicates(numbers);\r\n    console.log(noDuplicates);      // [1,2,3,4,5]\r\n&lt;/script&gt;\r\n</code></pre><hr>\r\n<p><strong><em>Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map</em></strong></p>\r\n<h1 id=\"h1--map-\"><a name=\"十、Map数据结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>十、Map数据结构</h1><p>? ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。</p>\r\n<p>? 键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。</p>\r\n<p>? 这和使用对象属性做为值的方法大相径庭，因为 <strong>对象的属性会被强制转换为字符串类型</strong>。</p>\r\n<h2 id=\"h2-10-1-map-map-\"><a name=\"10.1 创建Map对象和Map的基本的存取操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.1 创建Map对象和Map的基本的存取操作</h2><blockquote>\r\n<ol>\r\n<li>Map创建也是使用Map构造函数</li><li>向Map存储键值对使用set(key, value);方法</li><li>可以使用get(key),来获取指定key对应的value</li></ol>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var map = new Map();\r\n    map.set(&quot;a&quot;, &quot;lisi&quot;);\r\n    map.set(&quot;b&quot;, &quot;zhangsan&quot;);\r\n    map.set(&quot;b&quot;, &quot;zhangsan222&quot;);  // 第二次添加，新的value会替换掉旧的\r\n    console.log(map.get(&quot;a&quot;));\r\n    console.log(map.get(&quot;b&quot;));   //zhangsan222\r\n    console.log(map.get(&quot;c&quot;)); //undefined.如果key不存在，则返回undefined\r\n    console.log(map.size); //2\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-10-2-map-set-3-\"><a name=\"10.2 Map与Set类似的3个方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.2 Map与Set类似的3个方法</h2><ul>\r\n<li>has(key) - 判断给定的 key 是否在 map 中存在</li><li>delete(key) - 移除 map 中的 key 及对应的值</li><li>clear() - 移除 map 中所有的键值对</li></ul>\r\n<h2 id=\"h2-10-3-map\"><a name=\"10.3 初始化Map\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.3 初始化Map</h2><blockquote>\r\n<p>创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。</p>\r\n<p>也就是传入的实际是一个二维数组！</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n  //map接受一个二维数组\r\n    var map = new Map([\r\n      //每一个数组中，第一个是是map的可以，第二个是map的value。如果只有第一个，则值是undefined\r\n        [&quot;name&quot;, &quot;lisi&quot;],  \r\n        [&quot;age&quot;, 20],\r\n        [&quot;sex&quot;, &quot;nan&quot;]\r\n    ]);\r\n    console.log(map.size);\r\n    console.log(map.get(&quot;name&quot;))\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-10-4-map-foreach-\"><a name=\"10.4 Map的forEach方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10.4 Map的forEach方法</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var map = new Map([\r\n        [&quot;name&quot;, &quot;李四&quot;],\r\n        [&quot;age&quot;, 20],\r\n        [&quot;sex&quot;, &quot;nan&quot;]\r\n    ]);\r\n    /*\r\n        回调函数有函数：\r\n        参数1：键值对的value\r\n        参数2：键值对的key\r\n        参数3：map对象本身\r\n     */\r\n    map.forEach(function (value, key, ownMap) {\r\n        console.log(`key=${key} ,vlue=${value}`);\r\n        console.log(this);\r\n    })\r\n &lt;/script&gt;\r\n</code></pre><h1 id=\"h1--for-of-\"><a name=\"十一、迭代器和for…of循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>十一、迭代器和for…of循环</h1><h2 id=\"h2-11-1-\"><a name=\"11.1 循环问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11.1 循环问题</h2><pre><code>var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];\r\n\r\nfor (var i = 0, len = colors.length; i &lt; len; i++) {\r\n    console.log(colors[i]);\r\n}\r\n</code></pre><blockquote>\r\n<p>上面的代码写起来简单，但是实际使用的过程中，我们需求自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。</p>\r\n<p>迭代器就是为了解决这个问题的。</p>\r\n</blockquote>\r\n<h2 id=\"h2-11-2-\"><a name=\"11.2 什么是迭代器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11.2 什么是迭代器</h2><p>? 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。</p>\r\n<p>? 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。</p>\r\n<blockquote>\r\n<p>我们可以用ES5之前的知识手动创建一个迭代器：</p>\r\n</blockquote>\r\n<pre><code>function createIterator(items) {\r\n    var i = 0;\r\n    return {\r\n        next: function() {\r\n            var done = (i &gt;= items.length);\r\n            var value = !done ? items[i++] : undefined;\r\n            return {\r\n                done: done,\r\n                value: value\r\n            };\r\n\r\n        }\r\n    };\r\n}\r\n//创建一个可以在指定数组上面迭代的迭代器对象。\r\nvar iterator = createIterator([1, 2, 3]);\r\n\r\nconsole.log(iterator.next());           // &quot;{ value: 1, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: 2, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: 3, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;\r\n\r\n// for all further calls\r\nconsole.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;\r\n</code></pre><p>从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。</p>\r\n<p>幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。</p>\r\n<h2 id=\"h2-11-3-\"><a name=\"11.3 生成器函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11.3 生成器函数</h2><blockquote>\r\n<p><strong>生成器函数就是返回迭代器的函数！</strong></p>\r\n<p>生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。</p>\r\n<p>看下面代码：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    //生成器函数。  注意中间的 * 不能丢\r\n    function * createIterator() {\r\n        //每个yield的后面的值表示我们迭代到的值。   yield也定义了我们迭代的顺序。\r\n        yield 3;\r\n        yield 4;\r\n        yield 2;\r\n    }\r\n    var it = createIterator();\r\n    console.log(it.next().value);   // 2\r\n    console.log(it.next().value);   // 4\r\n    console.log(it.next().value);   // 2\r\n    console.log(it.next().value);  //undefined\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p><strong>迭代器函数也是函数，所以他可以像正常的函数一样调用，但是生成器函数会自动返回一个迭代器对象。</strong></p>\r\n<p>每调用一次迭代器的next方法，如果碰到yield都会返回一个迭代到的一个对象，然后停止继续执行，直到下次调用next方法，会从上次停止的地方继续执行。</p>\r\n</blockquote>\r\n<pre><code>//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。\r\nfunction *createIterator(items) {\r\n    for (let i = 0; i &lt; items.length; i++) {\r\n      //每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 {value : items[i], done : true}\r\n        yield items[i]; \r\n    }\r\n}\r\n\r\nlet iterator = createIterator([1, 2, 3]);\r\n\r\nconsole.log(iterator.next());           // &quot;{ value: 1, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: 2, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: 3, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;\r\n\r\n// 进一步调用\r\nconsole.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;\r\n</code></pre><blockquote>\r\n<p>注意：</p>\r\n</blockquote>\r\n<ol>\r\n<li>yield 关键字只能 <strong>直接用在生成器内部</strong> 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。</li></ol>\r\n<h2 id=\"h2-11-4-\"><a name=\"11.4 生成器函数表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11.4 生成器函数表达式</h2><blockquote>\r\n<p>你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如：</p>\r\n</blockquote>\r\n<pre><code>let createIterator = function *(items) {\r\n    for (let i = 0; i &lt; items.length; i++) {\r\n        yield items[i];\r\n    }\r\n};\r\n\r\nlet iterator = createIterator([1, 2, 3]);\r\n\r\nconsole.log(iterator.next());           // &quot;{ value: 1, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: 2, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: 3, done: false }&quot;\r\nconsole.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;\r\n\r\n// 进一步调用\r\nconsole.log(iterator.next());           // &quot;{ value: undefined, done: true }&quot;\r\n</code></pre><blockquote>\r\n<p>注意：无法使用箭头函数来创建生成器。</p>\r\n</blockquote>\r\n<h2 id=\"h2-11-5-for-of-\"><a name=\"11.5 可迭代类型和for-of迭代循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11.5 可迭代类型和for-of迭代循环</h2><blockquote>\r\n<p>迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。</p>\r\n</blockquote>\r\n<p>? 与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性的对象。</p>\r\n<p>? 该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 <strong>for-of</strong> 循环而设计的。</p>\r\n<p>? 换句话说，默认情况下只有 <strong>数组、set、Map和字符串</strong>才可以使用迭代器去迭代。 (也就可以使用for…of了)</p>\r\n<p>? for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！</p>\r\n<blockquote>\r\n<p>使用 for…of 迭代数组：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var arr = [&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;];\r\n    for(var item of arr){\r\n        console.log(item)\r\n    }\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>使用 for…of 迭代Set:</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var set = new Set([&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;]);\r\n    for(var item of set){\r\n        console.log(item)\r\n    }\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>使用 for…of 迭代Map：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var map = new Map([[&quot;name&quot;, &quot;lisi&quot;],[&quot;sex&quot;, &quot;男&quot;],[&quot;age&quot;, 20]]);\r\n    map.set(&quot;aaa&quot;, &quot;bbb&quot;)\r\n    for(var item of map){\r\n        console.log(item);  //注意：这里迭代到的是由key和value组成的数组。\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>使用for … of迭代字符串</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    var s = &quot;abcd&quot;;\r\n    for(let c of s){\r\n        console.log(c)\r\n    }\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常</p>\r\n</blockquote>\r\n<p>?</p>\r\n<p>说明：以数组为例。</p>\r\n<p>? for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。</p>\r\n<p>? 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。</p>\r\n<h2 id=\"h2-11-6-\"><a name=\"11.6 访问可迭代类型的默认迭代器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11.6 访问可迭代类型的默认迭代器</h2><blockquote>\r\n<p>Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    let s = &quot;abcd&quot;;\r\n    let it = s[Symbol.iterator]();  //调用字符串的Symbol.iterator方法\r\n    console.log(it.next());  //返回迭代器迭代到的第一个对象\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function isIterable(object) {\r\n        return typeof object[Symbol.iterator] === &quot;function&quot;;\r\n    }\r\n\r\n    console.log(isIterable([1, 2, 3]));     // true\r\n    console.log(isIterable(&quot;Hello&quot;));       // true\r\n    console.log(isIterable(new Map()));     // true\r\n    console.log(isIterable(new Set()));     // true\r\n    console.log(isIterable({&quot;name&quot;:&quot;李四&quot;})); // false。普通对象不可迭代\r\n&lt;/script&gt;\r\n</code></pre><h2 id=\"h2-11-7-\"><a name=\"11.7 自定义可迭代类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11.7 自定义可迭代类型</h2><blockquote>\r\n<p>开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如：</p>\r\n</blockquote>\r\n<pre><code>let collection = {\r\n    items: [],\r\n    *[Symbol.iterator]() {\r\n        for (let item of this.items) {\r\n            yield item;\r\n        }\r\n    }\r\n\r\n};\r\n\r\ncollection.items.push(1);\r\ncollection.items.push(2);\r\ncollection.items.push(3);\r\n\r\nfor (let x of collection) {\r\n    console.log(x);\r\n}\r\n</code></pre><h1 id=\"h1--\"><a name=\"十二、类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>十二、类</h1><blockquote>\r\n<p>和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。</p>\r\n<p>这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。</p>\r\n<p>尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。</p>\r\n</blockquote>\r\n<h2 id=\"h2-12-1-es5-\"><a name=\"12.1 ES5之前的模拟的类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.1 ES5之前的模拟的类</h2><p>? 在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：</p>\r\n<pre><code>function PersonType(name) {\r\n    this.name = name;\r\n}\r\n\r\nPersonType.prototype.sayName = function() {\r\n    console.log(this.name);\r\n};\r\n\r\nlet person = new PersonType(&quot;Nicholas&quot;);\r\nperson.sayName();   // 输出 &quot;Nicholas&quot;\r\n\r\nconsole.log(person instanceof PersonType);  // true\r\nconsole.log(person instanceof Object);      // true\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<p>前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。</p>\r\n<h2 id=\"h2-12-2-es6-\"><a name=\"12.2 ES6中基本的类声明\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.2 ES6中基本的类声明</h2><blockquote>\r\n<p>在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。</p>\r\n</blockquote>\r\n<pre><code>//class关键字必须是小写。   后面就是跟的类名\r\nclass PersonClass {\r\n    // 等效于 PersonType 构造函数。\r\n    constructor(name) {  //这个表示类的构造函数。constuctor也是关键字必须小写。\r\n        this.name = name;  //创建属性。  也叫当前类型的自有属性。\r\n    } \r\n    // 等效于 PersonType.prototype.sayName.   这里的sayName使用了我们前面的简写的方式。\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n}\r\nlet person = new PersonClass(&quot;Nicholas&quot;);\r\nperson.sayName();   // 输出 &quot;Nicholas&quot;\r\n\r\nconsole.log(person instanceof PersonClass);     // true\r\nconsole.log(person instanceof Object);          // true\r\n\r\nconsole.log(typeof PersonClass);                    // &quot;function&quot;\r\nconsole.log(typeof PersonClass.prototype.sayName);  // &quot;function&quot;\r\n</code></pre><blockquote>\r\n<p>说明：</p>\r\n</blockquote>\r\n<ol>\r\n<li>自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 <strong>尽可能的将所有自有属性创建在构造函数中</strong>，这样当查找属性时可以做到一目了然。</li><li>类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。</li></ol>\r\n<p><strong><em>虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记</em></strong></p>\r\n<ol>\r\n<li>类声明和函数定义不同，<strong>类的声明是不会被提升的</strong>。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。</li><li>类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。</li><li>所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。</li><li>所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。</li><li>不使用 new 来调用类构造函数会抛出错误。也就是 <strong>必须使用new 类()</strong> 的方式使用</li><li>试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的）</li></ol>\r\n<h2 id=\"h2-12-2-\"><a name=\"12.2 匿名类表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.2 匿名类表达式</h2><blockquote>\r\n<p>函数有函数表达式，类也有类表达式。</p>\r\n<p>类表达式的功能和前面的类的声明是一样的。</p>\r\n</blockquote>\r\n<pre><code>let PersonClass = class {\r\n\r\n    // 等效于 PersonType 构造函数\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    // 等效于 PersonType.prototype.sayName\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n};\r\n\r\nlet person = new PersonClass(&quot;Nicholas&quot;);\r\nperson.sayName();   // 输出 &quot;Nicholas&quot;\r\n\r\nconsole.log(person instanceof PersonClass);     // true\r\nconsole.log(person instanceof Object);          // true\r\n\r\nconsole.log(typeof PersonClass);                    // &quot;function&quot;\r\nconsole.log(typeof PersonClass.prototype.sayName);  // &quot;function&quot;\r\n</code></pre><h2 id=\"h2-12-3-\"><a name=\"12.3 具名类表达式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.3 具名类表达式</h2><pre><code>\r\nlet PersonClass = class PersonClass2{\r\n\r\n    // 等效于 PersonType 构造函数\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    // 等效于 PersonType.prototype.sayName\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n};\r\n</code></pre><blockquote>\r\n<p>注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的.</p>\r\n</blockquote>\r\n<h2 id=\"h2-12-4-\"><a name=\"12.4 作为一等公民的类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.4 作为一等公民的类型</h2><blockquote>\r\n<p>在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。</p>\r\n<p>类也是一等公民。</p>\r\n</blockquote>\r\n<ol>\r\n<li>类可以作为参数传递</li></ol>\r\n<pre><code>function createObject(classDef) {\r\n    return new classDef();\r\n}\r\n\r\nlet obj = createObject(class {\r\n\r\n    sayHi() {\r\n        console.log(&quot;Hi!&quot;);\r\n    }\r\n});\r\n\r\nobj.sayHi();        // &quot;Hi!&quot;\r\n</code></pre><ol>\r\n<li>立即调用类构造函数，创建单例</li></ol>\r\n<pre><code>let person = new class {\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n\r\n}(&quot;Nicholas&quot;);\r\n\r\nperson.sayName();       // &quot;Nicholas&quot;\r\n</code></pre><h2 id=\"h2-12-5-\"><a name=\"12.5 动态计算类成员的命名\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.5 动态计算类成员的命名</h2><blockquote>\r\n<p>类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算)</p>\r\n</blockquote>\r\n<pre><code>let methodName = &quot;sayName&quot;;\r\nclass PersonClass {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    [methodName]() {\r\n        console.log(this.name);\r\n    }\r\n}\r\nlet me = new PersonClass(&quot;Nicholas&quot;);\r\nme.sayName();           // &quot;Nicholas&quot;\r\n</code></pre><h2 id=\"h2-12-6-\"><a name=\"12.6 静态成员\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.6 静态成员</h2><blockquote>\r\n<p>在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。</p>\r\n</blockquote>\r\n<pre><code>function PersonType(name) {\r\n    this.name = name;\r\n}\r\n// 静态方法。  直接添加到构造方法上。  (其实是把构造函数当做一个普通的对象来用。)\r\nPersonType.create = function(name) {\r\n    return new PersonType(name);\r\n};\r\n// 实例方法\r\nPersonType.prototype.sayName = function() {\r\n    console.log(this.name);\r\n};\r\nvar person = PersonType.create(&quot;Nicholas&quot;);\r\n</code></pre><blockquote>\r\n<p>在上面的create方法在其他语言中一般都是作为静态方法来使用的。</p>\r\n</blockquote>\r\n<p><strong>下面高能，请注意：</strong></p>\r\n<p>ECMAScript 6 的类通过在方法之前使用正式的 <strong><em>static</em></strong> 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的：</p>\r\n<pre><code>class PersonClass {\r\n\r\n    // 等效于 PersonType 构造函数\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    // 等效于 PersonType.prototype.sayName\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n\r\n    // 等效于 PersonType.create。\r\n    static create(name) {\r\n        return new PersonClass(name);\r\n    }\r\n}\r\n\r\nlet person = PersonClass.create(&quot;Nicholas&quot;);\r\n</code></pre><blockquote>\r\n<p>注意：静态成员通过实例对象不能访问，只能通过类名访问！！！</p>\r\n<p>通过和ES5模拟静态方法的例子你应该知道为啥了吧</p>\r\n</blockquote>\r\n<h2 id=\"h2-12-7-es6-\"><a name=\"12.7 ES6中的继承\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.7 ES6中的继承</h2><blockquote>\r\n<p>在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子：</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function Father(name) {\r\n        this.name = name;\r\n    }\r\n    Father.prototype.sayName = function () {\r\n        console.log(this.name);\r\n    }\r\n\r\n    function Son(name,age) {\r\n        Father.call(this, name);\r\n        this.age = age;\r\n    }\r\n    Son.prototype = new Father();\r\n    Son.prototype.constructor = Son;\r\n    Son.prototype.sayAge = function () {\r\n        console.log(this.age);\r\n    }\r\n\r\n    var son1 = new Son(&quot;儿子&quot;, 20);\r\n    son1.sayAge();  //20\r\n    son1.sayName(); //儿子\r\n\r\n&lt;/script&gt;\r\n</code></pre><h3 id=\"h3-12-7-1-\"><a name=\"12.7.1 继承的基本写法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.7.1 继承的基本写法</h3><blockquote>\r\n<p>如果在ES6通过类的方式完成继承就简单了很多。</p>\r\n<p>需要用到一个新的关键字：extends</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    class Father{\r\n        constructor(name){\r\n            this.name = name;\r\n        }\r\n        sayName(){\r\n            console.log(this.name);\r\n        }\r\n    }\r\n    class Son extends Father{  //extents后面跟表示要继承的类型\r\n        constructor(name, age){\r\n            super(name);  //相当于以前的：Father.call(this, name);\r\n            this.age = age;\r\n        }\r\n        //子类独有的方法\r\n        sayAge(){\r\n            console.log(this.age);\r\n        }\r\n    }\r\n\r\n    var son1 = new Son(&quot;李四&quot;, 30);\r\n    son1.sayAge();\r\n    son1.sayName();\r\n    console.log(son1 instanceof Son);  // true\r\n    console.log(son1 instanceof Father);  //true\r\n\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。</p>\r\n</blockquote>\r\n<p><strong><em>关于super的使用，有几点需要注意：</em></strong></p>\r\n<ol>\r\n<li>你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。</li><li>你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。</li><li>在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。</li></ol>\r\n<h3 id=\"h3-12-7-2-\"><a name=\"12.7.2 在子类中屏蔽父类的方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.7.2 在子类中屏蔽父类的方法</h3><blockquote>\r\n<p>如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 )</p>\r\n</blockquote>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    class Father{\r\n        constructor(name){\r\n            this.name = name;\r\n        }\r\n        sayName(){\r\n            console.log(this.name);\r\n        }\r\n    }\r\n    class Son extends Father{  //extents后面跟表示要继承的类型\r\n        constructor(name, age){\r\n            super(name);  //相当于以前的：Father.call(this, name);\r\n            this.age = age;\r\n        }\r\n        //子类独有的方法\r\n        sayAge(){\r\n            console.log(this.age);\r\n        }\r\n        //子类中的方法会屏蔽到父类中的同名方法。\r\n        sayName(){\r\n            super.syaName();  //调用被覆盖的父类中的方法。 \r\n            console.log(&quot;我是子类的方法，我屏蔽了父类：&quot; + name);\r\n        }\r\n    }\r\n\r\n    var son1 = new Son(&quot;李四&quot;, 30);\r\n    son1.sayAge();\r\n    son1.sayName();\r\n&lt;/script&gt;\r\n</code></pre><blockquote>\r\n<p>如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。</p>\r\n<p>注意：</p>\r\n<ol>\r\n<li>如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法</li><li>普通方法调用需要使用super.父类的方法() 来调用。</li></ol>\r\n</blockquote>\r\n<h3 id=\"h3-12-7-3-\"><a name=\"12.7.3 静态方法也可以继承\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12.7.3 静态方法也可以继承</h3><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n   class Father{\r\n       static foo(){\r\n           console.log(&quot;我是父类的静态方法&quot;);\r\n       }\r\n   }\r\n   class Son extends Father{\r\n\r\n   }\r\n   Son.foo(); //子类也继承了父类的静态方法。  这种方式调用和直接通过父类名调用时一样的。\r\n\r\n&lt;/script&gt;\r\n</code></pre>', '91', '\r\n# 八、新的基本类型：Symbol\r\n\r\n> 以前我们有5种基本数据类型：Number、String、Boolean、Null、Undefined\r\n> \r\n> ES6新增了一种新的数据类型：Symbol\r\n> \r\n> 在ES5之前我们都没办法创建私有变量，只能想办法去封装。symbol 来创建私有成员，这也是 JavaScript 开发者长久以来期待的一项特性。\r\n\r\n## 8.1 创建Symbol\r\n\r\n> Symbol在基本数据类型中是比较特别的。我们以前的都可以用字面量去创建基本数据类型的数据，但是Symbol却不可以使用字面量的是形式去创建。\r\n> \r\n> 我们可以使用symbol全局函数来创建Symbol。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let firstName = Symbol();   //创建一个Symbol\r\n    let person = {};\r\n\r\n    person[firstName] = \"张三\";\r\n    console.log(person[firstName]);     // \"张三\"\r\n</script>\r\n```\r\n\r\n说明：上面的代码中，firstName 作为 symbol 类型被创建并赋值给 person 对象以作其属性。每次访问这个属性时必须使用该 symbol 。\r\n\r\n> 在创建Symbol的时候，也可以传入字符串，这个字符串也仅仅是在调试输出的时候方便，实际没有啥用处。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var s1 = Symbol(\"abc\");\r\n    var s2 = Symbol(\"abc\");\r\n    console.log(s1 == s2); //false\r\n</script>\r\n```\r\n\r\n> 注意：任意两个Symbol都不会相等，即使创建他们的时候使用了相同的参数。\r\n\r\n## 8.2 识别Symbol\r\n\r\n> 既然 symbol 是基础类型，你可以使用 typeof 操作符来判断变量是否为 symbol 。ECMAScript 6 拓展了 typeof 使其操作 symbol 时返回 “symbol”。例如：\r\n\r\n```\r\nlet symbol = Symbol();\r\nconsole.log(typeof symbol);         // \"symbol\"\r\n```\r\n\r\n## 8.3 Symbol作为属性名\r\n\r\n? 由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\r\n\r\n```\r\nvar mySymbol = Symbol();\r\n\r\n// 第一种写法\r\n\r\nvar a = {};\r\n\r\na[mySymbol] = \'Hello!\';\r\n\r\n// 第二种写法\r\n\r\nvar a = {\r\n\r\n    [mySymbol]: \'Hello!\'\r\n}\r\n```\r\n\r\n> 以上两种写法都是相同的结果\r\n\r\n注意：\r\n\r\n1.  symbol作为对象的属性的时候，只能使用 [ ] 去访问，不能使用点去访问。\r\n\r\n2.  symbol作为对象的属性名使用的时候，该属性还是公开属性，不是私有属性。但是这个时候使用for… in和for…of\r\n\r\n    时无法遍历到这个symbol属性的。\r\n\r\n## 8.4 Symbol属性名的遍历\r\n\r\n? Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。\r\n\r\n> 看下面的代码\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var obj = {};\r\n    var a = Symbol(\'a\');\r\n    var b = Symbol(\'b\');\r\n\r\n    obj[a] = \'Hello\';\r\n    obj[b] = \'World\';\r\n    // 返回obj对象所有Symbol类型的属性名组成的数组。\r\n    var objectSymbols = Object.getOwnPropertySymbols(obj);\r\n    console.log(objectSymbols)  //[Symbol(a), Symbol(b)]\r\n</script>\r\n```\r\n\r\n> 看下面的代码\r\n\r\n```\r\nvar obj = {};\r\n\r\nvar foo = Symbol(\"foo\");\r\nobj[foo] = \"lisi\";\r\nfor (var i in obj) {\r\n  console.log(i); // 无输出 。   因为遍历不到Symbol型的属性 \r\n}\r\n\r\nObject.getOwnPropertyNames(obj);// []   只能拿到非Symbol类型的属性\r\n\r\nObject.getOwnPropertySymbols(obj) //[Symbol(foo)]\r\n\r\n```\r\n\r\n> 还有一个新API可以拿到所有类型的属性，包括常规和Symbol型的。\r\n> \r\n> Reflect.ownKeys\r\n\r\n```\r\nlet obj = {\r\n  [Symbol(\'my_key\')]: 1,\r\n  enum: 2,\r\n  nonEnum: 3\r\n};\r\n\r\nReflect.ownKeys(obj);//  [\"enum\", \"nonEnum\", Symbol(my_key)]\r\n\r\n```\r\n\r\n说明：\r\n\r\n1.  由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。\r\n\r\n## 8.5 Symbol.for(字符串)和Symbol.keyFor(symbol类型的值)\r\n\r\n> 一、Symbol.for(字符串参数)：在全局环境中搜索 以该字符串作为参数的Symbol值，如果搜到则返回这个sybol，如果搜不到则创建一个Symbol，并把它注册在全局环境中。\r\n\r\n```\r\n    <script type=\"text/javascript\">\r\n        //第一次搜不到，则新创建一个返回，并在全局环境(window)中注册\r\n        var a = Symbol.for(\"foo\");\r\n        //第二次搜到上次创建的\r\n        var b = Symbol.for(\"foo\");\r\n        console.log(a === b);  //因为两次搜到的是同一个Symbol，所以此处是true\r\n    </script>\r\n```\r\n\r\n> Symbol.for()和Symbol()都可以创建Symbol类型的数据。\r\n> \r\n> 二者区别：\r\n> \r\n> 1.  Symbol.for()对同样的字符串，每次得到结果肯定是一样的。因为都是从全局环境中搜索。\r\n> 2.  Symbol()则不会有搜索的过程，每次都是一个全新的不同的symbol，而且也不会向全局环境中注册。\r\n> \r\n> 看下面的代码\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n   var a = Symbol(\"foo\");\r\n   var b = Symbol.for(\"foo\");\r\n   console.log(a == b); //false\r\n</script>\r\n```\r\n\r\n> 二、Symbol.keyFor(symbol):返回一个已经注册的symbol的”key”。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var a = Symbol(\"foo\");\r\n    var b = Symbol.for(\"foo\");\r\n    console.log(Symbol.keyFor(a)); // undefined.   因为a没有想全局环境中登记，所以是undefinded\r\n    console.log(Symbol.keyFor(b)); // foo\r\n</script>\r\n```\r\n\r\n# 九、Set数据结构\r\n\r\n? JavaScript 在绝大部分历史时期内只有一种集合类型，那就是数组。数组在 JavaScript 中的使用方式和其它语言很相似，但是其它集合类型的缺乏导致数组也经常被当作队列（queues）和栈（stacks）来使用。\r\n\r\n? 因为数组的索引只能是数字类型，当开发者觉得非数字类型的索引是必要的时候会使用非数组对象。这项用法促进了以非类数组对象为基础的 set 和 map 集合类型的实现。\r\n\r\n> Set是类似数组的一种结构，可以存储数据，与数组的区别主要是 **Set中的元素不能重复，而数组中的元素可以重复**。\r\n> \r\n> 一句话总结：**_Set类型是一个包含无重复元素的有序列表_**\r\n\r\n## 9.1 创建Set和并添加元素\r\n\r\n> Set本身是一个构造函数。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //创建Set数据结构对象。\r\n    var s = new Set();\r\n    //调用set对象的add方法，向set中添加元素\r\n    s.add(\"a\");\r\n    s.add(\"c\");\r\n    s.add(\"b\");\r\n    //set的size属性可以获取set中元素的个数\r\n    console.log(s.size)\r\n</script>\r\n```\r\n\r\n## 9.2 Set中不能添加重复元素\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var s = new Set();\r\n    s.add(\"a\");\r\n    s.add(\"c\");\r\n    s.add(\"b\");\r\n    s.add(\"a\");  //重复，所以添加失败。注意这个地方并不会保存。\r\n    console.log(s.size); // 长度是3\r\n</script>   \r\n```\r\n\r\n> 看下面的代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var s = new Set();\r\n    s.add(5);\r\n    s.add(\"5\");\r\n    console.log(s.size); // 长度是2\r\n</script>\r\n```\r\n\r\n? 在上面的代码中，数字5和字符串5都会添加成功。为什么呢？\r\n\r\n> Set是使用什么机制来判断两个元素是否相等的呢？\r\n> \r\n> **是通过我们前面说过的 Object.is(a, b) 来判断两个元素是否相等。**\r\n> \r\n> 回忆一下：这个方法除了 +0和-0、NaN和NaN认为相等，其余和三个 === 是完全一样的。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var s = new Set();\r\n    s.add(+0);\r\n    s.add(-0);  //重复添加不进去\r\n    s.add(NaN);\r\n    s.add(NaN); //重复添加不进去\r\n    s.add([]);\r\n    s.add([]);  //两个空数组不相等，所以可以添加进去\r\n    s.add({});\r\n    s.add({});  // 两个空对象也不重复，所以也可以添加进去\r\n    console.log(s.size); // 长度是6\r\n</script>\r\n```\r\n\r\n## 9.3 使用数组初始化Set\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。\r\n    var s = new Set([2, 3, 2, 2, 4]);\r\n    console.log(s.size)\r\n</script>\r\n```\r\n\r\n## 9.4 判断一个值是否在Set中\r\n\r\n> 使用Set的 has() 方法可以判断一个值是否在这个set中。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let set = new Set();\r\n    set.add(5);\r\n    set.add(\"5\");\r\n\r\n    console.log(set.has(5));    // true\r\n    console.log(set.has(6));    // false\r\n</script>\r\n```\r\n\r\n## 9.5 移除Set中的元素\r\n\r\n> delete(要删除的值) ：删除单个值\r\n> \r\n> clear()：清空所有的值\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let set = new Set();\r\n    set.add(5);\r\n    set.add(\"5\");\r\n\r\n    console.log(set.has(5));    // true\r\n\r\n    set.delete(5);\r\n\r\n    console.log(set.has(5));    // false\r\n    console.log(set.size);      // 1\r\n\r\n    set.clear();\r\n\r\n    console.log(set.has(\"5\"));  // false\r\n    console.log(set.size);      // 0\r\n</script>\r\n```\r\n\r\n## 9.6 遍历Set\r\n\r\n> 数组有个方法forEach可以遍历数组。\r\n> \r\n> 1.  Set也有forEach可以遍历Set。\r\n> \r\n> 使用Set的forEach遍历时的回调函数有三个参数：\r\n> \r\n> function (value, key, ownerSet){\r\n> \r\n> }\r\n> \r\n> 参数1：遍历到的元素的值\r\n> \r\n> 参数2：对set集合来说，参数2的值和参数1的值是完全一样的。\r\n> \r\n> 参数3：这个set自己\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let set = new Set([\"a\", \"c\", \"b\", 9]);\r\n    set.forEach(function (v, k, s) {\r\n        console.log(v + \"   \" + (v === k) + \"  \" + (s === set));   // 永远是true\r\n    })\r\n\r\n</script>\r\n```\r\n\r\n> 1.  for…of也可以遍历set。\r\n\r\n```\r\nfor(var v of set){\r\n    console.log(v)\r\n}\r\n```\r\n\r\n## 9.7 将Set转换为数组\r\n\r\n> 将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。\r\n> \r\n> **把Set转换为数组使用前面讲到的扩展运算符也很容易**\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let set = new Set([1, 2, 3, 3, 3, 4, 5]),\r\n        arr = [...set];  //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响\r\n\r\n    console.log(arr);             // [1,2,3,4,5]\r\n</script>\r\n```\r\n\r\n> 这种情况在需要去数组中重复元素的时候非常好用。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function eliminateDuplicates(items) {\r\n        return [...new Set(items)];\r\n    }\r\n    let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1],\r\n        //返回的是新的没有重复元素的数组。\r\n        noDuplicates = eliminateDuplicates(numbers);\r\n    console.log(noDuplicates);      // [1,2,3,4,5]\r\n</script>\r\n```\r\n\r\n* * *\r\n\r\n**_Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map_**\r\n\r\n# 十、Map数据结构\r\n\r\n? ECMAScript 6 中的 map 类型包含一组有序的键值对，其中键和值可以是任何类型。\r\n\r\n? 键的比较结果由 Object.is() 来决定，所以你可以同时使用 5 和 “5” 做为键来存储，因为它们是不同的类型。\r\n\r\n? 这和使用对象属性做为值的方法大相径庭，因为 **对象的属性会被强制转换为字符串类型**。\r\n\r\n## 10.1 创建Map对象和Map的基本的存取操作\r\n\r\n> 1.  Map创建也是使用Map构造函数\r\n> 2.  向Map存储键值对使用set(key, value);方法\r\n> 3.  可以使用get(key),来获取指定key对应的value\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var map = new Map();\r\n    map.set(\"a\", \"lisi\");\r\n    map.set(\"b\", \"zhangsan\");\r\n    map.set(\"b\", \"zhangsan222\");  // 第二次添加，新的value会替换掉旧的\r\n    console.log(map.get(\"a\"));\r\n    console.log(map.get(\"b\"));   //zhangsan222\r\n    console.log(map.get(\"c\")); //undefined.如果key不存在，则返回undefined\r\n    console.log(map.size); //2\r\n</script>\r\n```\r\n\r\n## 10.2 Map与Set类似的3个方法\r\n\r\n*   has(key) - 判断给定的 key 是否在 map 中存在\r\n*   delete(key) - 移除 map 中的 key 及对应的值\r\n*   clear() - 移除 map 中所有的键值对\r\n\r\n## 10.3 初始化Map\r\n\r\n> 创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。\r\n> \r\n> 也就是传入的实际是一个二维数组！\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n  //map接受一个二维数组\r\n    var map = new Map([\r\n      //每一个数组中，第一个是是map的可以，第二个是map的value。如果只有第一个，则值是undefined\r\n        [\"name\", \"lisi\"],  \r\n        [\"age\", 20],\r\n        [\"sex\", \"nan\"]\r\n    ]);\r\n    console.log(map.size);\r\n    console.log(map.get(\"name\"))\r\n</script>   \r\n```\r\n\r\n## 10.4 Map的forEach方法\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var map = new Map([\r\n        [\"name\", \"李四\"],\r\n        [\"age\", 20],\r\n        [\"sex\", \"nan\"]\r\n    ]);\r\n    /*\r\n        回调函数有函数：\r\n        参数1：键值对的value\r\n        参数2：键值对的key\r\n        参数3：map对象本身\r\n     */\r\n    map.forEach(function (value, key, ownMap) {\r\n        console.log(`key=${key} ,vlue=${value}`);\r\n        console.log(this);\r\n    })\r\n </script>\r\n```\r\n\r\n# 十一、迭代器和for…of循环\r\n\r\n## 11.1 循环问题\r\n\r\n```\r\nvar colors = [\"red\", \"green\", \"blue\"];\r\n\r\nfor (var i = 0, len = colors.length; i < len; i++) {\r\n    console.log(colors[i]);\r\n}\r\n```\r\n\r\n> 上面的代码写起来简单，但是实际使用的过程中，我们需求自己去控制变量，如果有嵌套的情况下，还要控制多个变量，很容易出错。\r\n> \r\n> 迭代器就是为了解决这个问题的。\r\n\r\n## 11.2 什么是迭代器\r\n\r\n? 迭代器只是带有特殊接口(方法)的对象。所有迭代器对象都带有 next() 方法并返回一个包含两个属性的结果对象。这些属性分别是 value 和 done，前者代表下一个位置的值，后者在没有更多值可供迭代的时候为 true 。迭代器带有一个内部指针，来指向集合中某个值的位置。当 next() 方法调用后，指针下一位置的值会被返回。\r\n\r\n? 若你在末尾的值被返回之后继续调用 next()，那么返回的 done 属性值为 true，value 的值则由迭代器设定。该值并不属于数据集，而是专门为数据关联的附加信息，如若该信息并未指定则返回 undefined 。迭代器返回的值和函数返回值有些类似，因为两者都是返回给调用者信息的最终手段。\r\n\r\n> 我们可以用ES5之前的知识手动创建一个迭代器：\r\n\r\n```\r\nfunction createIterator(items) {\r\n    var i = 0;\r\n    return {\r\n        next: function() {\r\n            var done = (i >= items.length);\r\n            var value = !done ? items[i++] : undefined;\r\n            return {\r\n                done: done,\r\n                value: value\r\n            };\r\n\r\n        }\r\n    };\r\n}\r\n//创建一个可以在指定数组上面迭代的迭代器对象。\r\nvar iterator = createIterator([1, 2, 3]);\r\n\r\nconsole.log(iterator.next());           // \"{ value: 1, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: 2, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: 3, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: undefined, done: true }\"\r\n\r\n// for all further calls\r\nconsole.log(iterator.next());           // \"{ value: undefined, done: true }\"\r\n```\r\n\r\n从以上的示例来看，根据 ECMAScript 6 规范模拟实现的迭代器还是有些复杂。\r\n\r\n幸运的是，ECMAScript 6 还提供了生成器，使得迭代器对象的创建容易了许多。\r\n\r\n## 11.3 生成器函数\r\n\r\n> **生成器函数就是返回迭代器的函数！**\r\n> \r\n> 生成器函数由 function 关键字和之后的星号（*）标识，同时还能使用新的 yield 关键字。\r\n> \r\n> 看下面代码：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    //生成器函数。  注意中间的 * 不能丢\r\n    function * createIterator() {\r\n        //每个yield的后面的值表示我们迭代到的值。   yield也定义了我们迭代的顺序。\r\n        yield 3;\r\n        yield 4;\r\n        yield 2;\r\n    }\r\n    var it = createIterator();\r\n    console.log(it.next().value);   // 2\r\n    console.log(it.next().value);   // 4\r\n    console.log(it.next().value);   // 2\r\n    console.log(it.next().value);  //undefined\r\n\r\n</script>\r\n```\r\n\r\n> **迭代器函数也是函数，所以他可以像正常的函数一样调用，但是生成器函数会自动返回一个迭代器对象。**\r\n> \r\n> 每调用一次迭代器的next方法，如果碰到yield都会返回一个迭代到的一个对象，然后停止继续执行，直到下次调用next方法，会从上次停止的地方继续执行。\r\n\r\n```\r\n//这个迭代器函数返回的迭代器可以迭代传入的数组中的所有元素。\r\nfunction *createIterator(items) {\r\n    for (let i = 0; i < items.length; i++) {\r\n      //每调用一次next，碰到yild程序就会停止，并返回迭代到的对象 {value : items[i], done : true}\r\n        yield items[i]; \r\n    }\r\n}\r\n\r\nlet iterator = createIterator([1, 2, 3]);\r\n\r\nconsole.log(iterator.next());           // \"{ value: 1, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: 2, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: 3, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: undefined, done: true }\"\r\n\r\n// 进一步调用\r\nconsole.log(iterator.next());           // \"{ value: undefined, done: true }\"\r\n```\r\n\r\n> 注意：\r\n\r\n1.  yield 关键字只能 **直接用在生成器内部** 。在其它地方甚至是生成器内部的函数中使用都会抛出语法错误。\r\n\r\n## 11.4 生成器函数表达式\r\n\r\n> 你可以使用函数表达式来创建生成器，只需在 function 关键字和圆括号之间添加星号（*）。例如：\r\n\r\n```\r\nlet createIterator = function *(items) {\r\n    for (let i = 0; i < items.length; i++) {\r\n        yield items[i];\r\n    }\r\n};\r\n\r\nlet iterator = createIterator([1, 2, 3]);\r\n\r\nconsole.log(iterator.next());           // \"{ value: 1, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: 2, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: 3, done: false }\"\r\nconsole.log(iterator.next());           // \"{ value: undefined, done: true }\"\r\n\r\n// 进一步调用\r\nconsole.log(iterator.next());           // \"{ value: undefined, done: true }\"\r\n```\r\n\r\n> 注意：无法使用箭头函数来创建生成器。\r\n\r\n## 11.5 可迭代类型和for-of迭代循环\r\n\r\n> 迭代器的主要工作就是迭代数据，但是不是所有的数据都是可以迭代的。\r\n\r\n? 与迭代器紧密相关的是，可迭代类型是指那些包含 Symbol.iterator 属性的对象。\r\n\r\n? 该 symbol 类型定义了返回迭代器的函数。在 ECMAScript 6 中，所有的集合对象（数组，set 和 map）与字符串都是可迭代类型，因此它们都有默认的迭代器。可迭代类型是为了 ECMAScript6 新添加的 **for-of** 循环而设计的。\r\n\r\n? 换句话说，默认情况下只有 **数组、set、Map和字符串**才可以使用迭代器去迭代。 (也就可以使用for…of了)\r\n\r\n? for…of循环只迭代出来的元素，根本不管索引！不管索引！不管索引！重要的问题重复三遍！\r\n\r\n> 使用 for…of 迭代数组：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var arr = [\"a\", \"c\", \"b\", \"d\"];\r\n    for(var item of arr){\r\n        console.log(item)\r\n    }\r\n\r\n</script>\r\n```\r\n\r\n> 使用 for…of 迭代Set:\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var set = new Set([\"a\", \"c\", \"b\", \"d\"]);\r\n    for(var item of set){\r\n        console.log(item)\r\n    }\r\n\r\n</script>\r\n```\r\n\r\n> 使用 for…of 迭代Map：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var map = new Map([[\"name\", \"lisi\"],[\"sex\", \"男\"],[\"age\", 20]]);\r\n    map.set(\"aaa\", \"bbb\")\r\n    for(var item of map){\r\n        console.log(item);  //注意：这里迭代到的是由key和value组成的数组。\r\n    }\r\n</script>\r\n```\r\n\r\n> 使用for … of迭代字符串\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    var s = \"abcd\";\r\n    for(let c of s){\r\n        console.log(c)\r\n    }\r\n</script>\r\n```\r\n\r\n> 注意：for…of 只能迭代可以迭代的对象，对于非可迭代对象使用for…of会抛出异常\r\n\r\n?\r\n\r\n说明：以数组为例。\r\n\r\n? for-of 循环首先会调用 values 数组的 Symbol.iterator 方法来获取迭代器（Symbol.iterator 方法由幕后的 JavaScript 引擎调用）。之后再调用 iterator.next() 并将结果对象中的 value 属性值，即 1，2，3，依次赋给 num 变量。当检测到结果对象中的 done 为 true，循环会退出，所以 num 不会被赋值为 undefined 。\r\n\r\n? 如果你只想简单的迭代数组或集合中的元素，那么 for-of 循环比 for 要更好。for-of 一般不容易出错，因为要追踪的条件更少。所以还是把 for 循环留给复杂控制条件的需求吧。\r\n\r\n## 11.6 访问可迭代类型的默认迭代器\r\n\r\n> Symbol.iterator是可迭代类型的一个方法，调用这个方法就可以获取到他的默认迭代器。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    let s = \"abcd\";\r\n    let it = s[Symbol.iterator]();  //调用字符串的Symbol.iterator方法\r\n    console.log(it.next());  //返回迭代器迭代到的第一个对象\r\n</script>\r\n```\r\n\r\n> 因为Symbol可以返回一个对象的默认迭代器，所以我们可以使用它来判断一个对象是否可迭代\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function isIterable(object) {\r\n        return typeof object[Symbol.iterator] === \"function\";\r\n    }\r\n\r\n    console.log(isIterable([1, 2, 3]));     // true\r\n    console.log(isIterable(\"Hello\"));       // true\r\n    console.log(isIterable(new Map()));     // true\r\n    console.log(isIterable(new Set()));     // true\r\n    console.log(isIterable({\"name\":\"李四\"})); // false。普通对象不可迭代\r\n</script>\r\n```\r\n\r\n## 11.7 自定义可迭代类型\r\n\r\n> 开发者自定义的对象默认是不可迭代类型，但是你可以为它们创建 Symbol.iterator 属性并指定一个生成器来使这个对象可迭代。例如：\r\n\r\n```\r\nlet collection = {\r\n    items: [],\r\n    *[Symbol.iterator]() {\r\n        for (let item of this.items) {\r\n            yield item;\r\n        }\r\n    }\r\n\r\n};\r\n\r\ncollection.items.push(1);\r\ncollection.items.push(2);\r\ncollection.items.push(3);\r\n\r\nfor (let x of collection) {\r\n    console.log(x);\r\n}\r\n```\r\n\r\n# 十二、类\r\n\r\n> 和大多数面向对象的语言（object-oriented programming language）不同，JavaScript 在诞生之初并不支持使用类和传统的类继承并作为主要的定义方式来创建相似或关联的对象。\r\n> \r\n> 这很令开发者困惑，而且在早于 ECMAScript 1 到 ECMAScript 5 这段时期，很多库都创建了一些实用工具（utility）来让 JavaScript 从表层上支持类。\r\n> \r\n> 尽管一些 JavaScript 开发者强烈主张该语言不需要类，但由于大量的库都对类做了实现，ECMAScript 6 也顺势将其引入。\r\n\r\n## 12.1 ES5之前的模拟的类\r\n\r\n? 在 ECMAScript 5 或更早的版本中，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：\r\n\r\n```\r\nfunction PersonType(name) {\r\n    this.name = name;\r\n}\r\n\r\nPersonType.prototype.sayName = function() {\r\n    console.log(this.name);\r\n};\r\n\r\nlet person = new PersonType(\"Nicholas\");\r\nperson.sayName();   // 输出 \"Nicholas\"\r\n\r\nconsole.log(person instanceof PersonType);  // true\r\nconsole.log(person instanceof Object);      // true\r\n```\r\n\r\n> 说明：\r\n\r\n前面的PersonType我们以前一直叫做构造函数，其实他就是一个类型，因为他确实表示了一种类型。\r\n\r\n## 12.2 ES6中基本的类声明\r\n\r\n> 在ES6直接借鉴其他语言，引入了类的概念。所以再实现上面那种模拟 的类就容易了很多。\r\n\r\n```\r\n//class关键字必须是小写。   后面就是跟的类名\r\nclass PersonClass {\r\n    // 等效于 PersonType 构造函数。\r\n    constructor(name) {  //这个表示类的构造函数。constuctor也是关键字必须小写。\r\n        this.name = name;  //创建属性。  也叫当前类型的自有属性。\r\n    } \r\n    // 等效于 PersonType.prototype.sayName.   这里的sayName使用了我们前面的简写的方式。\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n}\r\nlet person = new PersonClass(\"Nicholas\");\r\nperson.sayName();   // 输出 \"Nicholas\"\r\n\r\nconsole.log(person instanceof PersonClass);     // true\r\nconsole.log(person instanceof Object);          // true\r\n\r\nconsole.log(typeof PersonClass);                    // \"function\"\r\nconsole.log(typeof PersonClass.prototype.sayName);  // \"function\"\r\n```\r\n\r\n> 说明：\r\n\r\n1.  自有属性：属性只出现在实例而不是原型上，而且只能由构造函数和方法来创建。在本例中，name 就是自有属性。我建议 **尽可能的将所有自有属性创建在构造函数中**，这样当查找属性时可以做到一目了然。\r\n2.  类声明只是上例中自定义类型的语法糖。PersonClass 声明实际上创建了一个行为和 constructor 方法相同的构造函数，这也是 typeof PersonClass 返回 “function” 的原因。sayName() 在本例中作为 PersonClass.prototype 的方法，和上个示例中 sayName() 和 PersonType.prototype 关系一致。这些相似度允许你混合使用自定义类型和类而不需要纠结使用方式。\r\n\r\n**_虽然类和以前的使用构造函数+原型的方式很像，但是还是有一些不太相同的地方，而且要牢记_**\r\n\r\n1.  类声明和函数定义不同，**类的声明是不会被提升的**。类声明的行为和 let 比较相似，所以当执行流作用到类声明之前类会存在于暂存性死区（temporal dead zone）内。\r\n2.  类声明中的代码自动运行在严格模式下，同时没有任何办法可以手动切换到非严格模式。\r\n3.  所有的方法都是不可枚举的（non-enumerable），这和自定义类型相比是个显著的差异，因为后者需要使用 Object.defineProperty() 才能定义不可枚举的方法。\r\n4.  所有的方法都不能使用 new 来调用，因为它们没有内部方法 [[Construct]]。\r\n5.  不使用 new 来调用类构造函数会抛出错误。也就是 **必须使用new 类()** 的方式使用\r\n6.  试图在类的方法内部重写类名的行为会抛出错误。（因为在类的内部，类名是作为一个常量存在的）\r\n\r\n## 12.2 匿名类表达式\r\n\r\n> 函数有函数表达式，类也有类表达式。\r\n> \r\n> 类表达式的功能和前面的类的声明是一样的。\r\n\r\n```\r\nlet PersonClass = class {\r\n\r\n    // 等效于 PersonType 构造函数\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    // 等效于 PersonType.prototype.sayName\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n};\r\n\r\nlet person = new PersonClass(\"Nicholas\");\r\nperson.sayName();   // 输出 \"Nicholas\"\r\n\r\nconsole.log(person instanceof PersonClass);     // true\r\nconsole.log(person instanceof Object);          // true\r\n\r\nconsole.log(typeof PersonClass);                    // \"function\"\r\nconsole.log(typeof PersonClass.prototype.sayName);  // \"function\"\r\n```\r\n\r\n## 12.3 具名类表达式\r\n\r\n```\r\n\r\nlet PersonClass = class PersonClass2{\r\n\r\n    // 等效于 PersonType 构造函数\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    // 等效于 PersonType.prototype.sayName\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n};\r\n\r\n```\r\n\r\n> 注意：具名类表达式中PersonClass2这个类名只能在类的内部访问到，在外面是访问不到的.\r\n\r\n## 12.4 作为一等公民的类型\r\n\r\n> 在JavaScript中，函数是作为一等公民存在的。(也叫一等函数)。\r\n> \r\n> 类也是一等公民。\r\n\r\n1.  类可以作为参数传递\r\n\r\n```\r\nfunction createObject(classDef) {\r\n    return new classDef();\r\n}\r\n\r\nlet obj = createObject(class {\r\n\r\n    sayHi() {\r\n        console.log(\"Hi!\");\r\n    }\r\n});\r\n\r\nobj.sayHi();        // \"Hi!\"\r\n```\r\n\r\n1.  立即调用类构造函数，创建单例\r\n\r\n```\r\nlet person = new class {\r\n\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n\r\n}(\"Nicholas\");\r\n\r\nperson.sayName();       // \"Nicholas\"\r\n```\r\n\r\n## 12.5 动态计算类成员的命名\r\n\r\n> 类的成员，也可以像我们前面的对象的属性一样可以动态计算.( 使用[ ] 来计算)\r\n\r\n```\r\nlet methodName = \"sayName\";\r\nclass PersonClass {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    [methodName]() {\r\n        console.log(this.name);\r\n    }\r\n}\r\nlet me = new PersonClass(\"Nicholas\");\r\nme.sayName();           // \"Nicholas\"\r\n```\r\n\r\n## 12.6 静态成员\r\n\r\n> 在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。\r\n\r\n```\r\nfunction PersonType(name) {\r\n    this.name = name;\r\n}\r\n// 静态方法。  直接添加到构造方法上。  (其实是把构造函数当做一个普通的对象来用。)\r\nPersonType.create = function(name) {\r\n    return new PersonType(name);\r\n};\r\n// 实例方法\r\nPersonType.prototype.sayName = function() {\r\n    console.log(this.name);\r\n};\r\nvar person = PersonType.create(\"Nicholas\");\r\n```\r\n\r\n> 在上面的create方法在其他语言中一般都是作为静态方法来使用的。\r\n\r\n**下面高能，请注意：**\r\n\r\nECMAScript 6 的类通过在方法之前使用正式的 **_static_** 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的：\r\n\r\n```\r\nclass PersonClass {\r\n\r\n    // 等效于 PersonType 构造函数\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n\r\n    // 等效于 PersonType.prototype.sayName\r\n    sayName() {\r\n        console.log(this.name);\r\n    }\r\n\r\n    // 等效于 PersonType.create。\r\n    static create(name) {\r\n        return new PersonClass(name);\r\n    }\r\n}\r\n\r\nlet person = PersonClass.create(\"Nicholas\");\r\n```\r\n\r\n> 注意：静态成员通过实例对象不能访问，只能通过类名访问！！！\r\n> \r\n> 通过和ES5模拟静态方法的例子你应该知道为啥了吧\r\n\r\n## 12.7 ES6中的继承\r\n\r\n> 在ES6之前要完成继承，需要写很多的代码。看下面的继承的例子：\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function Father(name) {\r\n        this.name = name;\r\n    }\r\n    Father.prototype.sayName = function () {\r\n        console.log(this.name);\r\n    }\r\n\r\n    function Son(name,age) {\r\n        Father.call(this, name);\r\n        this.age = age;\r\n    }\r\n    Son.prototype = new Father();\r\n    Son.prototype.constructor = Son;\r\n    Son.prototype.sayAge = function () {\r\n        console.log(this.age);\r\n    }\r\n\r\n    var son1 = new Son(\"儿子\", 20);\r\n    son1.sayAge();  //20\r\n    son1.sayName(); //儿子\r\n\r\n</script>\r\n```\r\n\r\n### 12.7.1 继承的基本写法\r\n\r\n> 如果在ES6通过类的方式完成继承就简单了很多。\r\n> \r\n> 需要用到一个新的关键字：extends\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    class Father{\r\n        constructor(name){\r\n            this.name = name;\r\n        }\r\n        sayName(){\r\n            console.log(this.name);\r\n        }\r\n    }\r\n    class Son extends Father{  //extents后面跟表示要继承的类型\r\n        constructor(name, age){\r\n            super(name);  //相当于以前的：Father.call(this, name);\r\n            this.age = age;\r\n        }\r\n        //子类独有的方法\r\n        sayAge(){\r\n            console.log(this.age);\r\n        }\r\n    }\r\n\r\n    var son1 = new Son(\"李四\", 30);\r\n    son1.sayAge();\r\n    son1.sayName();\r\n    console.log(son1 instanceof Son);  // true\r\n    console.log(son1 instanceof Father);  //true\r\n\r\n</script>\r\n```\r\n\r\n> 这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。\r\n\r\n**_关于super的使用，有几点需要注意：_**\r\n\r\n1.  你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。\r\n2.  你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。\r\n3.  在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。\r\n\r\n### 12.7.2 在子类中屏蔽父类的方法\r\n\r\n> 如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 )\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    class Father{\r\n        constructor(name){\r\n            this.name = name;\r\n        }\r\n        sayName(){\r\n            console.log(this.name);\r\n        }\r\n    }\r\n    class Son extends Father{  //extents后面跟表示要继承的类型\r\n        constructor(name, age){\r\n            super(name);  //相当于以前的：Father.call(this, name);\r\n            this.age = age;\r\n        }\r\n        //子类独有的方法\r\n        sayAge(){\r\n            console.log(this.age);\r\n        }\r\n        //子类中的方法会屏蔽到父类中的同名方法。\r\n        sayName(){\r\n            super.syaName();  //调用被覆盖的父类中的方法。 \r\n            console.log(\"我是子类的方法，我屏蔽了父类：\" + name);\r\n        }\r\n    }\r\n\r\n    var son1 = new Son(\"李四\", 30);\r\n    son1.sayAge();\r\n    son1.sayName();\r\n</script>\r\n```\r\n\r\n> 如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。\r\n> \r\n> 注意：\r\n> \r\n> 1.  如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法\r\n> 2.  普通方法调用需要使用super.父类的方法() 来调用。\r\n\r\n### 12.7.3 静态方法也可以继承\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n   class Father{\r\n       static foo(){\r\n           console.log(\"我是父类的静态方法\");\r\n       }\r\n   }\r\n   class Son extends Father{\r\n\r\n   }\r\n   Son.foo(); //子类也继承了父类的静态方法。  这种方式调用和直接通过父类名调用时一样的。\r\n\r\n</script>\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('66', '初识JQuery', '<h1 id=\"h1--jquery\"><a name=\"认识jQuery\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>认识jQuery</h1><p><a href=\"http://lib.csdn.net/base/jquery\" title=\"jQuery知识库\">jQuery</a>是继prototype之后又一个优秀的<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>框架。它是轻量级的js库 ，它兼容<a href=\"http://lib.csdn.net/base/css3\" title=\"CSS3知识库\">CSS3</a>，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。</p>\r\n<p>The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！</p>\r\n<p>它兼容CSS3，还兼容各种浏览器，jQuery使用户能更方便地处理DOM、事件、实现动画效果，并且方便地为网站提供AJAX交互。</p>\r\n<p>其主要的优势有：轻量级、强大的选择器、出色的DOM封装操作、可靠的事件处理机制、完善的jQuery、不污染顶级变量、出色的浏览器兼容性、链式操作方法、隐式迭代、行为层与结构层分离、丰富的插件支持、完善的文档、开源。</p>\r\n<p>第一个小例子：</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;认识jQuery&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;&lt;!-- jquery不需要安装之类的，只需要文件引入就可以了 --&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        alert(&quot;Hello World!&quot;);\r\n    });\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><span>$</span>在jQuery通常就是“jQuery”的简写。<br>$(document).ready(function(){});就等同于JavaScript中的window.onload(function(){});</p>\r\n<p>window.onload(function(){}):<br>1.必须等到网页全部被加载完成之后后才执行<br>2.只有一个，如有多个执行最后一个<br>3.不能被简写</p>\r\n<p><span>$</span>(document).ready(function(){}):<br>1.等到所有DOM结构绘制完毕后执行，可能其DOM元素关联的还没有加载完毕<br>2.可以书写多个<br>3.可以被简写：$(function(){});</p>\r\n<p><strong>DOM:</strong><br>jQuery中的$(‘#foo’).html();相当于getElementById(‘foo’).innerHTML;</p>\r\n<p>DOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象;<br>复制代码 代码如下:</p>\r\n<p>var domObj = document.getElementById(“id”); //DOM对象<br>var <span>$</span>obj = <span>$</span>(“#id”); //jQuery对象;</p>\r\n<p>var $variable=jQuery对象；<br>var variable=DOM对象；</p>\r\n<p><strong>jQuery对象转换成DOM对象：</strong><br>jQuery对象不能使用DOM中的方法，但是如果对jQuery对象方法不熟悉，或者jQuery没有封装想要的方法，不得不使用DOM中的方法，有以下两种处理：</p>\r\n<p>（1）jQuery对象是一个类似于数组的对象，可以通过[index]的方法得到相应的DOM对象。<br>jQuery代码如下：<br>var <span>$</span>cr=<span>$</span>(“#cr”); //jQuery对象<br>var cr=$(cr[0]); //DOM对象<br>alert(cr.checked); //检测这个checkbox是否被选中</p>\r\n<p>（2）另一种方法是jQuery自身提供的，通过get(index)方法得到相应的DOM对象。<br>jQuery代码如下：<br>var <span>$</span>cr=<span>$</span>(“#cr”); //jQuery对象<br>var cr=$cr.get(0); //DOM对象<br>alert(cr.checked); //检测这个checkbox是否被选中</p>\r\n<p><strong>DOM对象转换成</strong>重点内容<strong>jQuery对象：</strong><br>对于一个DOM对象，只需要<span>$</span>()把DOM对象包装起来，就可以获得一个jQuery对象，方式为$(DOM对象)</p>\r\n<p>jQuery代码如下：<br>var cr=document.getElementById(“cr”); //DOM对象<br>var <span>$</span>cr=<span>$</span>(cr); //jQuery对象</p>\r\n<p><strong>解决其他库与JQuery的冲突：</strong><br>1.jQuery库在其他库之后导入<br>在其他库和jQuery库都被加载完毕之后，可以再任何时候调用jQuery.noConfict()函数来将变量$的控制权移交给其他JavaScript库。</p>\r\n<p>2.jQuery库在其他库之前导入<br>如果jQuery库在其他库之前导入，那么可以直接使用“jQuery”来做一些jQuery的工作，同时，可以使用$()方法作为其他库的快捷方式。这里无需调用jQuery.noConfict()函数</p>\r\n', '92', '\r\n# 认识jQuery\r\n\r\n[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")是继prototype之后又一个优秀的[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")框架。它是轻量级的js库 ，它兼容[CSS3](http://lib.csdn.net/base/css3 \"CSS3知识库\")，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n\r\nThe Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！\r\n\r\n它兼容CSS3，还兼容各种浏览器，jQuery使用户能更方便地处理DOM、事件、实现动画效果，并且方便地为网站提供AJAX交互。\r\n\r\n其主要的优势有：轻量级、强大的选择器、出色的DOM封装操作、可靠的事件处理机制、完善的jQuery、不污染顶级变量、出色的浏览器兼容性、链式操作方法、隐式迭代、行为层与结构层分离、丰富的插件支持、完善的文档、开源。\r\n\r\n第一个小例子：\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>认识jQuery</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script><!-- jquery不需要安装之类的，只需要文件引入就可以了 -->\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        alert(\"Hello World!\");\r\n    });\r\n    </script>\r\n</head>\r\n<body>\r\n\r\n</body>\r\n</html>\r\n```\r\n\r\n<span>$</span>在jQuery通常就是“jQuery”的简写。\r\n$(document).ready(function(){});就等同于JavaScript中的window.onload(function(){});\r\n\r\nwindow.onload(function(){}):\r\n1.必须等到网页全部被加载完成之后后才执行\r\n2.只有一个，如有多个执行最后一个\r\n3.不能被简写\r\n\r\n<span>$</span>(document).ready(function(){}):\r\n1.等到所有DOM结构绘制完毕后执行，可能其DOM元素关联的还没有加载完毕\r\n2.可以书写多个\r\n3.可以被简写：$(function(){});\r\n\r\n**DOM:**\r\njQuery中的$(‘#foo’).html();相当于getElementById(‘foo’).innerHTML;\r\n\r\nDOM对象，即是我们用传统的方法(javascript)获得的对象，jQuery对象即是用jQuery类库的选择器获得的对象;\r\n复制代码 代码如下:\r\n\r\nvar domObj = document.getElementById(“id”); //DOM对象\r\nvar <span>$</span>obj = <span>$</span>(“#id”); //jQuery对象;\r\n\r\nvar $variable=jQuery对象；\r\nvar variable=DOM对象；\r\n\r\n**jQuery对象转换成DOM对象：**\r\njQuery对象不能使用DOM中的方法，但是如果对jQuery对象方法不熟悉，或者jQuery没有封装想要的方法，不得不使用DOM中的方法，有以下两种处理：\r\n\r\n（1）jQuery对象是一个类似于数组的对象，可以通过[index]的方法得到相应的DOM对象。\r\njQuery代码如下：\r\nvar <span>$</span>cr=<span>$</span>(“#cr”); //jQuery对象\r\nvar cr=$(cr[0]); //DOM对象\r\nalert(cr.checked); //检测这个checkbox是否被选中\r\n\r\n（2）另一种方法是jQuery自身提供的，通过get(index)方法得到相应的DOM对象。\r\njQuery代码如下：\r\nvar <span>$</span>cr=<span>$</span>(“#cr”); //jQuery对象\r\nvar cr=$cr.get(0); //DOM对象\r\nalert(cr.checked); //检测这个checkbox是否被选中\r\n\r\n**DOM对象转换成**重点内容**jQuery对象：**\r\n对于一个DOM对象，只需要<span>$</span>()把DOM对象包装起来，就可以获得一个jQuery对象，方式为$(DOM对象)\r\n\r\njQuery代码如下：\r\nvar cr=document.getElementById(“cr”); //DOM对象\r\nvar <span>$</span>cr=<span>$</span>(cr); //jQuery对象\r\n\r\n**解决其他库与JQuery的冲突：**\r\n1.jQuery库在其他库之后导入\r\n在其他库和jQuery库都被加载完毕之后，可以再任何时候调用jQuery.noConfict()函数来将变量$的控制权移交给其他JavaScript库。\r\n\r\n2.jQuery库在其他库之前导入\r\n如果jQuery库在其他库之前导入，那么可以直接使用“jQuery”来做一些jQuery的工作，同时，可以使用$()方法作为其他库的快捷方式。这里无需调用jQuery.noConfict()函数\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('67', 'JQuery选择器', '<h1 id=\"h1-jquery-\"><a name=\"jQuery选择器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>jQuery选择器</h1><p>1.css选择器<br>标签选择器：E{CSS规则}<br>ID选择器：#ID{CSS规则}<br>类选择器：.className{CSS规则}<br>群选择器：E1,E2,E3{CSS规则}<br>后代选择器：E F{CSS规则}<br>通配选择器：*{CSS规则}<br>其他选择器：伪类选择器（E:PseudoElements{CSS规则}）、子选择器(E&gt;F{CSS规则})、临近选择器(E + F{CSS规则})、属性选择器(E[attr]{CSS规则})</p>\r\n<p>2.<a href=\"http://lib.csdn.net/base/jquery\" title=\"jQuery知识库\">jQuery</a>选择器<br>jQuery选择器完全继承了CSS的风格。利用jQuery选择器，可以非常便捷和快速地找出特定的DOM元素，然后为他们添加相应的行为。</p>\r\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    function demo(){\r\n        alert(&#39;javascript demo&#39;);\r\n    }\r\n&lt;/script&gt;\r\n&lt;p onclick=&quot;demo();&quot;&gt;点击我&lt;/p&gt;\r\n</code></pre><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(&quot;.demo&quot;).click(function(){\r\n        alert(&#39; jquery demo&#39;);\r\n    });\r\n&lt;/script&gt;\r\n&lt;p class=&quot;demo&quot;&gt;点击我&lt;/p&gt;\r\n</code></pre><p><strong>jQuery选择器的优势：</strong><br><span>$</span>()函数在很多<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>类库中都被作为一个选择器函数来使用，<span>$</span>(“#ID”)用来代替document.getElementById()函数。通过$(“tagName”)来代替document.getElementsByTagName()函数。<br>jQuery选择支持CSS1、CSS2的全部和<a href=\"http://lib.csdn.net/base/css3\" title=\"CSS3知识库\">CSS3</a>的部分选择器。</p>\r\n<pre><code>&lt;div&gt;test&lt;/div&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\ndocument.getElementById(&quot;tt&quot;).style.color=&quot;red&quot;;\r\n&lt;/script&gt;\r\n//报错，因为没有ID为tt的元素\r\n</code></pre><pre><code>//改进版\r\n&lt;div&gt;test&lt;/div&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\nif(docuemnt.getElementById(&quot;tt&quot;)){\r\n    docuemnt.getElementById(&quot;tt&quot;).style.color=&quot;red&quot;;\r\n}\r\n&lt;/script&gt;\r\n//这样可以解决这个问题，但是代码量无疑变多了\r\n</code></pre><pre><code>&lt;div&gt;test&lt;/div&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n$(&quot;#tt&quot;).css(&quot;color&quot;,&quot;red&quot;);//这里无需判断$(&quot;#tt&quot;)是否存在\r\n&lt;/script&gt;\r\n</code></pre><p><strong>jQuery选择器：</strong></p>\r\n<p><strong>基本选择器：</strong></p>\r\n<h1 id=\"h1-id-id-span-span-id-\"><a name=\"id 给指定的id匹配一个元素<span>$</span>(‘#id’)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>id 给指定的id匹配一个元素<span>$</span>(‘#id’)</h1><p>.class 给指定的class匹配元素<span>$</span>(‘.class’)<br>element 给指定的元素名匹配元素 <span>$</span>(‘element’)</p>\r\n<ul>\r\n<li>匹配所有元素 <span>$</span>(‘*’)<br>selector1,selectro2… 将每个匹配到的元素合并后一起返回 $(‘selector1,selectro2’)</li></ul>\r\n<p><strong>层次选择器：</strong><br><span>$</span>(“ancestor descendant”) 选取ancestor元素下所有的descendant后代元素<br><span>$</span>(“parent&gt;child”) 选取parent元素下child子元素<br><span>$</span>(“prev+next”) 选取紧接在prev后的下一个next元素 prev与next是同辈元素(一个)<br><span>$</span>(“prev~sibling”) 选取紧接在prev后的所有sibling元素 prev与sibling是同辈元素(多个)</p>\r\n<p>可以使用next()方法来代替<span>$</span>(“prev+next”)<br><span>$</span>(“.one + div”) == $(“.one”).next(“div”)</p>\r\n<p>可以使用nextAll()方法来代替<span>$</span>(“prev~sibling”)<br><span>$</span>(“#prev~div”) == $(“#prev”).nextAll(“div”)</p>\r\n<p><strong>过滤选择器：</strong><br>:first 选取第一个元素 <span>$</span>(“div:first”)<br>:last 选取最后一个元素 <span>$</span>(“div:last”)<br>:not(selector) 去除所有与给定选择器匹配的元素 <span>$</span>(“input:not(.myClass)”)选取className不是myClass的input元素<br>:even 选取索引是偶数的所有元素，索引从0开始 <span>$</span>(“input:even”)<br>:odd 选取索引是奇数的所有元素，索引从0开始 $(“input:odd”)<br>:eq(index) 选取索引等于index的元素(index从0开始)<br>:gt(index) 选取索引大于index的元素(index从0开始)<br>:lt(index) 选取索引小于index的元素(index从0开始)<br>:header 选取所有的标题元素，例如h1,h2,h3等等<br>:animated 选取当前执行动画的所有元素<br>:focus 执行当前获取焦点的元素</p>\r\n<p><strong>内容过滤选择器：</strong><br>:contains(text) 选取含有文本内容为“text”的元素 <span>$</span>(“div:contains(‘我’)”)<br>:empty 选取不包含子元素或者文本的空元素 <span>$</span>(“div:empty”)<br>:has(selector) 选取含有选择器所匹配的元素的元素 <span>$</span>(“div:has(p)”)选取含有p元素的div元素<br>:parent 选取含有子元素或者文本元素的元素 $(“div:parent”)选取拥有子元素（包括文本元素）的div元素</p>\r\n<p><strong>可见性过滤选择器：</strong><br>:hidden 选取所有不可见的元素 <span>$</span>(“:hidden”)所有不可见的元素 <span>$</span>(“input:hidden”)选取不可见的input元素<br>:visible 选取所有可见的元素 $(“div:visible”) 选取所有可见的div元素</p>\r\n<p><strong>属性过滤选择器：</strong></p>\r\n<pre><code>[attribute]  选取拥有此属性的元素  $(&quot;div[id]&quot;)\r\n[attribute=value]  选取属性值为value的元素\r\n[attribute!=value]  选取属性值不等于value的元素\r\n[attribute^=value]  选取属性值以value开始的元素\r\n[attribute$=value]  选取属性值以value结束的元素\r\n[attribute*=value]  选取属性值含有value的元素\r\n[attribute|=value]  选取属性等于给定字符串或以该字符串为前缀(该字符后跟一个连字符&#39;-&#39;)的元素  $(&quot;div[title|=&#39;en&#39;]&quot;)\r\n[attribute~=value]  选取属性用空格分隔的值中包含一个给定值的元素  $(&quot;div[title~=&#39;en&#39;]&quot;)\r\n[attribute1][attribute2][attributeN]  用属性选择器合并成一个符合属性选择器，满足多个条件。每选择一次，缩小范围一次  $(&quot;div[id][title$=&#39;test&#39;]&quot;)选取拥有属性id，并且属性title以“test”结束的div元素\r\n</code></pre><p><strong>子元素过滤选择器：</strong><br>:nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素(index从1算起)<br>:first-child 选取每个父元素的第一个子元素<br>:last-child 选取每个父元素的自后一个子元素<br>:only-child 如果这个元素是父元素中唯一一个子元素，那么被匹配，否则，不被匹配</p>\r\n<p>:nth-child(even) 选取每个父元素下的索引值是偶数的元素<br>:nth-child(odd) 选取每个父元素下的索引值是奇数的元素<br>:nth-child(2) 选取每个父元素下的索引值为2的元素<br>:nth-child(3n) 选取每个父元素下索引值是3的倍数的元素（n从1开始）<br>:nth-child(3n+1) 选取每个父元素下的索引值是3n+1的元素 （n从1开始）</p>\r\n<p><strong>表单对象属性过滤选择器：</strong><br>:enabled 选取所有可用元素 $(“#form1 :enabled”)选取id为form1的表单内的所有可用元素<br>:disabled 选取所有不可用元素 同理<br>:checked 选取所有被选中的元素(单选框、复选框)<br>:selected 选取所有被选中的选项元素(下拉列表)</p>\r\n<p><strong>表单选择器：</strong><br>:input 选取所有的input、textarea、select、button元素<br>:text 选取所有的但行文本框<br>:password 选取所有的密码框<br>:radio 选取所有的单选框<br>:checkbox 选取所有的多选框<br>:submit 选取所有的提交按钮<br>:images 选取所有的图像按钮<br>:reset 选取所有的重置按钮<br>:button 选取所有的按钮<br>:file 选取所有的上传域<br>:hidden 选取所有不可见元素</p>\r\n<p>在里面进行相应的调试：</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;jQuery选择器&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    div,span,p{\r\n        width: 140px;\r\n        height: 140px;\r\n        margin: 5px;\r\n        background: #aaa;\r\n        border:#000 1px solid;\r\n        float: left;\r\n        font-size: 17px;\r\n        font-family: Verdana;\r\n    }\r\n    div.mini{\r\n        width: 55px;\r\n        height: 55px;\r\n        background: #aaa;\r\n        font-size: 12px;\r\n    }\r\n    div.hide{\r\n        display: none;\r\n    }\r\n    &lt;/style&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n\r\n    });\r\n\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt;\r\n        id为one，class为one的div\r\n        &lt;div class=&quot;mini&quot;&gt;class为mini&lt;/div&gt;\r\n    &lt;/div&gt;\r\n    &lt;div class=&quot;one&quot; id=&quot;two&quot; title=&quot;test&quot;&gt;\r\n        id为two，class为one，title为mini的div\r\n        &lt;div class=&quot;mini&quot; title=&quot;other&quot;&gt;class位mini，title为other&lt;/div&gt;\r\n        &lt;div class=&quot;mini&quot; title=&quot;test&quot;&gt;class位mini，title为test&lt;/div&gt;\r\n    &lt;/div&gt;\r\n    &lt;div class=&quot;one&quot;&gt;\r\n        &lt;div class=&quot;mini&quot;&gt;class为·mini&lt;/div&gt;\r\n        &lt;div class=&quot;mini&quot;&gt;class为·miniclass为·mini&lt;/div&gt;\r\n        &lt;div class=&quot;mini&quot;&gt;class为·mini&lt;/div&gt;\r\n        &lt;div class=&quot;mini&quot;&gt;&lt;/div&gt;\r\n    &lt;/div&gt;\r\n    &lt;div class=&quot;one&quot;&gt;\r\n        &lt;div class=&quot;mini&quot;&gt;class为·mini&lt;/div&gt;\r\n        &lt;div class=&quot;mini&quot;&gt;class为·mini&lt;/div&gt;\r\n        &lt;div class=&quot;mini&quot;&gt;class为·mini&lt;/div&gt;\r\n        &lt;div class=&quot;mini&quot; title=&quot;tesst&quot;&gt;class位mini，title为tesst&lt;/div&gt;\r\n    &lt;/div&gt;\r\n    &lt;div style=&quot;display:none;&quot; class=&quot;none&quot;&gt;\r\n        style=&quot;display:none;&quot; class=&quot;none&quot;\r\n    &lt;/div&gt;\r\n    &lt;div class=&quot;hide&quot;&gt;class=&quot;hide&quot;&lt;/div&gt;\r\n    &lt;div&gt;\r\n        包含input的type为“hidden”的div\r\n        &lt;input type=&quot;hidden&quot; size=&quot;8&quot;&gt;\r\n    &lt;/div&gt;\r\n    &lt;span id=&quot;mover&quot;&gt;正在执行动画的span元素&lt;/span&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>一些方法：</strong><br>show():显示隐藏的匹配元素<br>css(name,value):给元素设置样式<br>text(String):设置匹配元素的文本内容<br>filter(expr):筛选出与指定表达式匹配的元素集合，其中expr可以是多个选择器的组合，注意区分它和find()方法。find()会在元素内寻找匹配元素，而filter()则是筛选元素。一个是对他的·子集操作，一个是对自身集合元素进行筛选<br>addClass(class):未匹配的元素添加指定的类名</p>\r\n', '93', '\r\n# jQuery选择器\r\n\r\n1.css选择器\r\n标签选择器：E{CSS规则}\r\nID选择器：#ID{CSS规则}\r\n类选择器：.className{CSS规则}\r\n群选择器：E1,E2,E3{CSS规则}\r\n后代选择器：E F{CSS规则}\r\n通配选择器：*{CSS规则}\r\n其他选择器：伪类选择器（E:PseudoElements{CSS规则}）、子选择器(E>F{CSS规则})、临近选择器(E + F{CSS规则})、属性选择器(E[attr]{CSS规则})\r\n\r\n2.[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")选择器\r\njQuery选择器完全继承了CSS的风格。利用jQuery选择器，可以非常便捷和快速地找出特定的DOM元素，然后为他们添加相应的行为。\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    function demo(){\r\n        alert(\'javascript demo\');\r\n    }\r\n</script>\r\n<p onclick=\"demo();\">点击我</p>\r\n```\r\n\r\n```\r\n<script type=\"text/javascript\">\r\n    $(\".demo\").click(function(){\r\n        alert(\' jquery demo\');\r\n    });\r\n</script>\r\n<p class=\"demo\">点击我</p>\r\n```\r\n\r\n**jQuery选择器的优势：**\r\n<span>$</span>()函数在很多[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")类库中都被作为一个选择器函数来使用，<span>$</span>(“#ID”)用来代替document.getElementById()函数。通过$(“tagName”)来代替document.getElementsByTagName()函数。\r\njQuery选择支持CSS1、CSS2的全部和[CSS3](http://lib.csdn.net/base/css3 \"CSS3知识库\")的部分选择器。\r\n\r\n```\r\n<div>test</div>\r\n<script type=\"text/javascript\">\r\ndocument.getElementById(\"tt\").style.color=\"red\";\r\n</script>\r\n//报错，因为没有ID为tt的元素\r\n```\r\n\r\n```\r\n//改进版\r\n<div>test</div>\r\n<script type=\"text/javascript\">\r\nif(docuemnt.getElementById(\"tt\")){\r\n    docuemnt.getElementById(\"tt\").style.color=\"red\";\r\n}\r\n</script>\r\n//这样可以解决这个问题，但是代码量无疑变多了\r\n```\r\n\r\n```\r\n<div>test</div>\r\n<script type=\"text/javascript\">\r\n$(\"#tt\").css(\"color\",\"red\");//这里无需判断$(\"#tt\")是否存在\r\n</script>\r\n```\r\n\r\n**jQuery选择器：**\r\n\r\n**基本选择器：**\r\n#id 给指定的id匹配一个元素<span>$</span>(‘#id’)\r\n.class 给指定的class匹配元素<span>$</span>(‘.class’)\r\nelement 给指定的元素名匹配元素 <span>$</span>(‘element’)\r\n* 匹配所有元素 <span>$</span>(‘*’)\r\nselector1,selectro2… 将每个匹配到的元素合并后一起返回 $(‘selector1,selectro2’)\r\n\r\n**层次选择器：**\r\n<span>$</span>(“ancestor descendant”) 选取ancestor元素下所有的descendant后代元素\r\n<span>$</span>(“parent>child”) 选取parent元素下child子元素\r\n<span>$</span>(“prev+next”) 选取紧接在prev后的下一个next元素 prev与next是同辈元素(一个)\r\n<span>$</span>(“prev~sibling”) 选取紧接在prev后的所有sibling元素 prev与sibling是同辈元素(多个)\r\n\r\n可以使用next()方法来代替<span>$</span>(“prev+next”)\r\n<span>$</span>(“.one + div”) == $(“.one”).next(“div”)\r\n\r\n可以使用nextAll()方法来代替<span>$</span>(“prev~sibling”)\r\n<span>$</span>(“#prev~div”) == $(“#prev”).nextAll(“div”)\r\n\r\n**过滤选择器：**\r\n:first 选取第一个元素 <span>$</span>(“div:first”)\r\n:last 选取最后一个元素 <span>$</span>(“div:last”)\r\n:not(selector) 去除所有与给定选择器匹配的元素 <span>$</span>(“input:not(.myClass)”)选取className不是myClass的input元素\r\n:even 选取索引是偶数的所有元素，索引从0开始 <span>$</span>(“input:even”)\r\n:odd 选取索引是奇数的所有元素，索引从0开始 $(“input:odd”)\r\n:eq(index) 选取索引等于index的元素(index从0开始)\r\n:gt(index) 选取索引大于index的元素(index从0开始)\r\n:lt(index) 选取索引小于index的元素(index从0开始)\r\n:header 选取所有的标题元素，例如h1,h2,h3等等\r\n:animated 选取当前执行动画的所有元素\r\n:focus 执行当前获取焦点的元素\r\n\r\n**内容过滤选择器：**\r\n:contains(text) 选取含有文本内容为“text”的元素 <span>$</span>(“div:contains(‘我’)”)\r\n:empty 选取不包含子元素或者文本的空元素 <span>$</span>(“div:empty”)\r\n:has(selector) 选取含有选择器所匹配的元素的元素 <span>$</span>(“div:has(p)”)选取含有p元素的div元素\r\n:parent 选取含有子元素或者文本元素的元素 $(“div:parent”)选取拥有子元素（包括文本元素）的div元素\r\n\r\n**可见性过滤选择器：**\r\n:hidden 选取所有不可见的元素 <span>$</span>(“:hidden”)所有不可见的元素 <span>$</span>(“input:hidden”)选取不可见的input元素\r\n:visible 选取所有可见的元素 $(“div:visible”) 选取所有可见的div元素\r\n\r\n**属性过滤选择器：**\r\n\r\n```\r\n[attribute]  选取拥有此属性的元素  $(\"div[id]\")\r\n[attribute=value]  选取属性值为value的元素\r\n[attribute!=value]  选取属性值不等于value的元素\r\n[attribute^=value]  选取属性值以value开始的元素\r\n[attribute$=value]  选取属性值以value结束的元素\r\n[attribute*=value]  选取属性值含有value的元素\r\n[attribute|=value]  选取属性等于给定字符串或以该字符串为前缀(该字符后跟一个连字符\'-\')的元素  $(\"div[title|=\'en\']\")\r\n[attribute~=value]  选取属性用空格分隔的值中包含一个给定值的元素  $(\"div[title~=\'en\']\")\r\n[attribute1][attribute2][attributeN]  用属性选择器合并成一个符合属性选择器，满足多个条件。每选择一次，缩小范围一次  $(\"div[id][title$=\'test\']\")选取拥有属性id，并且属性title以“test”结束的div元素\r\n```\r\n\r\n**子元素过滤选择器：**\r\n:nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素(index从1算起)\r\n:first-child 选取每个父元素的第一个子元素\r\n:last-child 选取每个父元素的自后一个子元素\r\n:only-child 如果这个元素是父元素中唯一一个子元素，那么被匹配，否则，不被匹配\r\n\r\n:nth-child(even) 选取每个父元素下的索引值是偶数的元素\r\n:nth-child(odd) 选取每个父元素下的索引值是奇数的元素\r\n:nth-child(2) 选取每个父元素下的索引值为2的元素\r\n:nth-child(3n) 选取每个父元素下索引值是3的倍数的元素（n从1开始）\r\n:nth-child(3n+1) 选取每个父元素下的索引值是3n+1的元素 （n从1开始）\r\n\r\n**表单对象属性过滤选择器：**\r\n:enabled 选取所有可用元素 $(“#form1 :enabled”)选取id为form1的表单内的所有可用元素\r\n:disabled 选取所有不可用元素 同理\r\n:checked 选取所有被选中的元素(单选框、复选框)\r\n:selected 选取所有被选中的选项元素(下拉列表)\r\n\r\n**表单选择器：**\r\n:input 选取所有的input、textarea、select、button元素\r\n:text 选取所有的但行文本框\r\n:password 选取所有的密码框\r\n:radio 选取所有的单选框\r\n:checkbox 选取所有的多选框\r\n:submit 选取所有的提交按钮\r\n:images 选取所有的图像按钮\r\n:reset 选取所有的重置按钮\r\n:button 选取所有的按钮\r\n:file 选取所有的上传域\r\n:hidden 选取所有不可见元素\r\n\r\n在里面进行相应的调试：\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>jQuery选择器</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <style type=\"text/css\">\r\n    div,span,p{\r\n        width: 140px;\r\n        height: 140px;\r\n        margin: 5px;\r\n        background: #aaa;\r\n        border:#000 1px solid;\r\n        float: left;\r\n        font-size: 17px;\r\n        font-family: Verdana;\r\n    }\r\n    div.mini{\r\n        width: 55px;\r\n        height: 55px;\r\n        background: #aaa;\r\n        font-size: 12px;\r\n    }\r\n    div.hide{\r\n        display: none;\r\n    }\r\n    </style>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n\r\n    });\r\n\r\n    </script>\r\n</head>\r\n<body>\r\n    <div class=\"one\" id=\"one\">\r\n        id为one，class为one的div\r\n        <div class=\"mini\">class为mini</div>\r\n    </div>\r\n    <div class=\"one\" id=\"two\" title=\"test\">\r\n        id为two，class为one，title为mini的div\r\n        <div class=\"mini\" title=\"other\">class位mini，title为other</div>\r\n        <div class=\"mini\" title=\"test\">class位mini，title为test</div>\r\n    </div>\r\n    <div class=\"one\">\r\n        <div class=\"mini\">class为·mini</div>\r\n        <div class=\"mini\">class为·miniclass为·mini</div>\r\n        <div class=\"mini\">class为·mini</div>\r\n        <div class=\"mini\"></div>\r\n    </div>\r\n    <div class=\"one\">\r\n        <div class=\"mini\">class为·mini</div>\r\n        <div class=\"mini\">class为·mini</div>\r\n        <div class=\"mini\">class为·mini</div>\r\n        <div class=\"mini\" title=\"tesst\">class位mini，title为tesst</div>\r\n    </div>\r\n    <div style=\"display:none;\" class=\"none\">\r\n        style=\"display:none;\" class=\"none\"\r\n    </div>\r\n    <div class=\"hide\">class=\"hide\"</div>\r\n    <div>\r\n        包含input的type为“hidden”的div\r\n        <input type=\"hidden\" size=\"8\">\r\n    </div>\r\n    <span id=\"mover\">正在执行动画的span元素</span>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n**一些方法：**\r\nshow():显示隐藏的匹配元素\r\ncss(name,value):给元素设置样式\r\ntext(String):设置匹配元素的文本内容\r\nfilter(expr):筛选出与指定表达式匹配的元素集合，其中expr可以是多个选择器的组合，注意区分它和find()方法。find()会在元素内寻找匹配元素，而filter()则是筛选元素。一个是对他的·子集操作，一个是对自身集合元素进行筛选\r\naddClass(class):未匹配的元素添加指定的类名\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('68', 'JQuery dom操作', '<h1 id=\"h1-jquery-dom-\"><a name=\"jQuery中的DOM操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>jQuery中的DOM操作</h1><p>一般来说，DOM分为三个方面：DOM Core(核心) 、HTML-DOM和CSS-DOM</p>\r\n<p>DOM Core：<br><a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>中的getElementById()、getElementsByTagName()、getAttribute()、setAttribute()都是DOM Core的组成部分。<a href=\"http://blog.csdn.net/u014785563/article/details/53290728\">详情查看</a></p>\r\n<p>HTML-DOM：<br>在使用JavaScript和DOM为HTML文件编写脚本时，有许多专属于HTML-DOM的属性。HTML-DOM提供了一些更为简明的记号来描述各种HTML元素的属性。<br>例如：<br>document.forms //HTML-DOM提供了一个form对象<br>element.src //使用HTML-DOM老获取某元素的src属性的方法</p>\r\n<p>CSS-DOM：<br>作用于获取和设置style对象的各种属性。<br>element.style.color=”red”</p>\r\n<p><strong><a href=\"http://lib.csdn.net/base/jquery\" title=\"jQuery知识库\">jQuery</a>中的DOM操作：</strong></p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;jQuery选择器&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        //查找元素节点\r\n        var $li=$(&quot;ul li:eq(1)&quot;);//获取ul第二个li节点\r\n        var li_txt=$li.text();//获取第二个li元素节点的文本内容\r\n        //alert(li_txt);\r\n\r\n        //查找属性节点\r\n        var $para=$(&quot;p&quot;);//获取p节点\r\n        var p_txt=$para.attr(&quot;title&quot;);//获取p节点属性title\r\n        //alert(p_txt);\r\n\r\n        // 创建节点\r\n        // 创建元素节点：\r\n        /*\r\n        var $li_1=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;);    //创建第一个li元素\r\n        var $li_2=$(&quot;&lt;li&gt;&lt;/li&gt;&quot;);    //创建第二个li元素\r\n        $(&quot;ul&quot;).append($li_1);\r\n        $(&quot;ul&quot;).append($li_2);\r\n\r\n        */\r\n\r\n        //创建文本节点\r\n\r\n        /*\r\n        var $li_1=$(&quot;&lt;li&gt;香蕉&lt;/li&gt;&quot;);\r\n        var $li_2=$(&quot;&lt;li&gt;雪梨&lt;/li&gt;&quot;);\r\n        $(&quot;ul&quot;).append($li_1);\r\n        $(&quot;ul&quot;).append($li_2);\r\n\r\n        */\r\n\r\n        //创建属性节点\r\n        var $li_1=$(&quot;&lt;li title=&quot;香蕉&quot;&gt;香蕉&lt;/li&gt;&quot;);\r\n        var $li_2=$(&quot;&lt;li title=&quot;雪梨&quot;&gt;雪梨&lt;/li&gt;&quot;);\r\n        $(&quot;ul&quot;).append($li_1);\r\n        $(&quot;ul&quot;).append($li_2);\r\n\r\n    });\r\n\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;p title=&quot;选择你喜欢的水果&quot;&gt;你最喜欢的水果是？&lt;/p&gt;\r\n    &lt;ul&gt;\r\n        &lt;li title=&quot;苹果&quot;&gt;苹果&lt;/li&gt;\r\n        &lt;li title=&quot;橘子&quot;&gt;橘子&lt;/li&gt;\r\n        &lt;li title=&quot;菠萝&quot;&gt;菠萝&lt;/li&gt;\r\n    &lt;/ul&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>插入节点：</strong></p>\r\n<p>append() 向每个匹配的元素内容内追加内容</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;p&quot;).append(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;);\r\n结果：&lt;p&gt;I am &lt;b&gt;fzw&lt;/b&gt;&lt;/p&gt;\r\n</code></pre><p>appendTo() 将所有匹配的元素加到指定的元素中。实际上，使用该方法是颠倒了常规的$(A).appendTo(B)的操作，既不是将B追加到A中，而是将A追加到B中。</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;).appendTo(&quot;p&quot;);\r\n结果：&lt;p&gt;I am &lt;b&gt;fzw&lt;/b&gt;&lt;/p&gt;\r\n</code></pre><p>prepend() 向每个内容的元素内部前置内容</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;p&quot;).prepend(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;)\r\n结果：&lt;p&gt;&lt;b&gt;fzw&lt;/b&gt;I am &lt;/p&gt;\r\n</code></pre><p>prependTo() 将所有匹配的元素前置到指定的元素中。实际上，使用该方法是颠倒了常规的，$(A).prependTo(B)的操作，既不是将B前置到A中，而是将A前置到B中</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;).prependTo(&quot;p&quot;)\r\n结果：&lt;p&gt;&lt;b&gt;fzw&lt;/b&gt;I am &lt;/p&gt;\r\n</code></pre><p>after() 在每个匹配到的元素之后插入内容</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;p&quot;).after(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;);\r\n结果：&lt;p&gt;I am &lt;/p&gt;&lt;b&gt;fzw&lt;/b&gt;\r\n</code></pre><p>insertAfter() 将所有匹配的元素插入到指定元素的后面，实力上，使用该方法是颠倒了常规的$(A).after(B)的操作，既不是将B插入到A后面，而是将A插入到B后面</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;).insertAfter(&quot;p&quot;); \r\n结果：&lt;p&gt;I am &lt;/p&gt;&lt;b&gt;fzw&lt;/b&gt;\r\n</code></pre><p>before() 在每个匹配的元素之前插入内容</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;p&quot;).before(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;); \r\n结果：&lt;b&gt;fzw&lt;/b&gt;&lt;p&gt;I am &lt;/p&gt;\r\n</code></pre><p>insertBefore() 将所有匹配的元素插入到指定元素的前面，实力上，使用该方法是颠倒了常规的$(A).before(B)的操作，既不是将B插入到A前面，而是将A插入到B前面</p>\r\n<pre><code>html代码：\r\n&lt;p&gt;I am &lt;/p&gt;\r\njQuery代码：\r\n$(&quot;&lt;b&gt;fzw&lt;/b&gt;&quot;).insertBefore(&quot;p&quot;); \r\n结果：&lt;b&gt;fzw&lt;/b&gt;&lt;p&gt;I am &lt;/p&gt;\r\n</code></pre><p><strong>删除节点：</strong><br>1、remove()方法：<br><span>$</span>(“ul li:eq(1)”).remove(); //获取第二个li元素节点，将它从网页中删除<br>当某个节点用remove()方法删除后，该节点所包含的所有后代节点将同时被删除。这个方法的返回值是一个指向已被删除的节点的引用，因此可以在以后再使用这些元素。<br>var <span>$</span>li=<span>$</span>(“ul li:eq(1)”).remove();<br>$li.appendTo(“ul”);</p>\r\n<p>2.detach()方法：<br>detach()方法和remove()方法一样，将它从网页中删除后，该节点所包含的所有后代节点并没有同时被删除。</p>\r\n<p>3.empty()方法：<br>empty()方法不是删除节点，而是清空节点，他能清空元素中的所有的后代节点</p>\r\n<p><strong>复制节点：</strong><br>clone()来复制节点<br><span>$</span>(ul li).click(function(){<br><span>$</span>(this).clone.appendTo(“ul”);<br>});</p>\r\n<p><strong>替换节点：</strong><br>replaceWith()替换节点<br>$(‘p’).replaceWith(“<strong>你最不喜欢的水果是？</strong>“);</p>\r\n<pre><code>(&quot;&lt;strong&gt;你最不喜欢的水果是？&lt;/strong&gt;&quot;).relaceAll(&quot;p&quot;);\r\n</code></pre><p><strong>包裹节点：</strong></p>\r\n<pre><code>$(&quot;strong&quot;).wrap(&quot;&lt;b&gt;&lt;/b&gt;&quot;);//用b标签吧strong元素包裹起来\r\n$(&quot;strong&quot;).wrapAll(&quot;&lt;b&gt;&lt;/b&gt;&quot;);//用b标签把所有的strong元素包裹起来\r\n$(&quot;strong&quot;).wrapInner(&quot;&lt;b&gt;&lt;/b&gt;&quot;);//所有的strong元素里面用b标签包裹起来\r\n</code></pre><p><strong>属性操作：</strong><br>使用attr()获取和设置属性，removeAttr()方法来删除属性<br><span>$</span>(“p”).attr(“title”,”you title”);<br><span>$</span>(“p”).attr({“title”:”you title”,”name”:”test”});<br>$(“p”).removeAttr(“title”);</p>\r\n<p><strong>样式操作：</strong><br>1.获取和设置样式<br>var p_class=<span>$</span>(“p”).attr(“class”);//获取样式<br>$(“p”).attr(“class”,”high”);//设置样式</p>\r\n<p>2.追加样式：<br>$(“p”).addClass(“another”);</p>\r\n<p>3.移除样式：<br>$(“p”).removeClass(“another”);</p>\r\n<p>4.切换样式：<br>$(“p”).toggleClass(“another”);</p>\r\n<p>5.判断是否有某个样式：<br>$(“p”).hasClass(“another”);</p>\r\n<p><strong>设置和获取HTML、文本和值：</strong></p>\r\n<p>1.html()方法</p>\r\n<pre><code>var p_html=$(&quot;p&quot;).html();//获取p元素内的HTML代码\r\n$(&quot;p&quot;).html(&quot;&lt;strong&gt;你最喜欢的水果是？&lt;/strong&gt;&quot;);//设置p元素内的html代码\r\n</code></pre><p>2.text()方法</p>\r\n<pre><code>var p_text=$(&quot;p&quot;).text();//获取p元素内的文本内容\r\n$(&quot;p&quot;).text(&quot;你最喜欢的水果是？&quot;);//设置p元素内的文本内容\r\n</code></pre><p>3.val()方法<br>类似于JavaScript中的value属性</p>\r\n<pre><code>var p_val=$(&quot;p&quot;).val();//获取p元素内的值\r\n$(&quot;p&quot;).val(&quot;&quot;);//设置p元素内的值\r\n</code></pre><p><strong>遍历节点：</strong></p>\r\n<p>1.children()方法<br>该方法用于取得匹配元素的子元素集合<br>2.next()方法<br>该方法用于获取匹配元素后面邻近的同辈元素<br>3.prev()方法<br>该方法用于获取匹配元素前面邻近的同辈元素<br>4.siblings()方法<br>该方法用于获取匹配元素前后所有的同辈元素<br>5.closest()<br>该方法用于取得最近的匹配元素，不匹配时，按层级往上查<br>6.parent(),parents(),closest()的区别<br>parent()获得一个父节点<br>parents()获得一堆祖先节点<br>closest()和parents()类似，但是只返回第一个匹配到的父节点</p>\r\n<p><strong>CSS-DOM操作：</strong></p>\r\n<p><span>$</span>(“p”).css(“color”);//获取颜色<br><span>$</span>(“p”).css(“color”,”red”);//设置颜色<br><span>$</span>(“p”).width();//获取宽度<br><span>$</span>(“p”).width(“400px”);//设置宽度<br>offset()方法：<br>获取元素在当前视窗的相对偏移，返回的对象包含两个属性，即top和left<br>var offset=$(“p”).offset();<br>var left=offset.left;<br>var right=offset.right;</p>\r\n<p>position()方法：<br>获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，返回的对象和offset()方法一样。</p>\r\n<p>scrollTop()和scrollLeft()<br>这两个方法分别获取元素的滚动条距顶端的距离和距左侧的距离。</p>\r\n<p><strong>部分实用的方法（后续动画也会有说到）：</strong><br>focus()方法处理获得焦点时的事件。<br>blur()方法处理失去焦点时的事件。<br>表单元素中的defaultValue属性包含该表单的初始值<br>this.defaultValue表示当前文本框的默认值<br>mouseover,鼠标移入发生的动作<br>mouseout,鼠标移出发生的动作</p>\r\n', '94', '\r\n# jQuery中的DOM操作\r\n\r\n一般来说，DOM分为三个方面：DOM Core(核心) 、HTML-DOM和CSS-DOM\r\n\r\nDOM Core：\r\n[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")中的getElementById()、getElementsByTagName()、getAttribute()、setAttribute()都是DOM Core的组成部分。[详情查看](http://blog.csdn.net/u014785563/article/details/53290728)\r\n\r\nHTML-DOM：\r\n在使用JavaScript和DOM为HTML文件编写脚本时，有许多专属于HTML-DOM的属性。HTML-DOM提供了一些更为简明的记号来描述各种HTML元素的属性。\r\n例如：\r\ndocument.forms //HTML-DOM提供了一个form对象\r\nelement.src //使用HTML-DOM老获取某元素的src属性的方法\r\n\r\nCSS-DOM：\r\n作用于获取和设置style对象的各种属性。\r\nelement.style.color=”red”\r\n\r\n**[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")中的DOM操作：**\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>jQuery选择器</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        //查找元素节点\r\n        var $li=$(\"ul li:eq(1)\");//获取ul第二个li节点\r\n        var li_txt=$li.text();//获取第二个li元素节点的文本内容\r\n        //alert(li_txt);\r\n\r\n        //查找属性节点\r\n        var $para=$(\"p\");//获取p节点\r\n        var p_txt=$para.attr(\"title\");//获取p节点属性title\r\n        //alert(p_txt);\r\n\r\n        // 创建节点\r\n        // 创建元素节点：\r\n        /*\r\n        var $li_1=$(\"<li></li>\");    //创建第一个li元素\r\n        var $li_2=$(\"<li></li>\");    //创建第二个li元素\r\n        $(\"ul\").append($li_1);\r\n        $(\"ul\").append($li_2);\r\n\r\n        */\r\n\r\n        //创建文本节点\r\n\r\n        /*\r\n        var $li_1=$(\"<li>香蕉</li>\");\r\n        var $li_2=$(\"<li>雪梨</li>\");\r\n        $(\"ul\").append($li_1);\r\n        $(\"ul\").append($li_2);\r\n\r\n        */\r\n\r\n        //创建属性节点\r\n        var $li_1=$(\"<li title=\"香蕉\">香蕉</li>\");\r\n        var $li_2=$(\"<li title=\"雪梨\">雪梨</li>\");\r\n        $(\"ul\").append($li_1);\r\n        $(\"ul\").append($li_2);\r\n\r\n    });\r\n\r\n    </script>\r\n</head>\r\n<body>\r\n    <p title=\"选择你喜欢的水果\">你最喜欢的水果是？</p>\r\n    <ul>\r\n        <li title=\"苹果\">苹果</li>\r\n        <li title=\"橘子\">橘子</li>\r\n        <li title=\"菠萝\">菠萝</li>\r\n    </ul>\r\n</body>\r\n</html>\r\n```\r\n\r\n**插入节点：**\r\n\r\nappend() 向每个匹配的元素内容内追加内容\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"p\").append(\"<b>fzw</b>\");\r\n结果：<p>I am <b>fzw</b></p>\r\n```\r\n\r\nappendTo() 将所有匹配的元素加到指定的元素中。实际上，使用该方法是颠倒了常规的$(A).appendTo(B)的操作，既不是将B追加到A中，而是将A追加到B中。\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"<b>fzw</b>\").appendTo(\"p\");\r\n结果：<p>I am <b>fzw</b></p>\r\n```\r\n\r\nprepend() 向每个内容的元素内部前置内容\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"p\").prepend(\"<b>fzw</b>\")\r\n结果：<p><b>fzw</b>I am </p>\r\n```\r\n\r\nprependTo() 将所有匹配的元素前置到指定的元素中。实际上，使用该方法是颠倒了常规的，$(A).prependTo(B)的操作，既不是将B前置到A中，而是将A前置到B中\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"<b>fzw</b>\").prependTo(\"p\")\r\n结果：<p><b>fzw</b>I am </p>\r\n```\r\n\r\nafter() 在每个匹配到的元素之后插入内容\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"p\").after(\"<b>fzw</b>\");\r\n结果：<p>I am </p><b>fzw</b>\r\n```\r\n\r\ninsertAfter() 将所有匹配的元素插入到指定元素的后面，实力上，使用该方法是颠倒了常规的$(A).after(B)的操作，既不是将B插入到A后面，而是将A插入到B后面\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"<b>fzw</b>\").insertAfter(\"p\"); \r\n结果：<p>I am </p><b>fzw</b>\r\n```\r\n\r\nbefore() 在每个匹配的元素之前插入内容\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"p\").before(\"<b>fzw</b>\"); \r\n结果：<b>fzw</b><p>I am </p>\r\n```\r\n\r\ninsertBefore() 将所有匹配的元素插入到指定元素的前面，实力上，使用该方法是颠倒了常规的$(A).before(B)的操作，既不是将B插入到A前面，而是将A插入到B前面\r\n\r\n```\r\nhtml代码：\r\n<p>I am </p>\r\njQuery代码：\r\n$(\"<b>fzw</b>\").insertBefore(\"p\"); \r\n结果：<b>fzw</b><p>I am </p>\r\n```\r\n\r\n**删除节点：**\r\n1、remove()方法：\r\n<span>$</span>(“ul li:eq(1)”).remove(); //获取第二个li元素节点，将它从网页中删除\r\n当某个节点用remove()方法删除后，该节点所包含的所有后代节点将同时被删除。这个方法的返回值是一个指向已被删除的节点的引用，因此可以在以后再使用这些元素。\r\nvar <span>$</span>li=<span>$</span>(“ul li:eq(1)”).remove();\r\n$li.appendTo(“ul”);\r\n\r\n2.detach()方法：\r\ndetach()方法和remove()方法一样，将它从网页中删除后，该节点所包含的所有后代节点并没有同时被删除。\r\n\r\n3.empty()方法：\r\nempty()方法不是删除节点，而是清空节点，他能清空元素中的所有的后代节点\r\n\r\n**复制节点：**\r\nclone()来复制节点\r\n<span>$</span>(ul li).click(function(){\r\n<span>$</span>(this).clone.appendTo(“ul”);\r\n});\r\n\r\n**替换节点：**\r\nreplaceWith()替换节点\r\n$(‘p’).replaceWith(“**你最不喜欢的水果是？**“);\r\n\r\n```\r\n(\"<strong>你最不喜欢的水果是？</strong>\").relaceAll(\"p\");\r\n```\r\n\r\n**包裹节点：**\r\n\r\n```\r\n$(\"strong\").wrap(\"<b></b>\");//用b标签吧strong元素包裹起来\r\n$(\"strong\").wrapAll(\"<b></b>\");//用b标签把所有的strong元素包裹起来\r\n$(\"strong\").wrapInner(\"<b></b>\");//所有的strong元素里面用b标签包裹起来\r\n```\r\n\r\n**属性操作：**\r\n使用attr()获取和设置属性，removeAttr()方法来删除属性\r\n<span>$</span>(“p”).attr(“title”,”you title”);\r\n<span>$</span>(“p”).attr({“title”:”you title”,”name”:”test”});\r\n$(“p”).removeAttr(“title”);\r\n\r\n**样式操作：**\r\n1.获取和设置样式\r\nvar p_class=<span>$</span>(“p”).attr(“class”);//获取样式\r\n$(“p”).attr(“class”,”high”);//设置样式\r\n\r\n2.追加样式：\r\n$(“p”).addClass(“another”);\r\n\r\n3.移除样式：\r\n$(“p”).removeClass(“another”);\r\n\r\n4.切换样式：\r\n$(“p”).toggleClass(“another”);\r\n\r\n5.判断是否有某个样式：\r\n$(“p”).hasClass(“another”);\r\n\r\n**设置和获取HTML、文本和值：**\r\n\r\n1.html()方法\r\n\r\n```\r\nvar p_html=$(\"p\").html();//获取p元素内的HTML代码\r\n$(\"p\").html(\"<strong>你最喜欢的水果是？</strong>\");//设置p元素内的html代码\r\n```\r\n\r\n2.text()方法\r\n\r\n```\r\nvar p_text=$(\"p\").text();//获取p元素内的文本内容\r\n$(\"p\").text(\"你最喜欢的水果是？\");//设置p元素内的文本内容\r\n```\r\n\r\n3.val()方法\r\n类似于JavaScript中的value属性\r\n\r\n```\r\nvar p_val=$(\"p\").val();//获取p元素内的值\r\n$(\"p\").val(\"\");//设置p元素内的值\r\n```\r\n\r\n**遍历节点：**\r\n\r\n1.children()方法\r\n该方法用于取得匹配元素的子元素集合\r\n2.next()方法\r\n该方法用于获取匹配元素后面邻近的同辈元素\r\n3.prev()方法\r\n该方法用于获取匹配元素前面邻近的同辈元素\r\n4.siblings()方法\r\n该方法用于获取匹配元素前后所有的同辈元素\r\n5.closest()\r\n该方法用于取得最近的匹配元素，不匹配时，按层级往上查\r\n6.parent(),parents(),closest()的区别\r\nparent()获得一个父节点\r\nparents()获得一堆祖先节点\r\nclosest()和parents()类似，但是只返回第一个匹配到的父节点\r\n\r\n**CSS-DOM操作：**\r\n\r\n<span>$</span>(“p”).css(“color”);//获取颜色\r\n<span>$</span>(“p”).css(“color”,”red”);//设置颜色\r\n<span>$</span>(“p”).width();//获取宽度\r\n<span>$</span>(“p”).width(“400px”);//设置宽度\r\noffset()方法：\r\n获取元素在当前视窗的相对偏移，返回的对象包含两个属性，即top和left\r\nvar offset=$(“p”).offset();\r\nvar left=offset.left;\r\nvar right=offset.right;\r\n\r\nposition()方法：\r\n获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，返回的对象和offset()方法一样。\r\n\r\nscrollTop()和scrollLeft()\r\n这两个方法分别获取元素的滚动条距顶端的距离和距左侧的距离。\r\n\r\n**部分实用的方法（后续动画也会有说到）：**\r\nfocus()方法处理获得焦点时的事件。\r\nblur()方法处理失去焦点时的事件。\r\n表单元素中的defaultValue属性包含该表单的初始值\r\nthis.defaultValue表示当前文本框的默认值\r\nmouseover,鼠标移入发生的动作\r\nmouseout,鼠标移出发生的动作\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('69', 'JQuery事件', '<h1 id=\"h1-jquery-\"><a name=\"jQuery中的事件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>jQuery中的事件</h1><h4 id=\"h4--strong-dom-strong-\"><a name=\"<strong>加载DOM：</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>加载DOM：</strong></h4><p><strong>执行时机：</strong><br>$(document).ready(function(){}); <a href=\"http://blog.csdn.net/u014785563/article/details/53456978\">详情解释</a></p>\r\n<p><strong>事件绑定：</strong></p>\r\n<p>bind(event,data,function)<br>第一个参数是事件类型，类型包括：blur focus load resize unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter change select submit keydown keypress keyup error等，当然也可以包含自定义名称（可以发现<a href=\"http://lib.csdn.net/base/jquery\" title=\"jQuery知识库\">jQuery</a>中对应的事件绑定类型比<a href=\"http://lib.csdn.net/base/javascript\" title=\"JavaScript知识库\">JavaScript</a>中的少了一个“on”）<br>第二个参数是可选参数，作为event.data属性值传递给事件对象的额外数据对象<br>第三个参数则是用来绑定的处理函数</p>\r\n<p>（1）基本效果：</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).bind(&quot;click&quot;,function(){\r\n            $(this).next().show();\r\n        })\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p>（2）加强效果：</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).bind(&quot;click&quot;,function(){\r\n            if($(this).next().is(&quot;:visible&quot;)){//如果内容是显示的\r\n                $(this).next().hide();\r\n            }else{\r\n                $(this).next().show();\r\n            }\r\n\r\n        })\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p>“:visible”在可见性过滤选择器可以查询到，<a href=\"http://blog.csdn.net/u014785563/article/details/53465749\">详情查看</a></p>\r\n<p>（3）改变事件绑定类型：</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).mouseover(function(){\r\n            $(this).next().show();\r\n        }).mouseout(function(){\r\n            $(this).next().hide();\r\n        })\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p>（4）合成事件：</p>\r\n<p>1.hover()方法的语言结构：hover(enter,leave);鼠标经过移出的组合方法</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).hover(function(){\r\n            $(this).next().show();\r\n        },function(){\r\n            $(this).next().hide();\r\n        })\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p>2.toggle()方法结构：toggle(fn1,fn2,…,fnN):该方法用于模拟鼠标连续点击事件，第一次点击触发第一个事件，第二次点击触发第二个事件，依次循环。</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).toggle(function(){\r\n            $(this).addClass(&quot;highlight&quot;);\r\n            $(this).next().show();\r\n        },function(){\r\n            $(this).removeClass(&quot;highlight&quot;);\r\n            $(this).next().hide();\r\n        })\r\n\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    .highlight{\r\n        background: #f30;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>事件冒泡：</strong><br>1.什么是冒泡：在页面上可以有多个事件，也可以一个元素响应多个事件。假设网页上有两个元素，其中一个元素完全嵌套在另一个元素中，并且绑定了click事件，同时在body元素上也绑定了click事件。<br>小例子：</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;Document&lt;/title&gt;\r\n        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        //为span元素绑定click事件\r\n        $(&#39;span&#39;).bind(&quot;click&quot;,function(){\r\n            var txt=$(&quot;#msg&quot;).html()+&quot;&lt;p&gt;内层span元素被单击&lt;/p&gt;&quot;;\r\n            $(&quot;#msg&quot;).html(txt);\r\n        });\r\n        //为div元素绑定click事件\r\n        $(&#39;#content&#39;).bind(&quot;click&quot;,function(){\r\n            var txt=$(&quot;#msg&quot;).html()+&quot;&lt;p&gt;外层div元素被单击&lt;/p&gt;&quot;;\r\n            $(&quot;#msg&quot;).html(txt);\r\n        });\r\n        //为body元素绑定click事件\r\n        $(&#39;body&#39;).bind(&quot;click&quot;,function(){\r\n            var txt=$(&quot;#msg&quot;).html()+&quot;&lt;p&gt;body元素被单击&lt;/p&gt;&quot;;\r\n            $(&quot;#msg&quot;).html(txt);\r\n        });\r\n\r\n    });\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;content&quot;&gt;\r\n        外层div元素\r\n        &lt;span&gt;内层span元素&lt;/span&gt;\r\n        外层div元素\r\n    &lt;/div&gt;\r\n    &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><font color=\"red\">元素会按照事件的顺序依次向下冒泡。</font>\r\n\r\n<p><font color=\"red\">事件冒泡引发的问题：</font><br>事件冒泡就可能会引起预料外的效果，上面小例子中，本来只想触发span里面的click事件，却全部触发了。所以，我们很有必要对时间的作用范围进行限制。</p>\r\n<p><font color=\"red\">事件对象：</font><br>$(“element”).bind(“click”,function(event){ //event:事件对象<br>});<br>这样的话，当单击element元素时，事件对象就被创建了，这是事件对象只有事件处理函数才能访问到。当事件处理函数结束之后，实践对象也就被销毁了</p>\r\n<p><font color=\"red\">停止事件冒泡：</font><br>在jQuery中提供了stopPropagation()方法来停止事件冒泡</p>\r\n<pre><code>$(&quot;span&quot;).bind(&quot;click&quot;,function(){\r\n    var txt=$(&quot;msg&quot;).html()+&quot;&lt;p&gt;内层span元素被单击&lt;/p&gt;&quot;；\r\n    $(&quot;#msg&quot;).html(txt);\r\n    event.stopPropagation();//停止事件冒泡\r\n});\r\n</code></pre><p><font color=\"red\">阻止默认行为：</font><br>在jQuery中，提供了preventDefault()方法来阻止元素的默认行为</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;Document&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;#sub&quot;).bind(&quot;click&quot;,function(event){\r\n            var username=$(&quot;#username&quot;).val();\r\n            if(username==&quot;&quot;){\r\n                $(&quot;#msg&quot;).html(&quot;&lt;p&gt;姓名不能为空&lt;/p&gt;&quot;);\r\n                event.preventDefault();\r\n                //可以改写为 return false;\r\n            }\r\n        });\r\n\r\n    });\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;form action=&quot;test.html&quot;&gt;\r\n        用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;\r\n        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;sub&quot;&gt;\r\n    &lt;/form&gt;\r\n    &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><font color=\"red\">事件捕获：</font><br>事件捕获与事件冒泡相反，是从外层到里层的，但是jQuery不支持，只有通过原声JavaScript来能进行。还有就是事件捕获并非所有浏览器都是支持的。</p>\r\n<p><font color=\"red\">事件对象的属性：</font><br>1.event.type</p>\r\n<pre><code>$(&quot;a&quot;).click(function(event){\r\n    alert(event.type);//获取事件类型\r\n    return false;//阻止链接跳转\r\n});\r\n</code></pre><p>2.event.preventDefault()方法<br>上面已经介绍了，适用于阻止元素默认行为</p>\r\n<p>3.event.stopPropagation()方法：<br>上面已经介绍过了，用于停止事件冒泡</p>\r\n<p>4.event.target<br>event.target的作用是获取到触发事件的元素。jQuery对其封装后，避免了各个浏览器不同标准的差异。</p>\r\n<pre><code>$(&quot;a[href=&#39;http://www.baidu.com&#39;]&quot;).click(function(event){\r\n    var tg=event.target;//获取事件对象\r\n    alert(tg.href);\r\n    return false;\r\n});\r\n</code></pre><p>5.event.relatedTarget<br>mouseover和mouseout所发生的元素可以通过event.target来访问，相关元素是通过event.relatedTarget来访问的。event.relatedTarget在mouseover中相当于IE浏览器的event.fromElement,在mouseout中相当于IE浏览器的event.toElement,jQuery对其封装，使之能兼容各种浏览器。</p>\r\n<p>6.event.pageX和event.pageY<br>该方法的作用是获取到光标相对于页面的x坐标和y坐标。如果没有使用jQuery时，那么IE浏览器使用page.x/page.y,在火狐浏览器中使用event.pageX和event.pageY.</p>\r\n<pre><code>$(&quot;a&quot;).click(function(event){\r\n    //获取鼠标当前相对于页面的坐标\r\n    alert(&quot;Current mouse position: &quot;+event.pageX+&quot;,&quot;+event.pageY);\r\n    return false;\r\n});\r\n</code></pre><p>7.event.which<br>该方法的作用是在鼠标点击事件中获取到鼠标的左中右键：</p>\r\n<pre><code>$(&quot;a&quot;).mousedown(function(e){\r\n    alert(e.which);\r\n});\r\n</code></pre><p>//获得键盘的按键</p>\r\n<pre><code>$(&quot;input&quot;).keyup(function(e){\r\n    alert(e.which);\r\n});\r\n</code></pre><p>8.event.metaKey<br>针对不同浏览器对键盘中的ctrl按键解释不同，jQuery进行封装，斌规定event.metaKey为键盘事件中获取ctrl按键</p>\r\n<p><font color=\"red\">移除事件：</font><br>unbind([type],[data]);<br>第一个参数是事件类型，第二个参数是将要移出的函数<br>（1）如果没有参数，则删除所有绑定的事件<br>（2）如果提供了事件类型作为参数，则只删除该类型的绑定事件<br>（3）如果把在绑定时传递的处理函数作为第2个参数，则只有这个特定的事件处理函数会被删除</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;移除事件&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;#delAll&quot;).click(function(){\r\n            $(&quot;#btn&quot;).unbind(&quot;click&quot;);\r\n        });\r\n        $(&quot;#btn&quot;).bind(&quot;click&quot;,function(){\r\n            $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定函数1&lt;/p&gt;&quot;);\r\n        }).bind(&quot;click&quot;,function(){\r\n            $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定函数2&lt;/p&gt;&quot;);\r\n        }).bind(&quot;click&quot;,function(){\r\n            $(&quot;#test&quot;).append(&quot;&lt;p&gt;我的绑定函数3&lt;/p&gt;&quot;);\r\n        });\r\n\r\n    });\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;button id=&quot;btn&quot;&gt;单击我&lt;/button&gt;\r\n    &lt;button id=&quot;delAll&quot;&gt;删除所有事件&lt;/button&gt;\r\n    &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>', '95', '\r\n# jQuery中的事件\r\n\r\n#### **加载DOM：**\r\n\r\n**执行时机：**\r\n$(document).ready(function(){}); [详情解释](http://blog.csdn.net/u014785563/article/details/53456978)\r\n\r\n**事件绑定：**\r\n\r\nbind(event,data,function)\r\n第一个参数是事件类型，类型包括：blur focus load resize unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter change select submit keydown keypress keyup error等，当然也可以包含自定义名称（可以发现[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")中对应的事件绑定类型比[JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\")中的少了一个“on”）\r\n第二个参数是可选参数，作为event.data属性值传递给事件对象的额外数据对象\r\n第三个参数则是用来绑定的处理函数\r\n\r\n（1）基本效果：\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').bind(\"click\",function(){\r\n            $(this).next().show();\r\n        })\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n（2）加强效果：\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').bind(\"click\",function(){\r\n            if($(this).next().is(\":visible\")){//如果内容是显示的\r\n                $(this).next().hide();\r\n            }else{\r\n                $(this).next().show();\r\n            }\r\n\r\n        })\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n“:visible”在可见性过滤选择器可以查询到，[详情查看](http://blog.csdn.net/u014785563/article/details/53465749)\r\n\r\n（3）改变事件绑定类型：\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').mouseover(function(){\r\n            $(this).next().show();\r\n        }).mouseout(function(){\r\n            $(this).next().hide();\r\n        })\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n（4）合成事件：\r\n\r\n1.hover()方法的语言结构：hover(enter,leave);鼠标经过移出的组合方法\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').hover(function(){\r\n            $(this).next().show();\r\n        },function(){\r\n            $(this).next().hide();\r\n        })\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n2.toggle()方法结构：toggle(fn1,fn2,…,fnN):该方法用于模拟鼠标连续点击事件，第一次点击触发第一个事件，第二次点击触发第二个事件，依次循环。\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').toggle(function(){\r\n            $(this).addClass(\"highlight\");\r\n            $(this).next().show();\r\n        },function(){\r\n            $(this).removeClass(\"highlight\");\r\n            $(this).next().hide();\r\n        })\r\n\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    .highlight{\r\n        background: #f30;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n**事件冒泡：**\r\n1.什么是冒泡：在页面上可以有多个事件，也可以一个元素响应多个事件。假设网页上有两个元素，其中一个元素完全嵌套在另一个元素中，并且绑定了click事件，同时在body元素上也绑定了click事件。\r\n小例子：\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>Document</title>\r\n        <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        //为span元素绑定click事件\r\n        $(\'span\').bind(\"click\",function(){\r\n            var txt=$(\"#msg\").html()+\"<p>内层span元素被单击</p>\";\r\n            $(\"#msg\").html(txt);\r\n        });\r\n        //为div元素绑定click事件\r\n        $(\'#content\').bind(\"click\",function(){\r\n            var txt=$(\"#msg\").html()+\"<p>外层div元素被单击</p>\";\r\n            $(\"#msg\").html(txt);\r\n        });\r\n        //为body元素绑定click事件\r\n        $(\'body\').bind(\"click\",function(){\r\n            var txt=$(\"#msg\").html()+\"<p>body元素被单击</p>\";\r\n            $(\"#msg\").html(txt);\r\n        });\r\n\r\n    });\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"content\">\r\n        外层div元素\r\n        <span>内层span元素</span>\r\n        外层div元素\r\n    </div>\r\n    <div id=\"msg\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n<font color=\"red\">元素会按照事件的顺序依次向下冒泡。</font>\r\n\r\n<font color=\"red\">事件冒泡引发的问题：</font>\r\n事件冒泡就可能会引起预料外的效果，上面小例子中，本来只想触发span里面的click事件，却全部触发了。所以，我们很有必要对时间的作用范围进行限制。\r\n\r\n<font color=\"red\">事件对象：</font>\r\n$(“element”).bind(“click”,function(event){ //event:事件对象\r\n});\r\n这样的话，当单击element元素时，事件对象就被创建了，这是事件对象只有事件处理函数才能访问到。当事件处理函数结束之后，实践对象也就被销毁了\r\n\r\n<font color=\"red\">停止事件冒泡：</font>\r\n在jQuery中提供了stopPropagation()方法来停止事件冒泡\r\n\r\n```\r\n$(\"span\").bind(\"click\",function(){\r\n    var txt=$(\"msg\").html()+\"<p>内层span元素被单击</p>\"；\r\n    $(\"#msg\").html(txt);\r\n    event.stopPropagation();//停止事件冒泡\r\n});\r\n```\r\n\r\n<font color=\"red\">阻止默认行为：</font>\r\n在jQuery中，提供了preventDefault()方法来阻止元素的默认行为\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>Document</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\"#sub\").bind(\"click\",function(event){\r\n            var username=$(\"#username\").val();\r\n            if(username==\"\"){\r\n                $(\"#msg\").html(\"<p>姓名不能为空</p>\");\r\n                event.preventDefault();\r\n                //可以改写为 return false;\r\n            }\r\n        });\r\n\r\n    });\r\n    </script>\r\n</head>\r\n<body>\r\n    <form action=\"test.html\">\r\n        用户名：<input type=\"text\" id=\"username\">\r\n        <input type=\"submit\" value=\"提交\" id=\"sub\">\r\n    </form>\r\n    <div id=\"msg\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n<font color=\"red\">事件捕获：</font>\r\n事件捕获与事件冒泡相反，是从外层到里层的，但是jQuery不支持，只有通过原声JavaScript来能进行。还有就是事件捕获并非所有浏览器都是支持的。\r\n\r\n<font color=\"red\">事件对象的属性：</font>\r\n1.event.type\r\n\r\n```\r\n$(\"a\").click(function(event){\r\n    alert(event.type);//获取事件类型\r\n    return false;//阻止链接跳转\r\n});\r\n```\r\n\r\n2.event.preventDefault()方法\r\n上面已经介绍了，适用于阻止元素默认行为\r\n\r\n3.event.stopPropagation()方法：\r\n上面已经介绍过了，用于停止事件冒泡\r\n\r\n4.event.target\r\nevent.target的作用是获取到触发事件的元素。jQuery对其封装后，避免了各个浏览器不同标准的差异。\r\n\r\n```\r\n$(\"a[href=\'http://www.baidu.com\']\").click(function(event){\r\n    var tg=event.target;//获取事件对象\r\n    alert(tg.href);\r\n    return false;\r\n});\r\n```\r\n\r\n5.event.relatedTarget\r\nmouseover和mouseout所发生的元素可以通过event.target来访问，相关元素是通过event.relatedTarget来访问的。event.relatedTarget在mouseover中相当于IE浏览器的event.fromElement,在mouseout中相当于IE浏览器的event.toElement,jQuery对其封装，使之能兼容各种浏览器。\r\n\r\n6.event.pageX和event.pageY\r\n该方法的作用是获取到光标相对于页面的x坐标和y坐标。如果没有使用jQuery时，那么IE浏览器使用page.x/page.y,在火狐浏览器中使用event.pageX和event.pageY.\r\n\r\n```\r\n$(\"a\").click(function(event){\r\n    //获取鼠标当前相对于页面的坐标\r\n    alert(\"Current mouse position: \"+event.pageX+\",\"+event.pageY);\r\n    return false;\r\n});\r\n```\r\n\r\n7.event.which\r\n该方法的作用是在鼠标点击事件中获取到鼠标的左中右键：\r\n\r\n```\r\n$(\"a\").mousedown(function(e){\r\n    alert(e.which);\r\n});\r\n```\r\n\r\n//获得键盘的按键\r\n\r\n```\r\n$(\"input\").keyup(function(e){\r\n    alert(e.which);\r\n});\r\n```\r\n\r\n8.event.metaKey\r\n针对不同浏览器对键盘中的ctrl按键解释不同，jQuery进行封装，斌规定event.metaKey为键盘事件中获取ctrl按键\r\n\r\n<font color=\"red\">移除事件：</font>\r\nunbind([type],[data]);\r\n第一个参数是事件类型，第二个参数是将要移出的函数\r\n（1）如果没有参数，则删除所有绑定的事件\r\n（2）如果提供了事件类型作为参数，则只删除该类型的绑定事件\r\n（3）如果把在绑定时传递的处理函数作为第2个参数，则只有这个特定的事件处理函数会被删除\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>移除事件</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\"#delAll\").click(function(){\r\n            $(\"#btn\").unbind(\"click\");\r\n        });\r\n        $(\"#btn\").bind(\"click\",function(){\r\n            $(\"#test\").append(\"<p>我的绑定函数1</p>\");\r\n        }).bind(\"click\",function(){\r\n            $(\"#test\").append(\"<p>我的绑定函数2</p>\");\r\n        }).bind(\"click\",function(){\r\n            $(\"#test\").append(\"<p>我的绑定函数3</p>\");\r\n        });\r\n\r\n    });\r\n    </script>\r\n</head>\r\n<body>\r\n    <button id=\"btn\">单击我</button>\r\n    <button id=\"delAll\">删除所有事件</button>\r\n    <div id=\"test\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('70', 'JQuery动画', '<h1 id=\"h1-jquery-\"><a name=\"jQuery中的动画\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>jQuery中的动画</h1><p><strong>1.show()、hide()：</strong></p>\r\n<p>show方法和hide方法是<a href=\"http://lib.csdn.net/base/jquery\" title=\"jQuery知识库\">jQuery</a>中最基本的动画方法。在HTML文档中，为一个元素用hide方法，会将该元素的display样式改为“none”</p>\r\n<p><span>$</span>(“element”).hide();等同于$(“elemnt”).css(“display”,”none”);</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).hover(function(){\r\n            $(this).next().show();\r\n        },function(){\r\n            $(this).next().hide();\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>2.show()、hide()方法让元素动起来：</strong></p>\r\n<p>show()、hide()不带参数，就和上面表现形式是一样的。但是如果想调用show()方法时，元素慢慢的显示出来，可以为show()方法制定一个速度参数<br><span>$</span>(“element”).show(1000);<br>$(“element”).hide(1000);<br>代码在1秒内显示或隐藏</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).hover(function(){\r\n            $(this).next().show(1000);\r\n        },function(){\r\n            $(this).next().hide(1000);\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>fadeln()、fadeOut()：</strong><br>与show()方法不同的是，fadeIn和fadeOut方法只改变元素的不透明度。fadeOut方法会在指定的一段时间内降低元素的不透明度，直到元素完全消失(dispaly:none;)。fadeIn则相反</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).hover(function(){\r\n            $(this).next().fadeIn();\r\n        },function(){\r\n            $(this).next().fadeOut();\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>slideUp()、slideDown()：</strong><br>slideUp方法和slideDown方法只改变元素的高度。如果一个元素的display的属性为none时，调用slideDown方法时，这个元素会从上到下延伸显示。slideUp则相反</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.10.2.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&#39;#panel h5.head&#39;).hover(function(){\r\n            $(this).next().slideDown();\r\n        },function(){\r\n            $(this).next().slideUp();\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .content{\r\n        display:none;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;\r\n        &lt;h5 class=&quot;head&quot;&gt;什么是jQuery&lt;/h5&gt;\r\n        &lt;div class=&quot;content&quot;&gt;\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>自定义简单动画：</strong><br>前面几个小例子都可以让元素动起来，animate方法也可以让元素动起来，而且animate更具有活性。</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;动画&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;#panel&quot;).css(&quot;opacity&quot;,&quot;0.5&quot;);\r\n        $(&quot;#panel&quot;).click(function(){\r\n            //$(this).animate({left:&quot;500px&quot;},3000);普通状态\r\n            //$(this).animate({left:&quot;+=500px&quot;},3000);累加动画\r\n            //$(this).animate({left:&quot;500px&quot;,height:&quot;200px&quot;},3000);多重动画\r\n            /*按顺序执行多个动画\r\n            $(this).animate({left:&quot;500px&quot;},3000);\r\n            $(this).animate({height:&quot;200px&quot;},3000);\r\n            */\r\n            //综合动画\r\n            $(this).animate({left:&quot;400px&quot;,height:&quot;200px&quot;,opacity:&quot;1&quot;},3000)\r\n                .animate({top:&quot;200px&quot;,width:&quot;200px&quot;},3000)\r\n                .fadeOut(&quot;slow&quot;);\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    #panel{\r\n        position: relative;\r\n        width: 100px;\r\n        height: 100px;\r\n        border: 1px solid #0050D0;\r\n        background: #96E555;\r\n        cursor: pointer;/*鼠标样式*/\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;panel&quot;&gt;&lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>动画回调函数：</strong><br>上面的小例子中，如果在最后一步想要的是切换CSS样式，只需要按照常规方法：css(“dorder”,”5px solid blue”)。将css()方法写入到最后一个动画的回调函数中，代码如下：</p>\r\n<pre><code>$(&quot;#panel&quot;).click(function(){\r\n    $(this).animate({left:&quot;400px&quot;,height:&quot;200px&quot;,opacity:&quot;1&quot;},3000)\r\n        .animate({top:&quot;200px&quot;,width:&quot;200px&quot;},3000,function(){\r\n            $(this).css(&quot;border&quot;,&quot;5px solid blue&quot;);\r\n        })      \r\n});\r\n</code></pre><p>这样一来，css方法就加入到动画队列中了</p>\r\n<font color=\"red\">callback回调函数适用于jQuery所有的动画效果方法</font>\r\n\r\n<p><strong>停止动画和判断是否处于动画状态：</strong></p>\r\n<p><strong>1.停止元素动画(stop方法)：</strong><br>很多时候需要停止匹配元素正在进行的动画，就需要stop方法了。stop方法的语法结构为：stop([clearQueue].[gotoEnd]);<br>参数clearQueue和gotoEnd都是可选参数，为Boolean值(ture或flase)。clearQueue代表是否清空未执行完的动画队列，gotoEnd代表是否直接将正在执行的动画跳转到末状态，如果直接使用stop则会立刻停止正在运动的动画</p>\r\n<p><strong>2.判断元素是否处于动画状态(animated方法)：</strong><br>if(!$(element).is(“:animated”)){<br>//如果当前没有进行动画，则添加动画<br>}</p>\r\n<p><strong>3.延迟动画(delay方法)：</strong><br>在动画执行过程中，如果想对动画进行延迟操作，那么可以使用delay()方法</p>\r\n<pre><code>$(this).animate({left:&quot;400px&quot;,height:&quot;200px&quot;,opacity:&quot;1&quot;},3000)\r\n       .delay(1000)\r\n       .animate({top:&quot;200px&quot;,wiodth:&quot;200px&quot;},3000)\r\n       .delay(2000)\r\n       .fadeOut(&quot;slow&quot;);\r\n</code></pre><p>delay()方法允许我们将队列中的函数延时执行，它既可以推迟动画队列中的函数执行，也可以用于自定义队列</p>\r\n<p><strong>其他动画方法：</strong><br>toggle(speed,[callback])<br>toggle方法可以切换元素的可见状态。如果元素是可见的，则切换为隐藏，如果元素是隐藏的，则切换可见。</p>\r\n<p>slideToggle(speed,[easing],[callback])<br>slideToggle方法通过高度变化来切换匹配元素的可见性。这个动画效果只调整元素的高度。</p>\r\n<p>fadeTo(speed,opacity,[callback])<br>fadeTo可以吧元素的不透明度以渐进的方式调整到指定的值，这个方法只调整不透明度。<br>fadeTo(600,0.5)</p>\r\n<p>fadeToggle(speed,[easing],[callback])<br>fadeToggle方法通过不透明变化来切换匹配元素的可见性。这个动画效果只调整元素的不透明度。</p>\r\n', '96', '\r\n# jQuery中的动画\r\n\r\n**1.show()、hide()：**\r\n\r\nshow方法和hide方法是[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")中最基本的动画方法。在HTML文档中，为一个元素用hide方法，会将该元素的display样式改为“none”\r\n\r\n<span>$</span>(“element”).hide();等同于$(“elemnt”).css(“display”,”none”);\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-1.10.2.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').hover(function(){\r\n            $(this).next().show();\r\n        },function(){\r\n            $(this).next().hide();\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n**2.show()、hide()方法让元素动起来：**\r\n\r\nshow()、hide()不带参数，就和上面表现形式是一样的。但是如果想调用show()方法时，元素慢慢的显示出来，可以为show()方法制定一个速度参数\r\n<span>$</span>(“element”).show(1000);\r\n$(“element”).hide(1000);\r\n代码在1秒内显示或隐藏\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-1.10.2.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').hover(function(){\r\n            $(this).next().show(1000);\r\n        },function(){\r\n            $(this).next().hide(1000);\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n**fadeln()、fadeOut()：**\r\n与show()方法不同的是，fadeIn和fadeOut方法只改变元素的不透明度。fadeOut方法会在指定的一段时间内降低元素的不透明度，直到元素完全消失(dispaly:none;)。fadeIn则相反\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-1.10.2.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').hover(function(){\r\n            $(this).next().fadeIn();\r\n        },function(){\r\n            $(this).next().fadeOut();\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n**slideUp()、slideDown()：**\r\nslideUp方法和slideDown方法只改变元素的高度。如果一个元素的display的属性为none时，调用slideDown方法时，这个元素会从上到下延伸显示。slideUp则相反\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title></title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-1.10.2.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\'#panel h5.head\').hover(function(){\r\n            $(this).next().slideDown();\r\n        },function(){\r\n            $(this).next().slideUp();\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .content{\r\n        display:none;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\">\r\n        <h5 class=\"head\">什么是jQuery</h5>\r\n        <div class=\"content\">\r\n            jQuery是继prototype之后又一个优秀的JavaScript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n**自定义简单动画：**\r\n前面几个小例子都可以让元素动起来，animate方法也可以让元素动起来，而且animate更具有活性。\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>动画</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\"#panel\").css(\"opacity\",\"0.5\");\r\n        $(\"#panel\").click(function(){\r\n            //$(this).animate({left:\"500px\"},3000);普通状态\r\n            //$(this).animate({left:\"+=500px\"},3000);累加动画\r\n            //$(this).animate({left:\"500px\",height:\"200px\"},3000);多重动画\r\n            /*按顺序执行多个动画\r\n            $(this).animate({left:\"500px\"},3000);\r\n            $(this).animate({height:\"200px\"},3000);\r\n            */\r\n            //综合动画\r\n            $(this).animate({left:\"400px\",height:\"200px\",opacity:\"1\"},3000)\r\n                .animate({top:\"200px\",width:\"200px\"},3000)\r\n                .fadeOut(\"slow\");\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    #panel{\r\n        position: relative;\r\n        width: 100px;\r\n        height: 100px;\r\n        border: 1px solid #0050D0;\r\n        background: #96E555;\r\n        cursor: pointer;/*鼠标样式*/\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div id=\"panel\"></div>\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\n**动画回调函数：**\r\n上面的小例子中，如果在最后一步想要的是切换CSS样式，只需要按照常规方法：css(“dorder”,”5px solid blue”)。将css()方法写入到最后一个动画的回调函数中，代码如下：\r\n\r\n```\r\n$(\"#panel\").click(function(){\r\n    $(this).animate({left:\"400px\",height:\"200px\",opacity:\"1\"},3000)\r\n        .animate({top:\"200px\",width:\"200px\"},3000,function(){\r\n            $(this).css(\"border\",\"5px solid blue\");\r\n        })      \r\n});\r\n```\r\n\r\n这样一来，css方法就加入到动画队列中了\r\n<font color=\"red\">callback回调函数适用于jQuery所有的动画效果方法</font>\r\n\r\n**停止动画和判断是否处于动画状态：**\r\n\r\n**1.停止元素动画(stop方法)：**\r\n很多时候需要停止匹配元素正在进行的动画，就需要stop方法了。stop方法的语法结构为：stop([clearQueue].[gotoEnd]);\r\n参数clearQueue和gotoEnd都是可选参数，为Boolean值(ture或flase)。clearQueue代表是否清空未执行完的动画队列，gotoEnd代表是否直接将正在执行的动画跳转到末状态，如果直接使用stop则会立刻停止正在运动的动画\r\n\r\n**2.判断元素是否处于动画状态(animated方法)：**\r\nif(!$(element).is(“:animated”)){\r\n//如果当前没有进行动画，则添加动画\r\n}\r\n\r\n**3.延迟动画(delay方法)：**\r\n在动画执行过程中，如果想对动画进行延迟操作，那么可以使用delay()方法\r\n\r\n```\r\n$(this).animate({left:\"400px\",height:\"200px\",opacity:\"1\"},3000)\r\n       .delay(1000)\r\n       .animate({top:\"200px\",wiodth:\"200px\"},3000)\r\n       .delay(2000)\r\n       .fadeOut(\"slow\");\r\n```\r\n\r\ndelay()方法允许我们将队列中的函数延时执行，它既可以推迟动画队列中的函数执行，也可以用于自定义队列\r\n\r\n**其他动画方法：**\r\ntoggle(speed,[callback])\r\ntoggle方法可以切换元素的可见状态。如果元素是可见的，则切换为隐藏，如果元素是隐藏的，则切换可见。\r\n\r\nslideToggle(speed,[easing],[callback])\r\nslideToggle方法通过高度变化来切换匹配元素的可见性。这个动画效果只调整元素的高度。\r\n\r\nfadeTo(speed,opacity,[callback])\r\nfadeTo可以吧元素的不透明度以渐进的方式调整到指定的值，这个方法只调整不透明度。\r\nfadeTo(600,0.5)\r\n\r\nfadeToggle(speed,[easing],[callback])\r\nfadeToggle方法通过不透明变化来切换匹配元素的可见性。这个动画效果只调整元素的不透明度。\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('71', 'JQuery表单操作', '<h1 id=\"h1-jquery-\"><a name=\"jQuery对表单的操作\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>jQuery对表单的操作</h1><p>一个表单主要是由三部分组成：<br>（1）表单标签：包含处理表单数据所用的服务器端程序URL以及数据提交到服务器的方法<br>（2）表单域：包含文本框、密码框、隐藏框、多行文本框、复选框、单选框、下拉选择框和文件上传框等。<br>（3）表单按钮：包括提交按钮、复位按钮和一般按钮，用于间数据传送到服务器上或者取消传送，还可以用来控制其他定义了处理脚本的处理工作。</p>\r\n<p><strong>1.单行文本框应用：</strong></p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;jQuery对表单的操作&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;:input&quot;).focus(function(){//当输入域获得焦点 (focus) \r\n            $(this).addClass(&quot;focus&quot;);\r\n        }).blur(function(){//当输入域失去焦点 (blur) \r\n            $(this).removeClass(&quot;focus&quot;);\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .focus{\r\n        border: 1px solid #f00;\r\n        background: #fcc;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;form action=&quot;#&quot; method=&quot;POST&quot; id=&quot;regForm&quot;&gt;\r\n        &lt;fieldset&gt;\r\n            &lt;legend&gt;个人基本信息&lt;/legend&gt;\r\n            &lt;div&gt;\r\n                &lt;label for=&quot;username&quot;&gt;名称：&lt;/label&gt;\r\n                &lt;input id=&quot;username&quot; type=&quot;text&quot;&gt;\r\n            &lt;/div&gt;\r\n            &lt;div&gt;\r\n                &lt;label for=&quot;pass&quot;&gt;密码：&lt;/label&gt;\r\n                &lt;input id=&quot;pass&quot; type=&quot;password&quot;&gt;\r\n            &lt;/div&gt;\r\n            &lt;div&gt;\r\n                &lt;label for=&quot;msg&quot;&gt;详细信息：&lt;/label&gt;\r\n                &lt;textarea id=&quot;msg&quot;&gt;&lt;/textarea&gt;\r\n            &lt;/div&gt;\r\n        &lt;/fieldset&gt;\r\n    &lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>2.多行文本框应用：</strong></p>\r\n<p>（1）高度的变化</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;jQuery对表单的操作&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        var $comment=$(&quot;#comment&quot;);//获得评论框\r\n        $(&#39;.bigger&#39;).click(function(){\r\n            if(!$comment.is(&quot;:animated&quot;)){\r\n                if($comment.height()&lt;500){\r\n                    $comment.animate({height:&quot;+=50&quot;},400);\r\n                }\r\n            }\r\n        });\r\n        $(&#39;.smaller&#39;).click(function(){\r\n            if(!$comment.is(&quot;:animated&quot;)){\r\n                if($comment.height()&gt;50){\r\n                    $comment.animate({height:&quot;-=50&quot;},400);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;form&gt;\r\n        &lt;div class=&quot;msg&quot;&gt;\r\n            &lt;div class=&quot;msg_caption&quot;&gt;\r\n                &lt;span class=&quot;bigger&quot;&gt;放大&lt;/span&gt;\r\n                &lt;span class=&quot;smaller&quot;&gt;缩小&lt;/span&gt;\r\n            &lt;/div&gt;\r\n            &lt;div&gt;\r\n                &lt;textarea id=&quot;comment&quot; rows=&quot;8&quot; cols=&quot;20&quot;&gt;\r\n                    多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高\r\n                &lt;/textarea&gt;\r\n            &lt;/div&gt;\r\n        &lt;/div&gt;\r\n    &lt;/form&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p>如改变滚动条高度变化就使用scrollTop方法来进行处理</p>\r\n<p><strong>3.下拉框应用：</strong></p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;jQuery对表单的操作&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;#add&quot;).click(function(){\r\n            var $options=$(&#39;#select1 option:selected&#39;);\r\n            $options.appendTo(&quot;#select2&quot;);\r\n        });\r\n        $(&quot;#addAll&quot;).click(function(){\r\n            var $options=$(&#39;#select1 option&#39;);\r\n            $options.appendTo(&quot;#select2&quot;);\r\n        });\r\n        $(&quot;#select1&quot;).dblclick(function(){\r\n            var $options=$(&#39;option:selected&#39;,this);\r\n            $options.appendTo(&quot;#select2&quot;);\r\n        });\r\n        $(&quot;#remove&quot;).click(function(){\r\n            var $options=$(&#39;#select2 option:selected&#39;);\r\n            $options.appendTo(&quot;#select1&quot;);\r\n        });\r\n        $(&quot;#removeAll&quot;).click(function(){\r\n            var $options=$(&#39;#select2 option&#39;);\r\n            $options.appendTo(&quot;#select1&quot;);\r\n        });\r\n        $(&quot;#select2&quot;).dblclick(function(){\r\n            var $options=$(&#39;option:selected&#39;,this);\r\n            $options.appendTo(&quot;#select1&quot;);\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div class=&quot;centent&quot;&gt;\r\n        &lt;select multiple id=&quot;select1&quot; style=&quot;width:100px;height:160px;&quot;&gt;\r\n            &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;\r\n            &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;\r\n            &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;\r\n            &lt;option value=&quot;4&quot;&gt;4&lt;/option&gt;\r\n            &lt;option value=&quot;5&quot;&gt;5&lt;/option&gt;\r\n            &lt;option value=&quot;6&quot;&gt;6&lt;/option&gt;\r\n            &lt;option value=&quot;7&quot;&gt;7&lt;/option&gt;\r\n            &lt;option value=&quot;8&quot;&gt;8&lt;/option&gt;\r\n        &lt;/select&gt;\r\n        &lt;div&gt;\r\n            &lt;span id=&quot;add&quot;&gt;选中添加到右边&amp;gt;&amp;gt;&lt;/span&gt;\r\n            &lt;span id=&quot;addAll&quot;&gt;全部添加到右边&amp;gt;&amp;gt;&lt;/span&gt;\r\n        &lt;/div&gt;\r\n\r\n    &lt;/div&gt;\r\n    &lt;div class=&quot;centent&quot;&gt;\r\n        &lt;select multiple id=&quot;select2&quot; style=&quot;width:100px;height:160px;&quot;&gt;&lt;/select&gt;\r\n        &lt;div&gt;\r\n            &lt;span id=&quot;remove&quot;&gt;&amp;lt;&amp;lt;选中删除到左边&lt;/span&gt;\r\n            &lt;span id=&quot;removeAll&quot;&gt;&amp;lt;&amp;lt;全部删除到左边&lt;/span&gt;\r\n        &lt;/div&gt;  \r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n</code></pre><p><strong>4.表单验证：</strong></p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;jQuery对表单的操作&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;form :input.required&quot;).each(function(){\r\n            var $required=$(&quot;&lt;strong class=&#39;high&#39;&gt;*&lt;/strong&gt;&quot;);\r\n            $(this).parent().append($required);//把它追加到文档中\r\n        });\r\n        $(&quot;form :input&quot;).blur(function(){\r\n            var $parent=$(this).parent();\r\n            $parent.find(&quot;.formtips&quot;).remove();\r\n            //验证用户名\r\n            if($(this).is(&quot;#username&quot;)){\r\n                if(this.value=&quot;&quot;||this.value.length&lt;6){\r\n                    var errorMsg=&#39;请至少输入6位用户名&#39;;\r\n                    $parent.append(&quot;&lt;span class=&#39;formtips onError&#39;&gt;&quot;+errorMsg+&quot;&lt;/span&gt;&quot;);\r\n                }else{\r\n                    var successMsg=&#39;输入正确&#39;;\r\n                    $parent.append(&quot;&lt;span class=&#39;formtips onSuccess&#39;&gt;&quot;+successMsg+&quot;&lt;/span&gt;&quot;);\r\n                }\r\n            }\r\n            //验证邮箱\r\n            if($(this).is(&quot;#email&quot;)){\r\n                if(this.value=&quot;&quot;||(this.value!=&quot;&quot; &amp;&amp; !/.+@.+\\.[a-zA-Z]{2,4}$/.test(this.value))){\r\n                    var errorMsg=&#39;请输入正确的Email地址&#39;;\r\n                    $parent.append(&quot;&lt;span class=&#39;formtips onError&#39;&gt;&quot;+errorMsg+&quot;&lt;/span&gt;&quot;);\r\n                }else{\r\n                    var successMsg=&#39;输入正确&#39;;\r\n                    $parent.append(&quot;&lt;span class=&#39;formtips onSuccess&#39;&gt;&quot;+successMsg+&quot;&lt;/span&gt;&quot;);\r\n                }\r\n            }\r\n        });\r\n        $(&quot;#send&quot;).click(function(){\r\n            $(&quot;form .required:input&quot;).trigger(&#39;blur&#39;);\r\n            var numError=$(&quot;form .onError&quot;).length;\r\n            if(numError){\r\n                return false;\r\n            }else{\r\n                alert(&quot;注册成功，密码已经发到邮箱，请查收&quot;);\r\n            }\r\n        });\r\n\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .high{\r\n        color:red;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;form method=&quot;post&quot; action=&quot;&quot;&gt;\r\n        &lt;div class=&quot;int&quot;&gt;\r\n            &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt;\r\n            &lt;input type=&quot;text&quot;  id=&quot;username&quot; class=&quot;required&quot; /&gt;\r\n        &lt;/div&gt;\r\n        &lt;div class=&quot;int&quot;&gt;\r\n            &lt;label for=&quot;email&quot;&gt;邮箱：&lt;/label&gt;\r\n            &lt;input type=&quot;text&quot;  id=&quot;email&quot; class=&quot;required&quot; /&gt;\r\n        &lt;/div&gt;\r\n        &lt;div class=&quot;int&quot;&gt;\r\n            &lt;label for=&quot;personinfo&quot;&gt;个人资料：&lt;/label&gt;\r\n            &lt;input type=&quot;text&quot;  id=&quot;personinfo&quot;/&gt;\r\n        &lt;/div&gt;\r\n        &lt;div class=&quot;sub&quot;&gt;\r\n            &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;send&quot; /&gt;\r\n            &lt;input type=&quot;reset&quot; id=&quot;res&quot; /&gt;\r\n        &lt;/div&gt;\r\n    &lt;/form&gt;\r\n&lt;/body&gt;\r\n</code></pre>', '97', '\r\n# jQuery对表单的操作\r\n\r\n一个表单主要是由三部分组成：\r\n（1）表单标签：包含处理表单数据所用的服务器端程序URL以及数据提交到服务器的方法\r\n（2）表单域：包含文本框、密码框、隐藏框、多行文本框、复选框、单选框、下拉选择框和文件上传框等。\r\n（3）表单按钮：包括提交按钮、复位按钮和一般按钮，用于间数据传送到服务器上或者取消传送，还可以用来控制其他定义了处理脚本的处理工作。\r\n\r\n**1.单行文本框应用：**\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>jQuery对表单的操作</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\":input\").focus(function(){//当输入域获得焦点 (focus) \r\n            $(this).addClass(\"focus\");\r\n        }).blur(function(){//当输入域失去焦点 (blur) \r\n            $(this).removeClass(\"focus\");\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .focus{\r\n        border: 1px solid #f00;\r\n        background: #fcc;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <form action=\"#\" method=\"POST\" id=\"regForm\">\r\n        <fieldset>\r\n            <legend>个人基本信息</legend>\r\n            <div>\r\n                <label for=\"username\">名称：</label>\r\n                <input id=\"username\" type=\"text\">\r\n            </div>\r\n            <div>\r\n                <label for=\"pass\">密码：</label>\r\n                <input id=\"pass\" type=\"password\">\r\n            </div>\r\n            <div>\r\n                <label for=\"msg\">详细信息：</label>\r\n                <textarea id=\"msg\"></textarea>\r\n            </div>\r\n        </fieldset>\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n**2.多行文本框应用：**\r\n\r\n（1）高度的变化\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>jQuery对表单的操作</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        var $comment=$(\"#comment\");//获得评论框\r\n        $(\'.bigger\').click(function(){\r\n            if(!$comment.is(\":animated\")){\r\n                if($comment.height()<500){\r\n                    $comment.animate({height:\"+=50\"},400);\r\n                }\r\n            }\r\n        });\r\n        $(\'.smaller\').click(function(){\r\n            if(!$comment.is(\":animated\")){\r\n                if($comment.height()>50){\r\n                    $comment.animate({height:\"-=50\"},400);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    </script>\r\n\r\n</head>\r\n<body>\r\n    <form>\r\n        <div class=\"msg\">\r\n            <div class=\"msg_caption\">\r\n                <span class=\"bigger\">放大</span>\r\n                <span class=\"smaller\">缩小</span>\r\n            </div>\r\n            <div>\r\n                <textarea id=\"comment\" rows=\"8\" cols=\"20\">\r\n                    多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高度变化多行文本框高\r\n                </textarea>\r\n            </div>\r\n        </div>\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n如改变滚动条高度变化就使用scrollTop方法来进行处理\r\n\r\n**3.下拉框应用：**\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>jQuery对表单的操作</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\"#add\").click(function(){\r\n            var $options=$(\'#select1 option:selected\');\r\n            $options.appendTo(\"#select2\");\r\n        });\r\n        $(\"#addAll\").click(function(){\r\n            var $options=$(\'#select1 option\');\r\n            $options.appendTo(\"#select2\");\r\n        });\r\n        $(\"#select1\").dblclick(function(){\r\n            var $options=$(\'option:selected\',this);\r\n            $options.appendTo(\"#select2\");\r\n        });\r\n        $(\"#remove\").click(function(){\r\n            var $options=$(\'#select2 option:selected\');\r\n            $options.appendTo(\"#select1\");\r\n        });\r\n        $(\"#removeAll\").click(function(){\r\n            var $options=$(\'#select2 option\');\r\n            $options.appendTo(\"#select1\");\r\n        });\r\n        $(\"#select2\").dblclick(function(){\r\n            var $options=$(\'option:selected\',this);\r\n            $options.appendTo(\"#select1\");\r\n        });\r\n    });\r\n    </script>\r\n</head>\r\n<body>\r\n    <div class=\"centent\">\r\n        <select multiple id=\"select1\" style=\"width:100px;height:160px;\">\r\n            <option value=\"1\">1</option>\r\n            <option value=\"2\">2</option>\r\n            <option value=\"3\">3</option>\r\n            <option value=\"4\">4</option>\r\n            <option value=\"5\">5</option>\r\n            <option value=\"6\">6</option>\r\n            <option value=\"7\">7</option>\r\n            <option value=\"8\">8</option>\r\n        </select>\r\n        <div>\r\n            <span id=\"add\">选中添加到右边&gt;&gt;</span>\r\n            <span id=\"addAll\">全部添加到右边&gt;&gt;</span>\r\n        </div>\r\n\r\n    </div>\r\n    <div class=\"centent\">\r\n        <select multiple id=\"select2\" style=\"width:100px;height:160px;\"></select>\r\n        <div>\r\n            <span id=\"remove\">&lt;&lt;选中删除到左边</span>\r\n            <span id=\"removeAll\">&lt;&lt;全部删除到左边</span>\r\n        </div>  \r\n    </div>\r\n</body>\r\n\r\n```\r\n\r\n**4.表单验证：**\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>jQuery对表单的操作</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\"form :input.required\").each(function(){\r\n            var $required=$(\"<strong class=\'high\'>*</strong>\");\r\n            $(this).parent().append($required);//把它追加到文档中\r\n        });\r\n        $(\"form :input\").blur(function(){\r\n            var $parent=$(this).parent();\r\n            $parent.find(\".formtips\").remove();\r\n            //验证用户名\r\n            if($(this).is(\"#username\")){\r\n                if(this.value=\"\"||this.value.length<6){\r\n                    var errorMsg=\'请至少输入6位用户名\';\r\n                    $parent.append(\"<span class=\'formtips onError\'>\"+errorMsg+\"</span>\");\r\n                }else{\r\n                    var successMsg=\'输入正确\';\r\n                    $parent.append(\"<span class=\'formtips onSuccess\'>\"+successMsg+\"</span>\");\r\n                }\r\n            }\r\n            //验证邮箱\r\n            if($(this).is(\"#email\")){\r\n                if(this.value=\"\"||(this.value!=\"\" && !/.+@.+\\.[a-zA-Z]{2,4}$/.test(this.value))){\r\n                    var errorMsg=\'请输入正确的Email地址\';\r\n                    $parent.append(\"<span class=\'formtips onError\'>\"+errorMsg+\"</span>\");\r\n                }else{\r\n                    var successMsg=\'输入正确\';\r\n                    $parent.append(\"<span class=\'formtips onSuccess\'>\"+successMsg+\"</span>\");\r\n                }\r\n            }\r\n        });\r\n        $(\"#send\").click(function(){\r\n            $(\"form .required:input\").trigger(\'blur\');\r\n            var numError=$(\"form .onError\").length;\r\n            if(numError){\r\n                return false;\r\n            }else{\r\n                alert(\"注册成功，密码已经发到邮箱，请查收\");\r\n            }\r\n        });\r\n\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .high{\r\n        color:red;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <form method=\"post\" action=\"\">\r\n        <div class=\"int\">\r\n            <label for=\"username\">用户名：</label>\r\n            <input type=\"text\"  id=\"username\" class=\"required\" />\r\n        </div>\r\n        <div class=\"int\">\r\n            <label for=\"email\">邮箱：</label>\r\n            <input type=\"text\"  id=\"email\" class=\"required\" />\r\n        </div>\r\n        <div class=\"int\">\r\n            <label for=\"personinfo\">个人资料：</label>\r\n            <input type=\"text\"  id=\"personinfo\"/>\r\n        </div>\r\n        <div class=\"sub\">\r\n            <input type=\"button\" value=\"提交\" id=\"send\" />\r\n            <input type=\"reset\" id=\"res\" />\r\n        </div>\r\n    </form>\r\n</body>\r\n\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('72', 'JQuery表格操作', '<h1 id=\"h1-jquery-\"><a name=\"jQuery表格应用、其他应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>jQuery表格应用、其他应用</h1><font color=\"red\">内容主要包含表格应用、字体变换、网页选项卡</font>\r\n\r\n<p><strong><a href=\"http://lib.csdn.net/base/jquery\" title=\"jQuery知识库\">jQuery</a>表格应用：</strong></p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;jQuery对表单的操作&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;tbody&gt;tr:odd&quot;).addClass(&quot;odd&quot;);\r\n        $(&quot;tbody&gt;tr:even&quot;).addClass(&quot;even&quot;);\r\n        $(&quot;tbody&gt;tr&quot;).click(function(){\r\n            $(this).addClass(&quot;selected&quot;)\r\n            .siblings().removeClass(&quot;selected&quot;);\r\n        });\r\n\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    table{\r\n        border: 1px black solid;\r\n    }\r\n    .even{\r\n        background: #FFF38F;\r\n    }\r\n    .odd{\r\n        background: #ffffee;\r\n    }\r\n    .selected{\r\n        background: red;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;table&gt;\r\n        &lt;thead&gt;\r\n            &lt;tr&gt;\r\n                &lt;th&gt;姓名&lt;/th&gt;\r\n                &lt;th&gt;性别&lt;/th&gt;\r\n                &lt;th&gt;暂住地&lt;/th&gt;\r\n            &lt;/tr&gt;\r\n        &lt;/thead&gt;\r\n        &lt;tbody&gt;\r\n            &lt;tr&gt;\r\n                &lt;th&gt;张三&lt;/th&gt;\r\n                &lt;th&gt;男&lt;/th&gt;\r\n                &lt;th&gt;杭州&lt;/th&gt;\r\n            &lt;/tr&gt;\r\n            &lt;tr&gt;\r\n                &lt;th&gt;张三&lt;/th&gt;\r\n                &lt;th&gt;男&lt;/th&gt;\r\n                &lt;th&gt;杭州&lt;/th&gt;\r\n            &lt;/tr&gt;\r\n            &lt;tr&gt;\r\n                &lt;th&gt;张三&lt;/th&gt;\r\n                &lt;th&gt;男&lt;/th&gt;\r\n                &lt;th&gt;杭州&lt;/th&gt;\r\n            &lt;/tr&gt;\r\n            &lt;tr&gt;\r\n                &lt;th&gt;张三&lt;/th&gt;\r\n                &lt;th&gt;男&lt;/th&gt;\r\n                &lt;th&gt;杭州&lt;/th&gt;\r\n            &lt;/tr&gt;\r\n            &lt;tr&gt;\r\n                &lt;th&gt;张三&lt;/th&gt;\r\n                &lt;th&gt;男&lt;/th&gt;\r\n                &lt;th&gt;杭州&lt;/th&gt;\r\n            &lt;/tr&gt;\r\n        &lt;/tbody&gt;\r\n    &lt;/table&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>其他应用：</strong></p>\r\n<p><strong>1.字体变换：</strong></p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;网页字体大小&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        $(&quot;span&quot;).click(function(){\r\n            var thisEle=$(&quot;#para&quot;).css(&quot;font-size&quot;);//获取到当前font-size的值\r\n            var textFontSize=parseInt(thisEle,10);//使用parseInt去掉单位\r\n            var cName=$(this).attr(&quot;class&quot;);\r\n            if(cName == &quot;bigger&quot;){\r\n                textFontSize += 2;\r\n            }else if(cName == &quot;smaller&quot;){\r\n                textFontSize -= 2;\r\n            }\r\n            $(&quot;#para&quot;).css(&quot;font-size&quot;,textFontSize);\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .bigger{\r\n        background: #ccc;\r\n        padding: 5px;\r\n    }\r\n    .smaller{\r\n        background: blue;\r\n        color: #fff;\r\n        padding: 5px;\r\n    }\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div class=&quot;msg&quot;&gt;\r\n        &lt;div class=&quot;msg_caption&quot;&gt;\r\n            &lt;span class=&quot;bigger&quot;&gt;放大&lt;/span&gt;\r\n            &lt;span class=&quot;smaller&quot;&gt;缩小&lt;/span&gt;\r\n        &lt;/div&gt;\r\n        &lt;div&gt;\r\n            &lt;p id=&quot;para&quot;&gt;\r\n                jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n            &lt;/p&gt;\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>2.网页选项卡：</strong></p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;网页选项卡&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n    $(document).ready(function(){\r\n        var $div_li=$(&quot;div.tab_menu ul li&quot;);\r\n        $div_li.click(function(){\r\n            $(this).addClass(&quot;selected&quot;)//添加li元素高亮\r\n                .siblings().removeClass(&quot;selected&quot;);//去除其他li元素高亮\r\n            var index=$div_li.index(this);//获取当前单击的li元素在全部li元素中的索引\r\n            $(&quot;div.tab_box&gt;div&quot;).eq(index).show()\r\n                .siblings().hide();\r\n        });\r\n    });\r\n    &lt;/script&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n    .tab_menu ul li{\r\n        float: left;\r\n        background: #ccc;\r\n        list-style-type:none;\r\n        margin-right: 5px;\r\n        border: 1px solid black;\r\n        position: 3px;\r\n    }\r\n    .tab_menu ul li.selected{\r\n        background: #fff;\r\n    }\r\n    .tab_box{\r\n        position: absolute;\r\n        width: 200px;\r\n        height: 200px;\r\n        border: 1px black solid;\r\n        margin-top: 20px\r\n    }\r\n\r\n    .hide{\r\n        display: none;\r\n    }\r\n\r\n    &lt;/style&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div class=&quot;tab&quot;&gt;\r\n        &lt;div class=&quot;tab_menu&quot;&gt;\r\n            &lt;ul&gt;\r\n                &lt;li class=&quot;selected&quot;&gt;时事&lt;/li&gt;\r\n                &lt;li&gt;体育&lt;/li&gt;\r\n                &lt;li&gt;娱乐&lt;/li&gt;\r\n            &lt;/ul&gt;\r\n        &lt;/div&gt;\r\n        &lt;div class=&quot;tab_box&quot;&gt;\r\n            &lt;div&gt;时事&lt;/div&gt;\r\n            &lt;div class=&quot;hide&quot;&gt;体育&lt;/div&gt;\r\n            &lt;div class=&quot;hide&quot;&gt;娱乐&lt;/div&gt;\r\n        &lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre>', '99', '\r\n# jQuery表格应用、其他应用\r\n\r\n<font color=\"red\">内容主要包含表格应用、字体变换、网页选项卡</font>\r\n\r\n**[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")表格应用：**\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>jQuery对表单的操作</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\"tbody>tr:odd\").addClass(\"odd\");\r\n        $(\"tbody>tr:even\").addClass(\"even\");\r\n        $(\"tbody>tr\").click(function(){\r\n            $(this).addClass(\"selected\")\r\n            .siblings().removeClass(\"selected\");\r\n        });\r\n\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    table{\r\n        border: 1px black solid;\r\n    }\r\n    .even{\r\n        background: #FFF38F;\r\n    }\r\n    .odd{\r\n        background: #ffffee;\r\n    }\r\n    .selected{\r\n        background: red;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <table>\r\n        <thead>\r\n            <tr>\r\n                <th>姓名</th>\r\n                <th>性别</th>\r\n                <th>暂住地</th>\r\n            </tr>\r\n        </thead>\r\n        <tbody>\r\n            <tr>\r\n                <th>张三</th>\r\n                <th>男</th>\r\n                <th>杭州</th>\r\n            </tr>\r\n            <tr>\r\n                <th>张三</th>\r\n                <th>男</th>\r\n                <th>杭州</th>\r\n            </tr>\r\n            <tr>\r\n                <th>张三</th>\r\n                <th>男</th>\r\n                <th>杭州</th>\r\n            </tr>\r\n            <tr>\r\n                <th>张三</th>\r\n                <th>男</th>\r\n                <th>杭州</th>\r\n            </tr>\r\n            <tr>\r\n                <th>张三</th>\r\n                <th>男</th>\r\n                <th>杭州</th>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</body>\r\n</html>\r\n```\r\n\r\n**其他应用：**\r\n\r\n**1.字体变换：**\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>网页字体大小</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        $(\"span\").click(function(){\r\n            var thisEle=$(\"#para\").css(\"font-size\");//获取到当前font-size的值\r\n            var textFontSize=parseInt(thisEle,10);//使用parseInt去掉单位\r\n            var cName=$(this).attr(\"class\");\r\n            if(cName == \"bigger\"){\r\n                textFontSize += 2;\r\n            }else if(cName == \"smaller\"){\r\n                textFontSize -= 2;\r\n            }\r\n            $(\"#para\").css(\"font-size\",textFontSize);\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .bigger{\r\n        background: #ccc;\r\n        padding: 5px;\r\n    }\r\n    .smaller{\r\n        background: blue;\r\n        color: #fff;\r\n        padding: 5px;\r\n    }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"msg\">\r\n        <div class=\"msg_caption\">\r\n            <span class=\"bigger\">放大</span>\r\n            <span class=\"smaller\">缩小</span>\r\n        </div>\r\n        <div>\r\n            <p id=\"para\">\r\n                jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML（标准通用标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。\r\n            </p>\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n**2.网页选项卡：**\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>网页选项卡</title>\r\n    <script type=\"text/javascript\" src=\"../js/jquery-3.1.1.js\"></script>\r\n    <script type=\"text/javascript\">\r\n    $(document).ready(function(){\r\n        var $div_li=$(\"div.tab_menu ul li\");\r\n        $div_li.click(function(){\r\n            $(this).addClass(\"selected\")//添加li元素高亮\r\n                .siblings().removeClass(\"selected\");//去除其他li元素高亮\r\n            var index=$div_li.index(this);//获取当前单击的li元素在全部li元素中的索引\r\n            $(\"div.tab_box>div\").eq(index).show()\r\n                .siblings().hide();\r\n        });\r\n    });\r\n    </script>\r\n    <style type=\"text/css\">\r\n    .tab_menu ul li{\r\n        float: left;\r\n        background: #ccc;\r\n        list-style-type:none;\r\n        margin-right: 5px;\r\n        border: 1px solid black;\r\n        position: 3px;\r\n    }\r\n    .tab_menu ul li.selected{\r\n        background: #fff;\r\n    }\r\n    .tab_box{\r\n        position: absolute;\r\n        width: 200px;\r\n        height: 200px;\r\n        border: 1px black solid;\r\n        margin-top: 20px\r\n    }\r\n\r\n    .hide{\r\n        display: none;\r\n    }\r\n\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"tab\">\r\n        <div class=\"tab_menu\">\r\n            <ul>\r\n                <li class=\"selected\">时事</li>\r\n                <li>体育</li>\r\n                <li>娱乐</li>\r\n            </ul>\r\n        </div>\r\n        <div class=\"tab_box\">\r\n            <div>时事</div>\r\n            <div class=\"hide\">体育</div>\r\n            <div class=\"hide\">娱乐</div>\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('73', 'jquery', '<p>jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。<br>jQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等</p>\r\n<h1 id=\"h1-u8BEDu8A00u7279u70B9\"><a name=\"语言特点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语言特点</h1><h2 id=\"h2-u5FEBu901Fu83B7u53D6u6587u6863u5143u7D20\"><a name=\"快速获取文档元素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>快速获取文档元素</h2><p>jQuery的选择机制构建于Css的选择器，它提供了快速查询DOM文档中元素的能力，而且大大强化了JavaScript中获取页面元素的方式。</p>\r\n<h2 id=\"h2-u63D0u4F9Bu6F02u4EAEu7684u9875u9762u52A8u6001u6548u679C\"><a name=\"提供漂亮的页面动态效果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>提供漂亮的页面动态效果</h2><p>jQuery中内置了一系列的动画效果，可以开发出非常漂亮的网页，许多网站都使用jQuery的内置的效果，比如淡入淡出、元素移除等动态特效。</p>\r\n<h2 id=\"h2--ajax-\"><a name=\"创建AJAX无刷新网页\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建AJAX无刷新网页</h2><p>AJAX是异步的JavaScript和ML的简称，可以开发出非常灵敏无刷新的网页，特别是开发服务器端网页时，比如PHP网站，需要往返地与服务器通信，如果不使用AJAX，每次数据更新不得不重新刷新网页，而使用AJAX特效后，可以对页面进行局部刷新，提供动态的效果。</p>\r\n<h2 id=\"h2--javascript-\"><a name=\"提供对JavaScript语言的增强\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>提供对JavaScript语言的增强</h2><p>jQuery提供了对基本JavaScript结构的增强，比如元素迭代和数组处理等操作。</p>\r\n<h2 id=\"h2-u589Eu5F3Au7684u4E8Bu4EF6u5904u7406\"><a name=\"增强的事件处理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>增强的事件处理</h2><p>jQuery提供了各种页面事件，它可以避免程序员在HTML中添加太事件处理代码，最重要的是，它的事件处理器消除了各种浏览器兼容性问题。</p>\r\n<h2 id=\"h2-u66F4u6539u7F51u9875u5185u5BB9\"><a name=\"更改网页内容\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>更改网页内容</h2><p>jQuery可以修改网页中的内容，比如更改网页的文本、插入或者翻转网页图像，jQuery简化了原本使用JavaScript代码需要处理的方式。[6-7] </p>\r\n', '76', 'jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。\r\njQuery的核心特性可以总结为：具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等\r\n\r\n# 语言特点\r\n## 快速获取文档元素\r\njQuery的选择机制构建于Css的选择器，它提供了快速查询DOM文档中元素的能力，而且大大强化了JavaScript中获取页面元素的方式。\r\n## 提供漂亮的页面动态效果\r\njQuery中内置了一系列的动画效果，可以开发出非常漂亮的网页，许多网站都使用jQuery的内置的效果，比如淡入淡出、元素移除等动态特效。\r\n## 创建AJAX无刷新网页\r\nAJAX是异步的JavaScript和ML的简称，可以开发出非常灵敏无刷新的网页，特别是开发服务器端网页时，比如PHP网站，需要往返地与服务器通信，如果不使用AJAX，每次数据更新不得不重新刷新网页，而使用AJAX特效后，可以对页面进行局部刷新，提供动态的效果。\r\n## 提供对JavaScript语言的增强\r\njQuery提供了对基本JavaScript结构的增强，比如元素迭代和数组处理等操作。\r\n## 增强的事件处理\r\njQuery提供了各种页面事件，它可以避免程序员在HTML中添加太事件处理代码，最重要的是，它的事件处理器消除了各种浏览器兼容性问题。\r\n## 更改网页内容\r\njQuery可以修改网页中的内容，比如更改网页的文本、插入或者翻转网页图像，jQuery简化了原本使用JavaScript代码需要处理的方式。[6-7] ');
INSERT INTO `article_info_true` VALUES ('74', '综合案列', '<h1 id=\"h1--\"><a name=\"综合开发，编写购物网首页\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>综合开发，编写购物网首页</h1><font color=\"red\">这章主要介绍如何搭建一个前端网页，文章最后面有完整的代码，前面的主要是说明</font>\r\n\r\n<p><strong>第一步：搭建网页结构</strong><br>购物网站基本上可以分为以下几部分：<br>头部：相当于网站的品牌，可用于放置Logo和通往各页面的链接<br>内容：防止页面的主体<br>底部：放置页面其他链接和版权信息</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;综合实战，购物网站&lt;/title&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;div id=&quot;header&quot;&gt;&lt;/div&gt;\r\n    &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;\r\n    &lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p><strong>第二步：网站样式（编写CSS）</strong><br>设置全局变量：<br>1.首先使用元素标签将每个元素的margin和padding属性设置为0,。这样做的好处是，可以让页面不受到不同浏览器默认设置的页边距和字边距的影响。<br>2.设置body元素的字体颜色，字号大小等，这样可以规范整个网站的样式风格。<br>3.设置其他属性的特定样式<br>reset.css:</p>\r\n<pre><code>body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td{\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\nbody,button,input,select,textarea{\r\n    font: 12px/1.5 tahoma,arial,\\5b8b\\4f53;}\r\n}\r\nh1,h2,h3,h4,h5,h6{\r\n    font-size: 100%;\r\n}\r\naddress,cite,dfn,em,var{\r\n    font-style: normal;\r\n}\r\ncode,kbd,pre,samp{\r\n    font-family: courier new,courier,monospace;\r\n}\r\nsmall{\r\n    font-size: 12px;\r\n}\r\nul,ol{\r\n    list-style: none;\r\n}\r\na{\r\n    text-decoration:none;\r\n}\r\na:hover{\r\n    text-decoration: underline;\r\n}\r\nsup{\r\n    vertical-align: text-top;\r\n}\r\nsub{\r\n    vertical-align: text-bottom;\r\n}\r\nlegend{\r\n    color: #000;\r\n}\r\nfieldset,img{\r\n    border: 0;\r\n}\r\nbutton,input,select,textarea{\r\n    font-size: 100%;\r\n}\r\ntable{\r\n    border-collapse: collapse;\r\n    border-spacing: 0;\r\n}\r\n.clear{\r\n    clear: both;\r\n    float: none;\r\n    height: 0;\r\n    overflow: hidden;\r\n}\r\nhtml .hide{\r\n    display: none;\r\n}\r\n</code></pre><p>因为篇幅有限，下面直接给出源码：<br>index.html:</p>\r\n<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;\r\n&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;综合实战，购物网站&lt;/title&gt;\r\n&lt;link rel=&quot;stylesheet&quot; href=&quot;styles/reset.css&quot; type=&quot;text/css&quot; /&gt;\r\n&lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot; type=&quot;text/css&quot; /&gt;\r\n&lt;link rel=&quot;stylesheet&quot; href=&quot;styles/skin/skin_0.css&quot; type=&quot;text/css&quot; id=&quot;cssfile&quot; /&gt;\r\n&lt;script src=&quot;scripts/jquery-3.1.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/jquery.cookie.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/input.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/changeSkin.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/nav.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/addhot.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/ad.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/tooltip.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/imgSlide.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;scripts/imgHover.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;div id=&quot;header&quot;&gt;\r\n    &lt;div class=&quot;contWidth&quot;&gt;\r\n        &lt;a class=&quot;logo&quot; href=&quot;#nogo&quot;&gt;&lt;img src=&quot;images/logo.gif&quot; alt=&quot;JaneShop&quot;/&gt;&lt;/a&gt;\r\n        &lt;div class=&quot;search&quot;&gt;\r\n            &lt;input type=&quot;text&quot; id=&quot;inputSearch&quot; class=&quot;&quot; value=&quot;请输入商品名称&quot; /&gt;\r\n        &lt;/div&gt;\r\n        &lt;ul id=&quot;skin&quot;&gt;\r\n            &lt;li id=&quot;skin_0&quot; title=&quot;蓝色&quot; class=&quot;selected&quot;&gt;蓝色&lt;/li&gt;\r\n            &lt;li id=&quot;skin_1&quot; title=&quot;紫色&quot;&gt;紫色&lt;/li&gt;\r\n            &lt;li id=&quot;skin_2&quot; title=&quot;红色&quot;&gt;红色&lt;/li&gt;\r\n            &lt;li id=&quot;skin_3&quot; title=&quot;天蓝色&quot;&gt;天蓝色&lt;/li&gt;\r\n            &lt;li id=&quot;skin_4&quot; title=&quot;橙色&quot;&gt;橙色&lt;/li&gt;\r\n            &lt;li id=&quot;skin_5&quot; title=&quot;淡绿色&quot;&gt;淡绿色&lt;/li&gt;\r\n        &lt;/ul&gt;\r\n        &lt;!-- 导航 start --&gt;\r\n        &lt;div id=&quot;nav&quot; class=&quot;mainNav&quot;&gt;\r\n            &lt;ul class=&quot;nav&quot;&gt;\r\n                 &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首 页&lt;/a&gt;&lt;/li&gt;\r\n                 &lt;li&gt;&lt;a href=&quot;#&quot;&gt;品 牌&lt;/a&gt;\r\n                    &lt;div class=&quot;jnNav&quot;&gt;\r\n                        &lt;div class=&quot;subitem&quot;&gt;\r\n                            &lt;dl class=&quot;fore&quot;&gt;\r\n                                &lt;dt&gt;\r\n                                    &lt;a href=&quot;#nogo&quot;&gt;品牌：&lt;/a&gt;\r\n                                &lt;/dt&gt;\r\n                                &lt;dd&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;安踏&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;奥康&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;骆驼&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em class=&quot;noborder&quot;&gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                &lt;/dd&gt;\r\n                            &lt;/dl&gt;\r\n                            &lt;dl&gt;\r\n                                &lt;dt&gt;\r\n                                    &lt;a href=&quot;#nogo&quot;&gt;品牌：&lt;/a&gt;\r\n                                &lt;/dt&gt;\r\n                                &lt;dd&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;安踏&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;奥康&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;骆驼&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em class=&quot;noborder&quot;&gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                &lt;/dd&gt;\r\n                            &lt;/dl&gt;\r\n                        &lt;/div&gt;\r\n                    &lt;/div&gt;\r\n                &lt;/li&gt;\r\n                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女 装&lt;/a&gt;\r\n                    &lt;div class=&quot;jnNav&quot;&gt;\r\n                        &lt;div class=&quot;subitem&quot;&gt;\r\n                            &lt;dl class=&quot;fore&quot;&gt;\r\n                                &lt;dt&gt;\r\n                                    &lt;a href=&quot;#nogo&quot;&gt;女 装：&lt;/a&gt;\r\n                                &lt;/dt&gt;\r\n                                &lt;dd&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;安踏&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;奥康&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;骆驼&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em class=&quot;noborder&quot;&gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                &lt;/dd&gt;\r\n                            &lt;/dl&gt;\r\n                            &lt;dl&gt;\r\n                                &lt;dt&gt;\r\n                                    &lt;a href=&quot;#nogo&quot;&gt;女 装：&lt;/a&gt;\r\n                                &lt;/dt&gt;\r\n                                &lt;dd&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;安踏&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;奥康&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;骆驼&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em class=&quot;noborder&quot;&gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                &lt;/dd&gt;\r\n                            &lt;/dl&gt;\r\n                        &lt;/div&gt;\r\n                    &lt;/div&gt;\r\n                &lt;/li&gt;\r\n                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男 装&lt;/a&gt;\r\n                    &lt;div class=&quot;jnNav&quot;&gt;\r\n                        &lt;div class=&quot;subitem&quot;&gt;\r\n                            &lt;dl class=&quot;fore&quot;&gt;\r\n                                &lt;dt&gt;\r\n                                    &lt;a href=&quot;#nogo&quot;&gt;男 装：&lt;/a&gt;\r\n                                &lt;/dt&gt;\r\n                                &lt;dd&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;安踏&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;奥康&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;骆驼&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em class=&quot;noborder&quot;&gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                &lt;/dd&gt;\r\n                            &lt;/dl&gt;\r\n                            &lt;dl&gt;\r\n                                &lt;dt&gt;\r\n                                    &lt;a href=&quot;#nogo&quot;&gt;男 装：&lt;/a&gt;\r\n                                &lt;/dt&gt;\r\n                                &lt;dd&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;安踏&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;奥康&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;骆驼&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;耐克&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;达芙妮&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em &gt;&lt;a href=&quot;#nogo&quot;&gt;李宁&lt;/a&gt;&lt;/em&gt;\r\n                                    &lt;em class=&quot;noborder&quot;&gt;&lt;a href=&quot;#nogo&quot;&gt;特步&lt;/a&gt;&lt;/em&gt;\r\n                                &lt;/dd&gt;\r\n                            &lt;/dl&gt;\r\n                        &lt;/div&gt;\r\n                    &lt;/div&gt;\r\n                 &lt;/li&gt;\r\n                 &lt;li&gt;&lt;a href=&quot;#&quot;&gt;鞋包配饰&lt;/a&gt;&lt;/li&gt;\r\n            &lt;/ul&gt;\r\n        &lt;/div&gt;\r\n        &lt;!-- 导航 end --&gt;\r\n    &lt;/div&gt;\r\n&lt;/div&gt;\r\n&lt;!--头部结束--&gt;\r\n&lt;!--主体开始--&gt;\r\n&lt;div id=&quot;content&quot;&gt;\r\n    &lt;div class=&quot;janeshop&quot;&gt;\r\n        &lt;!-- 商品分类 start --&gt;\r\n        &lt;div id=&quot;jnCatalog&quot;&gt;\r\n            &lt;h2 title=&quot;商品分类&quot;&gt;商品分类&lt;/h2&gt;\r\n            &lt;div class=&quot;jnCatainfo&quot;&gt;\r\n                &lt;h3&gt;推荐品牌&lt;/h3&gt;\r\n                &lt;ul&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;耐克&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; class=&quot;promoted&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;达芙妮&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;李宁&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;安踏&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;奥康&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; class=&quot;promoted&quot;&gt;骆驼&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;特步&lt;/a&gt;&lt;/li&gt;\r\n                &lt;/ul&gt;\r\n                &lt;br class=&quot;clear&quot; /&gt;\r\n                &lt;h3&gt;女装&lt;/h3&gt;\r\n                &lt;ul&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;呢大衣&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;T恤&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;羽绒&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;衬衫&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;羊绒衫&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;针织&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;连衣裙&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;皮外套&lt;/a&gt;&lt;/li&gt;\r\n                &lt;/ul&gt;\r\n                &lt;br class=&quot;clear&quot; /&gt;\r\n                &lt;h3&gt;男装&lt;/h3&gt;\r\n                &lt;ul&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;衬衫&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;T恤衫&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;夹克&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;大皮衣&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;风衣&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;牛仔裤&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;西服&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;卫衣&lt;/a&gt;&lt;/li&gt;\r\n                &lt;/ul&gt;\r\n                &lt;br class=&quot;clear&quot; /&gt;\r\n                &lt;h3&gt;鞋包配饰&lt;/h3&gt;\r\n                &lt;ul&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;围巾&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;旅行箱&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;真皮包&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;韩版&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;达芙妮&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;单肩包&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;毛线&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;#nogo&quot; &gt;清仓靴子&lt;/a&gt;&lt;/li&gt;\r\n                &lt;/ul&gt;\r\n                &lt;br class=&quot;clear&quot; /&gt;\r\n            &lt;/div&gt;\r\n        &lt;/div&gt;\r\n        &lt;!-- 商品分类 end --&gt;\r\n\r\n        &lt;!-- 大屏广告 start --&gt;\r\n        &lt;div id=&quot;jnImageroll&quot;&gt;\r\n            &lt;a href=&quot;#nogo&quot; id=&quot;JS_imgWrap&quot;&gt;\r\n                &lt;img src=&quot;images/ads/1.jpg&quot; alt=&quot;相约情人节&quot;/&gt;\r\n                &lt;img src=&quot;images/ads/2.jpg&quot; alt=&quot;新款上线&quot;/&gt;\r\n                &lt;img src=&quot;images/ads/3.jpg&quot; alt=&quot;愤怒小鸟特卖&quot;/&gt;\r\n                &lt;img src=&quot;images/ads/4.jpg&quot; alt=&quot;男鞋促销第一波&quot;/&gt;\r\n                &lt;img src=&quot;images/ads/5.jpg&quot; alt=&quot;春季新品发布&quot;/&gt;\r\n            &lt;/a&gt;\r\n            &lt;div&gt;\r\n                &lt;a href=&quot;###1&quot;&gt;&lt;em&gt;相约情人节&lt;/em&gt;&lt;em&gt;全场119元起&lt;/em&gt;&lt;/a&gt;\r\n                &lt;a href=&quot;###2&quot;&gt;&lt;em&gt;新款上线&lt;/em&gt;&lt;em&gt;全场357元起&lt;/em&gt;&lt;/a&gt;\r\n                &lt;a href=&quot;###3&quot;&gt;&lt;em&gt;愤怒小鸟特卖&lt;/em&gt;&lt;em&gt;全场89元&lt;/em&gt;&lt;/a&gt;\r\n                &lt;a href=&quot;###4&quot;&gt;&lt;em&gt;男鞋促销第一波&lt;/em&gt;&lt;em&gt;全场3.1折起&lt;/em&gt;&lt;/a&gt;\r\n                &lt;a href=&quot;###5&quot; class=&quot;last&quot;&gt;&lt;em&gt;春季新品发布&lt;/em&gt;&lt;em&gt;全场4.1折起&lt;/em&gt;&lt;/a&gt;\r\n            &lt;/div&gt;\r\n        &lt;/div&gt;\r\n        &lt;!-- 大屏广告 end --&gt;\r\n\r\n        &lt;!-- 最新动态 start --&gt;\r\n        &lt;div id=&quot;jnNotice&quot;&gt;\r\n            &lt;div id=&quot;jnMiaosha&quot;&gt;\r\n                &lt;a href=&quot;#nogo&quot; class=&quot;JS_css3&quot;&gt;&lt;img src=&quot;images/upload/20120216.jpg&quot; alt=&quot;冬品清仓&quot;  /&gt;&lt;/a&gt;\r\n            &lt;/div&gt;\r\n            &lt;div id=&quot;jnNoticeInfo&quot;&gt;\r\n                &lt;h2 title=&quot;最新动态&quot;&gt;最新动态&lt;/h2&gt;\r\n                &lt;ul&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;###1&quot; class=&quot;tooltip&quot; title=&quot;[活动] 伊伴春鞋迎春大促&quot;&gt;[活动] 伊伴春鞋迎春大促&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;###2&quot; class=&quot;tooltip&quot; title=&quot;[活动] 千百度冬靴新品火热让利&quot;&gt;[活动] 千百度冬靴新品火热让利&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;###3&quot; class=&quot;tooltip&quot; title=&quot;[活动] COEY秋冬新品全场2.3折起&quot;&gt;[活动] COEY秋冬新品全场2.3折起&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;###4&quot; class=&quot;tooltip&quot; title=&quot;[活动] 伊伴春鞋迎春大促&quot;&gt;[活动] 伊伴春鞋迎春大促&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;###5&quot; class=&quot;tooltip&quot; title=&quot;[活动] 千百度冬靴新品火热让利&quot;&gt;[活动] 千百度冬靴新品火热让利&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a href=&quot;###6&quot; class=&quot;tooltip&quot; title=&quot;[活动] COEY秋冬新品全场2.3折起&quot;&gt;[活动] COEY秋冬新品全场2.3折起&lt;/a&gt;&lt;/li&gt;\r\n                &lt;/ul&gt;\r\n                &lt;br class=&quot;clear&quot; /&gt;\r\n            &lt;/div&gt;\r\n        &lt;/div&gt;\r\n        &lt;!-- 最新动态 end --&gt;\r\n\r\n        &lt;!-- 品牌活动 start --&gt;\r\n        &lt;div id=&quot;jnBrand&quot;&gt;\r\n            &lt;div id=&quot;jnBrandTab&quot;&gt;\r\n                &lt;h2 title=&quot;品牌活动&quot;&gt;品牌活动&lt;/h2&gt;\r\n                &lt;ul&gt;\r\n                    &lt;li&gt;&lt;a title=&quot;运动&quot; href=&quot;#nogo&quot;&gt;运动&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a title=&quot;女鞋&quot; href=&quot;#nogo&quot;&gt;女鞋&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a title=&quot;男鞋&quot; href=&quot;#nogo&quot;&gt;男鞋&lt;/a&gt;&lt;/li&gt;\r\n                    &lt;li&gt;&lt;a title=&quot;Applife&quot; href=&quot;#nogo&quot;&gt;童鞋&lt;/a&gt;&lt;/li&gt;\r\n                &lt;/ul&gt;\r\n            &lt;/div&gt;\r\n            &lt;div id=&quot;jnBrandContent&quot;&gt;\r\n                &lt;div id=&quot;jnBrandList&quot;&gt;\r\n                    &lt;ul&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###1&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;耐克&quot; src=&quot;images/upload/20120217.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###1&quot;&gt;耐克&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###2&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;阿迪达斯&quot; src=&quot;images/upload/20120218.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###2&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###3&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;李宁&quot; src=&quot;images/upload/20120219.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###3&quot;&gt;李宁&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###4&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;安踏&quot; src=&quot;images/upload/20120220.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###4&quot;&gt;安踏&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###1&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;耐克&quot; src=&quot;images/upload/20120217.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###1&quot;&gt;耐克&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###2&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;阿迪达斯&quot; src=&quot;images/upload/20120218.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###2&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###3&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;李宁&quot; src=&quot;images/upload/20120219.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###3&quot;&gt;李宁&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###4&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;安踏&quot; src=&quot;images/upload/20120220.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###4&quot;&gt;安踏&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###1&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;耐克&quot; src=&quot;images/upload/20120217.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###1&quot;&gt;耐克&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###2&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;阿迪达斯&quot; src=&quot;images/upload/20120218.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###2&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###3&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;李宁&quot; src=&quot;images/upload/20120219.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###3&quot;&gt;李宁&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###4&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;安踏&quot; src=&quot;images/upload/20120220.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###4&quot;&gt;安踏&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###1&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;耐克&quot; src=&quot;images/upload/20120217.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###1&quot;&gt;耐克&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###2&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;阿迪达斯&quot; src=&quot;images/upload/20120218.jpg&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###2&quot;&gt;阿迪达斯&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###3&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;李宁&quot; src=&quot;images/upload/20120219.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###3&quot;&gt;李宁&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                        &lt;li&gt;\r\n                            &lt;a href=&quot;###4&quot; class=&quot;JS_live&quot;&gt;&lt;img alt=&quot;安踏&quot; src=&quot;images/upload/20120220.png&quot; /&gt;&lt;/a&gt;\r\n                            &lt;span&gt;&lt;a href=&quot;###4&quot;&gt;安踏&lt;/a&gt;&lt;/span&gt;\r\n                        &lt;/li&gt;\r\n                    &lt;/ul&gt;\r\n                &lt;/div&gt;\r\n            &lt;/div&gt;\r\n        &lt;/div&gt;\r\n        &lt;!-- 品牌活动 end --&gt;\r\n\r\n    &lt;/div&gt;\r\n&lt;/div&gt;\r\n&lt;!--主体结束--&gt;\r\n&lt;!--底部开始--&gt;\r\n&lt;div id=&quot;footer&quot;&gt;Copyright &amp;copy; 2009 - 2012 JaneShop Inc. &lt;/div&gt;\r\n&lt;!--底部结束--&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;\r\n</code></pre><p>main.css:</p>\r\n<pre><code>/*头部样式开始*/\r\n#header{\r\n    background: url(&quot;../images/headerbg.png&quot;) repeat-x scroll 0 0 #FFFFFF;\r\n    height: 105px;\r\n}\r\n#header .contWidth {\r\n    position: relative;\r\n    height: 105px;\r\n    margin: 0 auto;\r\n    width: 990px;\r\n    z-index: 100;\r\n}\r\n#header .logo { \r\n    float:left; \r\n    margin:0 0 0 10px; \r\n    color:#FFF; \r\n    line-height:80px;\r\n}\r\n#header .search {\r\n    left: 198px;\r\n    position: absolute;\r\n    top: 20px;\r\n}\r\n#inputSearch {\r\n    border: 1px solid #BABEBF;\r\n    color: #999999;\r\n    font-size: 14px;\r\n    height: 17px;\r\n    padding: 3px 6px 5px 6px;\r\n    width: 200px;\r\n}\r\n#inputSearch.focus{\r\n    border: 1px solid #00A5FF;\r\n}\r\n/* 切换皮肤控件样式 */\r\n#skin { \r\n    float:right; \r\n    margin:10px; \r\n    padding:4px; \r\n    width:120px; \r\n}\r\n#skin li { \r\n    float:left; \r\n    margin-right:4px; \r\n    width:15px; \r\n    height:15px; \r\n    text-indent:-9999px; \r\n    overflow:hidden; \r\n    display:block; \r\n    cursor:pointer; \r\n    background-image:url(&quot;../images/theme.gif&quot;); \r\n}\r\n#skin_0 { background-position:0px 0px; }\r\n#skin_1 { background-position:15px 0px; }\r\n#skin_2 { background-position:35px 0px; }\r\n#skin_3 { background-position:55px 0px; }\r\n#skin_4 { background-position:75px 0px; }\r\n#skin_5 { background-position:95px 0px; }\r\n#skin_0.selected { background-position:0px 15px; }\r\n#skin_1.selected { background-position:15px 15px; }\r\n#skin_2.selected { background-position:35px 15px; }\r\n#skin_3.selected { background-position:55px 15px; }\r\n#skin_4.selected { background-position:75px 15px; }\r\n#skin_5.selected { background-position:95px 15px; }\r\n/*导航样式开始*/\r\n.mainNav {\r\n    position: absolute;\r\n    top: 68px;\r\n    left: 0;\r\n    height: 37px;\r\n    line-height: 37px;\r\n    width: 990px;\r\n    z-index:100;\r\n    background-color: #4A4A4A;\r\n}\r\n.mainNav .nav {\r\n    display: inline;\r\n    float: left;\r\n    margin-left: 25px;\r\n}\r\n.mainNav ul li { \r\n    float:left; \r\n    display: inline;\r\n    margin-right:14px;\r\n    position: relative ;\r\n    z-index:100;\r\n}\r\n.mainNav ul li a { \r\n    display:block;\r\n    padding:0 8px; \r\n    font-weight:700;\r\n    color:#fff;\r\n    font-size:14px;\r\n}\r\n.mainNav ul li a:hover { \r\n    background:none; \r\n}\r\n/* 二级菜单 */\r\n.jnNav {\r\n    background:#FFFFFF;\r\n    border: 1px solid #B1B1B1;\r\n    border-top:0;\r\n    left: 0;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    top: 37px;\r\n    width: 474px;\r\n    z-index: 1000;\r\n    display:none;\r\n}\r\n.jnNav .subitem {\r\n    float: left;\r\n    height: auto !important;\r\n    min-height: 100px;\r\n    padding: 10px 12px;\r\n    width: 450px;\r\n}\r\n.jnNav .subitem dl {\r\n    border-top: 1px dashed #C4C4C4;\r\n    overflow: hidden;\r\n    padding: 8px 0;\r\n    float:left;\r\n}\r\n.jnNav .subitem .fore {\r\n    border-top-style: none;\r\n    padding-top: 0;\r\n}\r\n.jnNav .subitem dt {\r\n    float: left;\r\n    font-weight: bold;\r\n    line-height: 16px;\r\n    padding: 4px 3px;\r\n    text-align: center;\r\n    width: 76px;\r\n}\r\n.jnNav .subitem dt a {\r\n    color: #000;\r\n    font-weight: 700;\r\n    font-size:12px;\r\n    padding:0;\r\n}\r\n.jnNav .subitem dd {\r\n    float: left;\r\n    overflow: hidden;\r\n    padding: 0;\r\n    width: 364px;\r\n}\r\n.jnNav .subitem em {\r\n    border-right: 1px solid #CCCCCC;\r\n    float: left;\r\n    font-style: normal;\r\n    height: 14px;\r\n    line-height: 14px;\r\n    margin: 5px 0;\r\n    padding: 0 8px;\r\n}\r\n.jnNav .subitem em a {\r\n    color: #666666;\r\n    white-space: nowrap;\r\n    font-size:12px;\r\n    font-weight:normal;\r\n    padding:0;\r\n}\r\n.jnNav .subitem em.noborder {\r\n    border-right: 0 none;\r\n}\r\n/* 主体样式 */\r\n#content{\r\n    clear: left;\r\n    margin: 0 auto;\r\n    position: relative;\r\n    width: 990px;\r\n}\r\n.janeshop{\r\n    height: 560px;\r\n    overflow: hidden;\r\n    padding: 10px 0;\r\n}\r\n/* 商品分类 */\r\n#jnCatalog{\r\n    float: left;\r\n    height: 560px;\r\n    margin: 0 11px 0 0;\r\n    overflow: hidden;\r\n    width: 187px;\r\n}\r\n#jnCatalog h2{\r\n    height:30px;\r\n    line-height:30px;\r\n    color:#fff;\r\n    font-size:12px;\r\n    text-indent:13px;\r\n    background-color:#6E6E6E;\r\n}\r\n.jnCatainfo{\r\n    border: 1px solid #6E6E6E;\r\n    border-style: none solid solid;\r\n    border-width: 0 1px 1px;\r\n    height: 524px;\r\n    overflow: hidden;\r\n    padding: 5px 10px 0;\r\n    width: 165px;\r\n}\r\n.jnCatainfo h3 {\r\n    border-bottom: 1px solid #EEEEEE;\r\n    height: 24px;\r\n    line-height:24px;\r\n    width: 164px;\r\n}\r\n.jnCatainfo ul {\r\n    float: left;\r\n    padding: 0 2px 8px;\r\n}\r\n.jnCatainfo li {\r\n    color: #AEADAE;\r\n    float: left;\r\n    height: 24px;\r\n    line-height: 24px;\r\n    width: 79px;\r\n    overflow: hidden;\r\n    position:relative;\r\n}\r\n.jnCatainfo li a{\r\n    color: #444444;\r\n}\r\n.jnCatainfo li a:hover{\r\n    color: #008CD7;\r\n    text-decoration: none;\r\n}\r\n.jnCatainfo li a.promoted{\r\n    color:#F9044E;\r\n}\r\n.jnCatainfo li .hot {\r\n    background: url(&quot;../images/hot.gif&quot;) no-repeat scroll 0 0 transparent;\r\n    height: 16px;\r\n    position: absolute;\r\n    top: 0;\r\n    width: 21px;\r\n}\r\n/* 大屏广告 */\r\n#jnImageroll {\r\n    float: left;\r\n    height: 320px;\r\n    margin: 0 11px 0 0;\r\n    overflow: hidden;\r\n    position: relative;\r\n    width: 550px;\r\n}\r\n#jnImageroll img {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n#jnImageroll div {\r\n    bottom: 0;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    float: left;\r\n}\r\n#jnImageroll div a {\r\n    background-color: #444444;\r\n    color: #FFFFFF;\r\n    display: inline-block;\r\n    float: left;\r\n    height: 32px;\r\n    margin-right: 1px;\r\n    overflow: hidden;\r\n    padding: 5px 15px;\r\n    text-align: center;\r\n    width: 79px;\r\n}\r\n#jnImageroll div a:hover {\r\n    text-decoration: none;\r\n}\r\n#jnImageroll div a em {\r\n    cursor: pointer;\r\n    display: block;\r\n    height: 16px;\r\n    overflow: hidden;\r\n    width: 79px;\r\n}\r\n#jnImageroll .last {\r\n    margin: 0;\r\n    width: 80px;\r\n}\r\n#jnImageroll a.chos {\r\n    background: url(&quot;../images/adindex.gif&quot;) no-repeat center 39px #37A7D7;\r\n    color: #FFFFFF;\r\n}\r\n/* 最新动态 */\r\n#jnNotice{\r\n    float: left;\r\n    height: 321px;\r\n    overflow: hidden;\r\n    width: 230px;\r\n}\r\n#jnMiaosha {\r\n    float: left;\r\n    height: 176px;\r\n    margin-bottom: 10px;\r\n    overflow: hidden;\r\n    width: 230px;\r\n}\r\n.JS_css3 img {\r\n    -webkit-transition:1s all;\r\n    -moz-transition:1s all;\r\n    -o-transition:1s all;\r\n    transition:1s all;\r\n}\r\n.JS_css3:hover img {\r\n    -webkit-transform:rotate(720deg);\r\n    -moz-transform:rotate(720deg);\r\n    -o-transform:rotate(720deg);\r\n    transform:rotate(720deg);\r\n}\r\n#jnNoticeInfo {\r\n    float: left;\r\n    border: 1px solid #DFDFDF;\r\n    height: 133px;\r\n    overflow: hidden;\r\n    width: 228px;\r\n}\r\n#jnNoticeInfo h2 {\r\n    height: 23px;\r\n    line-height: 23px;\r\n    border-bottom: 1px solid #DFDFDF;\r\n    text-indent:12px;\r\n}\r\n#jnNoticeInfo ul {\r\n    float: left;\r\n    padding: 6px 2px 0 12px;\r\n}\r\n#jnNoticeInfo li {\r\n    height: 20px;\r\n    line-height: 20px;\r\n    overflow: hidden;\r\n}\r\n#jnNoticeInfo li a{\r\n    color:#666666;\r\n}\r\n#jnNoticeInfo li a:hover{\r\n    color: #008CD7;\r\n    text-decoration: none;\r\n}\r\n/* 品牌活动 */\r\n#jnBrand {\r\n    float: left;\r\n    height: 230px;\r\n    margin: 10px 0 0;\r\n    overflow: hidden;\r\n    width: 790px;\r\n}\r\n#jnBrandTab {\r\n    border-bottom: 1px solid #E4E4E4;\r\n    height: 29px;\r\n    position: relative;\r\n    width: 790px;\r\n    float: left;\r\n}\r\n#jnBrandTab h2 {\r\n    height: 29px;\r\n    line-height: 29px;\r\n    left: 0;\r\n    position: absolute;\r\n    width: 100px;\r\n}\r\n#jnBrandTab ul {\r\n    position: absolute;\r\n    right: 0;\r\n    top: 10px;\r\n}\r\n#jnBrandTab li {\r\n    float: left;\r\n    margin: 0 10px 0 0;\r\n}\r\n#jnBrandTab li a {\r\n    background-color: #E4E4E4;\r\n    color: #000000;\r\n    display: inline-block;\r\n    height: 20px;\r\n    line-height: 20px;\r\n    padding: 0 10px;\r\n}\r\n#jnBrandTab .chos {\r\n    background: url(&quot;../images/chos.gif&quot;) no-repeat scroll 50% bottom transparent;\r\n    padding-bottom: 3px;\r\n}\r\n#jnBrandTab .chos a {\r\n    background-color: #FA5889;\r\n    color: #FFFFFF;\r\n    outline: 0 none;\r\n}\r\n#jnBrandContent {\r\n    float: left;\r\n    height: 188px;\r\n    overflow: hidden;\r\n    margin: 8px 5px;\r\n    width: 790px;\r\n    position: relative;\r\n}\r\n#jnBrandList {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    width: 3200px;\r\n}\r\n#jnBrandContent li {\r\n    float: left;\r\n    height: 188px;\r\n    overflow: hidden;\r\n    padding: 0 5px;\r\n    position: relative;\r\n    width: 185px;\r\n}\r\n#jnBrandContent li img {\r\n    left: 5px;\r\n    position: absolute;\r\n    top: 0;\r\n}\r\n#jnBrandContent li span {\r\n    background-color: #EFEFEF;\r\n    bottom: 0;\r\n    color: #666666;\r\n    display: inline-block;\r\n    font-size: 14px;\r\n    height: 24px;\r\n    line-height: 24px;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    text-align: center;\r\n    width: 183px;\r\n}\r\n#jnBrandContent li a {\r\n    color:#666666;\r\n}\r\n#jnBrandContent li a:hover{\r\n    color: #008CD7;\r\n    text-decoration: none;\r\n}\r\n/* details.html */\r\n#jnProitem{\r\n    float: left;\r\n    width: 312px; \r\n    height: 560px;\r\n    display:inline;\r\n}\r\n#jnProitem .jqzoomWrap {\r\n    border: 1px solid #BBBBBB;\r\n    cursor: pointer;\r\n    float: left;\r\n    padding: 0;\r\n    position: relative;\r\n}\r\n#jnProitem span {\r\n    clear: both;\r\n    display: block;\r\n    padding-bottom: 10px;\r\n    padding-top: 10px;\r\n    text-align: center;\r\n    width: 320px;\r\n}\r\n#jnProitem ul.imgList{\r\n    height: 80px;\r\n}\r\n#jnProitem ul.imgList li { \r\n    float:left;\r\n    margin-right:10px;  \r\n}\r\n#jnProitem ul.imgList li img { \r\n    width:60px; \r\n    height:60px; \r\n    padding:1px;\r\n    background:#EEE;\r\n    cursor:pointer; \r\n}\r\n#jnProitem ul.imgList li img:hover { \r\n    padding:1px; \r\n    background:#999; \r\n}\r\n\r\n.tab{ \r\n    clear:both;\r\n    float: left;\r\n    height: 230px;\r\n    overflow: hidden;\r\n    width: 310px;\r\n}\r\n.tab .tab_menu { \r\n    clear:both;\r\n}\r\n.tab .tab_menu li { \r\n    float:left; \r\n    text-align:center; \r\n    cursor:pointer; \r\n    list-style:none; \r\n    padding:1px 6px; \r\n    margin-right:4px; \r\n    background:#F1F1F1;\r\n    border:1px solid #898989; \r\n    border-bottom:none;\r\n}\r\n.tab .tab_menu li.hover { \r\n    background:#DFDFDF;\r\n}\r\n.tab .tab_menu li.selected { \r\n    color:#FFF; \r\n    background:#6D84B4;\r\n}\r\n.tab .tab_box { \r\n    clear:both; \r\n    border:1px solid #898989;\r\n}\r\n.tab .hide{\r\n    display:none\r\n}\r\n#jnDetails {\r\n    float: left;\r\n    display:inline;\r\n    overflow: hidden;\r\n    width: 468px;\r\n}\r\n#jnDetails .jnProDetail{\r\n    padding:0 10px 10px 10px;\r\n}\r\n#jnDetails .jnProDetailList li{\r\n    line-height:25px;\r\n    float:left;\r\n    width:100%;\r\n}\r\n#jnDetails .jnProDetailList strong.del {\r\n    color: #404040;\r\n    font-size: 12px;\r\n    position: static;\r\n    text-decoration: line-through;\r\n}\r\n#jnDetails .jnProDetailList strong {\r\n    font-weight:400;\r\n}\r\n#jnDetails .jnProDetailList .tbDetailPrice strong {\r\n    font-weight: 700;\r\n    color: #FF5500;\r\n    font: 24px Tahoma,Arial,Helvetica,sans-serif;\r\n    padding-right: 5px;\r\n    vertical-align: middle;\r\n}\r\n#jnDetails .jnProDetailList .color_change li , #jnDetails .jnProDetailList .pro_size li{ \r\n    float:left; \r\n    margin-right:10px; \r\n    width:40px;\r\n}\r\n#jnDetails .jnProDetailList .color_change img { \r\n    width:30px; \r\n    height:30px; \r\n    padding:1px; \r\n    background:#EEE;\r\n    border:1px solid #BBB;\r\n    cursor:pointer; \r\n}\r\n#jnDetails .jnProDetailList .color_change img:hover,#jnDetails .jnProDetailList .color_change img.hover { \r\n    border:1px solid #f60;\r\n}\r\n#jnDetails .jnProDetailList .pro_size li{\r\n    display:block; \r\n    margin-right:6px;\r\n    border:1px solid #AAA;\r\n    cursor:pointer; \r\n    width:30px; \r\n    height:30px; \r\n    line-height:30px; \r\n    overflow:hidden;\r\n    text-align:center;\r\n}\r\n#jnDetails .jnProDetailList .pro_size li.cur{\r\n    border:1px solid #AAA;\r\n    background-color:#f60;\r\n}\r\n/* rating css */\r\n.rating{\r\n    overflow:hidden;\r\n    width:80px;\r\n    height:16px;\r\n    margin:0 0 20px 0;\r\n    padding:0;\r\n    list-style:none;\r\n    clear:both;\r\n    position:relative;\r\n    background: url(../images/star-matrix.gif) no-repeat 0 0;\r\n}\r\n.nostar {background-position:0 0}\r\n.onestar {background-position:0 -16px}\r\n.twostar {background-position:0 -32px}\r\n.threestar {background-position:0 -48px}\r\n.fourstar {background-position:0 -64px}\r\n.fivestar {background-position:0 -80px}\r\nul.rating li {\r\n    cursor: pointer;\r\n    float:left;\r\n    text-indent:-999em;\r\n}\r\nul.rating li a {\r\n    position:absolute;\r\n    left:0;\r\n    top:0;\r\n    width:16px;\r\n    height:16px;\r\n    text-decoration:none;\r\n    z-index: 200;\r\n}\r\nul.rating li.one a {left:0}\r\nul.rating li.two a {left:16px;}\r\nul.rating li.three a {left:32px;}\r\nul.rating li.four a {left:48px;}\r\nul.rating li.five a {left:64px;}\r\nul.rating li a:hover {\r\n    z-index:2;\r\n    width:80px;\r\n    height:16px;\r\n    overflow:hidden;\r\n    left:0; \r\n    background: url(../images/star-matrix.gif) no-repeat 0 0\r\n}\r\nul.rating li.one a:hover {background-position:0 -96px;}\r\nul.rating li.two a:hover {background-position:0 -112px;}\r\nul.rating li.three a:hover {background-position:0 -128px}\r\nul.rating li.four a:hover {background-position:0 -144px}\r\nul.rating li.five a:hover {background-position:0 -160px}\r\n\r\n/* footer */\r\n#footer {\r\n    margin: 0 auto;\r\n    width: 990px;\r\n    color: #666666;\r\n    padding: 18px 0;\r\n    text-align: center;\r\n}\r\n\r\n/* tooltip */\r\n#tooltip{\r\n    position:absolute;\r\n    border:1px solid #333;\r\n    background:#f7f5d1;\r\n    padding:1px;\r\n    color:#333;\r\n    display:none;\r\n}\r\n/* imgHover */\r\n.imageMask{\r\n    background-color:#ffffff; \r\n    filter:alpha(opacity=0);\r\n    opacity: 0; \r\n    cursor: pointer;\r\n}\r\n.imageOver{\r\n    background:url(../images/zoom.gif) no-repeat 50% 50%;   \r\n    filter:alpha(opacity=60);\r\n    opacity: 0.6;   \r\n}\r\n\r\n/* jquery zoom */\r\n.zoomPad{\r\n    position:relative;\r\n    float:left;\r\n    z-index:99;\r\n    cursor:crosshair;\r\n}\r\n.zoomPreload{\r\n   -moz-opacity:0.8;\r\n   opacity: 0.8;\r\n   filter: alpha(opacity = 80);\r\n   color: #333;\r\n   font-size: 12px;\r\n   font-family: Tahoma;\r\n   text-decoration: none;\r\n   border: 1px solid #CCC;\r\n   background-color: white;\r\n   padding: 8px;\r\n   text-align:center;\r\n   background-image: url(../images/zoomloader.gif);\r\n   background-repeat: no-repeat;\r\n   background-position: 43px 30px;\r\n   z-index:110;\r\n   width:90px;\r\n   height:43px;\r\n   position:absolute;\r\n   top:0px;\r\n   left:0px;\r\n    * width:100px;\r\n    * height:49px;\r\n}\r\n.zoomPup{\r\n    overflow:hidden;\r\n    background-color: #FFF;\r\n    -moz-opacity:0.6;\r\n    opacity: 0.6;\r\n    filter: alpha(opacity = 60);\r\n    z-index:120;\r\n    position:absolute;\r\n    border:1px solid #CCC;\r\n    z-index:101;\r\n    cursor:crosshair;\r\n}\r\n.zoomOverlay{\r\n    position:absolute;\r\n    left:0px;\r\n    top:0px;\r\n    background:#FFF;\r\n    /*opacity:0.5;*/\r\n    z-index:5000;\r\n    width:100%;\r\n    height:100%;\r\n    display:none;\r\n    z-index:101;\r\n}\r\n.zoomWindow{\r\n    position:absolute;\r\n    left:110%;\r\n    top:40px;\r\n    background:#FFF;\r\n    z-index:6000;\r\n    height:auto;\r\n  z-index:10000;\r\n  z-index:110;\r\n}\r\n.zoomWrapper{\r\n    position:relative;\r\n    border:1px solid #999;\r\n  z-index:110;\r\n}\r\n.zoomWrapperTitle{\r\n    display:block;\r\n    background:#999;\r\n    color:#FFF;\r\n    height:18px;\r\n    line-height:18px;\r\n    width:100%;\r\n  overflow:hidden;\r\n    text-align:center;\r\n    font-size:12px;\r\n  position:absolute;\r\n  top:0px;\r\n  left:0px;\r\n  z-index:120;\r\n  -moz-opacity:0.6;\r\n  opacity: 0.6;\r\n  filter: alpha(opacity = 60);\r\n}\r\n.zoomWrapperImage{\r\n    display:block;\r\n  position:relative;\r\n  overflow:hidden;\r\n  z-index:110;\r\n\r\n}\r\n.zoomWrapperImage img{\r\n  border:0px;\r\n  display:block;\r\n  position:absolute;\r\n  z-index:101;\r\n}\r\n.zoomIframe{\r\n  z-index: -1;\r\n  filter:alpha(opacity=0);\r\n  -moz-opacity: 0.80;\r\n  opacity: 0.80;\r\n  position:absolute;\r\n  display:block;\r\n}\r\n</code></pre><font color=\"red\">不要忘了最上面的reset.css</font>\r\n\r\n<p>skin_0.css - skin_5.css:</p>\r\n<pre><code>skin_0.css :\r\n.mainNav {\r\n    background-color: #4A4A4A;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #6E6E6E;\r\n}\r\nskin_1.css :\r\n.mainNav {\r\n    background-color: #BE46D8;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #D49AE1;\r\n}\r\nskin_2.css :\r\n.mainNav {\r\n    background-color: #E44072;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #F296B2;\r\n}\r\nskin_3.css :\r\n.mainNav {\r\n    background-color: #37C7D4;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #98E0E6;\r\n}\r\nskin_4.css :\r\n.mainNav {\r\n    background-color: #F9AF2A;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #FFCF78;\r\n}\r\nskin_5.css :\r\n.mainNav {\r\n    background-color: #B1D410;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #CDE074;\r\n}\r\n</code></pre><p>ad.js:</p>\r\n<pre><code>/* 首页大屏广告效果 */\r\n$(function(){\r\n    var $imgrolls = $(&quot;#jnImageroll div a&quot;);\r\n    $imgrolls.css(&quot;opacity&quot;,&quot;0.7&quot;);\r\n    var len  = $imgrolls.length;\r\n    var index = 0;\r\n    var adTimer = null;\r\n    $imgrolls.mouseover(function(){\r\n        index = $imgrolls.index(this);\r\n        showImg(index);\r\n    }).eq(0).mouseover();   \r\n    //滑入 停止动画，滑出开始动画.\r\n    $(&#39;#jnImageroll&#39;).hover(function(){\r\n            if(adTimer){ \r\n                clearInterval(adTimer);\r\n            }\r\n         },function(){\r\n            adTimer = setInterval(function(){\r\n                showImg(index);\r\n                index++;\r\n                if(index==len){index=0;}\r\n            } , 5000);\r\n    }).trigger(&quot;mouseleave&quot;);\r\n})\r\n//显示不同的幻灯片\r\nfunction showImg(index){\r\n    var $rollobj = $(&quot;#jnImageroll&quot;);\r\n    var $rolllist = $rollobj.find(&quot;div a&quot;);\r\n    var newhref = $rolllist.eq(index).attr(&quot;href&quot;);\r\n    $(&quot;#JS_imgWrap&quot;).attr(&quot;href&quot;,newhref)\r\n             .find(&quot;img&quot;).eq(index).stop(true,true).fadeIn().siblings().fadeOut();\r\n    $rolllist.removeClass(&quot;chos&quot;).css(&quot;opacity&quot;,&quot;0.7&quot;)\r\n             .eq(index).addClass(&quot;chos&quot;).css(&quot;opacity&quot;,&quot;1&quot;); \r\n}\r\n</code></pre><p>addhot.js:</p>\r\n<pre><code>$(function(){\r\n    $(&quot;.jnCatainfo .promoted&quot;).append(&quot;&lt;s class=&#39;hot&#39;&gt;&lt;/s&gt;&quot;);\r\n})\r\n</code></pre><p>changeSkin.js:</p>\r\n<pre><code>$(function(){\r\n    var $li=$(&quot;#skin li&quot;);\r\n    $li.click(function(){\r\n        switchSkin(this.id);\r\n    });\r\n    var cookie_skin=$.cookie(&quot;MyCssSkin&quot;);\r\n    if(cookie_skin){\r\n        switchSkin(cookie_skin);\r\n    }\r\n});\r\nfunction switchSkin(skinName){\r\n    $(&quot;#&quot;+skinName).addClass(&quot;selected&quot;).siblings().removeClass(&quot;selected&quot;);\r\n    $(&quot;#cssfile&quot;).attr(&quot;href&quot;,&quot;styles/skin/&quot;+skinName+&quot;.css&quot;);\r\n    //设置不同的皮肤\r\n    $.cookie(&quot;MyCssSkin&quot;,skinName,{path:&#39;/&#39;,expires:10});\r\n\r\n}\r\n</code></pre><p>imgHover.js:</p>\r\n<pre><code>/* 滑过图片出现放大镜效果 */\r\n$(function(){\r\n    $(&quot;#jnBrandList li&quot;).each(function(index){\r\n        var $img = $(this).find(&quot;img&quot;);\r\n        var img_w = $img.width();\r\n        var img_h = $img.height();\r\n        var spanHtml = &#39;&lt;span style=&quot;position:absolute;top:0;left:5px;width:&#39;+img_w+&#39;px;height:&#39;+img_h+&#39;px;&quot; class=&quot;imageMask&quot;&gt;&lt;/span&gt;&#39;;\r\n        $(spanHtml).appendTo(this);\r\n    })\r\n    $(&quot;#jnBrandList&quot;).delegate(&quot;.imageMask&quot;, &quot;hover&quot;, function(){\r\n        $(this).toggleClass(&quot;imageOver&quot;);\r\n    });\r\n})\r\n</code></pre><p>imgSlide.js:</p>\r\n<pre><code>$(function(){\r\n    $(&quot;#jnBrandTab li a&quot;).click(function(){\r\n        $(this).parent().addClass(&quot;chos&quot;)\r\n               .siblings().removeClass(&quot;chos&quot;);\r\n        var idx=$(&quot;#jnBrandTab li a&quot;).index(this);\r\n        showBrandList(idx);\r\n        return false;\r\n    }).eq(0).click();\r\n});\r\nfunction showBrandList(index){\r\n    var $rollobj=$(&quot;#jnBrandList&quot;);\r\n    var rollWidth=$rollobj.find(&quot;li&quot;).outerWidth();\r\n    rollWidth=rollWidth*4;\r\n    $rollobj.stop(true,false).animate({left:-rollWidth*index},1000);\r\n}\r\n</code></pre><p>input.js:</p>\r\n<pre><code>$(function(){\r\n    $(&quot;#inputSearch&quot;).focus(function(){\r\n        $(this).addClass(&quot;focus&quot;);\r\n        if($(this).val()==this.defaultValue){\r\n            $(this).val(&quot;&quot;);\r\n        }\r\n    }).blur(function(){\r\n        $(this).removeClass(&quot;focus&quot;);\r\n        if($(this).val()==&quot;&quot;){\r\n            $(this).val(this.defaultValue);\r\n        }\r\n    }).keyup(function(e){\r\n        if(e.which==13){\r\n            alert(&#39;回车提交表单&#39;);\r\n        }\r\n    })\r\n})\r\n</code></pre><p>nav.js:</p>\r\n<pre><code>$(function(){\r\n    $(&quot;#nav li&quot;).hover(function(){\r\n        $(this).find(&quot;.jnNav&quot;).show();\r\n    },function(){\r\n        $(this).find(&quot;.jnNav&quot;).hide();\r\n    });\r\n})\r\n</code></pre><p>tooltip.js:</p>\r\n<pre><code>$(function(){\r\n    var x=10;\r\n    var y=20;\r\n    $(&quot;a.tooltip&quot;).mouseover(function(e){\r\n        this.myTitle=this.title;\r\n        this.title=&quot;&quot;;\r\n        var tooltip=&quot;&lt;div id=&#39;tooltip&#39;&gt;&quot;+this.myTitle+&quot;&lt;/div&gt;&quot;;//创建div元素\r\n        $(&quot;body&quot;).append(tooltip);\r\n        $(&quot;#tooltip&quot;)\r\n            .css({\r\n                &quot;top&quot;:(e.pageY+y)+&quot;px&quot;,\r\n                &quot;left&quot;:(e.pageX+x)+&quot;px&quot;\r\n            }).show(&quot;fast&quot;);  //设置x坐标和y坐标，并且显示\r\n    }).mouseout(function(){\r\n        this.title=this.myTitle;\r\n        $(&quot;#tooltip&quot;).remove();\r\n    }).mouseover(function(e){\r\n        $(&quot;#tooltip&quot;)\r\n            .css({\r\n                &quot;top&quot;:(e.pageY+y)+&quot;px&quot;,\r\n                &quot;left&quot;:(e.pageX+x)+&quot;px&quot;\r\n            });\r\n    });\r\n\r\n})\r\n</code></pre>', '100', '# 综合开发，编写购物网首页\r\n\r\n<font color=\"red\">这章主要介绍如何搭建一个前端网页，文章最后面有完整的代码，前面的主要是说明</font>\r\n\r\n**第一步：搭建网页结构**\r\n购物网站基本上可以分为以下几部分：\r\n头部：相当于网站的品牌，可用于放置Logo和通往各页面的链接\r\n内容：防止页面的主体\r\n底部：放置页面其他链接和版权信息\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>综合实战，购物网站</title>\r\n</head>\r\n<body>\r\n    <div id=\"header\"></div>\r\n    <div id=\"content\"></div>\r\n    <div id=\"footer\"></div>\r\n</body>\r\n</html>\r\n```\r\n\r\n**第二步：网站样式（编写CSS）**\r\n设置全局变量：\r\n1.首先使用元素标签将每个元素的margin和padding属性设置为0,。这样做的好处是，可以让页面不受到不同浏览器默认设置的页边距和字边距的影响。\r\n2.设置body元素的字体颜色，字号大小等，这样可以规范整个网站的样式风格。\r\n3.设置其他属性的特定样式\r\nreset.css:\r\n\r\n```\r\nbody,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td{\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\nbody,button,input,select,textarea{\r\n    font: 12px/1.5 tahoma,arial,\\5b8b\\4f53;}\r\n}\r\nh1,h2,h3,h4,h5,h6{\r\n    font-size: 100%;\r\n}\r\naddress,cite,dfn,em,var{\r\n    font-style: normal;\r\n}\r\ncode,kbd,pre,samp{\r\n    font-family: courier new,courier,monospace;\r\n}\r\nsmall{\r\n    font-size: 12px;\r\n}\r\nul,ol{\r\n    list-style: none;\r\n}\r\na{\r\n    text-decoration:none;\r\n}\r\na:hover{\r\n    text-decoration: underline;\r\n}\r\nsup{\r\n    vertical-align: text-top;\r\n}\r\nsub{\r\n    vertical-align: text-bottom;\r\n}\r\nlegend{\r\n    color: #000;\r\n}\r\nfieldset,img{\r\n    border: 0;\r\n}\r\nbutton,input,select,textarea{\r\n    font-size: 100%;\r\n}\r\ntable{\r\n    border-collapse: collapse;\r\n    border-spacing: 0;\r\n}\r\n.clear{\r\n    clear: both;\r\n    float: none;\r\n    height: 0;\r\n    overflow: hidden;\r\n}\r\nhtml .hide{\r\n    display: none;\r\n}\r\n```\r\n\r\n因为篇幅有限，下面直接给出源码：\r\nindex.html:\r\n\r\n```\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\r\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\r\n    <title>综合实战，购物网站</title>\r\n<link rel=\"stylesheet\" href=\"styles/reset.css\" type=\"text/css\" />\r\n<link rel=\"stylesheet\" href=\"styles/main.css\" type=\"text/css\" />\r\n<link rel=\"stylesheet\" href=\"styles/skin/skin_0.css\" type=\"text/css\" id=\"cssfile\" />\r\n<script src=\"scripts/jquery-3.1.1.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/jquery.cookie.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/input.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/changeSkin.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/nav.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/addhot.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/ad.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/tooltip.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/imgSlide.js\" type=\"text/javascript\"></script>\r\n<script src=\"scripts/imgHover.js\" type=\"text/javascript\"></script>\r\n\r\n</head>\r\n<body>\r\n<div id=\"header\">\r\n    <div class=\"contWidth\">\r\n        <a class=\"logo\" href=\"#nogo\"><img src=\"images/logo.gif\" alt=\"JaneShop\"/></a>\r\n        <div class=\"search\">\r\n            <input type=\"text\" id=\"inputSearch\" class=\"\" value=\"请输入商品名称\" />\r\n        </div>\r\n        <ul id=\"skin\">\r\n            <li id=\"skin_0\" title=\"蓝色\" class=\"selected\">蓝色</li>\r\n            <li id=\"skin_1\" title=\"紫色\">紫色</li>\r\n            <li id=\"skin_2\" title=\"红色\">红色</li>\r\n            <li id=\"skin_3\" title=\"天蓝色\">天蓝色</li>\r\n            <li id=\"skin_4\" title=\"橙色\">橙色</li>\r\n            <li id=\"skin_5\" title=\"淡绿色\">淡绿色</li>\r\n        </ul>\r\n        <!-- 导航 start -->\r\n        <div id=\"nav\" class=\"mainNav\">\r\n            <ul class=\"nav\">\r\n                 <li><a href=\"#\">首 页</a></li>\r\n                 <li><a href=\"#\">品 牌</a>\r\n                    <div class=\"jnNav\">\r\n                        <div class=\"subitem\">\r\n                            <dl class=\"fore\">\r\n                                <dt>\r\n                                    <a href=\"#nogo\">品牌：</a>\r\n                                </dt>\r\n                                <dd>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em ><a href=\"#nogo\">安踏</a></em>\r\n                                    <em ><a href=\"#nogo\">奥康</a></em>\r\n                                    <em ><a href=\"#nogo\">骆驼</a></em>\r\n                                    <em ><a href=\"#nogo\">特步</a></em>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em class=\"noborder\"><a href=\"#nogo\">特步</a></em>\r\n                                </dd>\r\n                            </dl>\r\n                            <dl>\r\n                                <dt>\r\n                                    <a href=\"#nogo\">品牌：</a>\r\n                                </dt>\r\n                                <dd>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em ><a href=\"#nogo\">安踏</a></em>\r\n                                    <em ><a href=\"#nogo\">奥康</a></em>\r\n                                    <em ><a href=\"#nogo\">骆驼</a></em>\r\n                                    <em ><a href=\"#nogo\">特步</a></em>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em class=\"noborder\"><a href=\"#nogo\">特步</a></em>\r\n                                </dd>\r\n                            </dl>\r\n                        </div>\r\n                    </div>\r\n                </li>\r\n                <li><a href=\"#\">女 装</a>\r\n                    <div class=\"jnNav\">\r\n                        <div class=\"subitem\">\r\n                            <dl class=\"fore\">\r\n                                <dt>\r\n                                    <a href=\"#nogo\">女 装：</a>\r\n                                </dt>\r\n                                <dd>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em ><a href=\"#nogo\">安踏</a></em>\r\n                                    <em ><a href=\"#nogo\">奥康</a></em>\r\n                                    <em ><a href=\"#nogo\">骆驼</a></em>\r\n                                    <em ><a href=\"#nogo\">特步</a></em>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em class=\"noborder\"><a href=\"#nogo\">特步</a></em>\r\n                                </dd>\r\n                            </dl>\r\n                            <dl>\r\n                                <dt>\r\n                                    <a href=\"#nogo\">女 装：</a>\r\n                                </dt>\r\n                                <dd>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em ><a href=\"#nogo\">安踏</a></em>\r\n                                    <em ><a href=\"#nogo\">奥康</a></em>\r\n                                    <em ><a href=\"#nogo\">骆驼</a></em>\r\n                                    <em ><a href=\"#nogo\">特步</a></em>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em class=\"noborder\"><a href=\"#nogo\">特步</a></em>\r\n                                </dd>\r\n                            </dl>\r\n                        </div>\r\n                    </div>\r\n                </li>\r\n                <li><a href=\"#\">男 装</a>\r\n                    <div class=\"jnNav\">\r\n                        <div class=\"subitem\">\r\n                            <dl class=\"fore\">\r\n                                <dt>\r\n                                    <a href=\"#nogo\">男 装：</a>\r\n                                </dt>\r\n                                <dd>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em ><a href=\"#nogo\">安踏</a></em>\r\n                                    <em ><a href=\"#nogo\">奥康</a></em>\r\n                                    <em ><a href=\"#nogo\">骆驼</a></em>\r\n                                    <em ><a href=\"#nogo\">特步</a></em>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em class=\"noborder\"><a href=\"#nogo\">特步</a></em>\r\n                                </dd>\r\n                            </dl>\r\n                            <dl>\r\n                                <dt>\r\n                                    <a href=\"#nogo\">男 装：</a>\r\n                                </dt>\r\n                                <dd>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em ><a href=\"#nogo\">安踏</a></em>\r\n                                    <em ><a href=\"#nogo\">奥康</a></em>\r\n                                    <em ><a href=\"#nogo\">骆驼</a></em>\r\n                                    <em ><a href=\"#nogo\">特步</a></em>\r\n                                    <em ><a href=\"#nogo\">耐克</a></em>\r\n                                    <em ><a href=\"#nogo\">阿迪达斯</a></em>\r\n                                    <em ><a href=\"#nogo\">达芙妮</a></em>\r\n                                    <em ><a href=\"#nogo\">李宁</a></em>\r\n                                    <em class=\"noborder\"><a href=\"#nogo\">特步</a></em>\r\n                                </dd>\r\n                            </dl>\r\n                        </div>\r\n                    </div>\r\n                 </li>\r\n                 <li><a href=\"#\">鞋包配饰</a></li>\r\n            </ul>\r\n        </div>\r\n        <!-- 导航 end -->\r\n    </div>\r\n</div>\r\n<!--头部结束-->\r\n<!--主体开始-->\r\n<div id=\"content\">\r\n    <div class=\"janeshop\">\r\n        <!-- 商品分类 start -->\r\n        <div id=\"jnCatalog\">\r\n            <h2 title=\"商品分类\">商品分类</h2>\r\n            <div class=\"jnCatainfo\">\r\n                <h3>推荐品牌</h3>\r\n                <ul>\r\n                    <li><a href=\"#nogo\" >耐克</a></li>\r\n                    <li><a href=\"#nogo\" class=\"promoted\">阿迪达斯</a></li>\r\n                    <li><a href=\"#nogo\" >达芙妮</a></li>\r\n                    <li><a href=\"#nogo\" >李宁</a></li>\r\n                    <li><a href=\"#nogo\" >安踏</a></li>\r\n                    <li><a href=\"#nogo\" >奥康</a></li>\r\n                    <li><a href=\"#nogo\" class=\"promoted\">骆驼</a></li>\r\n                    <li><a href=\"#nogo\" >特步</a></li>\r\n                </ul>\r\n                <br class=\"clear\" />\r\n                <h3>女装</h3>\r\n                <ul>\r\n                    <li><a href=\"#nogo\" >呢大衣</a></li>\r\n                    <li><a href=\"#nogo\" >T恤</a></li>\r\n                    <li><a href=\"#nogo\" >羽绒</a></li>\r\n                    <li><a href=\"#nogo\" >衬衫</a></li>\r\n                    <li><a href=\"#nogo\" >羊绒衫</a></li>\r\n                    <li><a href=\"#nogo\" >针织</a></li>\r\n                    <li><a href=\"#nogo\" >连衣裙</a></li>\r\n                    <li><a href=\"#nogo\" >皮外套</a></li>\r\n                </ul>\r\n                <br class=\"clear\" />\r\n                <h3>男装</h3>\r\n                <ul>\r\n                    <li><a href=\"#nogo\" >衬衫</a></li>\r\n                    <li><a href=\"#nogo\" >T恤衫</a></li>\r\n                    <li><a href=\"#nogo\" >夹克</a></li>\r\n                    <li><a href=\"#nogo\" >大皮衣</a></li>\r\n                    <li><a href=\"#nogo\" >风衣</a></li>\r\n                    <li><a href=\"#nogo\" >牛仔裤</a></li>\r\n                    <li><a href=\"#nogo\" >西服</a></li>\r\n                    <li><a href=\"#nogo\" >卫衣</a></li>\r\n                </ul>\r\n                <br class=\"clear\" />\r\n                <h3>鞋包配饰</h3>\r\n                <ul>\r\n                    <li><a href=\"#nogo\" >围巾</a></li>\r\n                    <li><a href=\"#nogo\" >旅行箱</a></li>\r\n                    <li><a href=\"#nogo\" >真皮包</a></li>\r\n                    <li><a href=\"#nogo\" >韩版</a></li>\r\n                    <li><a href=\"#nogo\" >达芙妮</a></li>\r\n                    <li><a href=\"#nogo\" >单肩包</a></li>\r\n                    <li><a href=\"#nogo\" >毛线</a></li>\r\n                    <li><a href=\"#nogo\" >清仓靴子</a></li>\r\n                </ul>\r\n                <br class=\"clear\" />\r\n            </div>\r\n        </div>\r\n        <!-- 商品分类 end -->\r\n\r\n        <!-- 大屏广告 start -->\r\n        <div id=\"jnImageroll\">\r\n            <a href=\"#nogo\" id=\"JS_imgWrap\">\r\n                <img src=\"images/ads/1.jpg\" alt=\"相约情人节\"/>\r\n                <img src=\"images/ads/2.jpg\" alt=\"新款上线\"/>\r\n                <img src=\"images/ads/3.jpg\" alt=\"愤怒小鸟特卖\"/>\r\n                <img src=\"images/ads/4.jpg\" alt=\"男鞋促销第一波\"/>\r\n                <img src=\"images/ads/5.jpg\" alt=\"春季新品发布\"/>\r\n            </a>\r\n            <div>\r\n                <a href=\"###1\"><em>相约情人节</em><em>全场119元起</em></a>\r\n                <a href=\"###2\"><em>新款上线</em><em>全场357元起</em></a>\r\n                <a href=\"###3\"><em>愤怒小鸟特卖</em><em>全场89元</em></a>\r\n                <a href=\"###4\"><em>男鞋促销第一波</em><em>全场3.1折起</em></a>\r\n                <a href=\"###5\" class=\"last\"><em>春季新品发布</em><em>全场4.1折起</em></a>\r\n            </div>\r\n        </div>\r\n        <!-- 大屏广告 end -->\r\n\r\n        <!-- 最新动态 start -->\r\n        <div id=\"jnNotice\">\r\n            <div id=\"jnMiaosha\">\r\n                <a href=\"#nogo\" class=\"JS_css3\"><img src=\"images/upload/20120216.jpg\" alt=\"冬品清仓\"  /></a>\r\n            </div>\r\n            <div id=\"jnNoticeInfo\">\r\n                <h2 title=\"最新动态\">最新动态</h2>\r\n                <ul>\r\n                    <li><a href=\"###1\" class=\"tooltip\" title=\"[活动] 伊伴春鞋迎春大促\">[活动] 伊伴春鞋迎春大促</a></li>\r\n                    <li><a href=\"###2\" class=\"tooltip\" title=\"[活动] 千百度冬靴新品火热让利\">[活动] 千百度冬靴新品火热让利</a></li>\r\n                    <li><a href=\"###3\" class=\"tooltip\" title=\"[活动] COEY秋冬新品全场2.3折起\">[活动] COEY秋冬新品全场2.3折起</a></li>\r\n                    <li><a href=\"###4\" class=\"tooltip\" title=\"[活动] 伊伴春鞋迎春大促\">[活动] 伊伴春鞋迎春大促</a></li>\r\n                    <li><a href=\"###5\" class=\"tooltip\" title=\"[活动] 千百度冬靴新品火热让利\">[活动] 千百度冬靴新品火热让利</a></li>\r\n                    <li><a href=\"###6\" class=\"tooltip\" title=\"[活动] COEY秋冬新品全场2.3折起\">[活动] COEY秋冬新品全场2.3折起</a></li>\r\n                </ul>\r\n                <br class=\"clear\" />\r\n            </div>\r\n        </div>\r\n        <!-- 最新动态 end -->\r\n\r\n        <!-- 品牌活动 start -->\r\n        <div id=\"jnBrand\">\r\n            <div id=\"jnBrandTab\">\r\n                <h2 title=\"品牌活动\">品牌活动</h2>\r\n                <ul>\r\n                    <li><a title=\"运动\" href=\"#nogo\">运动</a></li>\r\n                    <li><a title=\"女鞋\" href=\"#nogo\">女鞋</a></li>\r\n                    <li><a title=\"男鞋\" href=\"#nogo\">男鞋</a></li>\r\n                    <li><a title=\"Applife\" href=\"#nogo\">童鞋</a></li>\r\n                </ul>\r\n            </div>\r\n            <div id=\"jnBrandContent\">\r\n                <div id=\"jnBrandList\">\r\n                    <ul>\r\n                        <li>\r\n                            <a href=\"###1\" class=\"JS_live\"><img alt=\"耐克\" src=\"images/upload/20120217.jpg\" /></a>\r\n                            <span><a href=\"###1\">耐克</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###2\" class=\"JS_live\"><img alt=\"阿迪达斯\" src=\"images/upload/20120218.jpg\" /></a>\r\n                            <span><a href=\"###2\">阿迪达斯</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###3\" class=\"JS_live\"><img alt=\"李宁\" src=\"images/upload/20120219.png\" /></a>\r\n                            <span><a href=\"###3\">李宁</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###4\" class=\"JS_live\"><img alt=\"安踏\" src=\"images/upload/20120220.png\" /></a>\r\n                            <span><a href=\"###4\">安踏</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###1\" class=\"JS_live\"><img alt=\"耐克\" src=\"images/upload/20120217.jpg\" /></a>\r\n                            <span><a href=\"###1\">耐克</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###2\" class=\"JS_live\"><img alt=\"阿迪达斯\" src=\"images/upload/20120218.jpg\" /></a>\r\n                            <span><a href=\"###2\">阿迪达斯</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###3\" class=\"JS_live\"><img alt=\"李宁\" src=\"images/upload/20120219.png\" /></a>\r\n                            <span><a href=\"###3\">李宁</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###4\" class=\"JS_live\"><img alt=\"安踏\" src=\"images/upload/20120220.png\" /></a>\r\n                            <span><a href=\"###4\">安踏</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###1\" class=\"JS_live\"><img alt=\"耐克\" src=\"images/upload/20120217.jpg\" /></a>\r\n                            <span><a href=\"###1\">耐克</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###2\" class=\"JS_live\"><img alt=\"阿迪达斯\" src=\"images/upload/20120218.jpg\" /></a>\r\n                            <span><a href=\"###2\">阿迪达斯</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###3\" class=\"JS_live\"><img alt=\"李宁\" src=\"images/upload/20120219.png\" /></a>\r\n                            <span><a href=\"###3\">李宁</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###4\" class=\"JS_live\"><img alt=\"安踏\" src=\"images/upload/20120220.png\" /></a>\r\n                            <span><a href=\"###4\">安踏</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###1\" class=\"JS_live\"><img alt=\"耐克\" src=\"images/upload/20120217.jpg\" /></a>\r\n                            <span><a href=\"###1\">耐克</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###2\" class=\"JS_live\"><img alt=\"阿迪达斯\" src=\"images/upload/20120218.jpg\" /></a>\r\n                            <span><a href=\"###2\">阿迪达斯</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###3\" class=\"JS_live\"><img alt=\"李宁\" src=\"images/upload/20120219.png\" /></a>\r\n                            <span><a href=\"###3\">李宁</a></span>\r\n                        </li>\r\n                        <li>\r\n                            <a href=\"###4\" class=\"JS_live\"><img alt=\"安踏\" src=\"images/upload/20120220.png\" /></a>\r\n                            <span><a href=\"###4\">安踏</a></span>\r\n                        </li>\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <!-- 品牌活动 end -->\r\n\r\n    </div>\r\n</div>\r\n<!--主体结束-->\r\n<!--底部开始-->\r\n<div id=\"footer\">Copyright &copy; 2009 - 2012 JaneShop Inc. </div>\r\n<!--底部结束-->\r\n</body>\r\n</html>\r\n\r\n```\r\n\r\nmain.css:\r\n\r\n```\r\n/*头部样式开始*/\r\n#header{\r\n    background: url(\"../images/headerbg.png\") repeat-x scroll 0 0 #FFFFFF;\r\n    height: 105px;\r\n}\r\n#header .contWidth {\r\n    position: relative;\r\n    height: 105px;\r\n    margin: 0 auto;\r\n    width: 990px;\r\n    z-index: 100;\r\n}\r\n#header .logo { \r\n    float:left; \r\n    margin:0 0 0 10px; \r\n    color:#FFF; \r\n    line-height:80px;\r\n}\r\n#header .search {\r\n    left: 198px;\r\n    position: absolute;\r\n    top: 20px;\r\n}\r\n#inputSearch {\r\n    border: 1px solid #BABEBF;\r\n    color: #999999;\r\n    font-size: 14px;\r\n    height: 17px;\r\n    padding: 3px 6px 5px 6px;\r\n    width: 200px;\r\n}\r\n#inputSearch.focus{\r\n    border: 1px solid #00A5FF;\r\n}\r\n/* 切换皮肤控件样式 */\r\n#skin { \r\n    float:right; \r\n    margin:10px; \r\n    padding:4px; \r\n    width:120px; \r\n}\r\n#skin li { \r\n    float:left; \r\n    margin-right:4px; \r\n    width:15px; \r\n    height:15px; \r\n    text-indent:-9999px; \r\n    overflow:hidden; \r\n    display:block; \r\n    cursor:pointer; \r\n    background-image:url(\"../images/theme.gif\"); \r\n}\r\n#skin_0 { background-position:0px 0px; }\r\n#skin_1 { background-position:15px 0px; }\r\n#skin_2 { background-position:35px 0px; }\r\n#skin_3 { background-position:55px 0px; }\r\n#skin_4 { background-position:75px 0px; }\r\n#skin_5 { background-position:95px 0px; }\r\n#skin_0.selected { background-position:0px 15px; }\r\n#skin_1.selected { background-position:15px 15px; }\r\n#skin_2.selected { background-position:35px 15px; }\r\n#skin_3.selected { background-position:55px 15px; }\r\n#skin_4.selected { background-position:75px 15px; }\r\n#skin_5.selected { background-position:95px 15px; }\r\n/*导航样式开始*/\r\n.mainNav {\r\n    position: absolute;\r\n    top: 68px;\r\n    left: 0;\r\n    height: 37px;\r\n    line-height: 37px;\r\n    width: 990px;\r\n    z-index:100;\r\n    background-color: #4A4A4A;\r\n}\r\n.mainNav .nav {\r\n    display: inline;\r\n    float: left;\r\n    margin-left: 25px;\r\n}\r\n.mainNav ul li { \r\n    float:left; \r\n    display: inline;\r\n    margin-right:14px;\r\n    position: relative ;\r\n    z-index:100;\r\n}\r\n.mainNav ul li a { \r\n    display:block;\r\n    padding:0 8px; \r\n    font-weight:700;\r\n    color:#fff;\r\n    font-size:14px;\r\n}\r\n.mainNav ul li a:hover { \r\n    background:none; \r\n}\r\n/* 二级菜单 */\r\n.jnNav {\r\n    background:#FFFFFF;\r\n    border: 1px solid #B1B1B1;\r\n    border-top:0;\r\n    left: 0;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    top: 37px;\r\n    width: 474px;\r\n    z-index: 1000;\r\n    display:none;\r\n}\r\n.jnNav .subitem {\r\n    float: left;\r\n    height: auto !important;\r\n    min-height: 100px;\r\n    padding: 10px 12px;\r\n    width: 450px;\r\n}\r\n.jnNav .subitem dl {\r\n    border-top: 1px dashed #C4C4C4;\r\n    overflow: hidden;\r\n    padding: 8px 0;\r\n    float:left;\r\n}\r\n.jnNav .subitem .fore {\r\n    border-top-style: none;\r\n    padding-top: 0;\r\n}\r\n.jnNav .subitem dt {\r\n    float: left;\r\n    font-weight: bold;\r\n    line-height: 16px;\r\n    padding: 4px 3px;\r\n    text-align: center;\r\n    width: 76px;\r\n}\r\n.jnNav .subitem dt a {\r\n    color: #000;\r\n    font-weight: 700;\r\n    font-size:12px;\r\n    padding:0;\r\n}\r\n.jnNav .subitem dd {\r\n    float: left;\r\n    overflow: hidden;\r\n    padding: 0;\r\n    width: 364px;\r\n}\r\n.jnNav .subitem em {\r\n    border-right: 1px solid #CCCCCC;\r\n    float: left;\r\n    font-style: normal;\r\n    height: 14px;\r\n    line-height: 14px;\r\n    margin: 5px 0;\r\n    padding: 0 8px;\r\n}\r\n.jnNav .subitem em a {\r\n    color: #666666;\r\n    white-space: nowrap;\r\n    font-size:12px;\r\n    font-weight:normal;\r\n    padding:0;\r\n}\r\n.jnNav .subitem em.noborder {\r\n    border-right: 0 none;\r\n}\r\n/* 主体样式 */\r\n#content{\r\n    clear: left;\r\n    margin: 0 auto;\r\n    position: relative;\r\n    width: 990px;\r\n}\r\n.janeshop{\r\n    height: 560px;\r\n    overflow: hidden;\r\n    padding: 10px 0;\r\n}\r\n/* 商品分类 */\r\n#jnCatalog{\r\n    float: left;\r\n    height: 560px;\r\n    margin: 0 11px 0 0;\r\n    overflow: hidden;\r\n    width: 187px;\r\n}\r\n#jnCatalog h2{\r\n    height:30px;\r\n    line-height:30px;\r\n    color:#fff;\r\n    font-size:12px;\r\n    text-indent:13px;\r\n    background-color:#6E6E6E;\r\n}\r\n.jnCatainfo{\r\n    border: 1px solid #6E6E6E;\r\n    border-style: none solid solid;\r\n    border-width: 0 1px 1px;\r\n    height: 524px;\r\n    overflow: hidden;\r\n    padding: 5px 10px 0;\r\n    width: 165px;\r\n}\r\n.jnCatainfo h3 {\r\n    border-bottom: 1px solid #EEEEEE;\r\n    height: 24px;\r\n    line-height:24px;\r\n    width: 164px;\r\n}\r\n.jnCatainfo ul {\r\n    float: left;\r\n    padding: 0 2px 8px;\r\n}\r\n.jnCatainfo li {\r\n    color: #AEADAE;\r\n    float: left;\r\n    height: 24px;\r\n    line-height: 24px;\r\n    width: 79px;\r\n    overflow: hidden;\r\n    position:relative;\r\n}\r\n.jnCatainfo li a{\r\n    color: #444444;\r\n}\r\n.jnCatainfo li a:hover{\r\n    color: #008CD7;\r\n    text-decoration: none;\r\n}\r\n.jnCatainfo li a.promoted{\r\n    color:#F9044E;\r\n}\r\n.jnCatainfo li .hot {\r\n    background: url(\"../images/hot.gif\") no-repeat scroll 0 0 transparent;\r\n    height: 16px;\r\n    position: absolute;\r\n    top: 0;\r\n    width: 21px;\r\n}\r\n/* 大屏广告 */\r\n#jnImageroll {\r\n    float: left;\r\n    height: 320px;\r\n    margin: 0 11px 0 0;\r\n    overflow: hidden;\r\n    position: relative;\r\n    width: 550px;\r\n}\r\n#jnImageroll img {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n#jnImageroll div {\r\n    bottom: 0;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    float: left;\r\n}\r\n#jnImageroll div a {\r\n    background-color: #444444;\r\n    color: #FFFFFF;\r\n    display: inline-block;\r\n    float: left;\r\n    height: 32px;\r\n    margin-right: 1px;\r\n    overflow: hidden;\r\n    padding: 5px 15px;\r\n    text-align: center;\r\n    width: 79px;\r\n}\r\n#jnImageroll div a:hover {\r\n    text-decoration: none;\r\n}\r\n#jnImageroll div a em {\r\n    cursor: pointer;\r\n    display: block;\r\n    height: 16px;\r\n    overflow: hidden;\r\n    width: 79px;\r\n}\r\n#jnImageroll .last {\r\n    margin: 0;\r\n    width: 80px;\r\n}\r\n#jnImageroll a.chos {\r\n    background: url(\"../images/adindex.gif\") no-repeat center 39px #37A7D7;\r\n    color: #FFFFFF;\r\n}\r\n/* 最新动态 */\r\n#jnNotice{\r\n    float: left;\r\n    height: 321px;\r\n    overflow: hidden;\r\n    width: 230px;\r\n}\r\n#jnMiaosha {\r\n    float: left;\r\n    height: 176px;\r\n    margin-bottom: 10px;\r\n    overflow: hidden;\r\n    width: 230px;\r\n}\r\n.JS_css3 img {\r\n    -webkit-transition:1s all;\r\n    -moz-transition:1s all;\r\n    -o-transition:1s all;\r\n    transition:1s all;\r\n}\r\n.JS_css3:hover img {\r\n    -webkit-transform:rotate(720deg);\r\n    -moz-transform:rotate(720deg);\r\n    -o-transform:rotate(720deg);\r\n    transform:rotate(720deg);\r\n}\r\n#jnNoticeInfo {\r\n    float: left;\r\n    border: 1px solid #DFDFDF;\r\n    height: 133px;\r\n    overflow: hidden;\r\n    width: 228px;\r\n}\r\n#jnNoticeInfo h2 {\r\n    height: 23px;\r\n    line-height: 23px;\r\n    border-bottom: 1px solid #DFDFDF;\r\n    text-indent:12px;\r\n}\r\n#jnNoticeInfo ul {\r\n    float: left;\r\n    padding: 6px 2px 0 12px;\r\n}\r\n#jnNoticeInfo li {\r\n    height: 20px;\r\n    line-height: 20px;\r\n    overflow: hidden;\r\n}\r\n#jnNoticeInfo li a{\r\n    color:#666666;\r\n}\r\n#jnNoticeInfo li a:hover{\r\n    color: #008CD7;\r\n    text-decoration: none;\r\n}\r\n/* 品牌活动 */\r\n#jnBrand {\r\n    float: left;\r\n    height: 230px;\r\n    margin: 10px 0 0;\r\n    overflow: hidden;\r\n    width: 790px;\r\n}\r\n#jnBrandTab {\r\n    border-bottom: 1px solid #E4E4E4;\r\n    height: 29px;\r\n    position: relative;\r\n    width: 790px;\r\n    float: left;\r\n}\r\n#jnBrandTab h2 {\r\n    height: 29px;\r\n    line-height: 29px;\r\n    left: 0;\r\n    position: absolute;\r\n    width: 100px;\r\n}\r\n#jnBrandTab ul {\r\n    position: absolute;\r\n    right: 0;\r\n    top: 10px;\r\n}\r\n#jnBrandTab li {\r\n    float: left;\r\n    margin: 0 10px 0 0;\r\n}\r\n#jnBrandTab li a {\r\n    background-color: #E4E4E4;\r\n    color: #000000;\r\n    display: inline-block;\r\n    height: 20px;\r\n    line-height: 20px;\r\n    padding: 0 10px;\r\n}\r\n#jnBrandTab .chos {\r\n    background: url(\"../images/chos.gif\") no-repeat scroll 50% bottom transparent;\r\n    padding-bottom: 3px;\r\n}\r\n#jnBrandTab .chos a {\r\n    background-color: #FA5889;\r\n    color: #FFFFFF;\r\n    outline: 0 none;\r\n}\r\n#jnBrandContent {\r\n    float: left;\r\n    height: 188px;\r\n    overflow: hidden;\r\n    margin: 8px 5px;\r\n    width: 790px;\r\n    position: relative;\r\n}\r\n#jnBrandList {\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    width: 3200px;\r\n}\r\n#jnBrandContent li {\r\n    float: left;\r\n    height: 188px;\r\n    overflow: hidden;\r\n    padding: 0 5px;\r\n    position: relative;\r\n    width: 185px;\r\n}\r\n#jnBrandContent li img {\r\n    left: 5px;\r\n    position: absolute;\r\n    top: 0;\r\n}\r\n#jnBrandContent li span {\r\n    background-color: #EFEFEF;\r\n    bottom: 0;\r\n    color: #666666;\r\n    display: inline-block;\r\n    font-size: 14px;\r\n    height: 24px;\r\n    line-height: 24px;\r\n    overflow: hidden;\r\n    position: absolute;\r\n    text-align: center;\r\n    width: 183px;\r\n}\r\n#jnBrandContent li a {\r\n    color:#666666;\r\n}\r\n#jnBrandContent li a:hover{\r\n    color: #008CD7;\r\n    text-decoration: none;\r\n}\r\n/* details.html */\r\n#jnProitem{\r\n    float: left;\r\n    width: 312px; \r\n    height: 560px;\r\n    display:inline;\r\n}\r\n#jnProitem .jqzoomWrap {\r\n    border: 1px solid #BBBBBB;\r\n    cursor: pointer;\r\n    float: left;\r\n    padding: 0;\r\n    position: relative;\r\n}\r\n#jnProitem span {\r\n    clear: both;\r\n    display: block;\r\n    padding-bottom: 10px;\r\n    padding-top: 10px;\r\n    text-align: center;\r\n    width: 320px;\r\n}\r\n#jnProitem ul.imgList{\r\n    height: 80px;\r\n}\r\n#jnProitem ul.imgList li { \r\n    float:left;\r\n    margin-right:10px;  \r\n}\r\n#jnProitem ul.imgList li img { \r\n    width:60px; \r\n    height:60px; \r\n    padding:1px;\r\n    background:#EEE;\r\n    cursor:pointer; \r\n}\r\n#jnProitem ul.imgList li img:hover { \r\n    padding:1px; \r\n    background:#999; \r\n}\r\n\r\n.tab{ \r\n    clear:both;\r\n    float: left;\r\n    height: 230px;\r\n    overflow: hidden;\r\n    width: 310px;\r\n}\r\n.tab .tab_menu { \r\n    clear:both;\r\n}\r\n.tab .tab_menu li { \r\n    float:left; \r\n    text-align:center; \r\n    cursor:pointer; \r\n    list-style:none; \r\n    padding:1px 6px; \r\n    margin-right:4px; \r\n    background:#F1F1F1;\r\n    border:1px solid #898989; \r\n    border-bottom:none;\r\n}\r\n.tab .tab_menu li.hover { \r\n    background:#DFDFDF;\r\n}\r\n.tab .tab_menu li.selected { \r\n    color:#FFF; \r\n    background:#6D84B4;\r\n}\r\n.tab .tab_box { \r\n    clear:both; \r\n    border:1px solid #898989;\r\n}\r\n.tab .hide{\r\n    display:none\r\n}\r\n#jnDetails {\r\n    float: left;\r\n    display:inline;\r\n    overflow: hidden;\r\n    width: 468px;\r\n}\r\n#jnDetails .jnProDetail{\r\n    padding:0 10px 10px 10px;\r\n}\r\n#jnDetails .jnProDetailList li{\r\n    line-height:25px;\r\n    float:left;\r\n    width:100%;\r\n}\r\n#jnDetails .jnProDetailList strong.del {\r\n    color: #404040;\r\n    font-size: 12px;\r\n    position: static;\r\n    text-decoration: line-through;\r\n}\r\n#jnDetails .jnProDetailList strong {\r\n    font-weight:400;\r\n}\r\n#jnDetails .jnProDetailList .tbDetailPrice strong {\r\n    font-weight: 700;\r\n    color: #FF5500;\r\n    font: 24px Tahoma,Arial,Helvetica,sans-serif;\r\n    padding-right: 5px;\r\n    vertical-align: middle;\r\n}\r\n#jnDetails .jnProDetailList .color_change li , #jnDetails .jnProDetailList .pro_size li{ \r\n    float:left; \r\n    margin-right:10px; \r\n    width:40px;\r\n}\r\n#jnDetails .jnProDetailList .color_change img { \r\n    width:30px; \r\n    height:30px; \r\n    padding:1px; \r\n    background:#EEE;\r\n    border:1px solid #BBB;\r\n    cursor:pointer; \r\n}\r\n#jnDetails .jnProDetailList .color_change img:hover,#jnDetails .jnProDetailList .color_change img.hover { \r\n    border:1px solid #f60;\r\n}\r\n#jnDetails .jnProDetailList .pro_size li{\r\n    display:block; \r\n    margin-right:6px;\r\n    border:1px solid #AAA;\r\n    cursor:pointer; \r\n    width:30px; \r\n    height:30px; \r\n    line-height:30px; \r\n    overflow:hidden;\r\n    text-align:center;\r\n}\r\n#jnDetails .jnProDetailList .pro_size li.cur{\r\n    border:1px solid #AAA;\r\n    background-color:#f60;\r\n}\r\n/* rating css */\r\n.rating{\r\n    overflow:hidden;\r\n    width:80px;\r\n    height:16px;\r\n    margin:0 0 20px 0;\r\n    padding:0;\r\n    list-style:none;\r\n    clear:both;\r\n    position:relative;\r\n    background: url(../images/star-matrix.gif) no-repeat 0 0;\r\n}\r\n.nostar {background-position:0 0}\r\n.onestar {background-position:0 -16px}\r\n.twostar {background-position:0 -32px}\r\n.threestar {background-position:0 -48px}\r\n.fourstar {background-position:0 -64px}\r\n.fivestar {background-position:0 -80px}\r\nul.rating li {\r\n    cursor: pointer;\r\n    float:left;\r\n    text-indent:-999em;\r\n}\r\nul.rating li a {\r\n    position:absolute;\r\n    left:0;\r\n    top:0;\r\n    width:16px;\r\n    height:16px;\r\n    text-decoration:none;\r\n    z-index: 200;\r\n}\r\nul.rating li.one a {left:0}\r\nul.rating li.two a {left:16px;}\r\nul.rating li.three a {left:32px;}\r\nul.rating li.four a {left:48px;}\r\nul.rating li.five a {left:64px;}\r\nul.rating li a:hover {\r\n    z-index:2;\r\n    width:80px;\r\n    height:16px;\r\n    overflow:hidden;\r\n    left:0; \r\n    background: url(../images/star-matrix.gif) no-repeat 0 0\r\n}\r\nul.rating li.one a:hover {background-position:0 -96px;}\r\nul.rating li.two a:hover {background-position:0 -112px;}\r\nul.rating li.three a:hover {background-position:0 -128px}\r\nul.rating li.four a:hover {background-position:0 -144px}\r\nul.rating li.five a:hover {background-position:0 -160px}\r\n\r\n/* footer */\r\n#footer {\r\n    margin: 0 auto;\r\n    width: 990px;\r\n    color: #666666;\r\n    padding: 18px 0;\r\n    text-align: center;\r\n}\r\n\r\n/* tooltip */\r\n#tooltip{\r\n    position:absolute;\r\n    border:1px solid #333;\r\n    background:#f7f5d1;\r\n    padding:1px;\r\n    color:#333;\r\n    display:none;\r\n}\r\n/* imgHover */\r\n.imageMask{\r\n    background-color:#ffffff; \r\n    filter:alpha(opacity=0);\r\n    opacity: 0; \r\n    cursor: pointer;\r\n}\r\n.imageOver{\r\n    background:url(../images/zoom.gif) no-repeat 50% 50%;   \r\n    filter:alpha(opacity=60);\r\n    opacity: 0.6;   \r\n}\r\n\r\n/* jquery zoom */\r\n.zoomPad{\r\n    position:relative;\r\n    float:left;\r\n    z-index:99;\r\n    cursor:crosshair;\r\n}\r\n.zoomPreload{\r\n   -moz-opacity:0.8;\r\n   opacity: 0.8;\r\n   filter: alpha(opacity = 80);\r\n   color: #333;\r\n   font-size: 12px;\r\n   font-family: Tahoma;\r\n   text-decoration: none;\r\n   border: 1px solid #CCC;\r\n   background-color: white;\r\n   padding: 8px;\r\n   text-align:center;\r\n   background-image: url(../images/zoomloader.gif);\r\n   background-repeat: no-repeat;\r\n   background-position: 43px 30px;\r\n   z-index:110;\r\n   width:90px;\r\n   height:43px;\r\n   position:absolute;\r\n   top:0px;\r\n   left:0px;\r\n    * width:100px;\r\n    * height:49px;\r\n}\r\n.zoomPup{\r\n    overflow:hidden;\r\n    background-color: #FFF;\r\n    -moz-opacity:0.6;\r\n    opacity: 0.6;\r\n    filter: alpha(opacity = 60);\r\n    z-index:120;\r\n    position:absolute;\r\n    border:1px solid #CCC;\r\n    z-index:101;\r\n    cursor:crosshair;\r\n}\r\n.zoomOverlay{\r\n    position:absolute;\r\n    left:0px;\r\n    top:0px;\r\n    background:#FFF;\r\n    /*opacity:0.5;*/\r\n    z-index:5000;\r\n    width:100%;\r\n    height:100%;\r\n    display:none;\r\n    z-index:101;\r\n}\r\n.zoomWindow{\r\n    position:absolute;\r\n    left:110%;\r\n    top:40px;\r\n    background:#FFF;\r\n    z-index:6000;\r\n    height:auto;\r\n  z-index:10000;\r\n  z-index:110;\r\n}\r\n.zoomWrapper{\r\n    position:relative;\r\n    border:1px solid #999;\r\n  z-index:110;\r\n}\r\n.zoomWrapperTitle{\r\n    display:block;\r\n    background:#999;\r\n    color:#FFF;\r\n    height:18px;\r\n    line-height:18px;\r\n    width:100%;\r\n  overflow:hidden;\r\n    text-align:center;\r\n    font-size:12px;\r\n  position:absolute;\r\n  top:0px;\r\n  left:0px;\r\n  z-index:120;\r\n  -moz-opacity:0.6;\r\n  opacity: 0.6;\r\n  filter: alpha(opacity = 60);\r\n}\r\n.zoomWrapperImage{\r\n    display:block;\r\n  position:relative;\r\n  overflow:hidden;\r\n  z-index:110;\r\n\r\n}\r\n.zoomWrapperImage img{\r\n  border:0px;\r\n  display:block;\r\n  position:absolute;\r\n  z-index:101;\r\n}\r\n.zoomIframe{\r\n  z-index: -1;\r\n  filter:alpha(opacity=0);\r\n  -moz-opacity: 0.80;\r\n  opacity: 0.80;\r\n  position:absolute;\r\n  display:block;\r\n}\r\n\r\n```\r\n\r\n<font color=\"red\">不要忘了最上面的reset.css</font>\r\n\r\nskin_0.css - skin_5.css:\r\n\r\n```\r\nskin_0.css :\r\n.mainNav {\r\n    background-color: #4A4A4A;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #6E6E6E;\r\n}\r\nskin_1.css :\r\n.mainNav {\r\n    background-color: #BE46D8;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #D49AE1;\r\n}\r\nskin_2.css :\r\n.mainNav {\r\n    background-color: #E44072;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #F296B2;\r\n}\r\nskin_3.css :\r\n.mainNav {\r\n    background-color: #37C7D4;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #98E0E6;\r\n}\r\nskin_4.css :\r\n.mainNav {\r\n    background-color: #F9AF2A;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #FFCF78;\r\n}\r\nskin_5.css :\r\n.mainNav {\r\n    background-color: #B1D410;\r\n}\r\n#jnCatalog h2 {\r\n    background-color: #CDE074;\r\n}\r\n```\r\n\r\nad.js:\r\n\r\n```\r\n/* 首页大屏广告效果 */\r\n$(function(){\r\n    var $imgrolls = $(\"#jnImageroll div a\");\r\n    $imgrolls.css(\"opacity\",\"0.7\");\r\n    var len  = $imgrolls.length;\r\n    var index = 0;\r\n    var adTimer = null;\r\n    $imgrolls.mouseover(function(){\r\n        index = $imgrolls.index(this);\r\n        showImg(index);\r\n    }).eq(0).mouseover();   \r\n    //滑入 停止动画，滑出开始动画.\r\n    $(\'#jnImageroll\').hover(function(){\r\n            if(adTimer){ \r\n                clearInterval(adTimer);\r\n            }\r\n         },function(){\r\n            adTimer = setInterval(function(){\r\n                showImg(index);\r\n                index++;\r\n                if(index==len){index=0;}\r\n            } , 5000);\r\n    }).trigger(\"mouseleave\");\r\n})\r\n//显示不同的幻灯片\r\nfunction showImg(index){\r\n    var $rollobj = $(\"#jnImageroll\");\r\n    var $rolllist = $rollobj.find(\"div a\");\r\n    var newhref = $rolllist.eq(index).attr(\"href\");\r\n    $(\"#JS_imgWrap\").attr(\"href\",newhref)\r\n             .find(\"img\").eq(index).stop(true,true).fadeIn().siblings().fadeOut();\r\n    $rolllist.removeClass(\"chos\").css(\"opacity\",\"0.7\")\r\n             .eq(index).addClass(\"chos\").css(\"opacity\",\"1\"); \r\n}\r\n```\r\n\r\naddhot.js:\r\n\r\n```\r\n$(function(){\r\n    $(\".jnCatainfo .promoted\").append(\"<s class=\'hot\'></s>\");\r\n})\r\n```\r\n\r\nchangeSkin.js:\r\n\r\n```\r\n$(function(){\r\n    var $li=$(\"#skin li\");\r\n    $li.click(function(){\r\n        switchSkin(this.id);\r\n    });\r\n    var cookie_skin=$.cookie(\"MyCssSkin\");\r\n    if(cookie_skin){\r\n        switchSkin(cookie_skin);\r\n    }\r\n});\r\nfunction switchSkin(skinName){\r\n    $(\"#\"+skinName).addClass(\"selected\").siblings().removeClass(\"selected\");\r\n    $(\"#cssfile\").attr(\"href\",\"styles/skin/\"+skinName+\".css\");\r\n    //设置不同的皮肤\r\n    $.cookie(\"MyCssSkin\",skinName,{path:\'/\',expires:10});\r\n\r\n}\r\n```\r\n\r\nimgHover.js:\r\n\r\n```\r\n/* 滑过图片出现放大镜效果 */\r\n$(function(){\r\n    $(\"#jnBrandList li\").each(function(index){\r\n        var $img = $(this).find(\"img\");\r\n        var img_w = $img.width();\r\n        var img_h = $img.height();\r\n        var spanHtml = \'<span style=\"position:absolute;top:0;left:5px;width:\'+img_w+\'px;height:\'+img_h+\'px;\" class=\"imageMask\"></span>\';\r\n        $(spanHtml).appendTo(this);\r\n    })\r\n    $(\"#jnBrandList\").delegate(\".imageMask\", \"hover\", function(){\r\n        $(this).toggleClass(\"imageOver\");\r\n    });\r\n})\r\n```\r\n\r\nimgSlide.js:\r\n\r\n```\r\n$(function(){\r\n    $(\"#jnBrandTab li a\").click(function(){\r\n        $(this).parent().addClass(\"chos\")\r\n               .siblings().removeClass(\"chos\");\r\n        var idx=$(\"#jnBrandTab li a\").index(this);\r\n        showBrandList(idx);\r\n        return false;\r\n    }).eq(0).click();\r\n});\r\nfunction showBrandList(index){\r\n    var $rollobj=$(\"#jnBrandList\");\r\n    var rollWidth=$rollobj.find(\"li\").outerWidth();\r\n    rollWidth=rollWidth*4;\r\n    $rollobj.stop(true,false).animate({left:-rollWidth*index},1000);\r\n}\r\n```\r\n\r\ninput.js:\r\n\r\n```\r\n$(function(){\r\n    $(\"#inputSearch\").focus(function(){\r\n        $(this).addClass(\"focus\");\r\n        if($(this).val()==this.defaultValue){\r\n            $(this).val(\"\");\r\n        }\r\n    }).blur(function(){\r\n        $(this).removeClass(\"focus\");\r\n        if($(this).val()==\"\"){\r\n            $(this).val(this.defaultValue);\r\n        }\r\n    }).keyup(function(e){\r\n        if(e.which==13){\r\n            alert(\'回车提交表单\');\r\n        }\r\n    })\r\n})\r\n```\r\n\r\nnav.js:\r\n\r\n```\r\n$(function(){\r\n    $(\"#nav li\").hover(function(){\r\n        $(this).find(\".jnNav\").show();\r\n    },function(){\r\n        $(this).find(\".jnNav\").hide();\r\n    });\r\n})\r\n```\r\n\r\ntooltip.js:\r\n\r\n```\r\n$(function(){\r\n    var x=10;\r\n    var y=20;\r\n    $(\"a.tooltip\").mouseover(function(e){\r\n        this.myTitle=this.title;\r\n        this.title=\"\";\r\n        var tooltip=\"<div id=\'tooltip\'>\"+this.myTitle+\"</div>\";//创建div元素\r\n        $(\"body\").append(tooltip);\r\n        $(\"#tooltip\")\r\n            .css({\r\n                \"top\":(e.pageY+y)+\"px\",\r\n                \"left\":(e.pageX+x)+\"px\"\r\n            }).show(\"fast\");  //设置x坐标和y坐标，并且显示\r\n    }).mouseout(function(){\r\n        this.title=this.myTitle;\r\n        $(\"#tooltip\").remove();\r\n    }).mouseover(function(e){\r\n        $(\"#tooltip\")\r\n            .css({\r\n                \"top\":(e.pageY+y)+\"px\",\r\n                \"left\":(e.pageX+x)+\"px\"\r\n            });\r\n    });\r\n\r\n})\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('75', 'mybatis基本增删改查', '<h1 id=\"h1-mybatis\"><a name=\"Mybatis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis</h1><h1 id=\"h1--\"><a name=\"基础知识：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>基础知识：</h1><h2 id=\"h2--jdbc-jdbc-\"><a name=\"对原生态 jdbc 程序（单独使用 jdbc 开发）问题总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>对原生态 jdbc 程序（单独使用 jdbc 开发）问题总结</h2><h3 id=\"h3-1-\"><a name=\"1、环境\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、环境</h3><p> <a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a> 环境 ：jdk1.8.0_77</p>\r\n<p> 开发工具 ： IDEA 2016.1</p>\r\n<p> <a href=\"http://lib.csdn.net/base/mysql\" title=\"MySQL知识库\">数据库</a> ： <a href=\"http://lib.csdn.net/base/mysql\" title=\"MySQL知识库\">MySQL</a> 5.7</p>\r\n<h3 id=\"h3-2-\"><a name=\"2、创建数据库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、创建数据库</h3><p> mybatis_test.sql</p>\r\n<p> Tables ：items、orderdetail、orders、user</p>\r\n<h3 id=\"h3-3-jdbc-\"><a name=\"3、JDBC 程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、JDBC 程序</h3><p> 使用 JDBC 查询 MySQL 数据库中用户表的记录</p>\r\n<p> 代码：</p>\r\n<pre><code>package cn.zhisheng.mybatis.jdbc;\r\n\r\n/**\r\n * Created by 10412 on 2016/11/27.\r\n */\r\n\r\nimport java.sql.*;\r\n\r\n/**\r\n *通过单独的jdbc程序来总结问题\r\n */\r\n\r\npublic class JdbcTest\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        //数据库连接\r\n        Connection connection = null;\r\n        //预编译的Statement，使用预编译的Statement可以提高数据库性能\r\n        PreparedStatement preparedStatement = null;\r\n        //结果集\r\n        ResultSet resultSet = null;\r\n\r\n        try\r\n        {\r\n            //加载数据库驱动\r\n            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\r\n\r\n            //通过驱动管理类获取数据库链接\r\n            connection =  DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mybatis_test?characterEncoding=utf-8&quot;, &quot;root&quot;, &quot;root&quot;);\r\n            //定义sql语句 ?表示占位符（在这里表示username）\r\n            String sql = &quot;select * from user where username = ?&quot;;\r\n            //获取预处理statement\r\n            preparedStatement = connection.prepareStatement(sql);\r\n            //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值\r\n            preparedStatement.setString(1, &quot;王五&quot;);\r\n            //向数据库发出sql执行查询，查询出结果集\r\n            resultSet =  preparedStatement.executeQuery();\r\n            //遍历查询结果集\r\n            while(resultSet.next())\r\n            {\r\n                System.out.println(resultSet.getString(&quot;id&quot;)+&quot;  &quot;+resultSet.getString(&quot;username&quot;));\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }finally{\r\n            //释放资源\r\n            if(resultSet!=null)\r\n            {\r\n                try {\r\n                    resultSet.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(preparedStatement!=null)\r\n            {\r\n                try {\r\n                    preparedStatement.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(connection!=null)\r\n            {\r\n                try {\r\n                    connection.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n</code></pre><h3 id=\"h3-4-\"><a name=\"4、问题总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4、问题总结</h3><blockquote>\r\n<ul>\r\n<li>数据库连接，使用时就创建，不使用立即释放，对数据库频繁连接开启和关闭，造成数据库资源的浪费，影响数据库性能。</li></ul>\r\n<pre><code>解决方法：使用数据库连接池管理数据库连接。\r\n</code></pre><ul>\r\n<li>将 sql 语句<strong>硬编码</strong>到 java 代码中，如果 sql 语句需要修改，那么就需要重新编译 java 代码，不利于系统的维护。</li></ul>\r\n<pre><code>设想：将 sql 语句配置在 xml 配置文件中，即使 sql 语句发生变化，也不需要重新编译 java 代码。\r\n</code></pre><ul>\r\n<li>向 preparedStatement 中设置参数，对占位符号位置和设置参数值，硬编码在 java 代码中，同样也不利于系统的维护。</li></ul>\r\n<pre><code>设想：将 sql 语句、占位符、参数值配置在 xml 配置文件中。\r\n</code></pre><ul>\r\n<li>从 resultSet 中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。</li></ul>\r\n<pre><code>设想：将查询的结果集自动映射成 java 对象。\r\n</code></pre></blockquote>\r\n<h2 id=\"h2-mybatis-\"><a name=\"Mybatis框架原理（掌握）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis框架原理（掌握）</h2><h3 id=\"h3-1-mybatis-\"><a name=\"1、Mybatis 是什么？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、Mybatis 是什么？</h3><p> Mybatis 是一个持久层的<a href=\"http://lib.csdn.net/base/architecture\" title=\"大型网站架构知识库\">架构</a>，是 apache 下的顶级项目。</p>\r\n<p> Mybatis 原先是托管在 googlecode 下，再后来是托管在 Github 上。</p>\r\n<p> Mybatis 让程序员将主要的精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活生成（半自动，大部分需要程序员编写 sql ）满足需要 sql 语句。</p>\r\n<p> Mybatis 可以将向 preparedStatement 中的输入参数自动进行<strong>输入映射</strong>，将查询结果集灵活的映射成 java 对象。（<strong>输出映射</strong>）</p>\r\n<h3 id=\"h3-2-mybatis-\"><a name=\"2、Mybatis 框架\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、Mybatis 框架</h3><p><img src=\"http://ohfk1r827.bkt.clouddn.com/Mybatis%E6%A1%86%E6%9E%B6.jpg\" alt=\"\"></p>\r\n<p>注解：</p>\r\n<blockquote>\r\n<ul>\r\n<li>SqlMapConfig.xml （Mybatis的全局配置文件，名称不定）配置了数据源、事务等 Mybatis 运行环境</li></ul>\r\n<ul>\r\n<li>Mapper.xml 映射文件（配置 sql 语句）</li></ul>\r\n<ul>\r\n<li>SqlSessionFactory （会话工厂）根据配置文件配置工厂、创建 SqlSession</li></ul>\r\n<ul>\r\n<li>SqlSession （会话）面向用户的接口、操作数据库（发出 sql 增删改查）</li></ul>\r\n<ul>\r\n<li>Executor （执行器）是一个接口（基本执行器、缓存执行器）、SqlSession 内部通过执行器操作数据库</li></ul>\r\n<ul>\r\n<li>Mapped Statement （底层封装对象）对操作数据库存储封装，包括 sql 语句、输入参数、输出结果类型<br>?</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-mybatis-\"><a name=\"Mybatis入门程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis入门程序</h2><h3 id=\"h3-1-\"><a name=\"1、需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、需求</h3><p>实现以下功能：</p>\r\n<blockquote>\r\n<ul>\r\n<li>根据用户id查询一个用户信息</li><li>根据用户名称模糊查询用户信息列表</li><li>添加用户</li><li>更新用户</li><li>删除用户</li></ul>\r\n</blockquote>\r\n<h3 id=\"h3-2-\"><a name=\"2、环境\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、环境</h3><p>java 环境 ：jdk1.8.0_77</p>\r\n<p>开发工具 ： IDEA 2016.1</p>\r\n<p>数据库 ： MySQL 5.7</p>\r\n<p>Mybatis 运行环境（ jar 包）</p>\r\n<p>MySQL 驱动包</p>\r\n<p>其他依赖包</p>\r\n<h3 id=\"h3-3-log4j-properties\"><a name=\"3、 log4j.properties\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、 log4j.properties</h3><p>在classpath下创建log4j.properties如下：</p>\r\n<pre><code># Global logging configuration\r\n#在开发环境日志级别要设置为DEBUG、生产环境要设置为INFO或者ERROR\r\nlog4j.rootLogger=DEBUG, stdout\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n</code></pre><p>Mybatis默认使用log4j作为输出日志信息。</p>\r\n<h3 id=\"h3-4-\"><a name=\"4、工程结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4、工程结构</h3><p><img src=\"http://ohfk1r827.bkt.clouddn.com/%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-5-sqlmapconfig-xml\"><a name=\"5、SqlMapConfig.xml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5、SqlMapConfig.xml</h3><p>配置 Mybatis 的运行环境、数据源、事务等</p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r\n&lt;!DOCTYPE configuration\r\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\r\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\r\n&lt;configuration&gt;\r\n    &lt;!-- 和spring整合后 environments配置将废除--&gt;\r\n    &lt;environments default=&quot;development&quot;&gt;\r\n        &lt;environment id=&quot;development&quot;&gt;\r\n            &lt;!-- 使用jdbc事务管理,事务由 Mybatis 控制--&gt;\r\n            &lt;transactionManager type=&quot;JDBC&quot; /&gt;\r\n            &lt;!-- 数据库连接池,由Mybatis管理，数据库名是mybatis_test，Mysql用户名root，密码root --&gt;\r\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\r\n                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;\r\n                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis_test?characterEncoding=utf-8&quot; /&gt;\r\n                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;\r\n                &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;\r\n            &lt;/dataSource&gt;\r\n        &lt;/environment&gt;\r\n    &lt;/environments&gt;\r\n&lt;/configuration&gt;\r\n</code></pre><h3 id=\"h3-6-po-\"><a name=\"6、创建 po 类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6、创建 po 类</h3><p>Po 类作为 mybatis 进行 sql 映射使用，po 类通常与数据库表对应，User.java 如下：</p>\r\n<pre><code>package cn.zhisheng.mybatis.po;\r\n\r\nimport java.util.Date;\r\n\r\n/**\r\n * Created by 10412 on 2016/11/28.\r\n */\r\npublic class User\r\n{\r\n    private int id;\r\n    private String username;            // 用户姓名\r\n    private String sex;                 // 性别\r\n    private Date birthday;              // 生日\r\n    private String address;             // 地址\r\n\r\n    //getter and setter\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public String getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(String sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-7-id-\"><a name=\"7、根据用户 id（主键）查询用户信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7、根据用户 id（主键）查询用户信息</h3><ul>\r\n<li><p>映射文件</p>\r\n<blockquote>\r\n<ul>\r\n<li>User.xml（原在 Ibatis 中命名）在 Mybatis 中命名规则为 xxxmapper.xml</li><li>在映射文件中配置 sql 语句</li></ul>\r\n</blockquote>\r\n<p><code>User.xml</code></p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r\n&lt;!DOCTYPE mapper\r\nPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;\r\n&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;\r\n&lt;mapper namespace=&quot;test&quot;&gt;\r\n&lt;/mapper&gt;\r\n</code></pre><p><code>namespace</code> ：命名空间，对 sql 进行分类化管理，用于隔离 sql 语句，后面会讲另一层非常重要的作用。</p>\r\n<p>?</p>\r\n<p>在 <code>User.xml</code> 中加入</p>\r\n<pre><code>&lt;!--通过select执行数据库查询\r\n       id:标识映射文件中的sql\r\n       将sql语句封装到mappedStatement对象中，所以id称为Statement的id\r\n       #{}：表示占位符\r\n       #{id}：其中的id表示接收输入的参数，参数名称就是id，如果输入参数是简单类型，那么#{}中的参数名可以任意，可以是value或者其他名称\r\n       parameterType：表示指定输入参数的类型\r\n       resultType：表示指定sql输出结果的所映射的java对象类型\r\n--&gt;\r\n&lt;!-- 根据id获取用户信息 --&gt;\r\n   &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.zhisheng.mybatis.po.User&quot;&gt;\r\n       select * from user where id = #{id}\r\n   &lt;/select&gt;\r\n</code></pre><p><code>User.xml</code> 映射文件已经完全写好了，那接下来就需要在 <code>SqlMapConfig.xml</code>中加载映射文件 <code>User.xml</code></p>\r\n<pre><code>&lt;!--加载映射文件--&gt;\r\n   &lt;mappers&gt;\r\n       &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;\r\n   &lt;/mappers&gt;\r\n</code></pre><p><img src=\"http://ohfk1r827.bkt.clouddn.com/%E5%8A%A0%E8%BD%BDUser%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6.jpg\" alt=\"\"></p>\r\n<p>?</p>\r\n</li><li><p>编写程序</p>\r\n<p><code>MybatisFirst.java</code></p>\r\n<p>?</p>\r\n</li></ul>\r\n<pre><code>   package cn.zhisheng.mybatis.first;\r\n\r\n   import cn.zhisheng.mybatis.po.User;\r\n   import org.apache.ibatis.io.Resources;\r\n   import org.apache.ibatis.session.SqlSession;\r\n   import org.apache.ibatis.session.SqlSessionFactory;\r\n   import org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n   import org.junit.Test;\r\n\r\n   import java.io.IOException;\r\n   import java.io.InputStream;\r\n\r\n       /**\r\n   * Created by 10412 on 2016/11/28.\r\n   */\r\n   public class MybatisFirst\r\n   {\r\n      //根据id查询用户信息，得到用户的一条记录\r\n      @Test\r\n      public void findUserByIdTest() throws IOException\r\n      {\r\n          //Mybatis 配置文件\r\n          String resource = &quot;SqlMapConfig.xml&quot;;\r\n\r\n          //得到配置文件流\r\n          InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n          //创建会话工厂,传入Mybatis的配置文件信息\r\n          SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        //通过工厂得到SqlSession\r\n         SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n         //通过SqlSession操作数据库\r\n         //第一个参数：映射文件中Statement的id，等于 = namespace + &quot;.&quot; + Statement的id\r\n         //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n         //sqlSession.selectOne 结果与映射文件中所匹配的resultType类型的对象\r\n         User user = sqlSession.selectOne(&quot;test.findUserById&quot;, 1);\r\n\r\n         System.out.println(user);\r\n\r\n         //释放资源\r\n         sqlSession.close();\r\n     }\r\n   }\r\n</code></pre><p>然后运行一下这个<a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\">测试</a>，发现结果如下就代表可以了：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test1.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-8-\"><a name=\"8、根据用户名称模糊查询用户信息列表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8、根据用户名称模糊查询用户信息列表</h3><ul>\r\n<li><p>映射文件</p>\r\n<p>依旧使用 User.xml 文件，只不过要在原来的文件中加入</p>\r\n<pre><code>&lt;!-- 自定义条件查询用户列表\r\nresultType：指定就是单条记录所映射的java对象类型\r\n  ${}:表示拼接sql串，将接收到的参数内容不加修饰的拼接在sql中\r\n  使用${}拼接sql，会引起sql注入\r\n  ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能够使用value \r\n--&gt;\r\n  &lt;select id=&quot;findUserByUsername&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.zhisheng.mybatis.po.User&quot;&gt;\r\n      select * from user where username like &#39;%${value}%&#39;\r\n  &lt;/select&gt;\r\n</code></pre><p><img src=\"http://ohfk1r827.bkt.clouddn.com/%E5%8A%A0%E8%BD%BDUser%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B62.jpg\" alt=\"\"></p>\r\n</li><li><p>编写程序</p>\r\n<p>依旧直接在刚才那个 <code>MybatisFirst.java</code> 中加入测试代码：</p>\r\n<pre><code>//根据用户名称模糊查询用户信息列表\r\n  <a href=\"https://github.com/Test\" title=\"&#64;Test\" class=\"at-link\">@Test</a>\r\n  public void findUserByUsernameTest() throws IOException\r\n  {\r\n      //Mybatis 配置文件\r\n      String resource = &quot;SqlMapConfig.xml&quot;;\r\n\r\n      //得到配置文件流\r\n      InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n      //创建会话工厂,传入Mybatis的配置文件信息\r\n      SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n    //通过工厂得到SqlSession\r\n    SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n    //通过SqlSession操作数据库\r\n    //第一个参数：映射文件中Statement的id，等于 = namespace + &quot;.&quot; + Statement的id\r\n    //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n\r\n    //selectList 查询结果可能多条\r\n    //list中的user和映射文件中resultType所指定的类型一致\r\n    List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByUsername&quot;, &quot;小明&quot;);\r\n\r\n    System.out.println(list);\r\n\r\n    //释放资源\r\n    sqlSession.close();\r\n}\r\n</code></pre></li></ul>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test.jpg\" alt=\"\"></p>\r\n<p>同样测试一下<code>findUserByUsernameTest</code> ，如果运行结果如下就代表没问题：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test3.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3--\"><a name=\"提示：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>提示：</h3><p>通过这个代码可以发现，其中有一部分代码是冗余的，我们可以将其封装成一个函数。</p>\r\n<pre><code>public void createSqlSessionFactory() throws IOException {\r\n        // 配置文件\r\n        String resource = &quot;SqlMapConfig.xml&quot;;\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory\r\n        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n    }\r\n</code></pre><h2 id=\"h2--\"><a name=\"注意：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>注意：</h2><h3 id=\"h3-1-\"><a name=\"1、#{ } 和 ${ } 的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、#{ } 和 ${ } 的区别</h3><blockquote>\r\n<ul>\r\n<li><code>#{ }</code>表示一个占位符号，通过<code>#{ }</code>可以实现 <code>preparedStatement</code> 向占位符中设置值，自动进行java 类型和 jdbc 类型转换，<code>#{ }</code> 可以有效防止sql注入。<code>#{ }</code> 可以接收简单类型值或 pojo 属性值（通过 OGNL 读取对象中的值，属性.属性.属性..方式获取对象属性值）。 如果 <code>parameterType</code> 传输单个简单类型值，<code>#{ }</code>括号中可以是 value 或其它名称。</li><li><code>${ }</code> 表示拼接 sql 串，通过<code>${ }</code>可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， <code>${ }</code>可以接收简单类型值或 pojo 属性值（（通过 OGNL 读取对象中的值，属性.属性.属性..方式获取对象属性值）），如果 parameterType 传输单个简单类型值，${}括号中只能是 value。</li></ul>\r\n</blockquote>\r\n<h3 id=\"h3-2-parametertype-resulttype-\"><a name=\"2、parameterType 和 resultType 区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、parameterType 和 resultType 区别</h3><blockquote>\r\n<ul>\r\n<li>parameterType：指定输入参数类型，mybatis 通过 ognl 从输入对象中获取参数值拼接在 sql 中。</li><li>resultType：指定输出结果类型，mybatis 将 sql 查询结果的一行记录数据映射为 resultType 指定类型的对象。</li></ul>\r\n</blockquote>\r\n<h3 id=\"h3-3-selectone-selectlist-\"><a name=\"3、selectOne 和 selectList 区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、selectOne 和 selectList 区别</h3><blockquote>\r\n<ul>\r\n<li>selectOne 查询一条记录来进行映射，如果使用selectOne查询多条记录则抛出异常：</li></ul>\r\n<pre><code>org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to bereturned by selectOne(), but found: 3 at\r\n</code></pre><ul>\r\n<li>selectList 可以查询一条或多条记录来进行映射。</li></ul>\r\n</blockquote>\r\n<h3 id=\"h3-9-\"><a name=\"9、添加用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9、添加用户</h3><ul>\r\n<li><p>映射文件</p>\r\n<p>在 User.xml 中加入：</p>\r\n<pre><code>&lt;!-- 添加用户 --&gt;\r\n  &lt;insert id=&quot;insetrUser&quot; parameterType=&quot;cn.zhisheng.mybatis.po.User&quot; &gt; \r\n     &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;\r\n          select LAST_INSERT_ID()\r\n      &lt;/selectKey&gt;\r\n      insert into user(username, birthday, sex, address)\r\n      values(#{username}, #{birthday}, #{sex}, #{address})\r\n  &lt;/insert&gt;\r\n</code></pre><p>注意:</p>\r\n<blockquote>\r\n<ul>\r\n<li>selectKey将主键返回，需要再返回</li><li>添加selectKey实现将主键返回</li><li>keyProperty:返回的主键存储在pojo中的哪个属性</li><li>order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after</li><li>resultType:返回的主键是什么类型</li><li>LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。</li></ul>\r\n</blockquote>\r\n</li></ul>\r\n<p>然后在 <code>MybatisFirst.java</code> 中写一个测试函数，代码如下</p>\r\n<pre><code>@Test\r\n    public void insetrUser() throws IOException, ParseException {\r\n        //Mybatis 配置文件\r\n        String resource = &quot;SqlMapConfig.xml&quot;;\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n        //通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        User user = new User();\r\n        SimpleDateFormat sdf = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);\r\n        user.setUsername(&quot;田志声&quot;);\r\n        user.setSex(&quot;男&quot;);\r\n        user.setBirthday(sdf.parse(&quot;2016-11-29&quot;));\r\n        user.setAddress(&quot;江西南昌&quot;);\r\n        sqlSession.insert(&quot;test.insetrUser&quot;, user);\r\n        sqlSession.commit();\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n</code></pre><p>然后 run 一下，如果出现的结果如下，那么就是成功了。</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/1.jpg\" alt=\"\"></p>\r\n<p>同时数据库也能查询到刚插入的用户信息：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/2.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-10-\"><a name=\"10、自增主键返回 与 非自增主键返回\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10、自增主键返回 与 非自增主键返回</h3><ul>\r\n<li><p>MySQL 自增主键：执行 insert 提交之前自动生成一个自增主键，通过 MySQL 函数获取到刚插入记录的自增主键： LAST_INSERT_ID() ，是在 insert 函数之后调用。</p>\r\n</li><li><p>非自增主键返回：使用 MySQL 的 uuid() 函数生成主键，需要修改表中 id 字段类型为 String ，长度设置为 35 位，执行思路：先通过 uuid() 查询到主键，将主键输入到 sql 语句中；执行 uuid() 语句顺序相对于 insert 语句之前执行。</p>\r\n<p>刚才那个插入用户的地方，其实也可以通过 uuid() 来生成主键，如果是这样的话，那么我们就需要在 <code>User.xml</code> 中加入如下代码：</p>\r\n<pre><code>&lt;!--使用 MySQL 的 uuid()生成主键\r\n  执行过程：\r\n  首先通过uuid()得到主键，将主键设置到user对象的id属性中\r\n  其次执行insert时，从user对象中取出id属性值\r\n--&gt;\r\n&lt;selectKey keyProperty=&quot;id&quot; order=&quot;BEFORE&quot; resultType=&quot;java.lang.String&quot;&gt;\r\n          select uuid()\r\n&lt;/selectKey&gt;\r\ninsert into user(id, username, birthday, sex, address) values(#{id}, #{username}, #{birthday}, #{sex}, #{address})\r\n</code></pre></li><li><p><a href=\"http://lib.csdn.net/base/oracle\" title=\"Oracle知识库\">Oracle</a> 使用序列生成主键</p>\r\n<p>首先自定义一个序列且用于生成主键，selectKey使用如下：</p>\r\n<pre><code>&lt;insert  id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt;\r\n&lt;selectKey resultType=&quot;java.lang.Integer&quot; order=&quot;BEFORE&quot; \r\n  keyProperty=&quot;id&quot;&gt;\r\n  SELECT 自定义序列.NEXTVAL FROM DUAL\r\n&lt;/selectKey&gt;\r\ninsert into user(id,username,birthday,sex,address) \r\n     values(#{id},#{username},#{birthday},#{sex},#{address})\r\n&lt;/insert&gt;\r\n</code></pre><p>?</p>\r\n</li></ul>\r\n<h3 id=\"h3-11-\"><a name=\"11、删除用户\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11、删除用户</h3><p>前面说了这么多了，这里就简单来说明下：</p>\r\n<p>在 User.xml 文件中加入如下代码：</p>\r\n<pre><code>&lt;!--删除用户--&gt;\r\n    &lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&gt;\r\n        delete from user where user.id = #{id}\r\n    &lt;/delete&gt;\r\n</code></pre><p>在 MybatisFirst.java 文件中加入如下代码：</p>\r\n<pre><code>//删除用户\r\n    @Test\r\n    public void deleteUserByIdTest() throws IOException\r\n    {\r\n        //Mybatis 配置文件\r\n        String resource = &quot;SqlMapConfig.xml&quot;;\r\n\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        //通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        //通过SqlSession操作数据库\r\n        //第一个参数：映射文件中Statement的id，等于 = namespace + &quot;.&quot; + Statement的id\r\n        //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n\r\n        sqlSession.delete(&quot;test.deleteUserById&quot;, 26);\r\n\r\n        //提交事务\r\n        sqlSession.commit();\r\n\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n</code></pre><p>测试结果如下：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/3.jpg\" alt=\"\"></p>\r\n<p>之前的数据库 user 表查询结果：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/4.jpg\" alt=\"\"></p>\r\n<p>执行完测试代码后，结果如下：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/5.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-12-\"><a name=\"12、更新用户信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12、更新用户信息</h3><p>在 User.xml 中加入如下代码：</p>\r\n<pre><code>&lt;!--根据id更新用户\r\n        需要输入用户的id\r\n        传入用户要更新的信息\r\n        parameterType指定user对象，包括id和更新信息，id必须存在\r\n        #{id}：从输入对象中获取id属性值\r\n--&gt;\r\n&lt;update id=&quot;updateUserById&quot; parameterType=&quot;cn.zhisheng.mybatis.po.User&quot;&gt;\r\n        update user set username = #{username}, birthday = #{birthday}, sex = #{sex}, address = #{address} where user.id = #{id}\r\n    &lt;/update&gt;\r\n</code></pre><p>然后在 MybatisFirst.java 中加入</p>\r\n<pre><code>//根据id更新用户信息\r\n    @Test\r\n    public void updateUserByIdTest() throws IOException, ParseException {\r\n        //Mybatis 配置文件\r\n        String resource = &quot;SqlMapConfig.xml&quot;;\r\n\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        //通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        //为了设置生日的日期输入\r\n        SimpleDateFormat sdf = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);\r\n\r\n        User user = new User();\r\n        //根据id更新用户信息\r\n        user.setId(24);\r\n        user.setUsername(&quot;张四风&quot;);\r\n        user.setBirthday(sdf.parse(&quot;2015-01-12&quot;));\r\n        user.setSex(&quot;女&quot;);\r\n        user.setAddress(&quot;上海黄埔&quot;);\r\n\r\n        //通过SqlSession操作数据库\r\n        //第一个参数：映射文件中Statement的id，等于 = namespace + &quot;.&quot; + Statement的id\r\n        //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n        sqlSession.update(&quot;test.updateUserById&quot;, user);\r\n\r\n        //提交事务\r\n        sqlSession.commit();\r\n\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n</code></pre><p>测试结果如下：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/6.jpg\" alt=\"\"></p>\r\n<p>查看数据库，id 为 24 的用户信息是否更新了：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/7.jpg\" alt=\"\"></p>\r\n<p>啊，是不是很爽，所有的需求都完成了。</p>\r\n<p>没错，这只是 Mybatis 的一个简单的入门程序，简单的实现了对数据库的增删改查功能，通过这个我们大概可以了解这个编程方式了。</p>\r\n', '101', '# Mybatis\r\n\r\n# 基础知识：\r\n\r\n## 对原生态 jdbc 程序（单独使用 jdbc 开发）问题总结\r\n\r\n### 1、环境\r\n\r\n [Java](http://lib.csdn.net/base/javase \"Java SE知识库\") 环境 ：jdk1.8.0_77\r\n\r\n 开发工具 ： IDEA 2016.1\r\n\r\n [数据库](http://lib.csdn.net/base/mysql \"MySQL知识库\") ： [MySQL](http://lib.csdn.net/base/mysql \"MySQL知识库\") 5.7\r\n\r\n### 2、创建数据库\r\n\r\n mybatis_test.sql\r\n\r\n Tables ：items、orderdetail、orders、user\r\n\r\n### 3、JDBC 程序\r\n\r\n 使用 JDBC 查询 MySQL 数据库中用户表的记录\r\n\r\n 代码：\r\n\r\n```\r\npackage cn.zhisheng.mybatis.jdbc;\r\n\r\n/**\r\n * Created by 10412 on 2016/11/27.\r\n */\r\n\r\nimport java.sql.*;\r\n\r\n/**\r\n *通过单独的jdbc程序来总结问题\r\n */\r\n\r\npublic class JdbcTest\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        //数据库连接\r\n        Connection connection = null;\r\n        //预编译的Statement，使用预编译的Statement可以提高数据库性能\r\n        PreparedStatement preparedStatement = null;\r\n        //结果集\r\n        ResultSet resultSet = null;\r\n\r\n        try\r\n        {\r\n            //加载数据库驱动\r\n            Class.forName(\"com.mysql.jdbc.Driver\");\r\n\r\n            //通过驱动管理类获取数据库链接\r\n            connection =  DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mybatis_test?characterEncoding=utf-8\", \"root\", \"root\");\r\n            //定义sql语句 ?表示占位符（在这里表示username）\r\n            String sql = \"select * from user where username = ?\";\r\n            //获取预处理statement\r\n            preparedStatement = connection.prepareStatement(sql);\r\n            //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值\r\n            preparedStatement.setString(1, \"王五\");\r\n            //向数据库发出sql执行查询，查询出结果集\r\n            resultSet =  preparedStatement.executeQuery();\r\n            //遍历查询结果集\r\n            while(resultSet.next())\r\n            {\r\n                System.out.println(resultSet.getString(\"id\")+\"  \"+resultSet.getString(\"username\"));\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }finally{\r\n            //释放资源\r\n            if(resultSet!=null)\r\n            {\r\n                try {\r\n                    resultSet.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(preparedStatement!=null)\r\n            {\r\n                try {\r\n                    preparedStatement.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            if(connection!=null)\r\n            {\r\n                try {\r\n                    connection.close();\r\n                } catch (SQLException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n### 4、问题总结\r\n\r\n> *   数据库连接，使用时就创建，不使用立即释放，对数据库频繁连接开启和关闭，造成数据库资源的浪费，影响数据库性能。\r\n>     \r\n>     \r\n>     \r\n>     解决方法：使用数据库连接池管理数据库连接。\r\n>     \r\n>     \r\n> *   将 sql 语句**硬编码**到 java 代码中，如果 sql 语句需要修改，那么就需要重新编译 java 代码，不利于系统的维护。\r\n>     \r\n>     \r\n>     \r\n>     设想：将 sql 语句配置在 xml 配置文件中，即使 sql 语句发生变化，也不需要重新编译 java 代码。\r\n>     \r\n>     \r\n> *   向 preparedStatement 中设置参数，对占位符号位置和设置参数值，硬编码在 java 代码中，同样也不利于系统的维护。\r\n>     \r\n>     \r\n>     \r\n>     设想：将 sql 语句、占位符、参数值配置在 xml 配置文件中。\r\n>     \r\n>     \r\n> *   从 resultSet 中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。\r\n>     \r\n>     \r\n>     \r\n>     设想：将查询的结果集自动映射成 java 对象。\r\n\r\n## Mybatis框架原理（掌握）\r\n\r\n### 1、Mybatis 是什么？\r\n\r\n Mybatis 是一个持久层的[架构](http://lib.csdn.net/base/architecture \"大型网站架构知识库\")，是 apache 下的顶级项目。\r\n\r\n Mybatis 原先是托管在 googlecode 下，再后来是托管在 Github 上。\r\n\r\n Mybatis 让程序员将主要的精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活生成（半自动，大部分需要程序员编写 sql ）满足需要 sql 语句。\r\n\r\n Mybatis 可以将向 preparedStatement 中的输入参数自动进行**输入映射**，将查询结果集灵活的映射成 java 对象。（**输出映射**）\r\n\r\n### 2、Mybatis 框架\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Mybatis%E6%A1%86%E6%9E%B6.jpg)\r\n\r\n注解：\r\n\r\n> *   SqlMapConfig.xml （Mybatis的全局配置文件，名称不定）配置了数据源、事务等 Mybatis 运行环境\r\n>     \r\n>     \r\n> *   Mapper.xml 映射文件（配置 sql 语句）\r\n>     \r\n>     \r\n> *   SqlSessionFactory （会话工厂）根据配置文件配置工厂、创建 SqlSession\r\n>     \r\n>     \r\n> *   SqlSession （会话）面向用户的接口、操作数据库（发出 sql 增删改查）\r\n>     \r\n>     \r\n> *   Executor （执行器）是一个接口（基本执行器、缓存执行器）、SqlSession 内部通过执行器操作数据库\r\n>     \r\n>     \r\n> *   Mapped Statement （底层封装对象）对操作数据库存储封装，包括 sql 语句、输入参数、输出结果类型\r\n>     ?\r\n\r\n## Mybatis入门程序\r\n\r\n### 1、需求\r\n\r\n实现以下功能：\r\n\r\n> *   根据用户id查询一个用户信息\r\n> *   根据用户名称模糊查询用户信息列表\r\n> *   添加用户\r\n> *   更新用户\r\n> *   删除用户\r\n\r\n### 2、环境\r\n\r\njava 环境 ：jdk1.8.0_77\r\n\r\n开发工具 ： IDEA 2016.1\r\n\r\n数据库 ： MySQL 5.7\r\n\r\nMybatis 运行环境（ jar 包）\r\n\r\nMySQL 驱动包\r\n\r\n其他依赖包\r\n\r\n### 3、 log4j.properties\r\n\r\n在classpath下创建log4j.properties如下：\r\n\r\n```\r\n# Global logging configuration\r\n#在开发环境日志级别要设置为DEBUG、生产环境要设置为INFO或者ERROR\r\nlog4j.rootLogger=DEBUG, stdout\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n\r\n```\r\n\r\nMybatis默认使用log4j作为输出日志信息。\r\n\r\n### 4、工程结构\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6.jpg)\r\n\r\n### 5、SqlMapConfig.xml\r\n\r\n配置 Mybatis 的运行环境、数据源、事务等\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <!-- 和spring整合后 environments配置将废除-->\r\n    <environments default=\"development\">\r\n        <environment id=\"development\">\r\n            <!-- 使用jdbc事务管理,事务由 Mybatis 控制-->\r\n            <transactionManager type=\"JDBC\" />\r\n            <!-- 数据库连接池,由Mybatis管理，数据库名是mybatis_test，Mysql用户名root，密码root -->\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\" />\r\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis_test?characterEncoding=utf-8\" />\r\n                <property name=\"username\" value=\"root\" />\r\n                <property name=\"password\" value=\"root\" />\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n</configuration>\r\n```\r\n\r\n### 6、创建 po 类\r\n\r\nPo 类作为 mybatis 进行 sql 映射使用，po 类通常与数据库表对应，User.java 如下：\r\n\r\n```\r\npackage cn.zhisheng.mybatis.po;\r\n\r\nimport java.util.Date;\r\n\r\n/**\r\n * Created by 10412 on 2016/11/28.\r\n */\r\npublic class User\r\n{\r\n    private int id;\r\n    private String username;            // 用户姓名\r\n    private String sex;                 // 性别\r\n    private Date birthday;              // 生日\r\n    private String address;             // 地址\r\n\r\n    //getter and setter\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public String getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(String sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n}\r\n```\r\n\r\n### 7、根据用户 id（主键）查询用户信息\r\n\r\n*   映射文件\r\n\r\n    > *   User.xml（原在 Ibatis 中命名）在 Mybatis 中命名规则为 xxxmapper.xml\r\n    > *   在映射文件中配置 sql 语句\r\n\r\n    `User.xml`\r\n\r\n    ```\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n    <!DOCTYPE mapper\r\n    PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n    \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n    <mapper namespace=\"test\">\r\n    </mapper>\r\n    ```\r\n\r\n    `namespace` ：命名空间，对 sql 进行分类化管理，用于隔离 sql 语句，后面会讲另一层非常重要的作用。\r\n\r\n    ?\r\n\r\n    在 `User.xml` 中加入\r\n\r\n    ```\r\n    <!--通过select执行数据库查询\r\n           id:标识映射文件中的sql\r\n           将sql语句封装到mappedStatement对象中，所以id称为Statement的id\r\n           #{}：表示占位符\r\n           #{id}：其中的id表示接收输入的参数，参数名称就是id，如果输入参数是简单类型，那么#{}中的参数名可以任意，可以是value或者其他名称\r\n           parameterType：表示指定输入参数的类型\r\n           resultType：表示指定sql输出结果的所映射的java对象类型\r\n    -->\r\n    <!-- 根据id获取用户信息 -->\r\n       <select id=\"findUserById\" parameterType=\"int\" resultType=\"cn.zhisheng.mybatis.po.User\">\r\n           select * from user where id = #{id}\r\n       </select>\r\n    ```\r\n\r\n    `User.xml` 映射文件已经完全写好了，那接下来就需要在 `SqlMapConfig.xml`中加载映射文件 `User.xml`\r\n\r\n    ```\r\n    <!--加载映射文件-->\r\n       <mappers>\r\n           <mapper resource=\"sqlmap/User.xml\"/>\r\n       </mappers>\r\n    ```\r\n\r\n    ![](http://ohfk1r827.bkt.clouddn.com/%E5%8A%A0%E8%BD%BDUser%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6.jpg)\r\n\r\n    ?\r\n\r\n*   编写程序\r\n\r\n    `MybatisFirst.java`\r\n\r\n    ?\r\n\r\n```\r\n   package cn.zhisheng.mybatis.first;\r\n\r\n   import cn.zhisheng.mybatis.po.User;\r\n   import org.apache.ibatis.io.Resources;\r\n   import org.apache.ibatis.session.SqlSession;\r\n   import org.apache.ibatis.session.SqlSessionFactory;\r\n   import org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n   import org.junit.Test;\r\n\r\n   import java.io.IOException;\r\n   import java.io.InputStream;\r\n\r\n       /**\r\n   * Created by 10412 on 2016/11/28.\r\n   */\r\n   public class MybatisFirst\r\n   {\r\n      //根据id查询用户信息，得到用户的一条记录\r\n      @Test\r\n      public void findUserByIdTest() throws IOException\r\n      {\r\n          //Mybatis 配置文件\r\n          String resource = \"SqlMapConfig.xml\";\r\n\r\n          //得到配置文件流\r\n          InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n          //创建会话工厂,传入Mybatis的配置文件信息\r\n          SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        //通过工厂得到SqlSession\r\n         SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n         //通过SqlSession操作数据库\r\n         //第一个参数：映射文件中Statement的id，等于 = namespace + \".\" + Statement的id\r\n         //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n         //sqlSession.selectOne 结果与映射文件中所匹配的resultType类型的对象\r\n         User user = sqlSession.selectOne(\"test.findUserById\", 1);\r\n\r\n         System.out.println(user);\r\n\r\n         //释放资源\r\n         sqlSession.close();\r\n     }\r\n   }\r\n```\r\n\r\n然后运行一下这个[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")，发现结果如下就代表可以了：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test1.jpg)\r\n\r\n### 8、根据用户名称模糊查询用户信息列表\r\n\r\n*   映射文件\r\n\r\n    依旧使用 User.xml 文件，只不过要在原来的文件中加入\r\n\r\n    ```\r\n    <!-- 自定义条件查询用户列表\r\n    resultType：指定就是单条记录所映射的java对象类型\r\n      ${}:表示拼接sql串，将接收到的参数内容不加修饰的拼接在sql中\r\n      使用${}拼接sql，会引起sql注入\r\n      ${value}：接收输入参数的内容，如果传入类型是简单类型，${}中只能够使用value \r\n    -->\r\n      <select id=\"findUserByUsername\" parameterType=\"java.lang.String\" resultType=\"cn.zhisheng.mybatis.po.User\">\r\n          select * from user where username like \'%${value}%\'\r\n      </select>\r\n    ```\r\n\r\n    ![](http://ohfk1r827.bkt.clouddn.com/%E5%8A%A0%E8%BD%BDUser%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B62.jpg)\r\n\r\n*   编写程序\r\n\r\n    依旧直接在刚才那个 `MybatisFirst.java` 中加入测试代码：\r\n\r\n    ```\r\n    //根据用户名称模糊查询用户信息列表\r\n      @Test\r\n      public void findUserByUsernameTest() throws IOException\r\n      {\r\n          //Mybatis 配置文件\r\n          String resource = \"SqlMapConfig.xml\";\r\n\r\n          //得到配置文件流\r\n          InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n          //创建会话工厂,传入Mybatis的配置文件信息\r\n          SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n        //通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        //通过SqlSession操作数据库\r\n        //第一个参数：映射文件中Statement的id，等于 = namespace + \".\" + Statement的id\r\n        //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n\r\n        //selectList 查询结果可能多条\r\n        //list中的user和映射文件中resultType所指定的类型一致\r\n        List<User> list = sqlSession.selectList(\"test.findUserByUsername\", \"小明\");\r\n\r\n        System.out.println(list);\r\n\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n    ```\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test.jpg)\r\n\r\n同样测试一下`findUserByUsernameTest` ，如果运行结果如下就代表没问题：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test3.jpg)\r\n\r\n### 提示：\r\n\r\n通过这个代码可以发现，其中有一部分代码是冗余的，我们可以将其封装成一个函数。\r\n\r\n```\r\npublic void createSqlSessionFactory() throws IOException {\r\n        // 配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        // 使用SqlSessionFactoryBuilder从xml配置文件中创建SqlSessionFactory\r\n        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n    }\r\n```\r\n\r\n## 注意：\r\n\r\n### 1、#{ } 和 ${ } 的区别\r\n\r\n> *   `#{ }`表示一个占位符号，通过`#{ }`可以实现 `preparedStatement` 向占位符中设置值，自动进行java 类型和 jdbc 类型转换，`#{ }` 可以有效防止sql注入。`#{ }` 可以接收简单类型值或 pojo 属性值（通过 OGNL 读取对象中的值，属性.属性.属性..方式获取对象属性值）。 如果 `parameterType` 传输单个简单类型值，`#{ }`括号中可以是 value 或其它名称。\r\n> *   `${ }` 表示拼接 sql 串，通过`${ }`可以将 parameterType 传入的内容拼接在 sql 中且不进行 jdbc 类型转换， `${ }`可以接收简单类型值或 pojo 属性值（（通过 OGNL 读取对象中的值，属性.属性.属性..方式获取对象属性值）），如果 parameterType 传输单个简单类型值，${}括号中只能是 value。\r\n\r\n### 2、parameterType 和 resultType 区别\r\n\r\n> *   parameterType：指定输入参数类型，mybatis 通过 ognl 从输入对象中获取参数值拼接在 sql 中。\r\n> *   resultType：指定输出结果类型，mybatis 将 sql 查询结果的一行记录数据映射为 resultType 指定类型的对象。\r\n\r\n### 3、selectOne 和 selectList 区别\r\n\r\n> *   selectOne 查询一条记录来进行映射，如果使用selectOne查询多条记录则抛出异常：\r\n>     \r\n>     \r\n>     \r\n>     org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to bereturned by selectOne(), but found: 3 at\r\n>     \r\n>     \r\n> *   selectList 可以查询一条或多条记录来进行映射。\r\n\r\n### 9、添加用户\r\n\r\n*   映射文件\r\n\r\n    在 User.xml 中加入：\r\n\r\n    ```\r\n    <!-- 添加用户 -->\r\n      <insert id=\"insetrUser\" parameterType=\"cn.zhisheng.mybatis.po.User\" > \r\n         <selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\">\r\n              select LAST_INSERT_ID()\r\n          </selectKey>\r\n          insert into user(username, birthday, sex, address)\r\n          values(#{username}, #{birthday}, #{sex}, #{address})\r\n      </insert>\r\n    ```\r\n\r\n    注意:\r\n\r\n    > *   selectKey将主键返回，需要再返回\r\n    > *   添加selectKey实现将主键返回\r\n    > *   keyProperty:返回的主键存储在pojo中的哪个属性\r\n    > *   order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after\r\n    > *   resultType:返回的主键是什么类型\r\n    > *   LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。\r\n\r\n然后在 `MybatisFirst.java` 中写一个测试函数，代码如下\r\n\r\n```\r\n@Test\r\n    public void insetrUser() throws IOException, ParseException {\r\n        //Mybatis 配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n        //通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        User user = new User();\r\n        SimpleDateFormat sdf = new SimpleDateFormat (\"yyyy-MM-dd\");\r\n        user.setUsername(\"田志声\");\r\n        user.setSex(\"男\");\r\n        user.setBirthday(sdf.parse(\"2016-11-29\"));\r\n        user.setAddress(\"江西南昌\");\r\n        sqlSession.insert(\"test.insetrUser\", user);\r\n        sqlSession.commit();\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n然后 run 一下，如果出现的结果如下，那么就是成功了。\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/1.jpg)\r\n\r\n同时数据库也能查询到刚插入的用户信息：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/2.jpg)\r\n\r\n### 10、自增主键返回 与 非自增主键返回\r\n\r\n*   MySQL 自增主键：执行 insert 提交之前自动生成一个自增主键，通过 MySQL 函数获取到刚插入记录的自增主键： LAST_INSERT_ID() ，是在 insert 函数之后调用。\r\n\r\n*   非自增主键返回：使用 MySQL 的 uuid() 函数生成主键，需要修改表中 id 字段类型为 String ，长度设置为 35 位，执行思路：先通过 uuid() 查询到主键，将主键输入到 sql 语句中；执行 uuid() 语句顺序相对于 insert 语句之前执行。\r\n\r\n    刚才那个插入用户的地方，其实也可以通过 uuid() 来生成主键，如果是这样的话，那么我们就需要在 `User.xml` 中加入如下代码：\r\n\r\n    ```\r\n    <!--使用 MySQL 的 uuid()生成主键\r\n      执行过程：\r\n      首先通过uuid()得到主键，将主键设置到user对象的id属性中\r\n      其次执行insert时，从user对象中取出id属性值\r\n    -->\r\n    <selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\">\r\n              select uuid()\r\n    </selectKey>\r\n    insert into user(id, username, birthday, sex, address) values(#{id}, #{username}, #{birthday}, #{sex}, #{address})\r\n    ```\r\n\r\n*   [Oracle](http://lib.csdn.net/base/oracle \"Oracle知识库\") 使用序列生成主键\r\n\r\n    首先自定义一个序列且用于生成主键，selectKey使用如下：\r\n\r\n    ```\r\n    <insert  id=\"insertUser\" parameterType=\"cn.itcast.mybatis.po.User\">\r\n    <selectKey resultType=\"java.lang.Integer\" order=\"BEFORE\" \r\n      keyProperty=\"id\">\r\n      SELECT 自定义序列.NEXTVAL FROM DUAL\r\n    </selectKey>\r\n    insert into user(id,username,birthday,sex,address) \r\n         values(#{id},#{username},#{birthday},#{sex},#{address})\r\n    </insert>\r\n\r\n    ```\r\n\r\n    ?\r\n\r\n### 11、删除用户\r\n\r\n前面说了这么多了，这里就简单来说明下：\r\n\r\n在 User.xml 文件中加入如下代码：\r\n\r\n```\r\n<!--删除用户-->\r\n    <delete id=\"deleteUserById\" parameterType=\"int\">\r\n        delete from user where user.id = #{id}\r\n    </delete>\r\n```\r\n\r\n在 MybatisFirst.java 文件中加入如下代码：\r\n\r\n```\r\n//删除用户\r\n    @Test\r\n    public void deleteUserByIdTest() throws IOException\r\n    {\r\n        //Mybatis 配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        //通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        //通过SqlSession操作数据库\r\n        //第一个参数：映射文件中Statement的id，等于 = namespace + \".\" + Statement的id\r\n        //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n\r\n        sqlSession.delete(\"test.deleteUserById\", 26);\r\n\r\n        //提交事务\r\n        sqlSession.commit();\r\n\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n测试结果如下：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/3.jpg)\r\n\r\n之前的数据库 user 表查询结果：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/4.jpg)\r\n\r\n执行完测试代码后，结果如下：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/5.jpg)\r\n\r\n### 12、更新用户信息\r\n\r\n在 User.xml 中加入如下代码：\r\n\r\n```\r\n<!--根据id更新用户\r\n        需要输入用户的id\r\n        传入用户要更新的信息\r\n        parameterType指定user对象，包括id和更新信息，id必须存在\r\n        #{id}：从输入对象中获取id属性值\r\n-->\r\n<update id=\"updateUserById\" parameterType=\"cn.zhisheng.mybatis.po.User\">\r\n        update user set username = #{username}, birthday = #{birthday}, sex = #{sex}, address = #{address} where user.id = #{id}\r\n    </update>\r\n```\r\n\r\n然后在 MybatisFirst.java 中加入\r\n\r\n```\r\n//根据id更新用户信息\r\n    @Test\r\n    public void updateUserByIdTest() throws IOException, ParseException {\r\n        //Mybatis 配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        SqlSessionFactory  sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        //通过工厂得到SqlSession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n\r\n        //为了设置生日的日期输入\r\n        SimpleDateFormat sdf = new SimpleDateFormat (\"yyyy-MM-dd\");\r\n\r\n        User user = new User();\r\n        //根据id更新用户信息\r\n        user.setId(24);\r\n        user.setUsername(\"张四风\");\r\n        user.setBirthday(sdf.parse(\"2015-01-12\"));\r\n        user.setSex(\"女\");\r\n        user.setAddress(\"上海黄埔\");\r\n\r\n        //通过SqlSession操作数据库\r\n        //第一个参数：映射文件中Statement的id，等于 = namespace + \".\" + Statement的id\r\n        //第二个参数：指定和映射文件中所匹配的parameterType类型的参数\r\n        sqlSession.update(\"test.updateUserById\", user);\r\n\r\n        //提交事务\r\n        sqlSession.commit();\r\n\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n测试结果如下：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/6.jpg)\r\n\r\n查看数据库，id 为 24 的用户信息是否更新了：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/7.jpg)\r\n\r\n啊，是不是很爽，所有的需求都完成了。\r\n\r\n没错，这只是 Mybatis 的一个简单的入门程序，简单的实现了对数据库的增删改查功能，通过这个我们大概可以了解这个编程方式了。\r\n');
INSERT INTO `article_info_true` VALUES ('76', 'mybatis开发dao层', '<h3 id=\"h3-mybatis-jdbc-\"><a name=\"Mybatis 解决 jdbc 编程的问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis 解决 jdbc 编程的问题</h3><p>1、 <a href=\"http://lib.csdn.net/base/mysql\" title=\"MySQL知识库\">数据库</a>链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>\r\n<p>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</p>\r\n<p>2、 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>代码。</p>\r\n<p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p>\r\n<p>3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>\r\n<p>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。</p>\r\n<p>4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>\r\n<p>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。</p>\r\n<h3 id=\"h3-mybatis-hibernate-\"><a name=\"Mybatis 与 Hibernate 不同\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis 与 Hibernate 不同</h3><p>Mybatis和<a href=\"http://lib.csdn.net/base/javaee\" title=\"Java EE知识库\">hibernate</a>不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</p>\r\n<p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</p>\r\n<p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</p>\r\n<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件<a href=\"http://lib.csdn.net/base/architecture\" title=\"大型网站架构知识库\">架构</a>都是好架构，所以框架只有适合才是最好。</p>\r\n<h2 id=\"h2-mybatis-dao\"><a name=\"Mybatis 开发 dao\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis 开发 dao</h2><h3 id=\"h3-u4E24u79CDu65B9u6CD5\"><a name=\"两种方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>两种方法</h3><ul>\r\n<li>原始 dao 开发方法（程序需要编写 dao 接口和 dao 实现类）（掌握）</li><li>Mybatis 的 mapper 接口（相当于 dao 接口）代理开发方法（掌握）</li></ul>\r\n<h3 id=\"h3-u9700u6C42\"><a name=\"需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>需求</h3><p>将下边的功能实现Dao：</p>\r\n<ul>\r\n<li>根据用户id查询一个用户信息</li><li>根据用户名称模糊查询用户信息列表</li><li>添加用户信息</li></ul>\r\n<p>Mybatis 配置文件 SqlMapConfig.xml</p>\r\n<h3 id=\"h3-sqlsession-\"><a name=\"Sqlsession 的使用范围\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Sqlsession 的使用范围</h3><p>SqlSession 中封装了对数据库的操作，如：查询、插入、更新、删除等。</p>\r\n<p>通过 SqlSessionFactory 创建 SqlSession，而 SqlSessionFactory 是通过 SqlSessionFactoryBuilder 进行创建。</p>\r\n<h3 id=\"h3-1-sqlsessionfactorybuilder\"><a name=\"1、SqlSessionFactoryBuilder\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、SqlSessionFactoryBuilder</h3><p>SqlSessionFactoryBuilder 用于创建 SqlSessionFacoty，SqlSessionFacoty 一旦创建完成就不需要SqlSessionFactoryBuilder 了，因为 SqlSession 是通过 SqlSessionFactory 生产，所以可以将SqlSessionFactoryBuilder 当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。</p>\r\n<h3 id=\"h3-2-sqlsessionfactory\"><a name=\"2、SqlSessionFactory\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、SqlSessionFactory</h3><p>SqlSessionFactory 是一个接口，接口中定义了 openSession 的不同重载方法，SqlSessionFactory 的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理 SqlSessionFactory。</p>\r\n<h3 id=\"h3-3-sqlsession\"><a name=\"3、SqlSession\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、SqlSession</h3><p>SqlSession 是一个面向用户的接口， sqlSession 中定义了数据库操作，默认使用 DefaultSqlSession 实现类。</p>\r\n<p>执行过程如下：</p>\r\n<p>1）、 加载数据源等配置信息</p>\r\n<p>Environment environment = configuration.getEnvironment();</p>\r\n<p>2）、 创建数据库链接</p>\r\n<p>3）、 创建事务对象</p>\r\n<p>4）、 创建Executor，SqlSession 所有操作都是通过 Executor 完成，mybatis 源码如下：</p>\r\n<pre><code>if (ExecutorType.BATCH == executorType) {\r\n      executor = newBatchExecutor(this, transaction);\r\n    } elseif (ExecutorType.REUSE == executorType) {\r\n      executor = new ReuseExecutor(this, transaction);\r\n    } else {\r\n      executor = new SimpleExecutor(this, transaction);\r\n    }\r\nif (cacheEnabled) {\r\n      executor = new CachingExecutor(executor, autoCommit);\r\n    }\r\n</code></pre><p>5）、 SqlSession的实现类即 DefaultSqlSession，此对象中对操作数据库实质上用的是 Executor</p>\r\n<h3 id=\"h3--\"><a name=\"结论：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>结论：</h3><pre><code>     每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围(定义局部变量使用)。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。\r\n\r\n     打开一个SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下：\r\n</code></pre><pre><code>SqlSession session = sqlSessionFactory.openSession();\r\n    try {\r\n         // do work\r\n    } finally {\r\n        session.close();\r\n}\r\n</code></pre><h2 id=\"h2--dao-\"><a name=\"原始 Dao 开发方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>原始 Dao 开发方法</h2><h3 id=\"h3--\"><a name=\"思路：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>思路：</h3><p>需要程序员编写 Dao 接口和 Dao 实现类；</p>\r\n<p>需要在 Dao 实现类中注入 SqlsessionFactory ，在方法体内通过 SqlsessionFactory 创建 Sqlsession。</p>\r\n<h3 id=\"h3-dao-\"><a name=\"Dao接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dao接口</h3><pre><code>public interface UserDao    //dao接口，用户管理\r\n{\r\n    //根据id查询用户信息\r\n    public User findUserById(int id) throws Exception;\r\n\r\n    //添加用户信息\r\n    public void addUser(User user) throws Exception;\r\n\r\n    //删除用户信息\r\n    public void deleteUser(int id) throws Exception;\r\n}\r\n</code></pre><h3 id=\"h3-dao-\"><a name=\"Dao 实现类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dao 实现类</h3><pre><code>public class UserDaoImpl  implements UserDao  //dao接口实现类\r\n{\r\n    //需要在 Dao 实现类中注入 SqlsessionFactory\r\n    //这里通过构造方法注入\r\n    private SqlSessionFactory sqlSessionFactory;\r\n    public UserDaoImpl(SqlSessionFactory sqlSessionFactory)\r\n    {\r\n        this.sqlSessionFactory = sqlSessionFactory;\r\n    }\r\n    @Override\r\n    public User findUserById(int id) throws Exception\r\n    {\r\n        //在方法体内通过 SqlsessionFactory 创建 Sqlsession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id);\r\n        sqlSession.close();\r\n        return user;\r\n    }\r\n    @Override\r\n    public void insertUser(User user) throws Exception\r\n    {\r\n        //在方法体内通过 SqlsessionFactory 创建 Sqlsession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //执行插入的操作\r\n        sqlSession.insert(&quot;test.insetrUser&quot;, user);\r\n        //提交事务\r\n        sqlSession.commit();\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n    @Override\r\n    public void deleteUser(int id) throws Exception\r\n    {\r\n        //在方法体内通过 SqlsessionFactory 创建 Sqlsession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        sqlSession.delete(&quot;test.deleteUserById&quot;, id);\r\n        //提交事务\r\n        sqlSession.commit();\r\n        sqlSession.close();\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-u6D4Bu8BD5\"><a name=\"测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试</h3><pre><code>public class UserDaoImplTest\r\n{\r\n    private SqlSessionFactory sqlSessionFactory;\r\n    //此方法是在 testFindUserById 方法之前执行的\r\n    @Before\r\n    public void setup() throws Exception\r\n    {\r\n        //创建sqlSessionFactory\r\n        //Mybatis 配置文件\r\n        String resource = &quot;SqlMapConfig.xml&quot;;\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n    }\r\n    @Test\r\n    public void testFindUserById() throws Exception\r\n    {\r\n        //创建UserDao的对象\r\n        UserDao userDao = new UserDaoImpl(sqlSessionFactory);\r\n        //调用UserDao方法\r\n        User user = userDao.findUserById(1);\r\n        System.out.println(user);\r\n    }\r\n}\r\n</code></pre><p>通过id查询用户信息<a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\">测试</a>结果如下：（其他的可以自己在写测试代码，原理类似）</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/dao%E5%BC%80%E5%8F%91.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-u95EEu9898\"><a name=\"问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>问题</h3><p>原始Dao开发中存在以下问题：</p>\r\n<ul>\r\n<li>Dao方法体存在重复代码：通过 SqlSessionFactory 创建 SqlSession，调用 SqlSession 的数据库操作方法</li><li>调用 sqlSession 的数据库操作方法需要指定 statement 的i d，这里存在硬编码，不得于开发维护。</li><li>调用 sqlSession 的数据库操作方法时传入的变量，由于 sqlsession 方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。</li></ul>\r\n<h2 id=\"h2-mybatis-mapper-\"><a name=\"Mybatis 的 mapper 接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mybatis 的 mapper 接口</h2><h3 id=\"h3-u601Du8DEF\"><a name=\"思路\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>思路</h3><p>程序员需要编写 mapper.xml 映射文件</p>\r\n<p>只需要程序员编写Mapper接口（相当于Dao接口），需遵循一些开发规范，mybatis 可以自动生成 mapper 接口类代理对象。</p>\r\n<p>开发规范：</p>\r\n<ul>\r\n<li><p>在 mapper.xml 中 namespace 等于 mapper 接口地址</p>\r\n<pre><code>&lt;mapper namespace=&quot;cn.zhisheng.mybatis.mapper.UserMapper&quot;&gt;&lt;/mapper&gt;\r\n</code></pre></li><li><p>在 xxxmapper.java 接口中的方法名要与 xxxMapper.xml 中 statement 的 id 一致。</p>\r\n</li><li><p>在 xxxmapper.java 接口中的输入参数类型要与 xxxMapper.xml 中 statement 的 parameterType 指定的参数类型一致。</p>\r\n</li><li><p>在 xxxmapper.java 接口中的返回值类型要与 xxxMapper.xml 中 statement 的 resultType 指定的类型一致。</p>\r\n<p><code>UserMapper.java</code></p>\r\n<pre><code>//根据id查询用户信息\r\n  public User findUserById(int id) throws Exception;\r\n</code></pre><p><code>UserMapper.xml</code></p>\r\n<pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.zhisheng.mybatis.po.User&quot;&gt;\r\n      select * from user where id = #{1}\r\n&lt;/select&gt;\r\n</code></pre></li></ul>\r\n<h3 id=\"h3--a-name-t20-a-\"><a name=\"<a name=\"t20\"></a>总结：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a name=\"t20\"></a>总结：</h3><p>以上的开发规范主要是对下边的代码进行统一的生成：</p>\r\n<pre><code>User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id);\r\nsqlSession.insert(&quot;test.insetrUser&quot;, user);\r\nsqlSession.delete(&quot;test.deleteUserById&quot;, id);\r\nList&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, username);\r\n</code></pre><h3 id=\"h3-u6D4Bu8BD5\"><a name=\"测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>测试</h3><p>测试之前记得在 SqlMapConfig.xml 文件中添加加载映射文件 UserMapper.xml：</p>\r\n<pre><code>&lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;\r\n</code></pre><p>测试代码：</p>\r\n<pre><code>public class UserMapperTest\r\n{\r\n    private SqlSessionFactory sqlSessionFactory;\r\n    //此方法是在 testFindUserById 方法之前执行的\r\n    @Before\r\n    public void setup() throws Exception\r\n    {\r\n        //创建sqlSessionFactory\r\n        //Mybatis 配置文件\r\n        String resource = &quot;SqlMapConfig.xml&quot;;\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n    }\r\n    @Test\r\n    public void testFindUserById() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建usermapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //调用UserMapper的方法\r\n        User user = userMapper.findUserById(1);\r\n        System.out.println(user);\r\n    }\r\n}\r\n</code></pre><p>通过id查询用户信息测试结果如下：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/mapper%E5%BC%80%E5%8F%91.jpg\" alt=\"\"></p>\r\n<p>通过姓名查询用户信息：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/mapper%E5%BC%80%E5%8F%912.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3--selectone-selectlist\"><a name=\"代理对象内部调用 selectOne 或者 selectList\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代理对象内部调用 selectOne 或者 selectList</h3><ul>\r\n<li>如果 mapper 方法返回单个 pojo 对象（非集合对象），代理对象内部通过 selectOne 查询数据库</li><li>如果 mapper 方法返回集合对象，代理对象内部通过 selectList 查询数据库</li></ul>\r\n<h3 id=\"h3-mapper-\"><a name=\"mapper接口方法参数只能有一个是否影响系统开发\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>mapper接口方法参数只能有一个是否影响系统开发</h3><blockquote>\r\n<p>mapper 接口方法参数只能有一个，系统是否不利于维护？</p>\r\n<p>系统框架中，dao层的代码是被业务层公用的。</p>\r\n<p>即使 mapper 接口只有一个参数，可以使用包装类型的 pojo 满足不同的业务方法的需求。</p>\r\n<p>注意：持久层方法的参数可以包装类型、map…. ，service方法中不建议使用包装类型。（不利于业务层的可扩展性）</p>\r\n</blockquote>\r\n<h2 id=\"h2-sqlmapconfig-xml-\"><a name=\"SqlMapConfig.xml 文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>SqlMapConfig.xml 文件</h2><p>Mybatis 的全局配置变量，配置内容和顺序如下：</p>\r\n<p>properties（属性）</p>\r\n<p>settings（全局配置参数）</p>\r\n<p>typeAliases（类型别名）</p>\r\n<p>typeHandlers（类型处理器）</p>\r\n<p>objectFactory（对象工厂）</p>\r\n<p>plugins（插件）</p>\r\n<p>environments（环境集合属性对象）</p>\r\n<p>? environment（环境子属性对象）</p>\r\n<p>? transactionManager（事务管理）</p>\r\n<p>? dataSource（数据源）</p>\r\n<p>mappers（映射器）</p>\r\n<h3 id=\"h3-properties-\"><a name=\"properties 属性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>properties 属性</h3><p>需求：将数据库连接参数单独配置在 db.properties 中，只需要在 SqlMapConfig.xml 中加载该配置文件 db.properties 的属性值。在 SqlMapConfig.xml 中就不需要直接对数据库的连接参数进行硬编码了。方便以后对参数进行统一的管理，其他的xml文件可以引用该 db.properties 。</p>\r\n<p><code>db.properties</code></p>\r\n<pre><code>jdbc.driver=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://localhost:3306/mybatis_test?characterEncoding=utf-8\r\njdbc.username=root\r\njdbc.password=root\r\n</code></pre><p>那么 SqlMapConfig.xml 中的配置变成如下：</p>\r\n<pre><code>&lt;!--加载配置文件--&gt;\r\n    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;\r\n    &lt;!-- 和spring整合后 environments配置将废除--&gt;\r\n    &lt;environments default=&quot;development&quot;&gt;\r\n        &lt;environment id=&quot;development&quot;&gt;\r\n            &lt;!-- 使用jdbc事务管理,事务由 Mybatis 控制--&gt;\r\n            &lt;transactionManager type=&quot;JDBC&quot; /&gt;\r\n            &lt;!-- 数据库连接池--&gt;\r\n            &lt;dataSource type=&quot;POOLED&quot;&gt;\r\n                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;\r\n                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;\r\n                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;\r\n                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;\r\n            &lt;/dataSource&gt;\r\n        &lt;/environment&gt;\r\n    &lt;/environments&gt;\r\n</code></pre><p>配置完成后我们测试一下是否能够和刚才一样的能够成功呢？那么我就先在db.properties中把数据库密码故意改错，看是否是正确的？不出意外的话是会报错的。</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/%E6%8A%A5%E9%94%99.jpg\" alt=\"\"></p>\r\n<p>注意： MyBatis 将按照下面的顺序来加载属性：</p>\r\n<ul>\r\n<li><p>在 properties 元素体内定义的属性首先被读取。</p>\r\n</li><li><p>然后会读取 properties 元素中 resource 或 url 加载的属性，它会覆盖已读取的同名属性。</p>\r\n</li><li><p>最后读取 parameterType 传递的属性，它会覆盖已读取的同名属性。</p>\r\n<p>因此，通过parameterType传递的属性具有最高优先级，resource或 url 加载的属性次之，最低优先级的是 properties 元素体内定义的属性。</p>\r\n</li></ul>\r\n<p>建议：</p>\r\n<ul>\r\n<li>不要在 properties 元素体内添加任何属性值，只将属性值定义在 db.properties 文件之中。</li><li>在 db.properties 文件之中定义的属性名要有一定的特殊性。如 xxx.xxx.xxx</li></ul>\r\n<h3 id=\"h3-settings-\"><a name=\"settings（全局配置参数）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>settings（全局配置参数）</h3><p>Mybatis 框架在运行时可以调整一些运行参数</p>\r\n<p>比如：开启二级缓存、开启延迟加载。。。</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/setting.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-typealiases-\"><a name=\"typeAliases（类型别名）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>typeAliases（类型别名）</h3><p>需求：</p>\r\n<p>在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数的类型、需要resultType指定输出结果的映射类型。</p>\r\n<p>如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。</p>\r\n<p><strong>Mybatis支持的别名：</strong></p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">别名</th>\r\n<th style=\"text-align:center\">映射的类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\">_byte</td>\r\n<td style=\"text-align:center\">byte</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">_long</td>\r\n<td style=\"text-align:center\">long</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">_short</td>\r\n<td style=\"text-align:center\">short</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">_int</td>\r\n<td style=\"text-align:center\">int</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">_integer</td>\r\n<td style=\"text-align:center\">int</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">_double</td>\r\n<td style=\"text-align:center\">double</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">_float</td>\r\n<td style=\"text-align:center\">float</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">_boolean</td>\r\n<td style=\"text-align:center\">boolean</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">string</td>\r\n<td style=\"text-align:center\">String</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">byte</td>\r\n<td style=\"text-align:center\">Byte</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">long</td>\r\n<td style=\"text-align:center\">Long</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">short</td>\r\n<td style=\"text-align:center\">Short</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">int</td>\r\n<td style=\"text-align:center\">Integer</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">integer</td>\r\n<td style=\"text-align:center\">Integer</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">double</td>\r\n<td style=\"text-align:center\">Double</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">float</td>\r\n<td style=\"text-align:center\">Float</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">boolean</td>\r\n<td style=\"text-align:center\">Boolean</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">date</td>\r\n<td style=\"text-align:center\">Date</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">decimal</td>\r\n<td style=\"text-align:center\">BigDecimal</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">bigdecimal</td>\r\n<td style=\"text-align:center\">BigDecimal</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>自定义别名：</strong></p>\r\n<p>在 SqlMapConfig.xml 中配置：(设置别名)</p>\r\n<pre><code>&lt;typeAliases&gt;\r\n    &lt;!-- 单个别名定义 --&gt;\r\n    &lt;typeAlias alias=&quot;user&quot; type=&quot;cn.zhisheng.mybatis.po.User&quot;/&gt;\r\n    &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt;\r\n    &lt;package name=&quot;cn.zhisheng.mybatis.po&quot;/&gt;\r\n    &lt;package name=&quot;其它包&quot;/&gt;\r\n&lt;/typeAliases&gt;\r\n</code></pre><p>在 UserMapper.xml 中引用别名：( resultType 为 user )</p>\r\n<pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;\r\n        select * from user where id = #{id}\r\n&lt;/select&gt;\r\n</code></pre><p>测试结果：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test4.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-typehandlers-\"><a name=\"typeHandlers（类型处理器）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>typeHandlers（类型处理器）</h3><p>mybatis中通过typeHandlers完成jdbc类型和java类型的转换。</p>\r\n<p>通常情况下，mybatis提供的类型处理器满足日常需要，不需要自定义.</p>\r\n<p>mybatis支持类型处理器：</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">类型处理器</th>\r\n<th style=\"text-align:center\"><strong>Java</strong>类型</th>\r\n<th style=\"text-align:center\"><strong>JDBC</strong>类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\">BooleanTypeHandler</td>\r\n<td style=\"text-align:center\">Boolean，boolean</td>\r\n<td style=\"text-align:center\">任何兼容的布尔值</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">ByteTypeHandler</td>\r\n<td style=\"text-align:center\">Byte，byte</td>\r\n<td style=\"text-align:center\">任何兼容的数字或字节类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">ShortTypeHandler</td>\r\n<td style=\"text-align:center\">Short，short</td>\r\n<td style=\"text-align:center\">任何兼容的数字或短整型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">IntegerTypeHandler</td>\r\n<td style=\"text-align:center\">Integer，int</td>\r\n<td style=\"text-align:center\">任何兼容的数字和整型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">LongTypeHandler</td>\r\n<td style=\"text-align:center\">Long，long</td>\r\n<td style=\"text-align:center\">任何兼容的数字或长整型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">FloatTypeHandler</td>\r\n<td style=\"text-align:center\">Float，float</td>\r\n<td style=\"text-align:center\">任何兼容的数字或单精度浮点型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DoubleTypeHandler</td>\r\n<td style=\"text-align:center\">Double，double</td>\r\n<td style=\"text-align:center\">任何兼容的数字或双精度浮点型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">BigDecimalTypeHandler</td>\r\n<td style=\"text-align:center\">BigDecimal</td>\r\n<td style=\"text-align:center\">任何兼容的数字或十进制小数类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">StringTypeHandler</td>\r\n<td style=\"text-align:center\">String</td>\r\n<td style=\"text-align:center\">CHAR和VARCHAR类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">ClobTypeHandler</td>\r\n<td style=\"text-align:center\">String</td>\r\n<td style=\"text-align:center\">CLOB和LONGVARCHAR类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">NStringTypeHandler</td>\r\n<td style=\"text-align:center\">String</td>\r\n<td style=\"text-align:center\">NVARCHAR和NCHAR类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">NClobTypeHandler</td>\r\n<td style=\"text-align:center\">String</td>\r\n<td style=\"text-align:center\">NCLOB类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">ByteArrayTypeHandler</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n<td style=\"text-align:center\">任何兼容的字节流类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">BlobTypeHandler</td>\r\n<td style=\"text-align:center\">byte[]</td>\r\n<td style=\"text-align:center\">BLOB和LONGVARBINARY类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DateTypeHandler</td>\r\n<td style=\"text-align:center\">Date（java.util）</td>\r\n<td style=\"text-align:center\">TIMESTAMP类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">DateOnlyTypeHandler</td>\r\n<td style=\"text-align:center\">Date（java.util）</td>\r\n<td style=\"text-align:center\">DATE类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">TimeOnlyTypeHandler</td>\r\n<td style=\"text-align:center\">Date（java.util）</td>\r\n<td style=\"text-align:center\">TIME类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">SqlTimestampTypeHandler</td>\r\n<td style=\"text-align:center\">Timestamp（java.sql）</td>\r\n<td style=\"text-align:center\">TIMESTAMP类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">SqlDateTypeHandler</td>\r\n<td style=\"text-align:center\">Date（java.sql）</td>\r\n<td style=\"text-align:center\">DATE类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">SqlTimeTypeHandler</td>\r\n<td style=\"text-align:center\">Time（java.sql）</td>\r\n<td style=\"text-align:center\">TIME类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">ObjectTypeHandler</td>\r\n<td style=\"text-align:center\">任意</td>\r\n<td style=\"text-align:center\">其他或未指定类型</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">EnumTypeHandler</td>\r\n<td style=\"text-align:center\">Enumeration类型</td>\r\n<td style=\"text-align:center\">VARCHAR-任何兼容的字符串类型，作为代码存储（而不是索引）。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"h3-mappers-\"><a name=\"mappers（映射器）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>mappers（映射器）</h3><ul>\r\n<li><p>使用相对于类路径的资源，如：</p>\r\n</li><li><p>使用完全限定路径<br>如：</p>\r\n</li><li><p>使用 mapper 接口类路径</p>\r\n<p>如：</p>\r\n<p>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</p>\r\n</li><li><p>注册指定包下的所有mapper接口<br>如：<br>注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。</p>\r\n</li></ul>\r\n<h2 id=\"h2-mapper-xml-\"><a name=\"Mapper.xml 映射文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mapper.xml 映射文件</h2><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。</p>\r\n<h3 id=\"h3-u8F93u5165u6620u5C04\"><a name=\"输入映射\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>输入映射</h3><p>通过 parameterType 指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型。</p>\r\n<p><strong>传递 pojo 包装对象</strong> （重点）</p>\r\n<p>开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。</p>\r\n<ul>\r\n<li><p>定义包装对象</p>\r\n<p>定义包装对象将查询条件(pojo)以类组合的方式包装起来。</p>\r\n<p><code>UserQueryVo.java</code></p>\r\n<pre><code>public class UserQueryVo    //用户包装类型\r\n{\r\n  //在这里包装所需要的查询条件\r\n  //用户查询条件\r\n  private UserCustom userCustom;\r\n  public UserCustom getUserCustom()\r\n  {\r\n      return userCustom;\r\n  }\r\n  public void setUserCustom(UserCustom userCustom)\r\n  {\r\n      this.userCustom = userCustom;\r\n  }\r\n  //还可以包装其他的查询条件，比如订单、商品\r\n}\r\n</code></pre><p><code>UserCustomer.java</code></p>\r\n<pre><code>public class UserCustom extends User    //用户的扩展类\r\n{\r\n  //可以扩展用户的信息\r\n}\r\n</code></pre></li><li><p><code>UserMapper.xml</code> 文件</p>\r\n<pre><code>&lt;!--用户信息综合查询\r\n  #{userCustom.sex} :取出pojo包装对象中的性别值\r\n  #{userCustom.username} :取出pojo包装对象中的用户名称\r\n  --&gt;\r\n  &lt;select id=&quot;findUserList&quot; parameterType=&quot;cn.zhisheng.mybatis.po.UserQueryVo&quot; resultType=&quot;cn.zhisheng.mybatis.po.UserCustom&quot;&gt;\r\n      select * from user where user.sex = #{userCustom.sex} and user.username like  &#39;%${userCustom.username}%&#39;\r\n  &lt;/select&gt;\r\n</code></pre></li><li><p>UserMapper.java</p>\r\n<pre><code>//用户信息综合查询\r\npublic List&lt;UserCustom&gt; findUserList(UserQueryVo userQueryVo) throws Exception;\r\n</code></pre></li><li><p>测试代码</p>\r\n<pre><code>//测试用户信息综合查询\r\n  <a href=\"https://github.com/Test\" title=\"&#64;Test\" class=\"at-link\">@Test</a>\r\n  public void testFindUserList() throws Exception\r\n  {\r\n      SqlSession sqlSession = sqlSessionFactory.openSession();\r\n      //创建usermapper对象,mybatis自动生成代理对象\r\n      UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n      //创建包装对象，设置查询条件\r\n      UserQueryVo userQueryVo = new UserQueryVo();\r\n      UserCustom userCustom = new UserCustom();\r\n      userCustom.setSex(&quot;男&quot;);\r\n      userCustom.setUsername(&quot;张小明&quot;);\r\n      userQueryVo.setUserCustom(userCustom);\r\n      //调用UserMapper的方法\r\n      List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo);   \r\n      System.out.println(list);\r\n  }\r\n</code></pre></li><li><p>测试结果</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test5.jpg\" alt=\"\"></p>\r\n</li></ul>\r\n<h3 id=\"h3-u8F93u51FAu6620u5C04\"><a name=\"输出映射\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>输出映射</h3><ul>\r\n<li><strong>resultType</strong></li></ul>\r\n<blockquote>\r\n<ul>\r\n<li><strong>使用 resultType 进行输出映射，只有查询出来的列名和 pojo 中的属性名一致，该列才可以映射成功。</strong></li><li>如果查询出来的列名和 pojo 中的属性名全部不一致，没有创建 pojo 对象。</li><li>只要查询出来的列名和 pojo 中的属性有一个一致，就会创建 pojo 对象。</li></ul>\r\n</blockquote>\r\n<h4 id=\"h4-u8F93u51FAu7B80u5355u7C7Bu578B\"><a name=\"输出简单类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>输出简单类型</h4><p>需求：用户信息综合查询列表总数，通过查询总数和上边用户综合查询列表才可以实现分页</p>\r\n<p>实现：</p>\r\n<pre><code>&lt;!--用户信息综合查询总数\r\n    parameterType:指定输入的类型和findUserList一样\r\n    resultType:输出结果类型为 int\r\n    --&gt;\r\n    &lt;select id=&quot;findUserCount&quot; parameterType=&quot;cn.zhisheng.mybatis.po.UserQueryVo&quot; resultType=&quot;int&quot;&gt;\r\n      select count(*) from user where user.sex = #{userCustom.sex} and user.username like  &#39;%${userCustom.username}%&#39;\r\n    &lt;/select&gt;\r\n</code></pre><pre><code> //用户信息综合查询总数\r\n    public int findUserCount(UserQueryVo userQueryVo) throws Exception;\r\n</code></pre><pre><code>//测试用户信息综合查询总数\r\n    @Test\r\n    public void testFindUserCount() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建usermapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //创建包装对象，设置查询条件\r\n        UserQueryVo userQueryVo = new UserQueryVo();\r\n        UserCustom userCustom = new UserCustom();\r\n        userCustom.setSex(&quot;男&quot;);\r\n        userCustom.setUsername(&quot;张小明&quot;);\r\n        userQueryVo.setUserCustom(userCustom);\r\n        //调用UserMapper的方法\r\n        System.out.println(userMapper.findUserCount(userQueryVo));\r\n    }\r\n</code></pre><p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test6.jpg\" alt=\"\"></p>\r\n<p>注意：查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。</p>\r\n<p><strong>输出pojo对象和pojo列表</strong></p>\r\n<p>不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。</p>\r\n<p>在mapper.java指定的方法返回值类型不一样：</p>\r\n<p>1、输出单个pojo对象，方法返回值是单个对象类型</p>\r\n<pre><code>//根据id查询用户信息\r\n    public User findUserById(int id) throws Exception;\r\n</code></pre><p>2、输出pojo对象list，方法返回值是List</p>\r\n<pre><code>  //根据用户名查询用户信息\r\n    public List&lt;User&gt; findUserByUsername(String userName) throws  Exception;\r\n</code></pre><p>resultType总结：</p>\r\n<p>输出pojo对象和输出pojo列表在sql中定义的resultType是一样的。</p>\r\n<p>返回单个pojo对象要保证sql查询出来的结果集为单条，内部使用session.selectOne方法调用，mapper接口使用pojo对象作为方法返回值。</p>\r\n<p>返回pojo列表表示查询出来的结果集可能为多条，内部使用session.selectList方法，mapper接口使用List对象作为方法返回值。</p>\r\n<ul>\r\n<li><strong>resultMap</strong></li></ul>\r\n<p>resultType 可以指定 pojo 将查询结果映射为 pojo，但需要 pojo 的属性名和 sql 查询的列名一致方可映射成功。</p>\r\n<p>如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。</p>\r\n<p>resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。</p>\r\n<p>使用方法：</p>\r\n<p>1、定义 resultMap</p>\r\n<p>2、使用 resultMap 作为 statement 的输出映射类型</p>\r\n<p>将下面的 sql 使用 User 完成映射</p>\r\n<pre><code>select id id_, username username_ from user where id = #{value}\r\n</code></pre><p>User 类中属性名和上边查询的列名不一致。</p>\r\n<p>所以需要：</p>\r\n<p>1、定义 resultMap</p>\r\n<pre><code>&lt;!--定义 resultMap\r\n    将select id id_, username username_ from user where id = #{value} 和User类中的属性做一个映射关系\r\n    type: resultMap最终映射的java对象类型\r\n    id:对resultMap的唯一标识\r\n    --&gt;\r\n    &lt;resultMap id=&quot;userResultMap&quot; type=&quot;user&quot;&gt;\r\n        &lt;!--id表示查询结果中的唯一标识\r\n        column：查询出来的列名\r\n        property：type指定pojo的属性名\r\n        最终resultMap对column和property做一个映射关系（对应关系）\r\n        --&gt;\r\n        &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;\r\n\r\n        &lt;!--result: 对普通结果映射定义\r\n        column：查询出来的列名\r\n        property：type指定pojo的属性名\r\n        最终resultMap对column和property做一个映射关系（对应关系）\r\n        --&gt;\r\n        &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt;\r\n    &lt;/resultMap&gt;\r\n</code></pre><p>2、使用 resultMap 作为 statement 的输出映射类型</p>\r\n<pre><code>&lt;!--使用 resultMap 作为输出映射类型\r\n        resultMap=&quot;userResultMap&quot;:其中的userResultMap就是我们刚才定义的 resultMap 的id值,如果这个resultMap在其他的mapper文件中，前边须加上namespace --&gt;\r\n    &lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;\r\n        select id id_, username username_ from user where id = #{value}\r\n    &lt;/select&gt;\r\n</code></pre><p>3、<code>UserMapper.java</code></p>\r\n<pre><code>//根据id查询用户信息，使用 resultMap 输出\r\npublic User findUserByIdResultMap(int id) throws Exception;\r\n</code></pre><p>4、测试</p>\r\n<pre><code>//测试根据id查询用户信息，使用 resultMap 输出\r\n    @Test\r\n    public void testFindUserByIdResultMap() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建usermapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //调用UserMapper的方法\r\n        User user = userMapper.findUserByIdResultMap(1);\r\n        System.out.println(user);\r\n    }\r\n</code></pre><p>5、测试结果</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test7.jpg\" alt=\"\"></p>\r\n<h2 id=\"h2--sql\"><a name=\"动态 SQL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>动态 SQL</h2><p>通过mybatis提供的各种标签方法实现动态拼接sql。</p>\r\n<p>需求：</p>\r\n<p>用户信息综合查询列表和用户信息查询列表总数这两个 statement的定义使用动态sql。</p>\r\n<p>对查询条件进行判断，如果输入的参数不为空才进行查询条件拼接。</p>\r\n<p><code>UserMapper.xml</code> (findUserList的配置如下，那么findUserCount的也是一样的，这里就不全部写出来了)</p>\r\n<pre><code>&lt;select id=&quot;findUserList&quot; parameterType=&quot;cn.zhisheng.mybatis.po.UserQueryVo&quot; resultType=&quot;cn.zhisheng.mybatis.po.UserCustom&quot;&gt;\r\n        select * from user\r\n        &lt;!--where可以自动的去掉条件中的第一个and--&gt;\r\n        &lt;where&gt;\r\n            &lt;if test=&quot;userCustom != null&quot;&gt;\r\n                &lt;if test=&quot;userCustom.sex != null and userCustom.sex != &#39;&#39;&quot;&gt;\r\n                    and user.sex = #{userCustom.sex}\r\n                &lt;/if&gt;\r\n                &lt;if test=&quot;userCustom.username != null&quot;&gt;\r\n                    and user.username like  &#39;%${userCustom.username}%&#39;\r\n                &lt;/if&gt;\r\n            &lt;/if&gt;\r\n        &lt;/where&gt;\r\n    &lt;/select&gt;\r\n</code></pre><p>测试代码：因为设置了动态的sql，如果不设置某个值，那么条件就不会拼接在sql上</p>\r\n<p>所以我们就注释掉设置username的语句</p>\r\n<pre><code>//userCustom.setUsername(&quot;张小明&quot;);\r\n</code></pre><p>测试结果：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test8.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-sql-\"><a name=\"Sql 片段\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Sql 片段</h3><p>通过上面的其实看到在 where sql语句中有很多重复代码，我们可以将其抽取出来，组成一个sql片段，其他的statement就可以引用这个sql片段，利于系统的开发。</p>\r\n<p>这里我们就拿上边sql 中的where定义一个sq片段如下：</p>\r\n<pre><code> &lt;!--sql片段\r\n    id:唯一标识\r\n    经验：是基于单表来定义sql片段，这样的话sql片段的可重用性才高\r\n    一般不包含where\r\n    --&gt;\r\n    &lt;sql id=&quot;query_user_where&quot;&gt;\r\n        &lt;if test=&quot;userCustom != null&quot;&gt;\r\n            &lt;if test=&quot;userCustom.sex != null and userCustom.sex != &#39;&#39;&quot;&gt;\r\n                and user.sex = #{userCustom.sex}\r\n            &lt;/if&gt;\r\n            &lt;if test=&quot;userCustom.username != null&quot;&gt;\r\n                and user.username like  &#39;%${userCustom.username}%&#39;\r\n            &lt;/if&gt;\r\n        &lt;/if&gt;\r\n    &lt;/sql&gt;\r\n</code></pre><p>那么我们该怎样引用这个sql片段呢？如下：</p>\r\n<pre><code>select * from user\r\n        &lt;where&gt;\r\n        &lt;!--refid: 指定sql片段的id，如果是写在其他的mapper文件中，则需要在前面加上namespace--&gt;\r\n            &lt;include refid=&quot;query_user_where&quot;/&gt;\r\n        &lt;/where&gt;\r\n</code></pre><p>测试的话还是那样了，就不继续说了，前面已经说了很多了。</p>\r\n<h3 id=\"h3-foreach\"><a name=\"foreach\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>foreach</h3><p>向sql传递数组或List，mybatis使用foreach解析</p>\r\n<p>需求：</p>\r\n<p>在用户查询列表和查询总数的statement中增加多个id输入查询。</p>\r\n<p>sql语句如下：</p>\r\n<pre><code>SELECT * FROM USER WHERE id=1 OR id=10 ORid=16\r\n或者\r\nSELECT * FROM USER WHERE id IN(1,10,16)\r\n</code></pre><p>在输入参数类型中添加 List ids 传入多个 id</p>\r\n<pre><code>public class UserQueryVo    //用户包装类型\r\n{\r\n    //传入多个id\r\n    private List&lt;Integer&gt; ids;\r\n}\r\n</code></pre><p>修改 UserMapper.xml文件</p>\r\n<p>WHERE id=1 OR id=10 OR id=16</p>\r\n<p>在查询条件中，查询条件定义成一个sql片段，需要修改sql片段。</p>\r\n<pre><code>&lt;if test=&quot;ids!=null&quot;&gt;\r\n            &lt;!-- 使用 foreach遍历传入ids\r\n            collection：指定输入 对象中集合属性\r\n            item：每个遍历生成对象中\r\n            open：开始遍历时拼接的串\r\n            close：结束遍历时拼接的串\r\n            separator：遍历的两个对象中需要拼接的串\r\n             --&gt;\r\n             &lt;!-- 使用实现下边的sql拼接：\r\n              AND (id=1 OR id=10 OR id=16) \r\n              --&gt;\r\n            &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;AND (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt;\r\n                &lt;!-- 每个遍历需要拼接的串 --&gt;\r\n                id=#{user_id}\r\n            &lt;/foreach&gt;\r\n\r\n            &lt;!-- 实现  “ and id IN(1,10,16)”拼接 --&gt;\r\n            &lt;!-- &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;and id IN(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;\r\n                每个遍历需要拼接的串\r\n                #{user_id}\r\n            &lt;/foreach&gt; --&gt;  \r\n            &lt;/if&gt;\r\n</code></pre><p>测试代码：</p>\r\n<pre><code> //传入多个id\r\nList&lt;Integer&gt; ids = new ArrayList&lt;&gt;();\r\nids.add(1);\r\nids.add(10);\r\nids.add(16);\r\n//将ids传入statement中\r\nuserQueryVo.setIds(ids);\r\n</code></pre>', '102', '\r\n### Mybatis 解决 jdbc 编程的问题\r\n\r\n1、 [数据库](http://lib.csdn.net/base/mysql \"MySQL知识库\")链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。\r\n\r\n解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。\r\n\r\n2、 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")代码。\r\n\r\n解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。\r\n\r\n3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。\r\n\r\n解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。\r\n\r\n4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。\r\n\r\n解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。\r\n\r\n### Mybatis 与 Hibernate 不同\r\n\r\nMybatis和[hibernate](http://lib.csdn.net/base/javaee \"Java EE知识库\")不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。\r\n\r\nMybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。\r\n\r\nHibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。\r\n\r\n总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件[架构](http://lib.csdn.net/base/architecture \"大型网站架构知识库\")都是好架构，所以框架只有适合才是最好。\r\n\r\n## Mybatis 开发 dao\r\n\r\n### 两种方法\r\n\r\n*   原始 dao 开发方法（程序需要编写 dao 接口和 dao 实现类）（掌握）\r\n*   Mybatis 的 mapper 接口（相当于 dao 接口）代理开发方法（掌握）\r\n\r\n### 需求\r\n\r\n将下边的功能实现Dao：\r\n\r\n*   根据用户id查询一个用户信息\r\n*   根据用户名称模糊查询用户信息列表\r\n*   添加用户信息\r\n\r\nMybatis 配置文件 SqlMapConfig.xml\r\n\r\n### Sqlsession 的使用范围\r\n\r\nSqlSession 中封装了对数据库的操作，如：查询、插入、更新、删除等。\r\n\r\n通过 SqlSessionFactory 创建 SqlSession，而 SqlSessionFactory 是通过 SqlSessionFactoryBuilder 进行创建。\r\n\r\n### 1、SqlSessionFactoryBuilder\r\n\r\nSqlSessionFactoryBuilder 用于创建 SqlSessionFacoty，SqlSessionFacoty 一旦创建完成就不需要SqlSessionFactoryBuilder 了，因为 SqlSession 是通过 SqlSessionFactory 生产，所以可以将SqlSessionFactoryBuilder 当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。\r\n\r\n### 2、SqlSessionFactory\r\n\r\nSqlSessionFactory 是一个接口，接口中定义了 openSession 的不同重载方法，SqlSessionFactory 的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理 SqlSessionFactory。\r\n\r\n### 3、SqlSession\r\n\r\nSqlSession 是一个面向用户的接口， sqlSession 中定义了数据库操作，默认使用 DefaultSqlSession 实现类。\r\n\r\n执行过程如下：\r\n\r\n1）、 加载数据源等配置信息\r\n\r\nEnvironment environment = configuration.getEnvironment();\r\n\r\n2）、 创建数据库链接\r\n\r\n3）、 创建事务对象\r\n\r\n4）、 创建Executor，SqlSession 所有操作都是通过 Executor 完成，mybatis 源码如下：\r\n\r\n```\r\nif (ExecutorType.BATCH == executorType) {\r\n      executor = newBatchExecutor(this, transaction);\r\n    } elseif (ExecutorType.REUSE == executorType) {\r\n      executor = new ReuseExecutor(this, transaction);\r\n    } else {\r\n      executor = new SimpleExecutor(this, transaction);\r\n    }\r\nif (cacheEnabled) {\r\n      executor = new CachingExecutor(executor, autoCommit);\r\n    }\r\n```\r\n\r\n5）、 SqlSession的实现类即 DefaultSqlSession，此对象中对操作数据库实质上用的是 Executor\r\n\r\n### 结论：\r\n\r\n```\r\n     每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围(定义局部变量使用)。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。\r\n\r\n     打开一个SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下：\r\n\r\n```\r\n\r\n```\r\nSqlSession session = sqlSessionFactory.openSession();\r\n    try {\r\n         // do work\r\n    } finally {\r\n        session.close();\r\n}\r\n```\r\n\r\n## 原始 Dao 开发方法\r\n\r\n### 思路：\r\n\r\n需要程序员编写 Dao 接口和 Dao 实现类；\r\n\r\n需要在 Dao 实现类中注入 SqlsessionFactory ，在方法体内通过 SqlsessionFactory 创建 Sqlsession。\r\n\r\n### Dao接口\r\n\r\n```\r\npublic interface UserDao    //dao接口，用户管理\r\n{\r\n    //根据id查询用户信息\r\n    public User findUserById(int id) throws Exception;\r\n\r\n    //添加用户信息\r\n    public void addUser(User user) throws Exception;\r\n\r\n    //删除用户信息\r\n    public void deleteUser(int id) throws Exception;\r\n}\r\n```\r\n\r\n### Dao 实现类\r\n\r\n```\r\npublic class UserDaoImpl  implements UserDao  //dao接口实现类\r\n{\r\n    //需要在 Dao 实现类中注入 SqlsessionFactory\r\n    //这里通过构造方法注入\r\n    private SqlSessionFactory sqlSessionFactory;\r\n    public UserDaoImpl(SqlSessionFactory sqlSessionFactory)\r\n    {\r\n        this.sqlSessionFactory = sqlSessionFactory;\r\n    }\r\n    @Override\r\n    public User findUserById(int id) throws Exception\r\n    {\r\n        //在方法体内通过 SqlsessionFactory 创建 Sqlsession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        User user = sqlSession.selectOne(\"test.findUserById\", id);\r\n        sqlSession.close();\r\n        return user;\r\n    }\r\n    @Override\r\n    public void insertUser(User user) throws Exception\r\n    {\r\n        //在方法体内通过 SqlsessionFactory 创建 Sqlsession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //执行插入的操作\r\n        sqlSession.insert(\"test.insetrUser\", user);\r\n        //提交事务\r\n        sqlSession.commit();\r\n        //释放资源\r\n        sqlSession.close();\r\n    }\r\n    @Override\r\n    public void deleteUser(int id) throws Exception\r\n    {\r\n        //在方法体内通过 SqlsessionFactory 创建 Sqlsession\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        sqlSession.delete(\"test.deleteUserById\", id);\r\n        //提交事务\r\n        sqlSession.commit();\r\n        sqlSession.close();\r\n    }\r\n}\r\n```\r\n\r\n### 测试\r\n\r\n```\r\npublic class UserDaoImplTest\r\n{\r\n    private SqlSessionFactory sqlSessionFactory;\r\n    //此方法是在 testFindUserById 方法之前执行的\r\n    @Before\r\n    public void setup() throws Exception\r\n    {\r\n        //创建sqlSessionFactory\r\n        //Mybatis 配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n    }\r\n    @Test\r\n    public void testFindUserById() throws Exception\r\n    {\r\n        //创建UserDao的对象\r\n        UserDao userDao = new UserDaoImpl(sqlSessionFactory);\r\n        //调用UserDao方法\r\n        User user = userDao.findUserById(1);\r\n        System.out.println(user);\r\n    }\r\n}\r\n```\r\n\r\n通过id查询用户信息[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")结果如下：（其他的可以自己在写测试代码，原理类似）\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/dao%E5%BC%80%E5%8F%91.jpg)\r\n\r\n### 问题\r\n\r\n原始Dao开发中存在以下问题：\r\n\r\n*   Dao方法体存在重复代码：通过 SqlSessionFactory 创建 SqlSession，调用 SqlSession 的数据库操作方法\r\n*   调用 sqlSession 的数据库操作方法需要指定 statement 的i d，这里存在硬编码，不得于开发维护。\r\n*   调用 sqlSession 的数据库操作方法时传入的变量，由于 sqlsession 方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。\r\n\r\n## Mybatis 的 mapper 接口\r\n\r\n### 思路\r\n\r\n程序员需要编写 mapper.xml 映射文件\r\n\r\n只需要程序员编写Mapper接口（相当于Dao接口），需遵循一些开发规范，mybatis 可以自动生成 mapper 接口类代理对象。\r\n\r\n开发规范：\r\n\r\n*   在 mapper.xml 中 namespace 等于 mapper 接口地址\r\n\r\n    ```\r\n    <mapper namespace=\"cn.zhisheng.mybatis.mapper.UserMapper\"></mapper>\r\n    ```\r\n\r\n*   在 xxxmapper.java 接口中的方法名要与 xxxMapper.xml 中 statement 的 id 一致。\r\n\r\n*   在 xxxmapper.java 接口中的输入参数类型要与 xxxMapper.xml 中 statement 的 parameterType 指定的参数类型一致。\r\n\r\n*   在 xxxmapper.java 接口中的返回值类型要与 xxxMapper.xml 中 statement 的 resultType 指定的类型一致。\r\n\r\n    `UserMapper.java`\r\n\r\n    ```\r\n    //根据id查询用户信息\r\n      public User findUserById(int id) throws Exception;\r\n    ```\r\n\r\n    `UserMapper.xml`\r\n\r\n    ```\r\n    <select id=\"findUserById\" parameterType=\"int\" resultType=\"cn.zhisheng.mybatis.po.User\">\r\n          select * from user where id = #{1}\r\n    </select>\r\n    ```\r\n\r\n### <a name=\"t20\"></a>总结：\r\n\r\n以上的开发规范主要是对下边的代码进行统一的生成：\r\n\r\n```\r\nUser user = sqlSession.selectOne(\"test.findUserById\", id);\r\nsqlSession.insert(\"test.insetrUser\", user);\r\nsqlSession.delete(\"test.deleteUserById\", id);\r\nList<User> list = sqlSession.selectList(\"test.findUserByName\", username);\r\n```\r\n\r\n### 测试\r\n\r\n测试之前记得在 SqlMapConfig.xml 文件中添加加载映射文件 UserMapper.xml：\r\n\r\n```\r\n<mapper resource=\"mapper/UserMapper.xml\"/>\r\n```\r\n\r\n测试代码：\r\n\r\n```\r\npublic class UserMapperTest\r\n{\r\n    private SqlSessionFactory sqlSessionFactory;\r\n    //此方法是在 testFindUserById 方法之前执行的\r\n    @Before\r\n    public void setup() throws Exception\r\n    {\r\n        //创建sqlSessionFactory\r\n        //Mybatis 配置文件\r\n        String resource = \"SqlMapConfig.xml\";\r\n        //得到配置文件流\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        //创建会话工厂,传入Mybatis的配置文件信息\r\n        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n    }\r\n    @Test\r\n    public void testFindUserById() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建usermapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //调用UserMapper的方法\r\n        User user = userMapper.findUserById(1);\r\n        System.out.println(user);\r\n    }\r\n}\r\n```\r\n\r\n通过id查询用户信息测试结果如下：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/mapper%E5%BC%80%E5%8F%91.jpg)\r\n\r\n通过姓名查询用户信息：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/mapper%E5%BC%80%E5%8F%912.jpg)\r\n\r\n### 代理对象内部调用 selectOne 或者 selectList\r\n\r\n*   如果 mapper 方法返回单个 pojo 对象（非集合对象），代理对象内部通过 selectOne 查询数据库\r\n*   如果 mapper 方法返回集合对象，代理对象内部通过 selectList 查询数据库\r\n\r\n### mapper接口方法参数只能有一个是否影响系统开发\r\n\r\n> mapper 接口方法参数只能有一个，系统是否不利于维护？\r\n> \r\n> 系统框架中，dao层的代码是被业务层公用的。\r\n> \r\n> 即使 mapper 接口只有一个参数，可以使用包装类型的 pojo 满足不同的业务方法的需求。\r\n> \r\n> 注意：持久层方法的参数可以包装类型、map…. ，service方法中不建议使用包装类型。（不利于业务层的可扩展性）\r\n\r\n## SqlMapConfig.xml 文件\r\n\r\nMybatis 的全局配置变量，配置内容和顺序如下：\r\n\r\nproperties（属性）\r\n\r\nsettings（全局配置参数）\r\n\r\ntypeAliases（类型别名）\r\n\r\ntypeHandlers（类型处理器）\r\n\r\nobjectFactory（对象工厂）\r\n\r\nplugins（插件）\r\n\r\nenvironments（环境集合属性对象）\r\n\r\n? environment（环境子属性对象）\r\n\r\n? transactionManager（事务管理）\r\n\r\n? dataSource（数据源）\r\n\r\nmappers（映射器）\r\n\r\n### properties 属性\r\n\r\n需求：将数据库连接参数单独配置在 db.properties 中，只需要在 SqlMapConfig.xml 中加载该配置文件 db.properties 的属性值。在 SqlMapConfig.xml 中就不需要直接对数据库的连接参数进行硬编码了。方便以后对参数进行统一的管理，其他的xml文件可以引用该 db.properties 。\r\n\r\n`db.properties`\r\n\r\n```\r\njdbc.driver=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://localhost:3306/mybatis_test?characterEncoding=utf-8\r\njdbc.username=root\r\njdbc.password=root\r\n```\r\n\r\n那么 SqlMapConfig.xml 中的配置变成如下：\r\n\r\n```\r\n<!--加载配置文件-->\r\n    <properties resource=\"db.properties\"></properties>\r\n    <!-- 和spring整合后 environments配置将废除-->\r\n    <environments default=\"development\">\r\n        <environment id=\"development\">\r\n            <!-- 使用jdbc事务管理,事务由 Mybatis 控制-->\r\n            <transactionManager type=\"JDBC\" />\r\n            <!-- 数据库连接池-->\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"${jdbc.driver}\" />\r\n                <property name=\"url\" value=\"${jdbc.url}\" />\r\n                <property name=\"username\" value=\"${jdbc.username}\" />\r\n                <property name=\"password\" value=\"${jdbc.password}\" />\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n```\r\n\r\n配置完成后我们测试一下是否能够和刚才一样的能够成功呢？那么我就先在db.properties中把数据库密码故意改错，看是否是正确的？不出意外的话是会报错的。\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/%E6%8A%A5%E9%94%99.jpg)\r\n\r\n注意： MyBatis 将按照下面的顺序来加载属性：\r\n\r\n*   在 properties 元素体内定义的属性首先被读取。\r\n\r\n*   然后会读取 properties 元素中 resource 或 url 加载的属性，它会覆盖已读取的同名属性。\r\n\r\n*   最后读取 parameterType 传递的属性，它会覆盖已读取的同名属性。\r\n\r\n    因此，通过parameterType传递的属性具有最高优先级，resource或 url 加载的属性次之，最低优先级的是 properties 元素体内定义的属性。\r\n\r\n建议：\r\n\r\n*   不要在 properties 元素体内添加任何属性值，只将属性值定义在 db.properties 文件之中。\r\n*   在 db.properties 文件之中定义的属性名要有一定的特殊性。如 xxx.xxx.xxx\r\n\r\n### settings（全局配置参数）\r\n\r\nMybatis 框架在运行时可以调整一些运行参数\r\n\r\n比如：开启二级缓存、开启延迟加载。。。\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/setting.jpg)\r\n\r\n### typeAliases（类型别名）\r\n\r\n需求：\r\n\r\n在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数的类型、需要resultType指定输出结果的映射类型。\r\n\r\n如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。\r\n\r\n**Mybatis支持的别名：**\r\n\r\n| 别名 | 映射的类型 |\r\n| :-: | :-: |\r\n| _byte | byte |\r\n| _long | long |\r\n| _short | short |\r\n| _int | int |\r\n| _integer | int |\r\n| _double | double |\r\n| _float | float |\r\n| _boolean | boolean |\r\n| string | String |\r\n| byte | Byte |\r\n| long | Long |\r\n| short | Short |\r\n| int | Integer |\r\n| integer | Integer |\r\n| double | Double |\r\n| float | Float |\r\n| boolean | Boolean |\r\n| date | Date |\r\n| decimal | BigDecimal |\r\n| bigdecimal | BigDecimal |\r\n\r\n**自定义别名：**\r\n\r\n在 SqlMapConfig.xml 中配置：(设置别名)\r\n\r\n```\r\n<typeAliases>\r\n    <!-- 单个别名定义 -->\r\n    <typeAlias alias=\"user\" type=\"cn.zhisheng.mybatis.po.User\"/>\r\n    <!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） -->\r\n    <package name=\"cn.zhisheng.mybatis.po\"/>\r\n    <package name=\"其它包\"/>\r\n</typeAliases>\r\n```\r\n\r\n在 UserMapper.xml 中引用别名：( resultType 为 user )\r\n\r\n```\r\n<select id=\"findUserById\" parameterType=\"int\" resultType=\"user\">\r\n        select * from user where id = #{id}\r\n</select>\r\n```\r\n\r\n测试结果：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test4.jpg)\r\n\r\n### typeHandlers（类型处理器）\r\n\r\nmybatis中通过typeHandlers完成jdbc类型和java类型的转换。\r\n\r\n通常情况下，mybatis提供的类型处理器满足日常需要，不需要自定义.\r\n\r\nmybatis支持类型处理器：\r\n\r\n| 类型处理器 | **Java**类型 | **JDBC**类型 |\r\n| :-: | :-: | :-: |\r\n| BooleanTypeHandler | Boolean，boolean | 任何兼容的布尔值 |\r\n| ByteTypeHandler | Byte，byte | 任何兼容的数字或字节类型 |\r\n| ShortTypeHandler | Short，short | 任何兼容的数字或短整型 |\r\n| IntegerTypeHandler | Integer，int | 任何兼容的数字和整型 |\r\n| LongTypeHandler | Long，long | 任何兼容的数字或长整型 |\r\n| FloatTypeHandler | Float，float | 任何兼容的数字或单精度浮点型 |\r\n| DoubleTypeHandler | Double，double | 任何兼容的数字或双精度浮点型 |\r\n| BigDecimalTypeHandler | BigDecimal | 任何兼容的数字或十进制小数类型 |\r\n| StringTypeHandler | String | CHAR和VARCHAR类型 |\r\n| ClobTypeHandler | String | CLOB和LONGVARCHAR类型 |\r\n| NStringTypeHandler | String | NVARCHAR和NCHAR类型 |\r\n| NClobTypeHandler | String | NCLOB类型 |\r\n| ByteArrayTypeHandler | byte[] | 任何兼容的字节流类型 |\r\n| BlobTypeHandler | byte[] | BLOB和LONGVARBINARY类型 |\r\n| DateTypeHandler | Date（java.util） | TIMESTAMP类型 |\r\n| DateOnlyTypeHandler | Date（java.util） | DATE类型 |\r\n| TimeOnlyTypeHandler | Date（java.util） | TIME类型 |\r\n| SqlTimestampTypeHandler | Timestamp（java.sql） | TIMESTAMP类型 |\r\n| SqlDateTypeHandler | Date（java.sql） | DATE类型 |\r\n| SqlTimeTypeHandler | Time（java.sql） | TIME类型 |\r\n| ObjectTypeHandler | 任意 | 其他或未指定类型 |\r\n| EnumTypeHandler | Enumeration类型 | VARCHAR-任何兼容的字符串类型，作为代码存储（而不是索引）。 |\r\n\r\n### mappers（映射器）\r\n\r\n*   使用相对于类路径的资源，如：\r\n\r\n*   使用完全限定路径\r\n    如：\r\n\r\n*   使用 mapper 接口类路径\r\n\r\n    如：\r\n\r\n    注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。\r\n\r\n*   注册指定包下的所有mapper接口\r\n    如：\r\n    注意：此种方法要求 mapper 接口名称和 mapper 映射文件名称相同，且放在同一个目录中。\r\n\r\n## Mapper.xml 映射文件\r\n\r\nMapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。\r\n\r\n### 输入映射\r\n\r\n通过 parameterType 指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型。\r\n\r\n**传递 pojo 包装对象** （重点）\r\n\r\n开发中通过pojo传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。\r\n\r\n*   定义包装对象\r\n\r\n    定义包装对象将查询条件(pojo)以类组合的方式包装起来。\r\n\r\n    `UserQueryVo.java`\r\n\r\n    ```\r\n    public class UserQueryVo    //用户包装类型\r\n    {\r\n      //在这里包装所需要的查询条件\r\n      //用户查询条件\r\n      private UserCustom userCustom;\r\n      public UserCustom getUserCustom()\r\n      {\r\n          return userCustom;\r\n      }\r\n      public void setUserCustom(UserCustom userCustom)\r\n      {\r\n          this.userCustom = userCustom;\r\n      }\r\n      //还可以包装其他的查询条件，比如订单、商品\r\n    }\r\n    ```\r\n\r\n    `UserCustomer.java`\r\n\r\n    ```\r\n    public class UserCustom extends User    //用户的扩展类\r\n    {\r\n      //可以扩展用户的信息\r\n    }\r\n    ```\r\n\r\n*   `UserMapper.xml` 文件\r\n\r\n    ```\r\n    <!--用户信息综合查询\r\n      #{userCustom.sex} :取出pojo包装对象中的性别值\r\n      #{userCustom.username} :取出pojo包装对象中的用户名称\r\n      -->\r\n      <select id=\"findUserList\" parameterType=\"cn.zhisheng.mybatis.po.UserQueryVo\" resultType=\"cn.zhisheng.mybatis.po.UserCustom\">\r\n          select * from user where user.sex = #{userCustom.sex} and user.username like  \'%${userCustom.username}%\'\r\n      </select>\r\n    ```\r\n\r\n*   UserMapper.java\r\n\r\n    ```\r\n    //用户信息综合查询\r\n    public List<UserCustom> findUserList(UserQueryVo userQueryVo) throws Exception;\r\n    ```\r\n\r\n*   测试代码\r\n\r\n    ```\r\n    //测试用户信息综合查询\r\n      @Test\r\n      public void testFindUserList() throws Exception\r\n      {\r\n          SqlSession sqlSession = sqlSessionFactory.openSession();\r\n          //创建usermapper对象,mybatis自动生成代理对象\r\n          UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n          //创建包装对象，设置查询条件\r\n          UserQueryVo userQueryVo = new UserQueryVo();\r\n          UserCustom userCustom = new UserCustom();\r\n          userCustom.setSex(\"男\");\r\n          userCustom.setUsername(\"张小明\");\r\n          userQueryVo.setUserCustom(userCustom);\r\n          //调用UserMapper的方法\r\n          List<UserCustom> list = userMapper.findUserList(userQueryVo);   \r\n          System.out.println(list);\r\n      }\r\n    ```\r\n\r\n*   测试结果\r\n\r\n    ![](http://ohfk1r827.bkt.clouddn.com/Test5.jpg)\r\n\r\n### 输出映射\r\n\r\n*   **resultType**\r\n\r\n> *   **使用 resultType 进行输出映射，只有查询出来的列名和 pojo 中的属性名一致，该列才可以映射成功。**\r\n> *   如果查询出来的列名和 pojo 中的属性名全部不一致，没有创建 pojo 对象。\r\n> *   只要查询出来的列名和 pojo 中的属性有一个一致，就会创建 pojo 对象。\r\n\r\n#### 输出简单类型\r\n\r\n需求：用户信息综合查询列表总数，通过查询总数和上边用户综合查询列表才可以实现分页\r\n\r\n实现：\r\n\r\n```\r\n<!--用户信息综合查询总数\r\n    parameterType:指定输入的类型和findUserList一样\r\n    resultType:输出结果类型为 int\r\n    -->\r\n    <select id=\"findUserCount\" parameterType=\"cn.zhisheng.mybatis.po.UserQueryVo\" resultType=\"int\">\r\n      select count(*) from user where user.sex = #{userCustom.sex} and user.username like  \'%${userCustom.username}%\'\r\n    </select>\r\n```\r\n\r\n```\r\n //用户信息综合查询总数\r\n    public int findUserCount(UserQueryVo userQueryVo) throws Exception;\r\n```\r\n\r\n```\r\n//测试用户信息综合查询总数\r\n    @Test\r\n    public void testFindUserCount() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建usermapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //创建包装对象，设置查询条件\r\n        UserQueryVo userQueryVo = new UserQueryVo();\r\n        UserCustom userCustom = new UserCustom();\r\n        userCustom.setSex(\"男\");\r\n        userCustom.setUsername(\"张小明\");\r\n        userQueryVo.setUserCustom(userCustom);\r\n        //调用UserMapper的方法\r\n        System.out.println(userMapper.findUserCount(userQueryVo));\r\n    }\r\n```\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test6.jpg)\r\n\r\n注意：查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。\r\n\r\n**输出pojo对象和pojo列表**\r\n\r\n不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。\r\n\r\n在mapper.java指定的方法返回值类型不一样：\r\n\r\n1、输出单个pojo对象，方法返回值是单个对象类型\r\n\r\n```\r\n//根据id查询用户信息\r\n    public User findUserById(int id) throws Exception;\r\n```\r\n\r\n2、输出pojo对象list，方法返回值是List\r\n\r\n```\r\n  //根据用户名查询用户信息\r\n    public List<User> findUserByUsername(String userName) throws  Exception;\r\n```\r\n\r\nresultType总结：\r\n\r\n输出pojo对象和输出pojo列表在sql中定义的resultType是一样的。\r\n\r\n返回单个pojo对象要保证sql查询出来的结果集为单条，内部使用session.selectOne方法调用，mapper接口使用pojo对象作为方法返回值。\r\n\r\n返回pojo列表表示查询出来的结果集可能为多条，内部使用session.selectList方法，mapper接口使用List对象作为方法返回值。\r\n\r\n*   **resultMap**\r\n\r\nresultType 可以指定 pojo 将查询结果映射为 pojo，但需要 pojo 的属性名和 sql 查询的列名一致方可映射成功。\r\n\r\n如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。\r\n\r\nresultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。\r\n\r\n使用方法：\r\n\r\n1、定义 resultMap\r\n\r\n2、使用 resultMap 作为 statement 的输出映射类型\r\n\r\n将下面的 sql 使用 User 完成映射\r\n\r\n```\r\nselect id id_, username username_ from user where id = #{value}\r\n```\r\n\r\nUser 类中属性名和上边查询的列名不一致。\r\n\r\n所以需要：\r\n\r\n1、定义 resultMap\r\n\r\n```\r\n<!--定义 resultMap\r\n    将select id id_, username username_ from user where id = #{value} 和User类中的属性做一个映射关系\r\n    type: resultMap最终映射的java对象类型\r\n    id:对resultMap的唯一标识\r\n    -->\r\n    <resultMap id=\"userResultMap\" type=\"user\">\r\n        <!--id表示查询结果中的唯一标识\r\n        column：查询出来的列名\r\n        property：type指定pojo的属性名\r\n        最终resultMap对column和property做一个映射关系（对应关系）\r\n        -->\r\n        <id column=\"id_\" property=\"id\"/>\r\n\r\n        <!--result: 对普通结果映射定义\r\n        column：查询出来的列名\r\n        property：type指定pojo的属性名\r\n        最终resultMap对column和property做一个映射关系（对应关系）\r\n        -->\r\n        <result column=\"username_\" property=\"username\"/>\r\n    </resultMap>\r\n```\r\n\r\n2、使用 resultMap 作为 statement 的输出映射类型\r\n\r\n```\r\n<!--使用 resultMap 作为输出映射类型\r\n        resultMap=\"userResultMap\":其中的userResultMap就是我们刚才定义的 resultMap 的id值,如果这个resultMap在其他的mapper文件中，前边须加上namespace -->\r\n    <select id=\"findUserByIdResultMap\" parameterType=\"int\" resultMap=\"userResultMap\">\r\n        select id id_, username username_ from user where id = #{value}\r\n    </select>\r\n```\r\n\r\n3、`UserMapper.java`\r\n\r\n```\r\n//根据id查询用户信息，使用 resultMap 输出\r\npublic User findUserByIdResultMap(int id) throws Exception;\r\n```\r\n\r\n4、测试\r\n\r\n```\r\n//测试根据id查询用户信息，使用 resultMap 输出\r\n    @Test\r\n    public void testFindUserByIdResultMap() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建usermapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //调用UserMapper的方法\r\n        User user = userMapper.findUserByIdResultMap(1);\r\n        System.out.println(user);\r\n    }\r\n```\r\n\r\n5、测试结果\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test7.jpg)\r\n\r\n## 动态 SQL\r\n\r\n通过mybatis提供的各种标签方法实现动态拼接sql。\r\n\r\n需求：\r\n\r\n用户信息综合查询列表和用户信息查询列表总数这两个 statement的定义使用动态sql。\r\n\r\n对查询条件进行判断，如果输入的参数不为空才进行查询条件拼接。\r\n\r\n`UserMapper.xml` (findUserList的配置如下，那么findUserCount的也是一样的，这里就不全部写出来了)\r\n\r\n```\r\n<select id=\"findUserList\" parameterType=\"cn.zhisheng.mybatis.po.UserQueryVo\" resultType=\"cn.zhisheng.mybatis.po.UserCustom\">\r\n        select * from user\r\n        <!--where可以自动的去掉条件中的第一个and-->\r\n        <where>\r\n            <if test=\"userCustom != null\">\r\n                <if test=\"userCustom.sex != null and userCustom.sex != \'\'\">\r\n                    and user.sex = #{userCustom.sex}\r\n                </if>\r\n                <if test=\"userCustom.username != null\">\r\n                    and user.username like  \'%${userCustom.username}%\'\r\n                </if>\r\n            </if>\r\n        </where>\r\n    </select>\r\n```\r\n\r\n测试代码：因为设置了动态的sql，如果不设置某个值，那么条件就不会拼接在sql上\r\n\r\n所以我们就注释掉设置username的语句\r\n\r\n```\r\n//userCustom.setUsername(\"张小明\");\r\n```\r\n\r\n测试结果：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test8.jpg)\r\n\r\n### Sql 片段\r\n\r\n通过上面的其实看到在 where sql语句中有很多重复代码，我们可以将其抽取出来，组成一个sql片段，其他的statement就可以引用这个sql片段，利于系统的开发。\r\n\r\n这里我们就拿上边sql 中的where定义一个sq片段如下：\r\n\r\n```\r\n <!--sql片段\r\n    id:唯一标识\r\n    经验：是基于单表来定义sql片段，这样的话sql片段的可重用性才高\r\n    一般不包含where\r\n    -->\r\n    <sql id=\"query_user_where\">\r\n        <if test=\"userCustom != null\">\r\n            <if test=\"userCustom.sex != null and userCustom.sex != \'\'\">\r\n                and user.sex = #{userCustom.sex}\r\n            </if>\r\n            <if test=\"userCustom.username != null\">\r\n                and user.username like  \'%${userCustom.username}%\'\r\n            </if>\r\n        </if>\r\n    </sql>\r\n```\r\n\r\n那么我们该怎样引用这个sql片段呢？如下：\r\n\r\n```\r\nselect * from user\r\n        <where>\r\n        <!--refid: 指定sql片段的id，如果是写在其他的mapper文件中，则需要在前面加上namespace-->\r\n            <include refid=\"query_user_where\"/>\r\n        </where>\r\n```\r\n\r\n测试的话还是那样了，就不继续说了，前面已经说了很多了。\r\n\r\n### foreach\r\n\r\n向sql传递数组或List，mybatis使用foreach解析\r\n\r\n需求：\r\n\r\n在用户查询列表和查询总数的statement中增加多个id输入查询。\r\n\r\nsql语句如下：\r\n\r\n```\r\nSELECT * FROM USER WHERE id=1 OR id=10 ORid=16\r\n或者\r\nSELECT * FROM USER WHERE id IN(1,10,16)\r\n```\r\n\r\n在输入参数类型中添加 List ids 传入多个 id\r\n\r\n```\r\npublic class UserQueryVo    //用户包装类型\r\n{\r\n    //传入多个id\r\n    private List<Integer> ids;\r\n}\r\n```\r\n\r\n修改 UserMapper.xml文件\r\n\r\nWHERE id=1 OR id=10 OR id=16\r\n\r\n在查询条件中，查询条件定义成一个sql片段，需要修改sql片段。\r\n\r\n```\r\n<if test=\"ids!=null\">\r\n            <!-- 使用 foreach遍历传入ids\r\n            collection：指定输入 对象中集合属性\r\n            item：每个遍历生成对象中\r\n            open：开始遍历时拼接的串\r\n            close：结束遍历时拼接的串\r\n            separator：遍历的两个对象中需要拼接的串\r\n             -->\r\n             <!-- 使用实现下边的sql拼接：\r\n              AND (id=1 OR id=10 OR id=16) \r\n              -->\r\n            <foreach collection=\"ids\" item=\"user_id\" open=\"AND (\" close=\")\" separator=\"or\">\r\n                <!-- 每个遍历需要拼接的串 -->\r\n                id=#{user_id}\r\n            </foreach>\r\n\r\n            <!-- 实现  “ and id IN(1,10,16)”拼接 -->\r\n            <!-- <foreach collection=\"ids\" item=\"user_id\" open=\"and id IN(\" close=\")\" separator=\",\">\r\n                每个遍历需要拼接的串\r\n                #{user_id}\r\n            </foreach> -->  \r\n            </if>\r\n```\r\n\r\n测试代码：\r\n\r\n```\r\n //传入多个id\r\nList<Integer> ids = new ArrayList<>();\r\nids.add(1);\r\nids.add(10);\r\nids.add(16);\r\n//将ids传入statement中\r\nuserQueryVo.setIds(ids);\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('77', 'mybatis查询结果映射', '<h2 id=\"h2-1mybatis-\"><a name=\"1Mybatis 高级知识\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1Mybatis 高级知识</h2><p>安排：对订单商品数据模型进行分析</p>\r\n<h2 id=\"h2-2-\"><a name=\"2订单商品数据模型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2订单商品数据模型</h2><p><img src=\"http://ohfk1r827.bkt.clouddn.com/sql.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-3-\"><a name=\"3数据模型分析思路：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3数据模型分析思路：</h3><p>1、每张表记录的数据内容（分模块对每张表记录的内容进行熟悉，相当于学习系统需求的过程）</p>\r\n<p>2、每张表重要的的字段设置（非空字段、外键字段）</p>\r\n<p>3、<a href=\"http://lib.csdn.net/base/mysql\" title=\"MySQL知识库\">数据库</a>级别表与表之间的关系（外键关系）</p>\r\n<p>4、表与表业务之间的关系（要建立在每个业务意义的基础上去分析）</p>\r\n<h3 id=\"h3-4-\"><a name=\"4数据模型分析模型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4数据模型分析模型</h3><ul>\r\n<li>用户表 user：记录购买商品的用户信息</li><li>订单表 order：记录用户所创建的订单(购买商品的订单)</li><li>订单明细表 orderdetail：（记录了订单的详细信息即购买商品的信息）</li><li>商品表 items：记录了商品信息</li></ul>\r\n<p><strong>表与表业务之间的关系</strong>：</p>\r\n<p>在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分析。</p>\r\n<p>先分析数据级别之间有关系的表之间的业务关系：</p>\r\n<p>1、<strong>usre和orders</strong>：</p>\r\n<p>user —&gt; orders：一个用户可以创建多个订单，一对多</p>\r\n<p>orders —&gt; user：一个订单只由一个用户创建，一对一</p>\r\n<p>2、 <strong>orders和orderdetail</strong>：</p>\r\n<p>orders —&gt; orderdetail：一个订单可以包括 多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系</p>\r\n<p>orderdetail —&gt; orders：一个订单明细只能包括在一个订单中，一对一</p>\r\n<p>3、 <strong>orderdetail 和 itesm</strong>：</p>\r\n<p>orderdetail —&gt; itesms：一个订单明细只对应一个商品信息，一对一</p>\r\n<p>items —&gt; orderdetail:一个商品可以包括在多个订单明细 ，一对多</p>\r\n<p>再分析数据库级别没有关系的表之间是否有业务关系：</p>\r\n<p>4、 <strong>orders 和 items</strong>：</p>\r\n<p>orders 和 items 之间可以通过 orderdetail 表建立 关系。</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/sqlmodel.jpg\" alt=\"\"></p>\r\n<h2 id=\"h2-5-\"><a name=\"5一对一查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5一对一查询</h2><h3 id=\"h3-6-\"><a name=\"6需求：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6需求：</h3><p>查询订单信息，关联查询创建订单的用户信息</p>\r\n<h3 id=\"h3-7-resulttype\"><a name=\"7使用 resultType\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7使用 resultType</h3><ul>\r\n<li><p>sql 语句</p>\r\n<p>确定查询的主表：订单表</p>\r\n<p>确定查询的关联表：用户表</p>\r\n<p>关联查询使用内链接？还是外链接？</p>\r\n<p>由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内链接。</p>\r\n<pre><code>SELECT orders.*, USER.username, USER.sex, USER.address FROM orders, USER WHERE orders.user_id = user.id\r\n</code></pre></li><li><p>创建 pojo</p>\r\n<p><code>Orders.[Java](http://lib.csdn.net/base/javase &quot;Java SE知识库&quot;)</code></p>\r\n<pre><code>public class Orders {\r\n  private Integer id;\r\n  private Integer userId;\r\n  private String number;\r\n  private Date createtime;\r\n  private String note;\r\n  //用户信息\r\n  private User user;\r\n  //订单明细\r\n  private List&lt;Orderdetail&gt; orderdetails;\r\n  //getter and setter\r\n}\r\n</code></pre><p><code>OrderCustom.java</code></p>\r\n<pre><code>//通过此类映射订单和用户查询的结果，让此类继承包括 字段较多的pojo类\r\npublic class OrdersCustom extends Orders{\r\n//添加用户属性\r\n/*USER.username,\r\n  USER.sex,\r\n  USER.address */\r\nprivate String username;\r\nprivate String sex;\r\nprivate String address;\r\n//getter and setter \r\n}\r\n</code></pre></li><li><p>映射文件</p>\r\n<p><code>OrdersMapperCustom.xml</code></p>\r\n<pre><code>&lt;!--查询订单关联查询用户信息--&gt;\r\n  &lt;select id=&quot;findOrdersUser&quot; resultType=&quot;cn.zhisheng.mybatis.po.OrdersCustom&quot;&gt;\r\n      SELECT orders.*, USER.username, USER.sex, USER.address FROM orders, USER WHERE orders.user_id = user.id\r\n  &lt;/select&gt;\r\n</code></pre></li><li><p>Mapper 文件</p>\r\n<p><code>OrdersMapperCustom.java</code></p>\r\n<pre><code>public interface OrdersMapperCustom\r\n{\r\n  public OrdersCustom findOrdersUser() throws Exception;\r\n}\r\n</code></pre></li><li><p><a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\">测试</a>代码（记得在 SqlConfig.xml中添加载 OrdersMapperCustom.xml 文件）</p>\r\n<pre><code><a href=\"https://github.com/Test\" title=\"&#64;Test\" class=\"at-link\">@Test</a>\r\n  public void testFindOrdersUser() throws Exception\r\n  {\r\n      SqlSession sqlSession = sqlSessionFactory.openSession();\r\n      //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n      OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n      //调用OrdersMapperCustom的方法\r\n       List&lt;OrdersCustom&gt; list = ordersMapperCustom.findOrdersUser();\r\n      System.out.println(list);\r\n      sqlSession.close();\r\n  }\r\n</code></pre></li><li><p>测试结果</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test9.jpg\" alt=\"\"></p>\r\n<p>?</p>\r\n<p>?</p>\r\n</li></ul>\r\n<h3 id=\"h3-8-resultmap\"><a name=\"8使用 resultMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8使用 resultMap</h3><ul>\r\n<li><p>sql 语句（和上面的一致）</p>\r\n</li><li><p>使用 resultMap 映射思路</p>\r\n<p>使用 resultMap 将查询结果中的订单信息映射到 Orders 对象中，在 orders 类中添加 User 属性，将关联查询出来的用户信息映射到 orders 对象中的 user 属性中。</p>\r\n<pre><code>//用户信息\r\nprivate User user;\r\n</code></pre></li><li><p>映射文件</p>\r\n<p><code>OrdersMapperCustom.xml</code></p>\r\n<p>先定义 resultMap</p>\r\n<pre><code>&lt;!--定义查询订单关联查询用户信息的resultMap\r\n      将整个查询结果映射到cn.zhisheng.mybatis.po.Orders\r\n  --&gt;\r\n  &lt;resultMap id=&quot;OrdersUserResultMap&quot; type=&quot;cn.zhisheng.mybatis.po.Orders&quot;&gt;\r\n      &lt;!--配置映射的订单信息--&gt;\r\n      &lt;!--id表示查询结果中的唯一标识  在这里是订单的唯一标识  如果是由多列组成的唯一标识，那么就需要配置多个id\r\n      column：id 是订单信息中的唯一标识列\r\n      property：id 是订单信息唯一标识列所映射到orders中的id属性\r\n      最终resultMap对column和property做一个映射关系（对应关系）\r\n      --&gt;\r\n      &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;\r\n      &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;\r\n      &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;\r\n      &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;\r\n      &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;\r\n\r\n      &lt;!--配置映射的关联用户信息\r\n          association 用于映射关联查询单个对象的信息\r\n          property  将要关联查询的用户信息映射到 orders中的属性中去\r\n      --&gt;\r\n      &lt;association property=&quot;user&quot; javaType=&quot;cn.zhisheng.mybatis.po.User&quot;&gt;\r\n          &lt;!--id 关联用户信息的唯一标识\r\n              column: 指定唯一标识用户的信息\r\n              property：映射到user的那个属性\r\n          --&gt;\r\n          &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;\r\n          &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;\r\n          &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;\r\n          &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;\r\n          &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;\r\n      &lt;/association&gt;\r\n  &lt;/resultMap&gt;\r\n</code></pre><pre><code>&lt;!--查询订单关联查询用户信息, 使用 resultMap--&gt;\r\n  &lt;select id=&quot;findOrdersUserResultMap&quot; resultMap=&quot;OrdersUserResultMap&quot;&gt;\r\n      SELECT orders.*, USER.username, USER.sex, USER.address FROM orders, USER WHERE orders.user_id = user.id\r\n  &lt;/select&gt;\r\n</code></pre></li><li><p>Mapper 文件</p>\r\n<pre><code>public List&lt;Orders&gt; findOrdersUserResultMap() throws Exception;\r\n</code></pre></li><li><p>测试代码</p>\r\n<pre><code><a href=\"https://github.com/Test\" title=\"&#64;Test\" class=\"at-link\">@Test</a>\r\n  public void testFindOrdersUserResultMap() throws Exception\r\n  {\r\n      SqlSession sqlSession = sqlSessionFactory.openSession();\r\n      //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n      OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n      //调用OrdersMapperCustom的方法\r\n      List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserResultMap();\r\n      System.out.println(list);\r\n      sqlSession.close();\r\n  }\r\n</code></pre></li><li><p>测试结果</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test10.jpg\" alt=\"\"></p>\r\n</li></ul>\r\n<h3 id=\"h3-9-resulttype-resultmap-\"><a name=\"9使用 resultType 和 resultMap 一对一查询小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9使用 resultType 和 resultMap 一对一查询小结</h3><ul>\r\n<li>resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。</li><li>resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。resultMap可以实现延迟加载，resultType无法实现延迟加载。</li></ul>\r\n<h2 id=\"h2-10-\"><a name=\"10一对多查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10一对多查询</h2><p><strong>需求</strong>：查询订单及订单明细信息</p>\r\n<p><strong>SQL语句</strong>：</p>\r\n<p>确定主查询表：订单表</p>\r\n<p>确定关联查询表：订单明细表</p>\r\n<p>在一对一查询基础上添加订单明细表关联即可。</p>\r\n<pre><code>SELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id FROM orders, USER,\r\norderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n</code></pre><p>分析：</p>\r\n<p>使用 resultType 将上边的查询结果映射到 pojo 中，订单信息的就是重复。</p>\r\n<p>要求：</p>\r\n<blockquote>\r\n<p>对 orders 映射不能出现重复记录。</p>\r\n</blockquote>\r\n<p>在 orders.java 类中添加 List orderDetails 属性。</p>\r\n<p>最终会将订单信息映射到 orders 中，订单所对应的订单明细映射到 orders 中的 orderDetails 属性中。</p>\r\n<p>映射成的 orders 记录数为两条（orders信息不重复）</p>\r\n<p>每个 orders 中的 orderDetails 属性存储了该订单所对应的订单明细。</p>\r\n<p><strong>映射文件</strong>：</p>\r\n<p>首先定义 resultMap</p>\r\n<pre><code>&lt;!--定义查询订单及订单明细信息的resultMap使用extends继承，不用在中配置订单信息和用户信息的映射--&gt;\r\n    &lt;resultMap id=&quot;OrdersAndOrderDetailResultMap&quot; type=&quot;cn.zhisheng.mybatis.po.Orders&quot; extends=&quot;OrdersUserResultMap&quot;&gt;\r\n        &lt;!-- 订单信息 --&gt;\r\n        &lt;!-- 用户信息 --&gt;\r\n        &lt;!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 --&gt;\r\n        &lt;!-- 订单明细信息\r\n        一个订单关联查询出了多条明细，要使用collection进行映射\r\n        collection：对关联查询到多条记录映射到集合对象中\r\n        property：将关联查询到多条记录映射到cn.zhisheng.mybatis.po.Orders哪个属性\r\n        ofType：指定映射到list集合属性中pojo的类型\r\n         --&gt;\r\n        &lt;collection property=&quot;orderdetails&quot; ofType=&quot;cn.zhisheng.mybatis.po.Orderdetail&quot;&gt;\r\n        &lt;!-- id：订单明细唯 一标识\r\n   property:要将订单明细的唯 一标识 映射到cn.zhisheng.mybatis.po.Orderdetail的哪个属性--&gt;\r\n            &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;\r\n            &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;\r\n            &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;\r\n            &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;\r\n        &lt;/collection&gt;\r\n    &lt;/resultMap&gt;\r\n</code></pre><pre><code> &lt;!--查询订单及订单明细信息, 使用 resultMap--&gt;\r\n    &lt;select id=&quot;findOrdersAndOrderDetailResultMap&quot; resultMap=&quot;OrdersAndOrderDetailResultMap&quot;&gt;\r\n        SELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id\r\n        FROM orders, USER,orderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n    &lt;/select&gt;\r\n</code></pre><p><strong>Mapper 文件</strong></p>\r\n<pre><code>public List&lt;Orders&gt; findOrdersAndOrderDetailResultMap() throws Exception;\r\n</code></pre><p><strong>测试文件</strong></p>\r\n<pre><code>@Test\r\n    public void testFindOrdersAndOrderDetailResultMap() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n        OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n        //调用OrdersMapperCustom的方法\r\n        List&lt;Orders&gt; list = ordersMapperCustom.findOrdersAndOrderDetailResultMap();\r\n        System.out.println(list);\r\n        sqlSession.close();\r\n    }\r\n</code></pre><p><strong>测试结果</strong></p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test11.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-11-\"><a name=\"11总结：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11总结：</h3><p>mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。</p>\r\n<p>使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。</p>\r\n<h2 id=\"h2-12-\"><a name=\"12多对多查询\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12多对多查询</h2><p><strong>需求</strong>：查询用户及用户购买商品信息。</p>\r\n<p><strong>SQL语句</strong>：</p>\r\n<p>查询主表是：用户表</p>\r\n<p>关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：</p>\r\n<p>orders、orderdetail、items</p>\r\n<pre><code>SELECT   orders.*, USER.username, USER.sex, USER.address,  orderdetail.id orderdetail_id,\r\norderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name,\r\nitems.detail items_detail, items.price items_price FROM orders, USER, orderdetail, items WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id\r\n</code></pre><p><strong>映射思路</strong>：</p>\r\n<p>将用户信息映射到 user 中。<br>在 user 类中添加订单列表属性List orderslist，将用户创建的订单映射到orderslist<br>在Orders中添加订单明细列表属性Listorderdetials，将订单的明细映射到orderdetials<br>在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items</p>\r\n<h3 id=\"h3-13-resultmap-\"><a name=\"13定义 resultMap：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>13定义 resultMap：</h3><pre><code>&lt;!--定义查询用户及用户购买商品信息的 resultMap--&gt;\r\n    &lt;resultMap id=&quot;UserAndItemsResultMap&quot; type=&quot;cn.zhisheng.mybatis.po.User&quot;&gt;\r\n        &lt;!--用户信息--&gt;\r\n        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;\r\n        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;\r\n        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;\r\n        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;\r\n        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;\r\n\r\n        &lt;!--订单信息\r\n            一个用户对应多个订单，使用collection映射\r\n        --&gt;\r\n        &lt;collection property=&quot;ordersList&quot; ofType=&quot;cn.zhisheng.mybatis.po.Orders&quot;&gt;\r\n            &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;\r\n            &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;\r\n            &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;\r\n            &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;\r\n            &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;\r\n\r\n            &lt;!-- 订单明细\r\n                一个订单包括 多个明细\r\n            --&gt;\r\n            &lt;collection property=&quot;orderdetails&quot; ofType=&quot;cn.zhisheng.mybatis.po.Orderdetail&quot;&gt;\r\n\r\n                &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;\r\n                &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;\r\n                &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;\r\n                &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;\r\n\r\n                &lt;!-- 商品信息\r\n                     一个订单明细对应一个商品\r\n                --&gt;\r\n                &lt;association property=&quot;items&quot; javaType=&quot;cn.zhisheng.mybatis.po.Items&quot;&gt;\r\n                    &lt;id column=&quot;items_id&quot; property=&quot;id&quot;/&gt;\r\n                    &lt;result column=&quot;items_name&quot; property=&quot;name&quot;/&gt;\r\n                    &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;\r\n                    &lt;result column=&quot;items_pic&quot; property=&quot;pic&quot;/&gt;\r\n                    &lt;result column=&quot;items_createtime&quot; property=&quot;createtime&quot;/&gt;\r\n                    &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;\r\n                 &lt;/association&gt;\r\n            &lt;/collection&gt;\r\n        &lt;/collection&gt;\r\n    &lt;/resultMap&gt;\r\n</code></pre><h3 id=\"h3-14-\"><a name=\"14映射文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14映射文件</h3><pre><code>&lt;!--查询用户及用户购买商品信息, 使用 resultMap--&gt;\r\n    &lt;select id=&quot;findUserAndItemsResultMap&quot; resultMap=&quot;UserAndItemsResultMap&quot;&gt;\r\n        SELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id\r\n        FROM orders, USER,orderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n    &lt;/select&gt;\r\n</code></pre><h3 id=\"h3-15mapper-\"><a name=\"15Mapper 文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15Mapper 文件</h3><pre><code>public List&lt;User&gt; findUserAndItemsResultMap() throws  Exception;\r\n</code></pre><h3 id=\"h3-16-\"><a name=\"16测试文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>16测试文件</h3><pre><code>@Test\r\n    public void testFindUserAndItemsResultMap() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n        OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n        //调用OrdersMapperCustom的方法\r\n        List&lt;User&gt; list = ordersMapperCustom.findUserAndItemsResultMap();\r\n        System.out.println(list);\r\n        sqlSession.close();\r\n    }\r\n</code></pre><h3 id=\"h3-17-\"><a name=\"17测试：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>17测试：</h3><p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test12.jpg\" alt=\"\"></p>\r\n<p>我去，竟然报错了，但是不要怕，通过查看报错信息可以知道我忘记在 User.java 中加入 orderlist 属性了，接下来我加上去，并加上 getter 和 setter 方法。</p>\r\n<pre><code>//用户创建的订单列表\r\n    private List&lt;Orders&gt; ordersList;\r\n    public List&lt;Orders&gt; getOrdersList() {\r\n        return ordersList;\r\n    }\r\n    public void setOrdersList(List&lt;Orders&gt; ordersList) {\r\n        this.ordersList = ordersList;\r\n    }\r\n</code></pre><p>再次测试就能成功了。</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test13.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-18-\"><a name=\"18多对多查询总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>18多对多查询总结</h3><p>将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量）</p>\r\n<p>针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。</p>\r\n<p>一对多是多对多的特例，如下需求：</p>\r\n<blockquote>\r\n<p>查询用户购买的商品信息，用户和商品的关系是多对多关系。</p>\r\n</blockquote>\r\n<p>需求1：</p>\r\n<blockquote>\r\n<p>查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)</p>\r\n<p>企业开发中常见明细列表，用户购买商品明细列表，</p>\r\n<p>使用resultType将上边查询列映射到pojo输出。</p>\r\n</blockquote>\r\n<p>需求2：</p>\r\n<blockquote>\r\n<p>查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）</p>\r\n<p>使用resultMap将用户购买的商品明细列表映射到user对象中。</p>\r\n</blockquote>\r\n<p>总结：</p>\r\n<blockquote>\r\n<p>使用resultMap是针对那些对查询结果映射有特殊要求的功能，，比如特殊要求映射成list中包括多个list。</p>\r\n</blockquote>\r\n<h2 id=\"h2-19resultmap-\"><a name=\"19ResultMap 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>19ResultMap 总结</h2><h3 id=\"h3-20resulttype-\"><a name=\"20resultType：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>20resultType：</h3><p>作用：</p>\r\n<blockquote>\r\n<p>将查询结果按照sql列名pojo属性名一致性映射到pojo中。</p>\r\n</blockquote>\r\n<p>场合：</p>\r\n<blockquote>\r\n<p>常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。</p>\r\n</blockquote>\r\n<h3 id=\"h3-21resultmap-\"><a name=\"21resultMap：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>21resultMap：</h3><blockquote>\r\n<p>使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。</p>\r\n</blockquote>\r\n<h3 id=\"h3-22association-\"><a name=\"22association：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>22association：</h3><p>作用：</p>\r\n<blockquote>\r\n<p>将关联查询信息映射到一个pojo对象中。</p>\r\n</blockquote>\r\n<p>场合：</p>\r\n<blockquote>\r\n<p>为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。<br>使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。</p>\r\n</blockquote>\r\n<h3 id=\"h3-23collection-\"><a name=\"23collection：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>23collection：</h3><p>作用：</p>\r\n<blockquote>\r\n<p>将关联查询信息映射到一个list集合中。</p>\r\n</blockquote>\r\n<p>场合：</p>\r\n<blockquote>\r\n<p>为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。</p>\r\n</blockquote>\r\n', '103', '\r\n\r\n## 1Mybatis 高级知识\r\n\r\n安排：对订单商品数据模型进行分析\r\n\r\n## 2订单商品数据模型\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/sql.jpg)\r\n\r\n### 3数据模型分析思路：\r\n\r\n1、每张表记录的数据内容（分模块对每张表记录的内容进行熟悉，相当于学习系统需求的过程）\r\n\r\n2、每张表重要的的字段设置（非空字段、外键字段）\r\n\r\n3、[数据库](http://lib.csdn.net/base/mysql \"MySQL知识库\")级别表与表之间的关系（外键关系）\r\n\r\n4、表与表业务之间的关系（要建立在每个业务意义的基础上去分析）\r\n\r\n### 4数据模型分析模型\r\n\r\n*   用户表 user：记录购买商品的用户信息\r\n*   订单表 order：记录用户所创建的订单(购买商品的订单)\r\n*   订单明细表 orderdetail：（记录了订单的详细信息即购买商品的信息）\r\n*   商品表 items：记录了商品信息\r\n\r\n**表与表业务之间的关系**：\r\n\r\n在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分析。\r\n\r\n先分析数据级别之间有关系的表之间的业务关系：\r\n\r\n1、**usre和orders**：\r\n\r\nuser —> orders：一个用户可以创建多个订单，一对多\r\n\r\norders —> user：一个订单只由一个用户创建，一对一\r\n\r\n2、 **orders和orderdetail**：\r\n\r\norders —> orderdetail：一个订单可以包括 多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系\r\n\r\norderdetail —> orders：一个订单明细只能包括在一个订单中，一对一\r\n\r\n3、 **orderdetail 和 itesm**：\r\n\r\norderdetail —> itesms：一个订单明细只对应一个商品信息，一对一\r\n\r\nitems —> orderdetail:一个商品可以包括在多个订单明细 ，一对多\r\n\r\n再分析数据库级别没有关系的表之间是否有业务关系：\r\n\r\n4、 **orders 和 items**：\r\n\r\norders 和 items 之间可以通过 orderdetail 表建立 关系。\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/sqlmodel.jpg)\r\n\r\n## 5一对一查询\r\n\r\n### 6需求：\r\n\r\n查询订单信息，关联查询创建订单的用户信息\r\n\r\n### 7使用 resultType\r\n\r\n*   sql 语句\r\n\r\n    确定查询的主表：订单表\r\n\r\n    确定查询的关联表：用户表\r\n\r\n    关联查询使用内链接？还是外链接？\r\n\r\n    由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内链接。\r\n\r\n    ```\r\n    SELECT orders.*, USER.username, USER.sex, USER.address FROM orders, USER WHERE orders.user_id = user.id\r\n    ```\r\n\r\n*   创建 pojo\r\n\r\n    `Orders.[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")`\r\n\r\n    ```\r\n    public class Orders {\r\n      private Integer id;\r\n      private Integer userId;\r\n      private String number;\r\n      private Date createtime;\r\n      private String note;\r\n      //用户信息\r\n      private User user;\r\n      //订单明细\r\n      private List<Orderdetail> orderdetails;\r\n      //getter and setter\r\n    }\r\n    ```\r\n\r\n    `OrderCustom.java`\r\n\r\n    ```\r\n    //通过此类映射订单和用户查询的结果，让此类继承包括 字段较多的pojo类\r\n    public class OrdersCustom extends Orders{\r\n    //添加用户属性\r\n    /*USER.username,\r\n      USER.sex,\r\n      USER.address */\r\n    private String username;\r\n    private String sex;\r\n    private String address;\r\n    //getter and setter \r\n    }\r\n    ```\r\n\r\n*   映射文件\r\n\r\n    `OrdersMapperCustom.xml`\r\n\r\n    ```\r\n    <!--查询订单关联查询用户信息-->\r\n      <select id=\"findOrdersUser\" resultType=\"cn.zhisheng.mybatis.po.OrdersCustom\">\r\n          SELECT orders.*, USER.username, USER.sex, USER.address FROM orders, USER WHERE orders.user_id = user.id\r\n      </select>\r\n    ```\r\n\r\n*   Mapper 文件\r\n\r\n    `OrdersMapperCustom.java`\r\n\r\n    ```\r\n    public interface OrdersMapperCustom\r\n    {\r\n      public OrdersCustom findOrdersUser() throws Exception;\r\n    }\r\n    ```\r\n\r\n*   [测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")代码（记得在 SqlConfig.xml中添加载 OrdersMapperCustom.xml 文件）\r\n\r\n    ```\r\n    @Test\r\n      public void testFindOrdersUser() throws Exception\r\n      {\r\n          SqlSession sqlSession = sqlSessionFactory.openSession();\r\n          //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n          OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n          //调用OrdersMapperCustom的方法\r\n           List<OrdersCustom> list = ordersMapperCustom.findOrdersUser();\r\n          System.out.println(list);\r\n          sqlSession.close();\r\n      }\r\n    ```\r\n\r\n*   测试结果\r\n\r\n    ![](http://ohfk1r827.bkt.clouddn.com/Test9.jpg)\r\n\r\n    ?\r\n\r\n    ?\r\n\r\n### 8使用 resultMap\r\n\r\n*   sql 语句（和上面的一致）\r\n\r\n*   使用 resultMap 映射思路\r\n\r\n    使用 resultMap 将查询结果中的订单信息映射到 Orders 对象中，在 orders 类中添加 User 属性，将关联查询出来的用户信息映射到 orders 对象中的 user 属性中。\r\n\r\n    ```\r\n    //用户信息\r\n    private User user;\r\n    ```\r\n\r\n*   映射文件\r\n\r\n    `OrdersMapperCustom.xml`\r\n\r\n    先定义 resultMap\r\n\r\n    ```\r\n    <!--定义查询订单关联查询用户信息的resultMap\r\n          将整个查询结果映射到cn.zhisheng.mybatis.po.Orders\r\n      -->\r\n      <resultMap id=\"OrdersUserResultMap\" type=\"cn.zhisheng.mybatis.po.Orders\">\r\n          <!--配置映射的订单信息-->\r\n          <!--id表示查询结果中的唯一标识  在这里是订单的唯一标识  如果是由多列组成的唯一标识，那么就需要配置多个id\r\n          column：id 是订单信息中的唯一标识列\r\n          property：id 是订单信息唯一标识列所映射到orders中的id属性\r\n          最终resultMap对column和property做一个映射关系（对应关系）\r\n          -->\r\n          <id column=\"id\" property=\"id\"/>\r\n          <result column=\"user_id\" property=\"userId\"/>\r\n          <result column=\"number\" property=\"number\"/>\r\n          <result column=\"createtime\" property=\"createtime\"/>\r\n          <result column=\"note\" property=\"note\"/>\r\n\r\n          <!--配置映射的关联用户信息\r\n              association 用于映射关联查询单个对象的信息\r\n              property  将要关联查询的用户信息映射到 orders中的属性中去\r\n          -->\r\n          <association property=\"user\" javaType=\"cn.zhisheng.mybatis.po.User\">\r\n              <!--id 关联用户信息的唯一标识\r\n                  column: 指定唯一标识用户的信息\r\n                  property：映射到user的那个属性\r\n              -->\r\n              <id column=\"user_id\" property=\"id\"/>\r\n              <result column=\"username\" property=\"username\"/>\r\n              <result column=\"sex\" property=\"sex\"/>\r\n              <result column=\"address\" property=\"address\"/>\r\n              <result column=\"birthday\" property=\"birthday\"/>\r\n          </association>\r\n      </resultMap>\r\n    ```\r\n\r\n    ```\r\n    <!--查询订单关联查询用户信息, 使用 resultMap-->\r\n      <select id=\"findOrdersUserResultMap\" resultMap=\"OrdersUserResultMap\">\r\n          SELECT orders.*, USER.username, USER.sex, USER.address FROM orders, USER WHERE orders.user_id = user.id\r\n      </select>\r\n    ```\r\n\r\n*   Mapper 文件\r\n\r\n    ```\r\n    public List<Orders> findOrdersUserResultMap() throws Exception;\r\n    ```\r\n\r\n*   测试代码\r\n\r\n    ```\r\n    @Test\r\n      public void testFindOrdersUserResultMap() throws Exception\r\n      {\r\n          SqlSession sqlSession = sqlSessionFactory.openSession();\r\n          //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n          OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n          //调用OrdersMapperCustom的方法\r\n          List<Orders> list = ordersMapperCustom.findOrdersUserResultMap();\r\n          System.out.println(list);\r\n          sqlSession.close();\r\n      }\r\n    ```\r\n\r\n*   测试结果\r\n\r\n    ![](http://ohfk1r827.bkt.clouddn.com/Test10.jpg)\r\n\r\n### 9使用 resultType 和 resultMap 一对一查询小结\r\n\r\n*   resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。\r\n*   resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。resultMap可以实现延迟加载，resultType无法实现延迟加载。\r\n\r\n## 10一对多查询\r\n\r\n**需求**：查询订单及订单明细信息\r\n\r\n**SQL语句**：\r\n\r\n确定主查询表：订单表\r\n\r\n确定关联查询表：订单明细表\r\n\r\n在一对一查询基础上添加订单明细表关联即可。\r\n\r\n```\r\nSELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id FROM orders, USER,\r\norderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n```\r\n\r\n分析：\r\n\r\n使用 resultType 将上边的查询结果映射到 pojo 中，订单信息的就是重复。\r\n\r\n要求：\r\n\r\n> 对 orders 映射不能出现重复记录。\r\n\r\n在 orders.java 类中添加 List orderDetails 属性。\r\n\r\n最终会将订单信息映射到 orders 中，订单所对应的订单明细映射到 orders 中的 orderDetails 属性中。\r\n\r\n映射成的 orders 记录数为两条（orders信息不重复）\r\n\r\n每个 orders 中的 orderDetails 属性存储了该订单所对应的订单明细。\r\n\r\n**映射文件**：\r\n\r\n首先定义 resultMap\r\n\r\n```\r\n<!--定义查询订单及订单明细信息的resultMap使用extends继承，不用在中配置订单信息和用户信息的映射-->\r\n    <resultMap id=\"OrdersAndOrderDetailResultMap\" type=\"cn.zhisheng.mybatis.po.Orders\" extends=\"OrdersUserResultMap\">\r\n        <!-- 订单信息 -->\r\n        <!-- 用户信息 -->\r\n        <!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 -->\r\n        <!-- 订单明细信息\r\n        一个订单关联查询出了多条明细，要使用collection进行映射\r\n        collection：对关联查询到多条记录映射到集合对象中\r\n        property：将关联查询到多条记录映射到cn.zhisheng.mybatis.po.Orders哪个属性\r\n        ofType：指定映射到list集合属性中pojo的类型\r\n         -->\r\n        <collection property=\"orderdetails\" ofType=\"cn.zhisheng.mybatis.po.Orderdetail\">\r\n        <!-- id：订单明细唯 一标识\r\n   property:要将订单明细的唯 一标识 映射到cn.zhisheng.mybatis.po.Orderdetail的哪个属性-->\r\n            <id column=\"orderdetail_id\" property=\"id\"/>\r\n            <result column=\"items_id\" property=\"itemsId\"/>\r\n            <result column=\"items_num\" property=\"itemsNum\"/>\r\n            <result column=\"orders_id\" property=\"ordersId\"/>\r\n        </collection>\r\n    </resultMap>\r\n```\r\n\r\n```\r\n <!--查询订单及订单明细信息, 使用 resultMap-->\r\n    <select id=\"findOrdersAndOrderDetailResultMap\" resultMap=\"OrdersAndOrderDetailResultMap\">\r\n        SELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id\r\n        FROM orders, USER,orderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n    </select>\r\n```\r\n\r\n**Mapper 文件**\r\n\r\n```\r\npublic List<Orders> findOrdersAndOrderDetailResultMap() throws Exception;\r\n```\r\n\r\n**测试文件**\r\n\r\n```\r\n@Test\r\n    public void testFindOrdersAndOrderDetailResultMap() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n        OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n        //调用OrdersMapperCustom的方法\r\n        List<Orders> list = ordersMapperCustom.findOrdersAndOrderDetailResultMap();\r\n        System.out.println(list);\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n**测试结果**\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test11.jpg)\r\n\r\n### 11总结：\r\n\r\nmybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。\r\n\r\n使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。\r\n\r\n## 12多对多查询\r\n\r\n**需求**：查询用户及用户购买商品信息。\r\n\r\n**SQL语句**：\r\n\r\n查询主表是：用户表\r\n\r\n关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：\r\n\r\norders、orderdetail、items\r\n\r\n```\r\nSELECT   orders.*, USER.username, USER.sex, USER.address,  orderdetail.id orderdetail_id,\r\norderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name,\r\nitems.detail items_detail, items.price items_price FROM orders, USER, orderdetail, items WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id\r\n```\r\n\r\n**映射思路**：\r\n\r\n将用户信息映射到 user 中。\r\n在 user 类中添加订单列表属性List orderslist，将用户创建的订单映射到orderslist\r\n在Orders中添加订单明细列表属性Listorderdetials，将订单的明细映射到orderdetials\r\n在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items\r\n\r\n### 13定义 resultMap：\r\n\r\n```\r\n<!--定义查询用户及用户购买商品信息的 resultMap-->\r\n    <resultMap id=\"UserAndItemsResultMap\" type=\"cn.zhisheng.mybatis.po.User\">\r\n        <!--用户信息-->\r\n        <id column=\"user_id\" property=\"id\"/>\r\n        <result column=\"username\" property=\"username\"/>\r\n        <result column=\"sex\" property=\"sex\"/>\r\n        <result column=\"birthday\" property=\"birthday\"/>\r\n        <result column=\"address\" property=\"address\"/>\r\n\r\n        <!--订单信息\r\n            一个用户对应多个订单，使用collection映射\r\n        -->\r\n        <collection property=\"ordersList\" ofType=\"cn.zhisheng.mybatis.po.Orders\">\r\n            <id column=\"id\" property=\"id\"/>\r\n            <result column=\"user_id\" property=\"userId\"/>\r\n            <result column=\"number\" property=\"number\"/>\r\n            <result column=\"createtime\" property=\"createtime\"/>\r\n            <result column=\"note\" property=\"note\"/>\r\n\r\n            <!-- 订单明细\r\n                一个订单包括 多个明细\r\n            -->\r\n            <collection property=\"orderdetails\" ofType=\"cn.zhisheng.mybatis.po.Orderdetail\">\r\n\r\n                <id column=\"orderdetail_id\" property=\"id\"/>\r\n                <result column=\"orders_id\" property=\"ordersId\"/>\r\n                <result column=\"items_id\" property=\"itemsId\"/>\r\n                <result column=\"items_num\" property=\"itemsNum\"/>\r\n\r\n                <!-- 商品信息\r\n                     一个订单明细对应一个商品\r\n                -->\r\n                <association property=\"items\" javaType=\"cn.zhisheng.mybatis.po.Items\">\r\n                    <id column=\"items_id\" property=\"id\"/>\r\n                    <result column=\"items_name\" property=\"name\"/>\r\n                    <result column=\"items_price\" property=\"price\"/>\r\n                    <result column=\"items_pic\" property=\"pic\"/>\r\n                    <result column=\"items_createtime\" property=\"createtime\"/>\r\n                    <result column=\"items_detail\" property=\"detail\"/>\r\n                 </association>\r\n            </collection>\r\n        </collection>\r\n    </resultMap>\r\n```\r\n\r\n### 14映射文件\r\n\r\n```\r\n<!--查询用户及用户购买商品信息, 使用 resultMap-->\r\n    <select id=\"findUserAndItemsResultMap\" resultMap=\"UserAndItemsResultMap\">\r\n        SELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id\r\n        FROM orders, USER,orderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id\r\n    </select>\r\n```\r\n\r\n### 15Mapper 文件\r\n\r\n```\r\npublic List<User> findUserAndItemsResultMap() throws  Exception;\r\n```\r\n\r\n### 16测试文件\r\n\r\n```\r\n@Test\r\n    public void testFindUserAndItemsResultMap() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n        OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n        //调用OrdersMapperCustom的方法\r\n        List<User> list = ordersMapperCustom.findUserAndItemsResultMap();\r\n        System.out.println(list);\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n### 17测试：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test12.jpg)\r\n\r\n我去，竟然报错了，但是不要怕，通过查看报错信息可以知道我忘记在 User.java 中加入 orderlist 属性了，接下来我加上去，并加上 getter 和 setter 方法。\r\n\r\n```\r\n//用户创建的订单列表\r\n    private List<Orders> ordersList;\r\n    public List<Orders> getOrdersList() {\r\n        return ordersList;\r\n    }\r\n    public void setOrdersList(List<Orders> ordersList) {\r\n        this.ordersList = ordersList;\r\n    }\r\n```\r\n\r\n再次测试就能成功了。\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test13.jpg)\r\n\r\n### 18多对多查询总结\r\n\r\n将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量）\r\n\r\n针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。\r\n\r\n一对多是多对多的特例，如下需求：\r\n\r\n> 查询用户购买的商品信息，用户和商品的关系是多对多关系。\r\n\r\n需求1：\r\n\r\n> 查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)\r\n> \r\n> 企业开发中常见明细列表，用户购买商品明细列表，\r\n> \r\n> 使用resultType将上边查询列映射到pojo输出。\r\n\r\n需求2：\r\n\r\n> 查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）\r\n> \r\n> 使用resultMap将用户购买的商品明细列表映射到user对象中。\r\n\r\n总结：\r\n\r\n> 使用resultMap是针对那些对查询结果映射有特殊要求的功能，，比如特殊要求映射成list中包括多个list。\r\n\r\n## 19ResultMap 总结\r\n\r\n### 20resultType：\r\n\r\n作用：\r\n\r\n> 将查询结果按照sql列名pojo属性名一致性映射到pojo中。\r\n\r\n场合：\r\n\r\n> 常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。\r\n\r\n### 21resultMap：\r\n\r\n> 使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。\r\n\r\n### 22association：\r\n\r\n作用：\r\n\r\n> 将关联查询信息映射到一个pojo对象中。\r\n\r\n场合：\r\n\r\n> 为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。\r\n> 使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。\r\n\r\n### 23collection：\r\n\r\n作用：\r\n\r\n> 将关联查询信息映射到一个list集合中。\r\n\r\n场合：\r\n\r\n> 为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。');
INSERT INTO `article_info_true` VALUES ('78', 'mybatis高级主题', '<h2 id=\"h2-1-\"><a name=\"1延迟加载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1延迟加载</h2><h3 id=\"h3-2-\"><a name=\"2什么是延迟加载？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2什么是延迟加载？</h3><p>resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。<br>需求：<br>如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。</p>\r\n<p>延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高 <a href=\"http://lib.csdn.net/base/mysql\" title=\"MySQL知识库\">数据库</a>性能，因为查询单表要比关联查询多张表速度要快。</p>\r\n<h3 id=\"h3-3-\"><a name=\"3打开延迟加载开关\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3打开延迟加载开关</h3><p>在mybatis核心配置文件中配置：</p>\r\n<p>lazyLoadingEnabled、aggressiveLazyLoading</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th style=\"text-align:center\">设置项</th>\r\n<th style=\"text-align:center\">描述</th>\r\n<th style=\"text-align:center\">允许值</th>\r\n<th style=\"text-align:center\">默认值</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td style=\"text-align:center\">lazyLoadingEnabled</td>\r\n<td style=\"text-align:center\">全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。</td>\r\n<td style=\"text-align:center\">true</td>\r\n<td style=\"text-align:center\">false</td>\r\n<td>false</td>\r\n</tr>\r\n<tr>\r\n<td style=\"text-align:center\">aggressiveLazyLoading</td>\r\n<td style=\"text-align:center\">当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。</td>\r\n<td style=\"text-align:center\">true</td>\r\n<td style=\"text-align:center\">false</td>\r\n<td>true</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>&lt;settings&gt;\r\n        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;\r\n        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;\r\n&lt;/settings&gt;\r\n</code></pre><h3 id=\"h3-4-association-\"><a name=\"4使用 association 实现延迟加载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4使用 association 实现延迟加载</h3><p>需求：查询订单并且关联查询用户信息</p>\r\n<h3 id=\"h3-5mapper-xml\"><a name=\"5Mapper.xml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5Mapper.xml</h3><p>需要定义两个 mapper 的方法对应的 statement。</p>\r\n<p>1、只查询订单信息</p>\r\n<p>SQL 语句： <code>select * from orders</code></p>\r\n<p>在查询订单的 statement 中使用 association 去延迟加载（执行）下边的 statement (关联查询用户信息)</p>\r\n<pre><code>&lt;!--查询订单并且关联查询用户信息，关联用户信息需要通过 association 延迟加载--&gt;\r\n    &lt;select id=&quot;findOrdersUserLazyLoading&quot; resultMap=&quot;OrdersUserLazyLoadingResultMap&quot;&gt;\r\n        select * from orders\r\n    &lt;/select&gt;\r\n</code></pre><p>2、关联查询用户信息</p>\r\n<p>通过上面查询订单信息中的 user_id 来关联查询用户信息。使用 UserMapper.xml 中的 findUserById</p>\r\n<p>SQL语句：<code>select * from user where id = user_id</code></p>\r\n<pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;\r\n        select * from user where id = #{value}\r\n    &lt;/select&gt;\r\n</code></pre><p>上边先去执行 findOrdersUserLazyLoading，当需要去查询用户的时候再去执行 findUserById ，通过 resultMap的定义将延迟加载执行配置起来。也就是通过 resultMap 去加载 UserMapper.xml 文件中的 select = findUserById</p>\r\n<h3 id=\"h3-6-resultmap\"><a name=\"6延迟加载的 resultMap\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6延迟加载的 resultMap</h3><pre><code>&lt;!--定义 关联用户信息（通过 association 延迟加载）的resultMap--&gt;\r\n    &lt;resultMap id=&quot;OrdersUserLazyLoadingResultMap&quot; type=&quot;cn.zhisheng.mybatis.po.Orders&quot;&gt;\r\n        &lt;!--对订单信息映射--&gt;\r\n        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;\r\n        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;\r\n        &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;\r\n        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;\r\n        &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;\r\n        &lt;!-- 实现对用户信息进行延迟加载\r\n        select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）\r\n        要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace\r\n        column：订单信息中关联用户信息查询的列，是user_id\r\n        关联查询的sql理解为：\r\n            SELECT orders.*,\r\n            (SELECT username FROM USER WHERE orders.user_id = user.id)username,\r\n            (SELECT sex FROM USER WHERE orders.user_id = user.id)sex\r\n            FROM orders--&gt;\r\n        &lt;association property=&quot;user&quot; javaType=&quot;cn.zhisheng.mybatis.po.User&quot; select=&quot;cn.zhisheng.mybatis.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&gt;\r\n        &lt;/association&gt;\r\n    &lt;/resultMap&gt;\r\n</code></pre><h3 id=\"h3-7ordermappercustom-java\"><a name=\"7OrderMapperCustom.java\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7OrderMapperCustom.java</h3><pre><code>public List&lt;Orders&gt; findOrdersUserLazyLoading() throws Exception;\r\n</code></pre><h3 id=\"h3-8-\"><a name=\"8测试代码：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8测试代码：</h3><pre><code>@Test\r\n    public void testFindOrdersUserLazyLoading() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n        OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n        //查询订单信息\r\n        List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserLazyLoading();\r\n        //遍历所查询的的订单信息\r\n        for (Orders orders : list)\r\n        {\r\n            //查询用户信息\r\n            User user = orders.getUser();\r\n            System.out.println(user);\r\n        }\r\n        sqlSession.close();\r\n    }\r\n</code></pre><h3 id=\"h3-9-\"><a name=\"9测试结果：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9测试结果：</h3><p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test14.jpg\" alt=\"\"></p>\r\n<p>整个延迟加载的思路：</p>\r\n<p>1、执行上边mapper方法（findOrdersUserLazyLoading），内部去调用cn.zhisheng.mybatis.mapper.OrdersMapperCustom 中的 findOrdersUserLazyLoading 只查询 orders 信息（单表）。</p>\r\n<p>2、在程序中去遍历上一步骤查询出的 List，当我们调用 Orders 中的 getUser 方法时，开始进行延迟加载。</p>\r\n<p>3、延迟加载，去调用 UserMapper.xml 中 findUserbyId 这个方法获取用户信息。</p>\r\n<h3 id=\"h3-10-\"><a name=\"10思考：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10思考：</h3><p>不使用 mybatis 提供的 association 及 collection 中的延迟加载功能，如何实现延迟加载？？</p>\r\n<p>实现方法如下：</p>\r\n<p>定义两个mapper方法：</p>\r\n<p>1、查询订单列表</p>\r\n<p>2、根据用户id查询用户信息</p>\r\n<p>实现思路：</p>\r\n<p>先去查询第一个mapper方法，获取订单信息列表</p>\r\n<p>在程序中（service），按需去调用第二个mapper方法去查询用户信息。</p>\r\n<p>总之：</p>\r\n<p>使用延迟加载方法，先去查询 简单的 sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。</p>\r\n<h3 id=\"h3-11-\"><a name=\"11一对多延迟加载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11一对多延迟加载</h3><p>上面的那个案例是一对一延迟加载，那么如果我们想一对多进行延迟加载呢，其实也是很简单的。</p>\r\n<p>一对多延迟加载的方法同一对一延迟加载，在collection标签中配置select内容。</p>\r\n<h3 id=\"h3-12-\"><a name=\"12延迟加载总结：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12延迟加载总结：</h3><p>作用：</p>\r\n<blockquote>\r\n<p>当需要查询关联信息时再去数据库查询，默认不去关联查询，提高数据库性能。<br>只有使用resultMap支持延迟加载设置。</p>\r\n</blockquote>\r\n<p>场合：</p>\r\n<blockquote>\r\n<p>当只有部分记录需要关联查询其它信息时，此时可按需延迟加载，需要关联查询时再向数据库发出sql，以提高数据库性能。</p>\r\n<p>当全部需要关联查询信息时，此时不用延迟加载，直接将关联查询信息全部返回即可，可使用resultType或resultMap完成映射。</p>\r\n</blockquote>\r\n<h2 id=\"h2-13-\"><a name=\"13查询缓存\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>13查询缓存</h2><h3 id=\"h3-14-\"><a name=\"14什么是查询缓存？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>14什么是查询缓存？</h3><p>mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。</p>\r\n<p>mybaits提供一级缓存，和二级缓存。</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/cache.jpg\" alt=\"\"></p>\r\n<ul>\r\n<li>一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</li><li><p>二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。</p>\r\n<p>为什么要用缓存？</p>\r\n</li></ul>\r\n<p>如果缓存中有数据就不用从数据库中获取，大大提高系统性能。</p>\r\n<h3 id=\"h3-15-\"><a name=\"15一级缓存\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>15一级缓存</h3><p><strong>工作原理</strong>：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/cache1.jpg\" alt=\"\"></p>\r\n<p>第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。</p>\r\n<p>得到用户信息，将用户信息存储到一级缓存中。</p>\r\n<p>如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</p>\r\n<p>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p>\r\n<p><strong>一级缓存<a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\">测试</a></strong></p>\r\n<p>Mybatis 默认支持一级缓存，不需要在配置文件中配置。</p>\r\n<p>所以我们直接按照上面的步骤进行测试：</p>\r\n<pre><code>//一级缓存测试\r\n    @Test\r\n    public void  testCache1() throws Exception {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建UserMapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //查询使用的是同一个session\r\n        //第一次发起请求，查询Id 为1的用户信息\r\n        User user1 = userMapper.findUserById(1);\r\n        System.out.println(user1);\r\n        //第二次发起请求，查询Id 为1的用户信息\r\n        User user2 = userMapper.findUserById(1);\r\n        System.out.println(user2);\r\n        sqlSession.close();\r\n    }\r\n</code></pre><p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test15.jpg\" alt=\"\"></p>\r\n<p>通过结果可以看出第二次没有发出sql查询请求，</p>\r\n<p>所以我们需要在中间执行 commit 操作</p>\r\n<pre><code>//如果sqlSession去执行commit操作（执行插入、更新、删除），\r\n// 清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。\r\n//更新user1的信息，\r\nuser1.setUsername(&quot;李飞&quot;);\r\n//user1.setSex(&quot;男&quot;);\r\n//user1.setAddress(&quot;北京&quot;);\r\nuserMapper.updateUserById(user1);\r\n//提交事务,才会去清空缓存\r\nsqlSession.commit();\r\n</code></pre><p>测试</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test16.jpg\" alt=\"\"></p>\r\n<p><strong>一级缓存应用</strong></p>\r\n<p>正式开发，是将 mybatis 和 <a href=\"http://lib.csdn.net/base/javaee\" title=\"Java EE知识库\">spring</a> 进行整合开发，事务控制在 service 中。</p>\r\n<p>一个 service 方法中包括很多 mapper 方法调用。</p>\r\n<p>service{</p>\r\n<pre><code>     //开始执行时，开启事务，创建SqlSession对象\r\n\r\n     //第一次调用mapper的方法findUserById(1)\r\n\r\n     //第二次调用mapper的方法findUserById(1)，从一级缓存中取数据\r\n\r\n     //方法结束，sqlSession关闭\r\n</code></pre><p>}</p>\r\n<p>如果是执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。</p>\r\n<h3 id=\"h3-16-\"><a name=\"16二级缓存\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>16二级缓存</h3><p>原理</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/cache2.jpg\" alt=\"\"></p>\r\n<p>首先开启mybatis的二级缓存。</p>\r\n<p>sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中。</p>\r\n<p>如果SqlSession3去执行相同 mapper下sql，执行commit提交，清空该 mapper下的二级缓存区域的数据。</p>\r\n<p>sqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</p>\r\n<p>二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。</p>\r\n<p>UserMapper有一个二级缓存区域（按namespace分） ，其它mapper也有自己的二级缓存区域（按namespace分）。</p>\r\n<p>每一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。</p>\r\n<p><strong>开启二级缓存</strong>：</p>\r\n<p>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存</p>\r\n<p>在 SqlMapConfig.xml 开启二级开关</p>\r\n<pre><code>&lt;!-- 开启二级缓存 --&gt;\r\n&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;\r\n</code></pre><p>然后在你的 Mapper 映射文件中添加一行： ，表示此 mapper 开启二级缓存。</p>\r\n<p><strong>调用 pojo 类实现序列化接口</strong>：</p>\r\n<p>二级缓存需要查询结果映射的pojo对象实现<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>.io.Serializable接口实现序列化和反序列化操作（因为二级缓存数据存储介质多种多样，在内存不一样），注意如果存在父类、成员pojo都需要实现序列化接口。</p>\r\n<pre><code>public class Orders implements Serializable\r\npublic class User implements Serializable\r\n</code></pre><p><strong>测试</strong></p>\r\n<pre><code>//二级缓存测试\r\n    @Test\r\n    public void testCache2() throws Exception\r\n    {\r\n        SqlSession sqlSession1 = sqlSessionFactory.openSession();\r\n        SqlSession sqlSession2 = sqlSessionFactory.openSession();\r\n        SqlSession sqlSession3 = sqlSessionFactory.openSession();\r\n\r\n        //创建UserMapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\r\n        //sqlSession1 执行查询 写入缓存(第一次查询请求)\r\n        User user1 = userMapper1.findUserById(1);\r\n        System.out.println(user1);\r\n        sqlSession1.close();\r\n\r\n        //sqlSession3  执行提交  清空缓存\r\n        UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);\r\n        User user3 = userMapper3.findUserById(1);\r\n        user3.setSex(&quot;女&quot;);\r\n        user3.setAddress(&quot;山东济南&quot;);\r\n        user3.setUsername(&quot;崔建&quot;);\r\n        userMapper3.updateUserById(user3);\r\n        //提交事务，清空缓存\r\n        sqlSession3.commit();\r\n        sqlSession3.close();\r\n\r\n        //sqlSession2 执行查询(第二次查询请求)\r\n        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\r\n        User user2 = userMapper2.findUserById(1);\r\n        System.out.println(user2);\r\n        sqlSession2.close();\r\n   }\r\n</code></pre><p><strong>结果</strong>：</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test17.jpg\" alt=\"\"></p>\r\n<p><strong>useCache 配置</strong></p>\r\n<p>在 statement 中设置 useCache=false 可以禁用当前 select 语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。</p>\r\n<pre><code>&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot; useCache=&quot;false&quot;&gt;\r\n</code></pre><p>总结：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。</p>\r\n<p><strong>刷新缓存（清空缓存）</strong></p>\r\n<p>在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。</p>\r\n<p>设置statement配置中的flushCache=”true” 属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。</p>\r\n<p>如下：</p>\r\n<pre><code>&lt;insert id=&quot;insetrUser&quot; parameterType=&quot;cn.zhisheng.mybatis.po.User&quot; flushCache=&quot;true&quot;&gt;\r\n</code></pre><p>一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。</p>\r\n<h3 id=\"h3-17mybatis-cache-\"><a name=\"17Mybatis Cache参数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>17Mybatis Cache参数</h3><p>flushInterval（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。</p>\r\n<p>size（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是1024。</p>\r\n<p>readOnly（只读）属性可以被设置为true或false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</p>\r\n<p>如下例子：</p>\r\n<pre><code>&lt;cache  eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot;  size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;\r\n</code></pre><p>这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会导致冲突。可用的收回策略有, 默认的是 LRU:</p>\r\n<ol>\r\n<li><p>LRU – 最近最少使用的:移除最长时间不被使用的对象。</p>\r\n</li><li><p>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</p>\r\n</li><li><p>SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</p>\r\n</li><li><p>WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p>\r\n</li></ol>\r\n<h3 id=\"h3-18mybatis-ehcache\"><a name=\"18Mybatis 整合 ehcache\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>18Mybatis 整合 ehcache</h3><p>ehcache 是一个分布式缓存框架。</p>\r\n<p><strong>分布缓存</strong></p>\r\n<p>我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/eheache.jpg\" alt=\"\"></p>\r\n<p>不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统 开发。所以要使用分布式缓存对缓存数据进行集中管理。</p>\r\n<p>mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。</p>\r\n<p><strong>整合方法</strong></p>\r\n<p>mybatis 提供了一个二级缓存 cache 接口（<code>org.apache.ibatis.cache</code> 下的 <code>Cache</code>），如果要实现自己的缓存逻辑，实现cache接口开发即可。</p>\r\n<pre><code>import java.util.concurrent.locks.ReadWriteLock;\r\npublic interface Cache {\r\n    String getId();\r\n    void putObject(Object var1, Object var2);\r\n    Object getObject(Object var1);\r\n    Object removeObject(Object var1);\r\n    void clear();\r\n    int getSize();\r\n    ReadWriteLock getReadWriteLock();\r\n}\r\n</code></pre><p>mybatis和ehcache整合，mybatis 和 ehcache 整合包中提供了一个 cache 接口的实现类(<code>org.apache.ibatis.cache.impl</code> 下的 <code>PerpetualCache</code>)。</p>\r\n<pre><code>package org.apache.ibatis.cache.impl;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.locks.ReadWriteLock;\r\nimport org.apache.ibatis.cache.Cache;\r\nimport org.apache.ibatis.cache.CacheException;\r\npublic class PerpetualCache implements Cache {\r\n    private String id;\r\n    private Map&lt;Object, Object&gt; cache = new HashMap();\r\n    public PerpetualCache(String id) {\r\n        this.id = id;\r\n    }\r\n    public String getId() {\r\n        return this.id;\r\n    }\r\n    public int getSize() {\r\n        return this.cache.size();\r\n    }\r\n    public void putObject(Object key, Object value) {\r\n        this.cache.put(key, value);\r\n    }\r\n    public Object getObject(Object key) {\r\n        return this.cache.get(key);\r\n    }\r\n    public Object removeObject(Object key) {\r\n        return this.cache.remove(key);\r\n    }\r\n    public void clear() {\r\n        this.cache.clear();\r\n    }\r\n    public ReadWriteLock getReadWriteLock() {\r\n        return null;\r\n    }\r\n    public boolean equals(Object o) {\r\n        if(this.getId() == null) {\r\n            throw new CacheException(&quot;Cache instances require an ID.&quot;);\r\n        } else if(this == o) {\r\n            return true;\r\n        } else if(!(o instanceof Cache)) {\r\n            return false;\r\n        } else {\r\n            Cache otherCache = (Cache)o;\r\n            return this.getId().equals(otherCache.getId());\r\n        }\r\n    }\r\n    public int hashCode() {\r\n        if(this.getId() == null) {\r\n            throw new CacheException(&quot;Cache instances require an ID.&quot;);\r\n        } else {\r\n            return this.getId().hashCode();\r\n        }\r\n    }\r\n}\r\n</code></pre><p>通过实现 Cache 接口可以实现 mybatis 缓存数据通过其它缓存数据库整合，mybatis 的特长是sql操作，缓存数据的管理不是 mybatis 的特长，为了提高缓存的性能将 mybatis 和第三方的缓存数据库整合，比如 ehcache、memcache、<a href=\"http://lib.csdn.net/base/redis\" title=\"Redis知识库\">Redis</a>等。</p>\r\n<ul>\r\n<li><p>引入依赖包</p>\r\n<p><code>ehcache-core-2.6.5.jar</code> 和 <code>mybatis-ehcache-1.0.2.jar</code></p>\r\n</li><li><p>引入缓存配置文件</p>\r\n<p>classpath下添加：ehcache.xml</p>\r\n<p>内容如下：</p>\r\n<pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\nxsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;\r\n&lt;diskStore path=&quot;C:\\JetBrains\\IDEAProject\\ehcache&quot; /&gt;\r\n&lt;defaultCache \r\n    maxElementsInMemory=&quot;1000&quot; \r\n    maxElementsOnDisk=&quot;10000000&quot;\r\n    eternal=&quot;false&quot; \r\n    overflowToDisk=&quot;false&quot; \r\n    timeToIdleSeconds=&quot;120&quot;\r\n    timeToLiveSeconds=&quot;120&quot; \r\n    diskExpiryThreadIntervalSeconds=&quot;120&quot;\r\n    memoryStoreEvictionPolicy=&quot;LRU&quot;&gt;\r\n&lt;/defaultCache&gt;\r\n&lt;/ehcache&gt;\r\n</code></pre><p>属性说明：</p>\r\n<ul>\r\n<li>diskStore：指定数据在磁盘中的存储位置。</li><li>defaultCache：当借助 CacheManager.add(“demoCache”) 创建Cache时，EhCache 便会采用指定的的管理策略</li></ul>\r\n<p>以下属性是必须的：</p>\r\n<ul>\r\n<li>maxElementsInMemory - 在内存中缓存的element的最大数目</li><li>maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大</li><li>eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断</li><li>overflowToDisk- 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</li></ul>\r\n<p>以下属性是可选的：</p>\r\n<ul>\r\n<li>timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大</li><li><p>timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</p>\r\n<p>diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.</p>\r\n</li><li><p>diskPersistent- 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</p>\r\n</li><li><p>diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作</p>\r\n</li><li>memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</li></ul>\r\n</li><li><p>开启ehcache缓存</p>\r\n<p>EhcacheCache 是ehcache对Cache接口的实现；修改mapper.xml文件，在cache中指定EhcacheCache。</p>\r\n<p>根据需求调整缓存参数：</p>\r\n<pre><code>&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot; &gt; \r\n      &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;\r\n      &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;\r\n      &lt;!-- 同ehcache参数maxElementsInMemory --&gt;\r\n    &lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;\r\n    &lt;!-- 同ehcache参数maxElementsOnDisk --&gt;\r\n      &lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;10000000&quot;/&gt;\r\n      &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;\r\n  &lt;/cache&gt;\r\n</code></pre></li></ul>\r\n<p><strong>测试</strong> ：(这命中率就代表成功将ehcache 与 mybatis 整合了)</p>\r\n<p><img src=\"http://ohfk1r827.bkt.clouddn.com/Test18.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-19-\"><a name=\"19应用场景\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>19应用场景</h3><p>对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用 mybatis 二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。</p>\r\n<p>实现方法如下：通过设置刷新间隔时间，由 mybatis 每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔 flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。</p>\r\n<h3 id=\"h3-20-\"><a name=\"20局限性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>20局限性</h3><p>mybatis 二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用 mybatis 的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为 mybaits 的二级缓存区域以 mapper 为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。</p>\r\n', '104', '\r\n## 1延迟加载\r\n\r\n### 2什么是延迟加载？\r\n\r\nresultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。\r\n需求：\r\n如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。\r\n\r\n延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高 [数据库](http://lib.csdn.net/base/mysql \"MySQL知识库\")性能，因为查询单表要比关联查询多张表速度要快。\r\n\r\n### 3打开延迟加载开关\r\n\r\n在mybatis核心配置文件中配置：\r\n\r\nlazyLoadingEnabled、aggressiveLazyLoading\r\n\r\n| 设置项 | 描述 | 允许值 | 默认值 |\r\n| :-: | :-: | :-: | :-: |\r\n| lazyLoadingEnabled | 全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。 | true | false | false |\r\n| aggressiveLazyLoading | 当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。 | true | false | true |\r\n\r\n```\r\n<settings>\r\n        <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n        <setting name=\"aggressiveLazyLoading\" value=\"false\"/>\r\n</settings>\r\n```\r\n\r\n### 4使用 association 实现延迟加载\r\n\r\n需求：查询订单并且关联查询用户信息\r\n\r\n### 5Mapper.xml\r\n\r\n需要定义两个 mapper 的方法对应的 statement。\r\n\r\n1、只查询订单信息\r\n\r\nSQL 语句： `select * from orders`\r\n\r\n在查询订单的 statement 中使用 association 去延迟加载（执行）下边的 statement (关联查询用户信息)\r\n\r\n```\r\n<!--查询订单并且关联查询用户信息，关联用户信息需要通过 association 延迟加载-->\r\n    <select id=\"findOrdersUserLazyLoading\" resultMap=\"OrdersUserLazyLoadingResultMap\">\r\n        select * from orders\r\n    </select>\r\n```\r\n\r\n2、关联查询用户信息\r\n\r\n通过上面查询订单信息中的 user_id 来关联查询用户信息。使用 UserMapper.xml 中的 findUserById\r\n\r\nSQL语句：`select * from user where id = user_id`\r\n\r\n```\r\n<select id=\"findUserById\" parameterType=\"int\" resultType=\"user\">\r\n        select * from user where id = #{value}\r\n    </select>\r\n```\r\n\r\n上边先去执行 findOrdersUserLazyLoading，当需要去查询用户的时候再去执行 findUserById ，通过 resultMap的定义将延迟加载执行配置起来。也就是通过 resultMap 去加载 UserMapper.xml 文件中的 select = findUserById\r\n\r\n### 6延迟加载的 resultMap\r\n\r\n```\r\n<!--定义 关联用户信息（通过 association 延迟加载）的resultMap-->\r\n    <resultMap id=\"OrdersUserLazyLoadingResultMap\" type=\"cn.zhisheng.mybatis.po.Orders\">\r\n        <!--对订单信息映射-->\r\n        <id column=\"id\" property=\"id\"/>\r\n        <result column=\"user_id\" property=\"userId\"/>\r\n        <result column=\"number\" property=\"number\"/>\r\n        <result column=\"createtime\" property=\"createtime\"/>\r\n        <result column=\"note\" property=\"note\"/>\r\n        <!-- 实现对用户信息进行延迟加载\r\n        select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement）\r\n        要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace\r\n        column：订单信息中关联用户信息查询的列，是user_id\r\n        关联查询的sql理解为：\r\n            SELECT orders.*,\r\n            (SELECT username FROM USER WHERE orders.user_id = user.id)username,\r\n            (SELECT sex FROM USER WHERE orders.user_id = user.id)sex\r\n            FROM orders-->\r\n        <association property=\"user\" javaType=\"cn.zhisheng.mybatis.po.User\" select=\"cn.zhisheng.mybatis.mapper.UserMapper.findUserById\" column=\"user_id\">\r\n        </association>\r\n    </resultMap>\r\n```\r\n\r\n### 7OrderMapperCustom.java\r\n\r\n```\r\npublic List<Orders> findOrdersUserLazyLoading() throws Exception;\r\n```\r\n\r\n### 8测试代码：\r\n\r\n```\r\n@Test\r\n    public void testFindOrdersUserLazyLoading() throws Exception\r\n    {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建OrdersMapperCustom对象,mybatis自动生成代理对象\r\n        OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);\r\n        //查询订单信息\r\n        List<Orders> list = ordersMapperCustom.findOrdersUserLazyLoading();\r\n        //遍历所查询的的订单信息\r\n        for (Orders orders : list)\r\n        {\r\n            //查询用户信息\r\n            User user = orders.getUser();\r\n            System.out.println(user);\r\n        }\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n### 9测试结果：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test14.jpg)\r\n\r\n整个延迟加载的思路：\r\n\r\n1、执行上边mapper方法（findOrdersUserLazyLoading），内部去调用cn.zhisheng.mybatis.mapper.OrdersMapperCustom 中的 findOrdersUserLazyLoading 只查询 orders 信息（单表）。\r\n\r\n2、在程序中去遍历上一步骤查询出的 List，当我们调用 Orders 中的 getUser 方法时，开始进行延迟加载。\r\n\r\n3、延迟加载，去调用 UserMapper.xml 中 findUserbyId 这个方法获取用户信息。\r\n\r\n### 10思考：\r\n\r\n不使用 mybatis 提供的 association 及 collection 中的延迟加载功能，如何实现延迟加载？？\r\n\r\n实现方法如下：\r\n\r\n定义两个mapper方法：\r\n\r\n1、查询订单列表\r\n\r\n2、根据用户id查询用户信息\r\n\r\n实现思路：\r\n\r\n先去查询第一个mapper方法，获取订单信息列表\r\n\r\n在程序中（service），按需去调用第二个mapper方法去查询用户信息。\r\n\r\n总之：\r\n\r\n使用延迟加载方法，先去查询 简单的 sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。\r\n\r\n### 11一对多延迟加载\r\n\r\n上面的那个案例是一对一延迟加载，那么如果我们想一对多进行延迟加载呢，其实也是很简单的。\r\n\r\n一对多延迟加载的方法同一对一延迟加载，在collection标签中配置select内容。\r\n\r\n### 12延迟加载总结：\r\n\r\n作用：\r\n\r\n> 当需要查询关联信息时再去数据库查询，默认不去关联查询，提高数据库性能。\r\n> 只有使用resultMap支持延迟加载设置。\r\n\r\n场合：\r\n\r\n> 当只有部分记录需要关联查询其它信息时，此时可按需延迟加载，需要关联查询时再向数据库发出sql，以提高数据库性能。\r\n> \r\n> 当全部需要关联查询信息时，此时不用延迟加载，直接将关联查询信息全部返回即可，可使用resultType或resultMap完成映射。\r\n\r\n## 13查询缓存\r\n\r\n### 14什么是查询缓存？\r\n\r\nmybatis提供查询缓存，用于减轻数据压力，提高数据库性能。\r\n\r\nmybaits提供一级缓存，和二级缓存。\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/cache.jpg)\r\n\r\n*   一级缓存是SqlSession级别的缓存。在操作数据库时需要构造 sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。\r\n*   二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\r\n\r\n    为什么要用缓存？\r\n\r\n如果缓存中有数据就不用从数据库中获取，大大提高系统性能。\r\n\r\n### 15一级缓存\r\n\r\n**工作原理**：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/cache1.jpg)\r\n\r\n第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。\r\n\r\n得到用户信息，将用户信息存储到一级缓存中。\r\n\r\n如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。\r\n\r\n第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。\r\n\r\n**一级缓存[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")**\r\n\r\nMybatis 默认支持一级缓存，不需要在配置文件中配置。\r\n\r\n所以我们直接按照上面的步骤进行测试：\r\n\r\n```\r\n//一级缓存测试\r\n    @Test\r\n    public void  testCache1() throws Exception {\r\n        SqlSession sqlSession = sqlSessionFactory.openSession();\r\n        //创建UserMapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\r\n        //查询使用的是同一个session\r\n        //第一次发起请求，查询Id 为1的用户信息\r\n        User user1 = userMapper.findUserById(1);\r\n        System.out.println(user1);\r\n        //第二次发起请求，查询Id 为1的用户信息\r\n        User user2 = userMapper.findUserById(1);\r\n        System.out.println(user2);\r\n        sqlSession.close();\r\n    }\r\n```\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test15.jpg)\r\n\r\n通过结果可以看出第二次没有发出sql查询请求，\r\n\r\n所以我们需要在中间执行 commit 操作\r\n\r\n```\r\n//如果sqlSession去执行commit操作（执行插入、更新、删除），\r\n// 清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。\r\n//更新user1的信息，\r\nuser1.setUsername(\"李飞\");\r\n//user1.setSex(\"男\");\r\n//user1.setAddress(\"北京\");\r\nuserMapper.updateUserById(user1);\r\n//提交事务,才会去清空缓存\r\nsqlSession.commit();\r\n```\r\n\r\n测试\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test16.jpg)\r\n\r\n**一级缓存应用**\r\n\r\n正式开发，是将 mybatis 和 [spring](http://lib.csdn.net/base/javaee \"Java EE知识库\") 进行整合开发，事务控制在 service 中。\r\n\r\n一个 service 方法中包括很多 mapper 方法调用。\r\n\r\nservice{\r\n\r\n```\r\n     //开始执行时，开启事务，创建SqlSession对象\r\n\r\n     //第一次调用mapper的方法findUserById(1)\r\n\r\n     //第二次调用mapper的方法findUserById(1)，从一级缓存中取数据\r\n\r\n     //方法结束，sqlSession关闭\r\n\r\n```\r\n\r\n}\r\n\r\n如果是执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。\r\n\r\n### 16二级缓存\r\n\r\n原理\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/cache2.jpg)\r\n\r\n首先开启mybatis的二级缓存。\r\n\r\nsqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中。\r\n\r\n如果SqlSession3去执行相同 mapper下sql，执行commit提交，清空该 mapper下的二级缓存区域的数据。\r\n\r\nsqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据。\r\n\r\n二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。\r\n\r\nUserMapper有一个二级缓存区域（按namespace分） ，其它mapper也有自己的二级缓存区域（按namespace分）。\r\n\r\n每一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。\r\n\r\n**开启二级缓存**：\r\n\r\nmybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存\r\n\r\n在 SqlMapConfig.xml 开启二级开关\r\n\r\n```\r\n<!-- 开启二级缓存 -->\r\n<setting name=\"cacheEnabled\" value=\"true\"/>\r\n```\r\n\r\n然后在你的 Mapper 映射文件中添加一行： ，表示此 mapper 开启二级缓存。\r\n\r\n**调用 pojo 类实现序列化接口**：\r\n\r\n二级缓存需要查询结果映射的pojo对象实现[Java](http://lib.csdn.net/base/javase \"Java SE知识库\").io.Serializable接口实现序列化和反序列化操作（因为二级缓存数据存储介质多种多样，在内存不一样），注意如果存在父类、成员pojo都需要实现序列化接口。\r\n\r\n```\r\npublic class Orders implements Serializable\r\npublic class User implements Serializable\r\n```\r\n\r\n**测试**\r\n\r\n```\r\n//二级缓存测试\r\n    @Test\r\n    public void testCache2() throws Exception\r\n    {\r\n        SqlSession sqlSession1 = sqlSessionFactory.openSession();\r\n        SqlSession sqlSession2 = sqlSessionFactory.openSession();\r\n        SqlSession sqlSession3 = sqlSessionFactory.openSession();\r\n\r\n        //创建UserMapper对象,mybatis自动生成代理对象\r\n        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\r\n        //sqlSession1 执行查询 写入缓存(第一次查询请求)\r\n        User user1 = userMapper1.findUserById(1);\r\n        System.out.println(user1);\r\n        sqlSession1.close();\r\n\r\n        //sqlSession3  执行提交  清空缓存\r\n        UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);\r\n        User user3 = userMapper3.findUserById(1);\r\n        user3.setSex(\"女\");\r\n        user3.setAddress(\"山东济南\");\r\n        user3.setUsername(\"崔建\");\r\n        userMapper3.updateUserById(user3);\r\n        //提交事务，清空缓存\r\n        sqlSession3.commit();\r\n        sqlSession3.close();\r\n\r\n        //sqlSession2 执行查询(第二次查询请求)\r\n        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\r\n        User user2 = userMapper2.findUserById(1);\r\n        System.out.println(user2);\r\n        sqlSession2.close();\r\n   }\r\n```\r\n\r\n**结果**：\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test17.jpg)\r\n\r\n**useCache 配置**\r\n\r\n在 statement 中设置 useCache=false 可以禁用当前 select 语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。\r\n\r\n```\r\n<select id=\"findUserById\" parameterType=\"int\" resultType=\"user\" useCache=\"false\">\r\n```\r\n\r\n总结：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。\r\n\r\n**刷新缓存（清空缓存）**\r\n\r\n在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。\r\n\r\n设置statement配置中的flushCache=”true” 属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。\r\n\r\n如下：\r\n\r\n```\r\n<insert id=\"insetrUser\" parameterType=\"cn.zhisheng.mybatis.po.User\" flushCache=\"true\">\r\n```\r\n\r\n一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。\r\n\r\n### 17Mybatis Cache参数\r\n\r\nflushInterval（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。\r\n\r\nsize（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是1024。\r\n\r\nreadOnly（只读）属性可以被设置为true或false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。\r\n\r\n如下例子：\r\n\r\n```\r\n<cache  eviction=\"FIFO\" flushInterval=\"60000\"  size=\"512\" readOnly=\"true\"/>\r\n```\r\n\r\n这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会导致冲突。可用的收回策略有, 默认的是 LRU:\r\n\r\n1.  LRU – 最近最少使用的:移除最长时间不被使用的对象。\r\n\r\n2.  FIFO – 先进先出:按对象进入缓存的顺序来移除它们。\r\n\r\n3.  SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。\r\n\r\n4.  WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。\r\n\r\n### 18Mybatis 整合 ehcache\r\n\r\nehcache 是一个分布式缓存框架。\r\n\r\n**分布缓存**\r\n\r\n我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/eheache.jpg)\r\n\r\n不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统 开发。所以要使用分布式缓存对缓存数据进行集中管理。\r\n\r\nmybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。\r\n\r\n**整合方法**\r\n\r\nmybatis 提供了一个二级缓存 cache 接口（`org.apache.ibatis.cache` 下的 `Cache`），如果要实现自己的缓存逻辑，实现cache接口开发即可。\r\n\r\n```\r\nimport java.util.concurrent.locks.ReadWriteLock;\r\npublic interface Cache {\r\n    String getId();\r\n    void putObject(Object var1, Object var2);\r\n    Object getObject(Object var1);\r\n    Object removeObject(Object var1);\r\n    void clear();\r\n    int getSize();\r\n    ReadWriteLock getReadWriteLock();\r\n}\r\n```\r\n\r\nmybatis和ehcache整合，mybatis 和 ehcache 整合包中提供了一个 cache 接口的实现类(`org.apache.ibatis.cache.impl` 下的 `PerpetualCache`)。\r\n\r\n```\r\npackage org.apache.ibatis.cache.impl;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.locks.ReadWriteLock;\r\nimport org.apache.ibatis.cache.Cache;\r\nimport org.apache.ibatis.cache.CacheException;\r\npublic class PerpetualCache implements Cache {\r\n    private String id;\r\n    private Map<Object, Object> cache = new HashMap();\r\n    public PerpetualCache(String id) {\r\n        this.id = id;\r\n    }\r\n    public String getId() {\r\n        return this.id;\r\n    }\r\n    public int getSize() {\r\n        return this.cache.size();\r\n    }\r\n    public void putObject(Object key, Object value) {\r\n        this.cache.put(key, value);\r\n    }\r\n    public Object getObject(Object key) {\r\n        return this.cache.get(key);\r\n    }\r\n    public Object removeObject(Object key) {\r\n        return this.cache.remove(key);\r\n    }\r\n    public void clear() {\r\n        this.cache.clear();\r\n    }\r\n    public ReadWriteLock getReadWriteLock() {\r\n        return null;\r\n    }\r\n    public boolean equals(Object o) {\r\n        if(this.getId() == null) {\r\n            throw new CacheException(\"Cache instances require an ID.\");\r\n        } else if(this == o) {\r\n            return true;\r\n        } else if(!(o instanceof Cache)) {\r\n            return false;\r\n        } else {\r\n            Cache otherCache = (Cache)o;\r\n            return this.getId().equals(otherCache.getId());\r\n        }\r\n    }\r\n    public int hashCode() {\r\n        if(this.getId() == null) {\r\n            throw new CacheException(\"Cache instances require an ID.\");\r\n        } else {\r\n            return this.getId().hashCode();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n通过实现 Cache 接口可以实现 mybatis 缓存数据通过其它缓存数据库整合，mybatis 的特长是sql操作，缓存数据的管理不是 mybatis 的特长，为了提高缓存的性能将 mybatis 和第三方的缓存数据库整合，比如 ehcache、memcache、[Redis](http://lib.csdn.net/base/redis \"Redis知识库\")等。\r\n\r\n*   引入依赖包\r\n\r\n    `ehcache-core-2.6.5.jar` 和 `mybatis-ehcache-1.0.2.jar`\r\n\r\n*   引入缓存配置文件\r\n\r\n    classpath下添加：ehcache.xml\r\n\r\n    内容如下：\r\n\r\n    ```\r\n    <ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\">\r\n    <diskStore path=\"C:\\JetBrains\\IDEAProject\\ehcache\" />\r\n    <defaultCache \r\n        maxElementsInMemory=\"1000\" \r\n        maxElementsOnDisk=\"10000000\"\r\n        eternal=\"false\" \r\n        overflowToDisk=\"false\" \r\n        timeToIdleSeconds=\"120\"\r\n        timeToLiveSeconds=\"120\" \r\n        diskExpiryThreadIntervalSeconds=\"120\"\r\n        memoryStoreEvictionPolicy=\"LRU\">\r\n    </defaultCache>\r\n    </ehcache>\r\n    ```\r\n\r\n    属性说明：\r\n\r\n    *   diskStore：指定数据在磁盘中的存储位置。\r\n    *   defaultCache：当借助 CacheManager.add(“demoCache”) 创建Cache时，EhCache 便会采用指定的的管理策略\r\n\r\n    以下属性是必须的：\r\n\r\n    *   maxElementsInMemory - 在内存中缓存的element的最大数目\r\n    *   maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大\r\n    *   eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断\r\n    *   overflowToDisk- 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上\r\n\r\n    以下属性是可选的：\r\n\r\n    *   timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大\r\n    *   timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大\r\n\r\n        diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.\r\n\r\n    *   diskPersistent- 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。\r\n\r\n    *   diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作\r\n    *   memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）\r\n*   开启ehcache缓存\r\n\r\n    EhcacheCache 是ehcache对Cache接口的实现；修改mapper.xml文件，在cache中指定EhcacheCache。\r\n\r\n    根据需求调整缓存参数：\r\n\r\n    ```\r\n    <cache type=\"org.mybatis.caches.ehcache.EhcacheCache\" > \r\n          <property name=\"timeToIdleSeconds\" value=\"3600\"/>\r\n          <property name=\"timeToLiveSeconds\" value=\"3600\"/>\r\n          <!-- 同ehcache参数maxElementsInMemory -->\r\n        <property name=\"maxEntriesLocalHeap\" value=\"1000\"/>\r\n        <!-- 同ehcache参数maxElementsOnDisk -->\r\n          <property name=\"maxEntriesLocalDisk\" value=\"10000000\"/>\r\n          <property name=\"memoryStoreEvictionPolicy\" value=\"LRU\"/>\r\n      </cache>\r\n    ```\r\n\r\n**测试** ：(这命中率就代表成功将ehcache 与 mybatis 整合了)\r\n\r\n![](http://ohfk1r827.bkt.clouddn.com/Test18.jpg)\r\n\r\n### 19应用场景\r\n\r\n对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用 mybatis 二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。\r\n\r\n实现方法如下：通过设置刷新间隔时间，由 mybatis 每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔 flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。\r\n\r\n### 20局限性\r\n\r\nmybatis 二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用 mybatis 的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为 mybaits 的二级缓存区域以 mapper 为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。');
INSERT INTO `article_info_true` VALUES ('79', 'springmvc框架原理', '<h1 id=\"h1-springmvc-1-\"><a name=\"springmvc学习笔记(1)-框架原理和入门配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc学习笔记(1)-框架原理和入门配置</h1><p>标签： springmvc</p>\r\n<hr>\r\n<p>本文主要介绍springmvc的框架原理，并通过一个入门程序展示环境搭建，配置以及部署调试。</p>\r\n<p>springmvc是<a href=\"http://lib.csdn.net/base/javaee\" title=\"Java EE知识库\">spring</a>框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</p>\r\n<h2 id=\"h2-springmvc-\"><a name=\"springmvc框架原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc框架原理</h2><p>给个官网示意图</p>\r\n<p><img src=\"http://docs.spring.io/spring/docs/current/spring-framework-reference/html/images/mvc.png\" alt=\"The request processing workflow in Spring Web MVC\"></p>\r\n<p>组件及其作用</p>\r\n<ul>\r\n<li>前端控制器(DispatcherServlet)：接收请求，响应结果，相当于转发器，中央处理器。减少了其他组件之间的耦合度</li><li>处理器映射器(HandlerMapping)：根据请求的url查找Handler</li><li><strong>Handler处理器</strong>：按照HandlerAdapter的要求编写</li><li>处理器适配器(HandlerAdapter)：按照特定规则(HandlerAdapter要求的规则)执行Handler。</li><li>视图解析器(ViewResolver)：进行视图解析，根据逻辑视图解析成真正的视图(View)</li><li><strong>视图(View)</strong>：View是一个接口实现类试吃不同的View类型（jsp,pdf等等）</li></ul>\r\n<p><em>注：其中加粗的为需要程序员开发的，没加粗的为不需要程序员开发的</em></p>\r\n<p>文末参考链接中《跟开涛学SpringMVC》里面有张图挺好的，感觉很详细.</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg\" alt=\"springmvc_核心架构图\"></p>\r\n<p>步骤：</p>\r\n<ul>\r\n<li>1.发起请求到前端控制器(<code>DispatcherServlet</code>)</li><li>2.前端控制器请求处理器映射器(<code>HandlerMapping</code>)查找<code>Handler</code>(可根据xml配置、注解进行查找)</li><li>3.处理器映射器(<code>HandlerMapping</code>)向前端控制器返回<code>Handler</code></li><li>4.前端控制器调用处理器适配器(<code>HandlerAdapter</code>)执行<code>Handler</code></li><li>5.处理器适配器(HandlerAdapter)去执行Handler</li><li>6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象)</li><li>7.处理器适配器(<code>HandlerAdapter</code>)向前端控制器返回<code>ModelAndView</code></li><li>8.前端控制器(<code>DispatcherServlet</code>)请求视图解析器(<code>ViewResolver</code>)进行视图解析，根据逻辑视图名解析成真正的视图(jsp)</li><li>9.视图解析器(ViewResolver)向前端控制器(<code>DispatcherServlet</code>)返回View</li><li>10.前端控制器进行视图渲染，即将模型数据(在<code>ModelAndView</code>对象中)填充到request域</li><li>11.前端控制器向用户响应结果</li></ul>\r\n<h2 id=\"h2-springmvc-\"><a name=\"springmvc入门程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc入门程序</h2><p>一个展示商品列表的小页面</p>\r\n<h3 id=\"h3-u73AFu5883u642Du5EFA\"><a name=\"环境搭建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>环境搭建</h3><p>intellij IDEA 15.0.2</p>\r\n<ul>\r\n<li>A方法(有待商榷)</li></ul>\r\n<p><code>new-&gt;project-&gt;maven-&gt;勾选create from archetype-&gt;选中webapp</code></p>\r\n<p>在<code>src/main</code>下新建<code>[Java](http://lib.csdn.net/base/javase &quot;Java SE知识库&quot;)</code>文件夹，标记为<code>Sources Root</code></p>\r\n<p>这样建出来的工程感觉有问题，点开一些xml文件一片红，心里不是很踏实，所以放弃这个方法了</p>\r\n<ul>\r\n<li>B方法</li></ul>\r\n<p><code>new-&gt;project-&gt;maven</code>，建一个裸的maven工程，手动建webapp的目录</p>\r\n<p>在<code>src/main</code>下新建文件夹<code>webapp</code></p>\r\n<p>pom.xml文件</p>\r\n<p>添加依赖</p>\r\n<pre><code>&lt;dependency&gt;\r\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\r\n    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\r\n    &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;\r\n&lt;/dependency&gt;\r\n</code></pre><p>加上下面的标签会生成Artifacts</p>\r\n<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;\r\n</code></pre><p>build标签的finalName要和Artifacts的output directory一致</p>\r\n<pre><code>&lt;build&gt;\r\n    &lt;finalName&gt;springmvc-2nd-1.0-SNAPSHOT&lt;/finalName&gt;\r\n&lt;/build&gt;\r\n</code></pre><h3 id=\"h3-u914Du7F6Eu6587u4EF6\"><a name=\"配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置文件</h3><ul>\r\n<li>配置前端控制器</li></ul>\r\n<p>web.xml</p>\r\n<pre><code>&lt;servlet&gt;\r\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\r\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\r\n    &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)\r\n      若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)\r\n    --&gt;\r\n    &lt;init-param&gt;\r\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\r\n        &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;\r\n    &lt;/init-param&gt;\r\n&lt;/servlet&gt;\r\n</code></pre><pre><code>&lt;servlet-mapping&gt;\r\n    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\r\n    &lt;!--\r\n    第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析\r\n    第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，\r\n            使用此种方式和实现RESTful风格的url\r\n    第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，\r\n            不能根据jsp页面找到handler，会报错\r\n    --&gt;\r\n    &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n</code></pre><ul>\r\n<li>配置Handler</li></ul>\r\n<p>将编写Handler在spring容器加载</p>\r\n<pre><code>&lt;!-- 配置Handler --&gt;\r\n&lt;bean name=&quot;/queryItems.action&quot; class=&quot;com.iot.ssm.controller.ItemsController&quot;/&gt;\r\n</code></pre><ul>\r\n<li>配置处理器映射器</li></ul>\r\n<p>在classpath下的springmvc.xml中配置处理器映射器</p>\r\n<pre><code>&lt;!-- 处理器映射器\r\n    将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n--&gt;\r\n&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;\r\n</code></pre><ul>\r\n<li>配置处理器适配器</li></ul>\r\n<p>所有处理器适配器都实现了<code>HandlerAdapter</code>接口</p>\r\n<p><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;</code></p>\r\n<p>源码</p>\r\n<pre><code>public boolean supports(Object handler) {\r\n        return handler instanceof Controller;\r\n}\r\n</code></pre><p>此适配器能执行实现<code>Controller</code>接口的Handler</p>\r\n<ul>\r\n<li>配置视图解析器</li></ul>\r\n<p>需要配置解析jsp的视图解析器</p>\r\n<pre><code> &lt;!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt;\r\n</code></pre><p>在springmvc.xml中视图解析器配置前缀和后缀：</p>\r\n<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r\n        &lt;!-- 配置jsp路径的前缀 --&gt;\r\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\r\n        &lt;!-- 配置jsp路径的后缀 --&gt;\r\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\r\n&lt;/bean&gt;\r\n</code></pre><p>程序中不用指定前缀和后缀：</p>\r\n<pre><code>//指定视图\r\n//下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n//modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);\r\n\r\n//下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\nmodelAndView.setViewName(&quot;items/itemsList&quot;);\r\n</code></pre><h3 id=\"h3-u90E8u7F72u8C03u8BD5\"><a name=\"部署调试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>部署调试</h3><p><code>HTTP Status 404 -</code><br>处理器映射器根据url找不到Handler,说明url错误</p>\r\n<p><code>HTTP Status 404 -/springmvc/WEB-INF/jsp/items/itemsLists.jsp</code><br>处理器映射器根据url找到了Handler，转发的jsp页面找不到</p>\r\n', '105', '# springmvc学习笔记(1)-框架原理和入门配置\r\n\r\n标签： springmvc\r\n\r\n* * *\r\n\r\n本文主要介绍springmvc的框架原理，并通过一个入门程序展示环境搭建，配置以及部署调试。\r\n\r\nspringmvc是[spring](http://lib.csdn.net/base/javaee \"Java EE知识库\")框架的一个模块，springmvc和spring无需通过中间整合层进行整合。\r\n\r\n## springmvc框架原理\r\n\r\n给个官网示意图\r\n\r\n![The request processing workflow in Spring Web MVC](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/images/mvc.png)\r\n\r\n组件及其作用\r\n\r\n*   前端控制器(DispatcherServlet)：接收请求，响应结果，相当于转发器，中央处理器。减少了其他组件之间的耦合度\r\n*   处理器映射器(HandlerMapping)：根据请求的url查找Handler\r\n*   **Handler处理器**：按照HandlerAdapter的要求编写\r\n*   处理器适配器(HandlerAdapter)：按照特定规则(HandlerAdapter要求的规则)执行Handler。\r\n*   视图解析器(ViewResolver)：进行视图解析，根据逻辑视图解析成真正的视图(View)\r\n*   **视图(View)**：View是一个接口实现类试吃不同的View类型（jsp,pdf等等）\r\n\r\n_注：其中加粗的为需要程序员开发的，没加粗的为不需要程序员开发的_\r\n\r\n文末参考链接中《跟开涛学SpringMVC》里面有张图挺好的，感觉很详细.\r\n\r\n![springmvc_核心架构图](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg)\r\n\r\n步骤：\r\n\r\n*   1.发起请求到前端控制器(`DispatcherServlet`)\r\n*   2.前端控制器请求处理器映射器(`HandlerMapping`)查找`Handler`(可根据xml配置、注解进行查找)\r\n*   3.处理器映射器(`HandlerMapping`)向前端控制器返回`Handler`\r\n*   4.前端控制器调用处理器适配器(`HandlerAdapter`)执行`Handler`\r\n*   5.处理器适配器(HandlerAdapter)去执行Handler\r\n*   6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象)\r\n*   7.处理器适配器(`HandlerAdapter`)向前端控制器返回`ModelAndView`\r\n*   8.前端控制器(`DispatcherServlet`)请求视图解析器(`ViewResolver`)进行视图解析，根据逻辑视图名解析成真正的视图(jsp)\r\n*   9.视图解析器(ViewResolver)向前端控制器(`DispatcherServlet`)返回View\r\n*   10.前端控制器进行视图渲染，即将模型数据(在`ModelAndView`对象中)填充到request域\r\n*   11.前端控制器向用户响应结果\r\n\r\n## springmvc入门程序\r\n\r\n一个展示商品列表的小页面\r\n\r\n### 环境搭建\r\n\r\nintellij IDEA 15.0.2\r\n\r\n*   A方法(有待商榷)\r\n\r\n`new->project->maven->勾选create from archetype->选中webapp`\r\n\r\n在`src/main`下新建`[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")`文件夹，标记为`Sources Root`\r\n\r\n这样建出来的工程感觉有问题，点开一些xml文件一片红，心里不是很踏实，所以放弃这个方法了\r\n\r\n*   B方法\r\n\r\n`new->project->maven`，建一个裸的maven工程，手动建webapp的目录\r\n\r\n在`src/main`下新建文件夹`webapp`\r\n\r\npom.xml文件\r\n\r\n添加依赖\r\n\r\n```\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>4.2.4.RELEASE</version>\r\n</dependency>\r\n```\r\n\r\n加上下面的标签会生成Artifacts\r\n\r\n```\r\n<packaging>war</packaging>\r\n```\r\n\r\nbuild标签的finalName要和Artifacts的output directory一致\r\n\r\n```\r\n<build>\r\n    <finalName>springmvc-2nd-1.0-SNAPSHOT</finalName>\r\n</build>\r\n```\r\n\r\n### 配置文件\r\n\r\n*   配置前端控制器\r\n\r\nweb.xml\r\n\r\n```\r\n<servlet>\r\n    <servlet-name>springmvc</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)\r\n      若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)\r\n    -->\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:springmvc.xml</param-value>\r\n    </init-param>\r\n</servlet>\r\n```\r\n\r\n```\r\n<servlet-mapping>\r\n    <servlet-name>springmvc</servlet-name>\r\n    <!--\r\n    第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析\r\n    第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，\r\n            使用此种方式和实现RESTful风格的url\r\n    第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，\r\n            不能根据jsp页面找到handler，会报错\r\n    -->\r\n    <url-pattern>*.action</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n*   配置Handler\r\n\r\n将编写Handler在spring容器加载\r\n\r\n```\r\n<!-- 配置Handler -->\r\n<bean name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/>\r\n\r\n```\r\n\r\n*   配置处理器映射器\r\n\r\n在classpath下的springmvc.xml中配置处理器映射器\r\n\r\n```\r\n<!-- 处理器映射器\r\n    将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n-->\r\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\r\n```\r\n\r\n*   配置处理器适配器\r\n\r\n所有处理器适配器都实现了`HandlerAdapter`接口\r\n\r\n`<bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\">`\r\n\r\n源码\r\n\r\n```\r\npublic boolean supports(Object handler) {\r\n        return handler instanceof Controller;\r\n}\r\n```\r\n\r\n此适配器能执行实现`Controller`接口的Handler\r\n\r\n*   配置视图解析器\r\n\r\n需要配置解析jsp的视图解析器\r\n\r\n```\r\n <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/>\r\n```\r\n\r\n在springmvc.xml中视图解析器配置前缀和后缀：\r\n\r\n```\r\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- 配置jsp路径的前缀 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <!-- 配置jsp路径的后缀 -->\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n</bean>\r\n```\r\n\r\n程序中不用指定前缀和后缀：\r\n\r\n```\r\n//指定视图\r\n//下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n//modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n\r\n//下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\nmodelAndView.setViewName(\"items/itemsList\");\r\n```\r\n\r\n### 部署调试\r\n\r\n`HTTP Status 404 -`\r\n处理器映射器根据url找不到Handler,说明url错误\r\n\r\n`HTTP Status 404 -/springmvc/WEB-INF/jsp/items/itemsLists.jsp`\r\n处理器映射器根据url找到了Handler，转发的jsp页面找不到\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('80', '非注解的处理器映射器和适配器', '<h1 id=\"h1-u975Eu6CE8u89E3u7684u5904u7406u5668u6620u5C04u5668u548Cu9002u914Du5668\"><a name=\"非注解的处理器映射器和适配器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>非注解的处理器映射器和适配器</h1><hr>\r\n<p>本文主要介绍非注解的处理器映射器和适配器配置</p>\r\n<h2 id=\"h2-u975Eu6CE8u89E3u7684u5904u7406u5668u6620u5C04u5668\"><a name=\"非注解的处理器映射器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>非注解的处理器映射器</h2><pre><code> &lt;!-- 配置Handler --&gt;\r\n&lt;bean id=&quot;itemsController&quot; name=&quot;/queryItems.action&quot; class=&quot;com.iot.ssm.controller.ItemsController&quot;/&gt;\r\n\r\n&lt;!-- 处理器映射器\r\n将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n --&gt;\r\n&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;\r\n\r\n&lt;!-- 简单url映射--&gt;\r\n&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;\r\n    &lt;property name=&quot;mappings&quot;&gt;\r\n        &lt;props&gt;\r\n            &lt;!-- 对 itemsController进行url映射--&gt;\r\n            &lt;prop key=&quot;/queryItems1.action&quot;&gt;itemsController&lt;/prop&gt;\r\n            &lt;prop key=&quot;/queryItems2.action&quot;&gt;itemsController&lt;/prop&gt;\r\n        &lt;/props&gt;\r\n    &lt;/property&gt;\r\n&lt;/bean&gt;\r\n</code></pre><p>多个映射器可并存，前端控制器判断url能让哪些映射器处理就让正确的映射器处理</p>\r\n<h2 id=\"h2-u975Eu6CE8u89E3u7684u5904u7406u5668u9002u914Du5668\"><a name=\"非注解的处理器适配器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>非注解的处理器适配器</h2><pre><code> &lt;!-- 处理器适配器\r\n     所有处理器适配器都实现了HandlerAdapter接口\r\n     --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;\r\n</code></pre><p>要求编写的Handler实现<code>Controller</code>接口</p>\r\n<p><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt;</code></p>\r\n<p>要求编写的Handler实现<code>HttpRequestHandler</code>接口</p>\r\n<pre><code>package com.iot.ssm.controller;\r\n\r\nimport com.iot.ssm.po.Items;\r\nimport org.springframework.web.HttpRequestHandler;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by brian on 2016/2/19.\r\n */\r\npublic class ItemsController2 implements HttpRequestHandler{\r\n    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {\r\n        //调用service查找数据库，查询商品列表，这里使用静态数据模拟\r\n        List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;();\r\n\r\n        //向list中填充静态数据\r\n        Items items_1 = new Items();\r\n        items_1.setName(&quot;联想笔记本&quot;);\r\n        items_1.setPrice(6000f);\r\n        items_1.setDetail(&quot;ThinkPad T430 联想笔记本电脑！&quot;);\r\n\r\n        Items items_2 = new Items();\r\n        items_2.setName(&quot;苹果手机&quot;);\r\n        items_2.setPrice(5000f);\r\n        items_2.setDetail(&quot;iphone6苹果手机！&quot;);\r\n\r\n        itemsList.add(items_1);\r\n        itemsList.add(items_2);\r\n\r\n        //设置模型数据\r\n        httpServletRequest.setAttribute(&quot;itemsList&quot;,itemsList);\r\n\r\n        //设置转发的视图\r\n        httpServletRequest.getRequestDispatcher(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;).forward(httpServletRequest,httpServletResponse);\r\n\r\n    }\r\n}\r\n</code></pre><p><code>HttpRequestHandler</code>适配器的<code>handleRequest</code>方法返回为<code>void</code>,没有返回<code>ModelAndView</code>，可通过response修改响应内容,比如返回json数据：</p>\r\n<pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);\r\nresponse.setContentType(&quot;application/json;charset=utf-8&quot;);\r\nresponse.getWriter().write(&quot;json串&quot;);\r\n</code></pre><hr>\r\n', '106', '# 非注解的处理器映射器和适配器\r\n\r\n* * *\r\n\r\n本文主要介绍非注解的处理器映射器和适配器配置\r\n\r\n## 非注解的处理器映射器\r\n\r\n```\r\n <!-- 配置Handler -->\r\n<bean id=\"itemsController\" name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/>\r\n\r\n<!-- 处理器映射器\r\n将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n -->\r\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\r\n\r\n<!-- 简单url映射-->\r\n<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\r\n    <property name=\"mappings\">\r\n        <props>\r\n            <!-- 对 itemsController进行url映射-->\r\n            <prop key=\"/queryItems1.action\">itemsController</prop>\r\n            <prop key=\"/queryItems2.action\">itemsController</prop>\r\n        </props>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n多个映射器可并存，前端控制器判断url能让哪些映射器处理就让正确的映射器处理\r\n\r\n## 非注解的处理器适配器\r\n\r\n```\r\n <!-- 处理器适配器\r\n     所有处理器适配器都实现了HandlerAdapter接口\r\n     -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\r\n```\r\n\r\n要求编写的Handler实现`Controller`接口\r\n\r\n`<bean class=\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\"/>`\r\n\r\n要求编写的Handler实现`HttpRequestHandler`接口\r\n\r\n```\r\npackage com.iot.ssm.controller;\r\n\r\nimport com.iot.ssm.po.Items;\r\nimport org.springframework.web.HttpRequestHandler;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by brian on 2016/2/19.\r\n */\r\npublic class ItemsController2 implements HttpRequestHandler{\r\n    public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {\r\n        //调用service查找数据库，查询商品列表，这里使用静态数据模拟\r\n        List<Items> itemsList = new ArrayList<Items>();\r\n\r\n        //向list中填充静态数据\r\n        Items items_1 = new Items();\r\n        items_1.setName(\"联想笔记本\");\r\n        items_1.setPrice(6000f);\r\n        items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\");\r\n\r\n        Items items_2 = new Items();\r\n        items_2.setName(\"苹果手机\");\r\n        items_2.setPrice(5000f);\r\n        items_2.setDetail(\"iphone6苹果手机！\");\r\n\r\n        itemsList.add(items_1);\r\n        itemsList.add(items_2);\r\n\r\n        //设置模型数据\r\n        httpServletRequest.setAttribute(\"itemsList\",itemsList);\r\n\r\n        //设置转发的视图\r\n        httpServletRequest.getRequestDispatcher(\"/WEB-INF/jsp/items/itemsList.jsp\").forward(httpServletRequest,httpServletResponse);\r\n\r\n    }\r\n}\r\n```\r\n\r\n`HttpRequestHandler`适配器的`handleRequest`方法返回为`void`,没有返回`ModelAndView`，可通过response修改响应内容,比如返回json数据：\r\n\r\n```\r\nresponse.setCharacterEncoding(\"utf-8\");\r\nresponse.setContentType(\"application/json;charset=utf-8\");\r\nresponse.getWriter().write(\"json串\");\r\n```\r\n\r\n* * *\r\n');
INSERT INTO `article_info_true` VALUES ('81', '注解的处理器映射器和适配器', '<h1 id=\"h1-u6CE8u89E3u7684u5904u7406u5668u6620u5C04u5668u548Cu9002u914Du5668\"><a name=\"注解的处理器映射器和适配器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>注解的处理器映射器和适配器</h1><h2 id=\"h2-u9ED8u8BA4u52A0u8F7D\"><a name=\"默认加载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>默认加载</h2><p>前端控制器从<code>\\org\\springframework\\web\\servlet\\DispatcherServlet.properties</code>件中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的</p>\r\n<p>注解的处理器映射器和适配器</p>\r\n<ul>\r\n<li>在spring3.1之前使用<code>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</code>注解映射器。</li><li>在spring3.1之后使用<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code>注解映射器。</li><li>在spring3.1之前使用<code>org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</code>注解适配器。</li><li>在spring3.1之后使用<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</code>注解适配器</li></ul>\r\n<h2 id=\"h2-u6CE8u89E3u7684u5904u7406u5668u6620u5C04u5668u548Cu9002u914Du5668\"><a name=\"注解的处理器映射器和适配器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>注解的处理器映射器和适配器</h2><pre><code>&lt;!-- 注解的映射器 --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;\r\n\r\n&lt;!-- 注解的适配器 --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;\r\n</code></pre><p>或者</p>\r\n<pre><code>    &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     --&gt;\r\n    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;\r\n</code></pre><h2 id=\"h2--handler\"><a name=\"开发注解Handler\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开发注解Handler</h2><p>使用注解的映射器和注解的适配器。(使用注解的映射器和注解的适配器必须配对使用)</p>\r\n<pre><code>//使用@Controller来标识它是一个控制器\r\n@Controller\r\npublic class ItemsController3 {\r\n\r\n    //商品查询列表\r\n    @RequestMapping(&quot;/queryItems&quot;)\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表，这里使用静态数据模拟\r\n        List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;();\r\n\r\n        //向list中填充静态数据\r\n        Items items_1 = new Items();\r\n        items_1.setName(&quot;联想笔记本&quot;);\r\n        items_1.setPrice(6000f);\r\n        items_1.setDetail(&quot;ThinkPad T430 c3 联想笔记本电脑！&quot;);\r\n\r\n        Items items_2 = new Items();\r\n        items_2.setName(&quot;苹果手机&quot;);\r\n        items_2.setPrice(5000f);\r\n        items_2.setDetail(&quot;iphone6苹果手机！&quot;);\r\n\r\n        itemsList.add(items_1);\r\n        itemsList.add(items_2);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(&quot;itemsList&quot;,itemsList);\r\n\r\n        //指定视图\r\n        modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);\r\n        return modelAndView;\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2--spring-handler\"><a name=\"在spring容器中加载Handler\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>在spring容器中加载Handler</h2><pre><code>&lt;!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    --&gt;\r\n    &lt;!--  &lt;bean  class=&quot;com.iot.ssm.controller.ItemsController3&quot;/&gt; --&gt;\r\n    &lt;!-- 可以扫描controller、service、...\r\n    这里让扫描controller，指定controller的包\r\n     --&gt;\r\n    &lt;context:component-scan base-package=&quot;com.iot.ssm.controller&quot;&gt;&lt;/context:component-scan&gt;\r\n</code></pre>', '107', '# 注解的处理器映射器和适配器\r\n\r\n## 默认加载\r\n\r\n前端控制器从`\\org\\springframework\\web\\servlet\\DispatcherServlet.properties`件中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的\r\n\r\n注解的处理器映射器和适配器\r\n\r\n*   在spring3.1之前使用`org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping`注解映射器。\r\n*   在spring3.1之后使用`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping`注解映射器。\r\n*   在spring3.1之前使用`org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter`注解适配器。\r\n*   在spring3.1之后使用`org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter`注解适配器\r\n\r\n## 注解的处理器映射器和适配器\r\n\r\n```\r\n<!-- 注解的映射器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\r\n\r\n<!-- 注解的适配器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\r\n\r\n```\r\n\r\n或者\r\n\r\n```\r\n    <!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     -->\r\n    <mvc:annotation-driven></mvc:annotation-driven>\r\n\r\n```\r\n\r\n## 开发注解Handler\r\n\r\n使用注解的映射器和注解的适配器。(使用注解的映射器和注解的适配器必须配对使用)\r\n\r\n```\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\npublic class ItemsController3 {\r\n\r\n    //商品查询列表\r\n    @RequestMapping(\"/queryItems\")\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表，这里使用静态数据模拟\r\n        List<Items> itemsList = new ArrayList<Items>();\r\n\r\n        //向list中填充静态数据\r\n        Items items_1 = new Items();\r\n        items_1.setName(\"联想笔记本\");\r\n        items_1.setPrice(6000f);\r\n        items_1.setDetail(\"ThinkPad T430 c3 联想笔记本电脑！\");\r\n\r\n        Items items_2 = new Items();\r\n        items_2.setName(\"苹果手机\");\r\n        items_2.setPrice(5000f);\r\n        items_2.setDetail(\"iphone6苹果手机！\");\r\n\r\n        itemsList.add(items_1);\r\n        itemsList.add(items_2);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(\"itemsList\",itemsList);\r\n\r\n        //指定视图\r\n        modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n        return modelAndView;\r\n    }\r\n}\r\n```\r\n\r\n## 在spring容器中加载Handler\r\n\r\n```\r\n<!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    -->\r\n    <!--  <bean  class=\"com.iot.ssm.controller.ItemsController3\"/> -->\r\n    <!-- 可以扫描controller、service、...\r\n    这里让扫描controller，指定controller的包\r\n     -->\r\n    <context:component-scan base-package=\"com.iot.ssm.controller\"></context:component-scan>\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('82', 'springmvc前端控制器', '<h1 id=\"h1-u524Du7AEFu63A7u5236u5668\"><a name=\"前端控制器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前端控制器</h1><hr>\r\n<p>1.前端控制器接收请求</p>\r\n<p>调用<code>doDispatch</code>方法</p>\r\n<pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n        HttpServletRequest processedRequest = request;\r\n        HandlerExecutionChain mappedHandler = null;\r\n        boolean multipartRequestParsed = false;\r\n\r\n         。。。。。\r\n}\r\n</code></pre><p>2.前端控制器调用<code>HandlerMapping</code>（处理器映射器）根据url查找Handler</p>\r\n<pre><code>// Determine handler for the current request.\r\nmappedHandler = getHandler(processedRequest);\r\n</code></pre><pre><code>/**\r\n     * Return the HandlerExecutionChain for this request.\r\n     * &lt;p&gt;Tries all handler mappings in order.\r\n     * @param request current HTTP request\r\n     * @return the HandlerExecutionChain, or {@code null} if no handler could be found\r\n     */\r\n    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\r\n        for (HandlerMapping hm : this.handlerMappings) {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\r\n                        &quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);\r\n            }\r\n            HandlerExecutionChain handler = hm.getHandler(request);\r\n            if (handler != null) {\r\n                return handler;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n</code></pre><p>3.调用处理器适配器执行Handler,得到执行的结果<code>ModelAndView mv</code></p>\r\n<p>在<code>doDispatch</code>方法中</p>\r\n<pre><code>// Actually invoke the handler.\r\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\r\n</code></pre><p>4.视图渲染，将model数据填充到request域</p>\r\n<p><code>doDispatch</code>-&gt;<code>processDispatchResult</code>-&gt;<code>render</code></p>\r\n<p>在<code>render</code>方法中,视图解析得到view</p>\r\n<pre><code>// We need to resolve the view name.\r\nview = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);\r\n</code></pre><p>调用view的渲染方法，将model数据填充到request域</p>\r\n<p>在<code>render</code>方法中,调用<code>View</code>接口的<code>render</code>方法</p>\r\n<pre><code>view.render(mv.getModelInternal(), request, response);\r\n</code></pre>', '108', '# 前端控制器\r\n\r\n* * *\r\n\r\n1.前端控制器接收请求\r\n\r\n调用`doDispatch`方法\r\n\r\n```\r\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n        HttpServletRequest processedRequest = request;\r\n        HandlerExecutionChain mappedHandler = null;\r\n        boolean multipartRequestParsed = false;\r\n\r\n         。。。。。\r\n}\r\n```\r\n\r\n2.前端控制器调用`HandlerMapping`（处理器映射器）根据url查找Handler\r\n\r\n```\r\n// Determine handler for the current request.\r\nmappedHandler = getHandler(processedRequest);\r\n```\r\n\r\n```\r\n/**\r\n     * Return the HandlerExecutionChain for this request.\r\n     * <p>Tries all handler mappings in order.\r\n     * @param request current HTTP request\r\n     * @return the HandlerExecutionChain, or {@code null} if no handler could be found\r\n     */\r\n    protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\r\n        for (HandlerMapping hm : this.handlerMappings) {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\r\n                        \"Testing handler map [\" + hm + \"] in DispatcherServlet with name \'\" + getServletName() + \"\'\");\r\n            }\r\n            HandlerExecutionChain handler = hm.getHandler(request);\r\n            if (handler != null) {\r\n                return handler;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n```\r\n\r\n3.调用处理器适配器执行Handler,得到执行的结果`ModelAndView mv`\r\n\r\n在`doDispatch`方法中\r\n\r\n```\r\n// Actually invoke the handler.\r\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\r\n```\r\n\r\n4.视图渲染，将model数据填充到request域\r\n\r\n`doDispatch`->`processDispatchResult`->`render`\r\n\r\n在`render`方法中,视图解析得到view\r\n\r\n```\r\n// We need to resolve the view name.\r\nview = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);\r\n\r\n```\r\n\r\n调用view的渲染方法，将model数据填充到request域\r\n\r\n在`render`方法中,调用`View`接口的`render`方法\r\n\r\n```\r\nview.render(mv.getModelInternal(), request, response);\r\n```\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('83', 'springmvc小结', '<p>通过入门程序理解springmvc前端控制器、处理器映射器、处理器适配器、视图解析器用法。并附上入门程序的非注解的完整的配置文件，注解的完整配置文件。</p>\r\n<h2 id=\"h2-u5165u95E8u7A0Bu5E8Fu914Du7F6Eu5C0Fu7ED3\"><a name=\"入门程序配置小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>入门程序配置小结</h2><p>前端控制器配置：</p>\r\n<ul>\r\n<li>第一种：<code>*.action</code>，访问以<code>.action</code>结尾 由<code>DispatcherServlet</code>进行解析</li><li>第二种：<code>/</code>，所以访问的地址都由<code>DispatcherServlet</code>进行解析，对于静态文件的解析需要配置不让<code>DispatcherServlet</code>进行解析,使用此种方式可以实现RESTful风格的url</li></ul>\r\n<p>处理器映射器：</p>\r\n<ul>\r\n<li>非注解处理器映射器（了解）</li><li>注解的处理器映射器（掌握）</li></ul>\r\n<p>对标记<code><a href=\"https://github.com/Controller\" title=\"&#64;Controller\" class=\"at-link\">@Controller</a></code>类中标识有<code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code>的方法进行映射。在<code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code>里边定义映射的url。使用注解的映射器不用在xml中配置url和Handler的映射关系。</p>\r\n<p>处理器适配器：</p>\r\n<p>非注解处理器适配器（了解）<br>注解的处理器适配器（掌握）<br>注解处理器适配器和注解的处理器映射器是<strong>配对使用</strong>。理解为不能使用非注解映射器进行映射。</p>\r\n<pre><code>&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;\r\n</code></pre><p>可以代替下边的配置：</p>\r\n<pre><code>&lt;!--注解映射器 --&gt;  \r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;  \r\n    &lt;!--注解适配器 --&gt;  \r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;\r\n</code></pre><h2 id=\"h2-u975Eu6CE8u89E3u7684u5B8Cu6574u7684u914Du7F6Eu6587u4EF6\"><a name=\"非注解的完整的配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>非注解的完整的配置文件</h2><p><code>src/main/resources/springmvc.xml</code></p>\r\n<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;\r\n\r\n    &lt;!-- 配置Handler --&gt;\r\n    &lt;bean name=&quot;/queryItems.action&quot; class=&quot;com.iot.ssm.controller.ItemsController&quot;/&gt;\r\n\r\n    &lt;!-- 处理器映射器\r\n    将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n     --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;\r\n\r\n    &lt;!-- 处理器适配器\r\n     所有处理器适配器都实现了HandlerAdapter接口\r\n     --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;\r\n\r\n    &lt;!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt;\r\n\r\n&lt;/beans&gt;\r\n</code></pre><h2 id=\"h2-u6CE8u89E3u7684u5B8Cu6574u914Du7F6Eu6587u4EF6\"><a name=\"注解的完整配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>注解的完整配置文件</h2><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;\r\n\r\n   &lt;!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    --&gt;\r\n    &lt;!--  &lt;bean  class=&quot;com.iot.ssm.controller.ItemsController3&quot;/&gt; --&gt;\r\n    &lt;!-- 可以扫描controller、service、...\r\n    这里让扫描controller，指定controller的包\r\n     --&gt;\r\n    &lt;context:component-scan base-package=&quot;com.iot.ssm.controller&quot;&gt;&lt;/context:component-scan&gt;\r\n\r\n    &lt;!-- 注解的映射器 --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;\r\n\r\n    &lt;!-- 注解的适配器 --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;/&gt;\r\n\r\n    &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     --&gt;\r\n    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;\r\n\r\n    &lt;!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r\n        &lt;!-- 配置jsp路径的前缀 --&gt;\r\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\r\n        &lt;!-- 配置jsp路径的后缀 --&gt;\r\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\r\n    &lt;/bean&gt;\r\n\r\n&lt;/beans&gt;\r\n</code></pre>', '109', '\r\n\r\n通过入门程序理解springmvc前端控制器、处理器映射器、处理器适配器、视图解析器用法。并附上入门程序的非注解的完整的配置文件，注解的完整配置文件。\r\n\r\n## 入门程序配置小结\r\n\r\n前端控制器配置：\r\n\r\n*   第一种：`*.action`，访问以`.action`结尾 由`DispatcherServlet`进行解析\r\n*   第二种：`/`，所以访问的地址都由`DispatcherServlet`进行解析，对于静态文件的解析需要配置不让`DispatcherServlet`进行解析,使用此种方式可以实现RESTful风格的url\r\n\r\n处理器映射器：\r\n\r\n*   非注解处理器映射器（了解）\r\n*   注解的处理器映射器（掌握）\r\n\r\n对标记`@Controller`类中标识有`@RequestMapping`的方法进行映射。在`@RequestMapping`里边定义映射的url。使用注解的映射器不用在xml中配置url和Handler的映射关系。\r\n\r\n处理器适配器：\r\n\r\n非注解处理器适配器（了解）\r\n注解的处理器适配器（掌握）\r\n注解处理器适配器和注解的处理器映射器是**配对使用**。理解为不能使用非注解映射器进行映射。\r\n\r\n```\r\n<mvc:annotation-driven></mvc:annotation-driven> \r\n```\r\n\r\n可以代替下边的配置：\r\n\r\n```\r\n<!--注解映射器 -->  \r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>  \r\n    <!--注解适配器 -->  \r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>  \r\n```\r\n\r\n## 非注解的完整的配置文件\r\n\r\n`src/main/resources/springmvc.xml`\r\n\r\n```\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n    <!-- 配置Handler -->\r\n    <bean name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/>\r\n\r\n    <!-- 处理器映射器\r\n    将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)\r\n     -->\r\n    <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/>\r\n\r\n    <!-- 处理器适配器\r\n     所有处理器适配器都实现了HandlerAdapter接口\r\n     -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/>\r\n\r\n    <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/>\r\n\r\n</beans>\r\n```\r\n\r\n## 注解的完整配置文件\r\n\r\n```\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n   <!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    -->\r\n    <!--  <bean  class=\"com.iot.ssm.controller.ItemsController3\"/> -->\r\n    <!-- 可以扫描controller、service、...\r\n    这里让扫描controller，指定controller的包\r\n     -->\r\n    <context:component-scan base-package=\"com.iot.ssm.controller\"></context:component-scan>\r\n\r\n    <!-- 注解的映射器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\r\n\r\n    <!-- 注解的适配器 -->\r\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\r\n\r\n    <!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     -->\r\n    <mvc:annotation-driven></mvc:annotation-driven>\r\n\r\n    <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- 配置jsp路径的前缀 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <!-- 配置jsp路径的后缀 -->\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('84', 'springmvc整合mybatis', '<p>本文主要展示如何在intellij IDEA中通过maven构建springmvc+mybatis框架的开发环境。</p>\r\n<p>需求：使用springmvc和mybatis完成商品列表查询</p>\r\n<h2 id=\"h2-u6574u5408u601Du8DEF\"><a name=\"整合思路\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>整合思路</h2><p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88mybatis%E6%80%9D%E8%B7%AF.png\" alt=\"springmvc_整合mybatis思路\"></p>\r\n<ul>\r\n<li><p>第一步：整合dao层</p>\r\n<ul>\r\n<li>mybatis和spring整合，通过spring管理mapper接口。</li><li>使用mapper的扫描器自动扫描mapper接口在spring中进行注册。</li></ul>\r\n</li><li><p>第二步：整合service层</p>\r\n<ul>\r\n<li>通过spring管理service接口。</li><li>使用配置方式将service接口配置在spring配置文件中。</li><li>实现事务控制。</li></ul>\r\n</li><li><p>第三步：整合springmvc</p>\r\n<ul>\r\n<li>由于springmvc是spring的模块，不需要整合。</li></ul>\r\n</li></ul>\r\n<h2 id=\"h2-u5DE5u7A0Bu7ED3u6784\"><a name=\"工程结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工程结构</h2><p>不同于<a href=\"http://blog.csdn.net/h3243212/article/details/50778934\">《mybatis学习笔记(17)-spring和mybatis整合》</a>中的示例demo,<strong>本文的整合采用maven构建</strong>。</p>\r\n<p>如何创建使用maven构建的web应用可以参考前面的一篇<a href=\"http://blog.csdn.net/h3243212/article/details/50828141#环境搭建\">《springmvc学习笔记(1)-框架原理和入门配置》</a></p>\r\n<p><code>new-&gt;project-&gt;maven</code>，建一个裸的maven工程，手动建webapp的目录</p>\r\n<p>在<code>src/main</code>下新建文件夹<code>webapp</code></p>\r\n<h3 id=\"h3-u6DFBu52A0u4F9Du8D56\"><a name=\"添加依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>添加依赖</h3><p>pom.xml文件</p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\r\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\r\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\r\n\r\n    &lt;groupId&gt;com.iot.learnssm&lt;/groupId&gt;\r\n    &lt;artifactId&gt;learnssm-firstssm&lt;/artifactId&gt;\r\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\r\n    &lt;packaging&gt;war&lt;/packaging&gt;\r\n\r\n    &lt;properties&gt;\r\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\r\n        &lt;!-- jar 版本设置 --&gt;\r\n        &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;\r\n    &lt;/properties&gt;\r\n\r\n    &lt;dependencies&gt;\r\n\r\n        &lt;!-- spring框架--&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\r\n            &lt;version&gt;${spring.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;\r\n            &lt;version&gt;${spring.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;\r\n            &lt;version&gt;${spring.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\r\n            &lt;version&gt;${spring.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\r\n            &lt;version&gt;${spring.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\r\n            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\r\n            &lt;version&gt;${spring.version}&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\r\n            &lt;version&gt;5.1.38&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\r\n            &lt;version&gt;3.3.1&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\r\n            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\r\n            &lt;version&gt;1.2.4&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;log4j&lt;/groupId&gt;\r\n            &lt;artifactId&gt;log4j&lt;/artifactId&gt;\r\n            &lt;version&gt;1.2.17&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\r\n            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\r\n            &lt;version&gt;1.7.18&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;\r\n            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;\r\n            &lt;version&gt;1.4&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n\r\n        &lt;!-- JSP tag --&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\r\n            &lt;artifactId&gt;jstl&lt;/artifactId&gt;\r\n            &lt;version&gt;1.2&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n        &lt;dependency&gt;\r\n            &lt;groupId&gt;taglibs&lt;/groupId&gt;\r\n            &lt;artifactId&gt;standard&lt;/artifactId&gt;\r\n            &lt;version&gt;1.1.2&lt;/version&gt;\r\n        &lt;/dependency&gt;\r\n    &lt;/dependencies&gt;\r\n\r\n&lt;/project&gt;\r\n</code></pre><p>这里添加的依赖可能有多的,但总比少包好，我开始就是引少了依赖(springframework的依赖只引用了<a href=\"http://lib.csdn.net/base/javaee\" title=\"Java EE知识库\">spring</a>-mvc,连spring-core都没引)，导致报错,以后会出一篇博客专门讲这个系列笔记中debug相关问题。</p>\r\n<h3 id=\"h3-u5EFAu5305\"><a name=\"建包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>建包</h3><p>在<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>目录下建各个package,按照maven的明明习惯:</p>\r\n<p><code>com.公司名.项目名.模块名</code></p>\r\n<p>这里我的包为：</p>\r\n<p><code>com.iot.learnssm.firstssm</code></p>\r\n<p>包含几个子包：</p>\r\n<ul>\r\n<li>controller</li><li>mapper</li><li>po</li><li><p>service</p>\r\n<ul>\r\n<li>impl</li></ul>\r\n</li></ul>\r\n<p>项目结构如图：</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B-1.png\" alt=\"springmvc_整合工程-1\"></p>\r\n<p>后面几篇笔记会依次记录mapper,service,controller各个部分的整合</p>\r\n<hr>\r\n<blockquote>\r\n<p>作者<a href=\"http://brianway.github.io/\"\">&#64;brianway</a>更多文章：<a href=\"http://brianway.github.io/\">个人网站</a> <code>|</code> <a href=\"http://blog.csdn.net/h3243212/\">CSDN</a> <code>|</code> <a href=\"http://my.oschina.net/brianway\">oschina</a></p>\r\n</blockquote>\r\n', '110', '\r\n本文主要展示如何在intellij IDEA中通过maven构建springmvc+mybatis框架的开发环境。\r\n\r\n需求：使用springmvc和mybatis完成商品列表查询\r\n\r\n## 整合思路\r\n\r\n![springmvc_整合mybatis思路](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88mybatis%E6%80%9D%E8%B7%AF.png)\r\n\r\n*   第一步：整合dao层\r\n\r\n    *   mybatis和spring整合，通过spring管理mapper接口。\r\n    *   使用mapper的扫描器自动扫描mapper接口在spring中进行注册。\r\n*   第二步：整合service层\r\n\r\n    *   通过spring管理service接口。\r\n    *   使用配置方式将service接口配置在spring配置文件中。\r\n    *   实现事务控制。\r\n*   第三步：整合springmvc\r\n\r\n    *   由于springmvc是spring的模块，不需要整合。\r\n\r\n## 工程结构\r\n\r\n不同于[《mybatis学习笔记(17)-spring和mybatis整合》](http://blog.csdn.net/h3243212/article/details/50778934)中的示例demo,**本文的整合采用maven构建**。\r\n\r\n如何创建使用maven构建的web应用可以参考前面的一篇[《springmvc学习笔记(1)-框架原理和入门配置》](http://blog.csdn.net/h3243212/article/details/50828141#环境搭建)\r\n\r\n`new->project->maven`，建一个裸的maven工程，手动建webapp的目录\r\n\r\n在`src/main`下新建文件夹`webapp`\r\n\r\n### 添加依赖\r\n\r\npom.xml文件\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.iot.learnssm</groupId>\r\n    <artifactId>learnssm-firstssm</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <packaging>war</packaging>\r\n\r\n    <properties>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <!-- jar 版本设置 -->\r\n        <spring.version>4.2.4.RELEASE</spring.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n\r\n        <!-- spring框架-->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-webmvc</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-core</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-orm</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-aspects</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-test</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-jdbc</artifactId>\r\n            <version>${spring.version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>5.1.38</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis</artifactId>\r\n            <version>3.3.1</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.mybatis</groupId>\r\n            <artifactId>mybatis-spring</artifactId>\r\n            <version>1.2.4</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>log4j</groupId>\r\n            <artifactId>log4j</artifactId>\r\n            <version>1.2.17</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.slf4j</groupId>\r\n            <artifactId>slf4j-api</artifactId>\r\n            <version>1.7.18</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>commons-dbcp</groupId>\r\n            <artifactId>commons-dbcp</artifactId>\r\n            <version>1.4</version>\r\n        </dependency>\r\n\r\n        <!-- JSP tag -->\r\n        <dependency>\r\n            <groupId>javax.servlet</groupId>\r\n            <artifactId>jstl</artifactId>\r\n            <version>1.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>taglibs</groupId>\r\n            <artifactId>standard</artifactId>\r\n            <version>1.1.2</version>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n\r\n这里添加的依赖可能有多的,但总比少包好，我开始就是引少了依赖(springframework的依赖只引用了[spring](http://lib.csdn.net/base/javaee \"Java EE知识库\")-mvc,连spring-core都没引)，导致报错,以后会出一篇博客专门讲这个系列笔记中debug相关问题。\r\n\r\n### 建包\r\n\r\n在[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")目录下建各个package,按照maven的明明习惯:\r\n\r\n`com.公司名.项目名.模块名`\r\n\r\n这里我的包为：\r\n\r\n`com.iot.learnssm.firstssm`\r\n\r\n包含几个子包：\r\n\r\n*   controller\r\n*   mapper\r\n*   po\r\n*   service\r\n\r\n    *   impl\r\n\r\n项目结构如图：\r\n\r\n![springmvc_整合工程-1](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B-1.png)\r\n\r\n后面几篇笔记会依次记录mapper,service,controller各个部分的整合\r\n\r\n* * *\r\n\r\n> 作者[@brianway](http://brianway.github.io/)更多文章：[个人网站](http://brianway.github.io/) `|` [CSDN](http://blog.csdn.net/h3243212/) `|` [oschina](http://my.oschina.net/brianway)');
INSERT INTO `article_info_true` VALUES ('85', 'springmvc整合mybatis之mapper', '<h2 id=\"h2--dao\"><a name=\"整合dao\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>整合dao</h2><p>首先在resource文件夹下添加两个文件：<a href=\"http://lib.csdn.net/base/mysql\" title=\"MySQL知识库\">数据库</a>配置文件和日志配置文件</p>\r\n<ul>\r\n<li>数据库配置文件db.properties</li></ul>\r\n<pre><code>jdbc.driver=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\r\njdbc.username=root\r\njdbc.password=123\r\n</code></pre><ul>\r\n<li>日志配置文件log4j.properties</li></ul>\r\n<pre><code># Global logging configuration\r\nlog4j.rootLogger=DEBUG, stdout\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n</code></pre><h3 id=\"h3-sqlmapconfig-xml\"><a name=\"sqlMapConfig.xml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>sqlMapConfig.xml</h3><p>mybatis自己的配置文件</p>\r\n<p>在resources目录下新建mybatis文件夹，并新建sqlMapConfig.xml文件</p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r\n&lt;!DOCTYPE configuration\r\n        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;\r\n        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;\r\n&lt;configuration&gt;\r\n\r\n    &lt;!-- 全局setting配置，根据需要添加 --&gt;\r\n\r\n    &lt;!-- 配置别名 --&gt;\r\n    &lt;typeAliases&gt;\r\n        &lt;!-- 批量扫描别名 --&gt;\r\n        &lt;package name=&quot;com.iot.learnssm.firstssm.po&quot;/&gt;\r\n    &lt;/typeAliases&gt;\r\n\r\n    &lt;!-- 配置mapper\r\n    由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。\r\n    必须遵循：mapper.xml和mapper.java文件同名且在一个目录\r\n     --&gt;\r\n\r\n    &lt;!-- &lt;mappers&gt;\r\n\r\n    &lt;/mappers&gt; --&gt;\r\n&lt;/configuration&gt;\r\n</code></pre><h3 id=\"h3-applicationcontext-dao-xml\"><a name=\"applicationContext-dao.xml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>applicationContext-dao.xml</h3><p>在resources目录下新建<a href=\"http://lib.csdn.net/base/javaee\" title=\"Java EE知识库\">spring</a>文件夹，并新建applicationContext-dao.xml文件</p>\r\n<p>配置：</p>\r\n<ul>\r\n<li>数据源</li><li>SqlSessionFactory</li><li>mapper扫描器</li></ul>\r\n<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;\r\n\r\n    &lt;!-- 加载db.properties文件中的内容，db.properties文件中key命名要有一定的特殊规则 --&gt;\r\n    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;\r\n    &lt;!-- 配置数据源 ，dbcp --&gt;\r\n\r\n    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\r\n        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&gt;\r\n        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;\r\n        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;\r\n        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;\r\n        &lt;property name=&quot;maxActive&quot; value=&quot;30&quot; /&gt;\r\n        &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt;\r\n    &lt;/bean&gt;\r\n\r\n    &lt;!-- 从整合包里找，org.mybatis:mybatis-spring:1.2.4 --&gt;\r\n    &lt;!-- sqlSessionFactory --&gt;\r\n    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;\r\n        &lt;!-- 数据库连接池 --&gt;\r\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;\r\n        &lt;!-- 加载mybatis的全局配置文件 --&gt;\r\n        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/sqlMapConfig.xml&quot; /&gt;\r\n    &lt;/bean&gt;\r\n    &lt;!-- mapper扫描器 --&gt;\r\n    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;\r\n        &lt;!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 --&gt;\r\n        &lt;property name=&quot;basePackage&quot; value=&quot;com.iot.learnssm.firstssm.mapper&quot;/&gt;\r\n        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;\r\n       &lt;!-- &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;\r\n       会导致数据源配置不管用，数据库连接不上。\r\n       且spring 4弃用\r\n       --&gt;\r\n    &lt;/bean&gt;\r\n\r\n&lt;/beans&gt;\r\n</code></pre><h3 id=\"h3--mapper\"><a name=\"手动定义商品查询mapper\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>手动定义商品查询mapper</h3><p>针对综合查询mapper，一般情况会有关联查询，建议自定义mapper</p>\r\n<ul>\r\n<li>ItemsMapperCustom.xml</li></ul>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r\n&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;\r\n&lt;mapper namespace=&quot;com.iot.learnssm.firstssm.mapper.ItemsMapperCustom&quot; &gt;\r\n\r\n   &lt;!-- 定义商品查询的sql片段，就是商品查询条件 --&gt;\r\n   &lt;sql id=&quot;query_items_where&quot;&gt;\r\n    &lt;!-- 使用动态sql，通过if判断，满足条件进行sql拼接 --&gt;\r\n    &lt;!-- 商品查询条件通过ItemsQueryVo包装对象 中itemsCustom属性传递 --&gt;\r\n        &lt;if test=&quot;itemsCustom!=null&quot;&gt;\r\n            &lt;if test=&quot;itemsCustom.name!=null and itemsCustom.name!=&#39;&#39;&quot;&gt;\r\n                items.name LIKE &#39;%${itemsCustom.name}%&#39;\r\n            &lt;/if&gt;\r\n        &lt;/if&gt;\r\n\r\n   &lt;/sql&gt;\r\n\r\n    &lt;!-- 商品列表查询 --&gt;\r\n    &lt;!-- parameterType传入包装对象(包装了查询条件)\r\n        resultType建议使用扩展对象\r\n     --&gt;\r\n    &lt;select id=&quot;findItemsList&quot; parameterType=&quot;com.iot.learnssm.firstssm.po.ItemsQueryVo&quot;\r\n         resultType=&quot;com.iot.learnssm.firstssm.po.ItemsCustom&quot;&gt;\r\n        SELECT items.* FROM items  \r\n        &lt;where&gt;\r\n            &lt;include refid=&quot;query_items_where&quot;&gt;&lt;/include&gt;\r\n        &lt;/where&gt;\r\n    &lt;/select&gt;\r\n\r\n&lt;/mapper&gt;\r\n</code></pre><ul>\r\n<li>ItemsMapperCustom.java</li></ul>\r\n<pre><code>public interface ItemsMapperCustom {\r\n    //商品查询列表\r\n    List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo)throws Exception;\r\n}\r\n</code></pre><ul>\r\n<li>po类<code>ItemsCustom</code></li></ul>\r\n<pre><code>package com.iot.learnssm.firstssm.po;\r\n\r\n/**\r\n * Created by Brian on 2016/3/2.\r\n * 商品信息的扩展类\r\n */\r\npublic class ItemsCustom extends Items{\r\n    //添加商品信息的扩展属性\r\n}\r\n</code></pre><ul>\r\n<li>输入pojo的包装类</li></ul>\r\n<pre><code>package com.iot.learnssm.firstssm.po;\r\n\r\n/**\r\n * Created by Brian on 2016/3/2.\r\n */\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n\r\n    public Items getItems() {\r\n        return items;\r\n    }\r\n\r\n    public void setItems(Items items) {\r\n        this.items = items;\r\n    }\r\n\r\n    public ItemsCustom getItemsCustom() {\r\n        return itemsCustom;\r\n    }\r\n\r\n    public void setItemsCustom(ItemsCustom itemsCustom) {\r\n        this.itemsCustom = itemsCustom;\r\n    }\r\n}\r\n</code></pre><p>整合好dao后的工程目录如图</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B-2.png\" alt=\"springmvc_整合工程-2\"></p>\r\n', '111', '\r\n## 整合dao\r\n\r\n首先在resource文件夹下添加两个文件：[数据库](http://lib.csdn.net/base/mysql \"MySQL知识库\")配置文件和日志配置文件\r\n\r\n*   数据库配置文件db.properties\r\n\r\n```\r\njdbc.driver=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\r\njdbc.username=root\r\njdbc.password=123\r\n```\r\n\r\n*   日志配置文件log4j.properties\r\n\r\n```\r\n# Global logging configuration\r\nlog4j.rootLogger=DEBUG, stdout\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n```\r\n\r\n### sqlMapConfig.xml\r\n\r\nmybatis自己的配置文件\r\n\r\n在resources目录下新建mybatis文件夹，并新建sqlMapConfig.xml文件\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n\r\n    <!-- 全局setting配置，根据需要添加 -->\r\n\r\n    <!-- 配置别名 -->\r\n    <typeAliases>\r\n        <!-- 批量扫描别名 -->\r\n        <package name=\"com.iot.learnssm.firstssm.po\"/>\r\n    </typeAliases>\r\n\r\n    <!-- 配置mapper\r\n    由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。\r\n    必须遵循：mapper.xml和mapper.java文件同名且在一个目录\r\n     -->\r\n\r\n    <!-- <mappers>\r\n\r\n    </mappers> -->\r\n</configuration>\r\n```\r\n\r\n### applicationContext-dao.xml\r\n\r\n在resources目录下新建[spring](http://lib.csdn.net/base/javaee \"Java EE知识库\")文件夹，并新建applicationContext-dao.xml文件\r\n\r\n配置：\r\n\r\n*   数据源\r\n*   SqlSessionFactory\r\n*   mapper扫描器\r\n\r\n```\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n    <!-- 加载db.properties文件中的内容，db.properties文件中key命名要有一定的特殊规则 -->\r\n    <context:property-placeholder location=\"classpath:db.properties\" />\r\n    <!-- 配置数据源 ，dbcp -->\r\n\r\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\r\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\r\n        <property name=\"url\" value=\"${jdbc.url}\"/>\r\n        <property name=\"username\" value=\"${jdbc.username}\" />\r\n        <property name=\"password\" value=\"${jdbc.password}\" />\r\n        <property name=\"maxActive\" value=\"30\" />\r\n        <property name=\"maxIdle\" value=\"5\" />\r\n    </bean>\r\n\r\n    <!-- 从整合包里找，org.mybatis:mybatis-spring:1.2.4 -->\r\n    <!-- sqlSessionFactory -->\r\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n        <!-- 数据库连接池 -->\r\n        <property name=\"dataSource\" ref=\"dataSource\" />\r\n        <!-- 加载mybatis的全局配置文件 -->\r\n        <property name=\"configLocation\" value=\"classpath:mybatis/sqlMapConfig.xml\" />\r\n    </bean>\r\n    <!-- mapper扫描器 -->\r\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n        <!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 -->\r\n        <property name=\"basePackage\" value=\"com.iot.learnssm.firstssm.mapper\"/>\r\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" />\r\n       <!-- <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" />\r\n       会导致数据源配置不管用，数据库连接不上。\r\n       且spring 4弃用\r\n       -->\r\n    </bean>\r\n\r\n</beans>\r\n\r\n```\r\n\r\n### 手动定义商品查询mapper\r\n\r\n针对综合查询mapper，一般情况会有关联查询，建议自定义mapper\r\n\r\n*   ItemsMapperCustom.xml\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\r\n<mapper namespace=\"com.iot.learnssm.firstssm.mapper.ItemsMapperCustom\" >\r\n\r\n   <!-- 定义商品查询的sql片段，就是商品查询条件 -->\r\n   <sql id=\"query_items_where\">\r\n    <!-- 使用动态sql，通过if判断，满足条件进行sql拼接 -->\r\n    <!-- 商品查询条件通过ItemsQueryVo包装对象 中itemsCustom属性传递 -->\r\n        <if test=\"itemsCustom!=null\">\r\n            <if test=\"itemsCustom.name!=null and itemsCustom.name!=\'\'\">\r\n                items.name LIKE \'%${itemsCustom.name}%\'\r\n            </if>\r\n        </if>\r\n\r\n   </sql>\r\n\r\n    <!-- 商品列表查询 -->\r\n    <!-- parameterType传入包装对象(包装了查询条件)\r\n        resultType建议使用扩展对象\r\n     -->\r\n    <select id=\"findItemsList\" parameterType=\"com.iot.learnssm.firstssm.po.ItemsQueryVo\"\r\n         resultType=\"com.iot.learnssm.firstssm.po.ItemsCustom\">\r\n        SELECT items.* FROM items  \r\n        <where>\r\n            <include refid=\"query_items_where\"></include>\r\n        </where>\r\n    </select>\r\n\r\n</mapper>\r\n```\r\n\r\n*   ItemsMapperCustom.java\r\n\r\n```\r\npublic interface ItemsMapperCustom {\r\n    //商品查询列表\r\n    List<ItemsCustom> findItemsList(ItemsQueryVo itemsQueryVo)throws Exception;\r\n}\r\n```\r\n\r\n*   po类`ItemsCustom`\r\n\r\n```\r\npackage com.iot.learnssm.firstssm.po;\r\n\r\n/**\r\n * Created by Brian on 2016/3/2.\r\n * 商品信息的扩展类\r\n */\r\npublic class ItemsCustom extends Items{\r\n    //添加商品信息的扩展属性\r\n}\r\n```\r\n\r\n*   输入pojo的包装类\r\n\r\n```\r\npackage com.iot.learnssm.firstssm.po;\r\n\r\n/**\r\n * Created by Brian on 2016/3/2.\r\n */\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n\r\n    public Items getItems() {\r\n        return items;\r\n    }\r\n\r\n    public void setItems(Items items) {\r\n        this.items = items;\r\n    }\r\n\r\n    public ItemsCustom getItemsCustom() {\r\n        return itemsCustom;\r\n    }\r\n\r\n    public void setItemsCustom(ItemsCustom itemsCustom) {\r\n        this.itemsCustom = itemsCustom;\r\n    }\r\n}\r\n```\r\n\r\n整合好dao后的工程目录如图\r\n\r\n![springmvc_整合工程-2](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%95%B4%E5%90%88%E5%B7%A5%E7%A8%8B-2.png)\r\n');
INSERT INTO `article_info_true` VALUES ('86', 'springmvc整合mybatis之service', '<p>本文记录如何整合service,包括定义spring接口，在spring容器配置service以及事务控制。让spring管理service接口。</p>\r\n<h2 id=\"h2--service-\"><a name=\"定义service接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>定义service接口</h2><pre><code>public interface ItemsService {\r\n    //商品查询列表\r\n    List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;\r\n\r\n}\r\n</code></pre><pre><code>public class ItemsServiceImpl implements ItemsService {\r\n\r\n    @Autowired\r\n    private ItemsMapperCustom itemsMapperCustom;\r\n\r\n    public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception {\r\n        return itemsMapperCustom.findItemsList(itemsQueryVo);\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2--spring-service\"><a name=\"在spring容器配置service\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>在spring容器配置service</h2><p>在<code>resources/spring</code>下创建applicationContext-service.xml，文件中配置service。</p>\r\n<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&quot;&gt;\r\n\r\n    &lt;!-- 商品管理的service --&gt;\r\n    &lt;bean id=&quot;itemsService&quot; class=&quot;com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl&quot;/&gt;\r\n\r\n&lt;/beans&gt;\r\n</code></pre><h2 id=\"h2-u4E8Bu52A1u63A7u5236\"><a name=\"事务控制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>事务控制</h2><p>在<code>resources/spring</code>下创建applicationContext-transaction.xml，在applicationContext-transaction.xml中使用spring声明式事务控制方法。</p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\r\n       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\r\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\r\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\r\n\r\n&lt;!-- 事务管理器\r\n        对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\r\n    --&gt;\r\n    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\r\n        &lt;!-- 数据源\r\n        dataSource在applicationContext-dao.xml中配置了\r\n         --&gt;\r\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\r\n    &lt;/bean&gt;\r\n\r\n    &lt;!-- 通知 --&gt;\r\n    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;\r\n        &lt;tx:attributes&gt;\r\n            &lt;!-- 传播行为 --&gt;\r\n            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;\r\n            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;\r\n            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;\r\n            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;\r\n            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;\r\n            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;\r\n            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;\r\n        &lt;/tx:attributes&gt;\r\n    &lt;/tx:advice&gt;\r\n    &lt;!-- aop --&gt;\r\n    &lt;aop:config&gt;\r\n        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.iot.learnssm.firstssm.service.impl.*.*(..))&quot;/&gt;\r\n    &lt;/aop:config&gt;\r\n&lt;/beans&gt;\r\n</code></pre>', '112', '\r\n\r\n本文记录如何整合service,包括定义spring接口，在spring容器配置service以及事务控制。让spring管理service接口。\r\n\r\n## 定义service接口\r\n\r\n```\r\npublic interface ItemsService {\r\n    //商品查询列表\r\n    List<ItemsCustom> findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;\r\n\r\n}\r\n```\r\n\r\n```\r\npublic class ItemsServiceImpl implements ItemsService {\r\n\r\n    @Autowired\r\n    private ItemsMapperCustom itemsMapperCustom;\r\n\r\n    public List<ItemsCustom> findItemsList(ItemsQueryVo itemsQueryVo) throws Exception {\r\n        return itemsMapperCustom.findItemsList(itemsQueryVo);\r\n    }\r\n}\r\n```\r\n\r\n## 在spring容器配置service\r\n\r\n在`resources/spring`下创建applicationContext-service.xml，文件中配置service。\r\n\r\n```\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\">\r\n\r\n    <!-- 商品管理的service -->\r\n    <bean id=\"itemsService\" class=\"com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl\"/>\r\n\r\n</beans>\r\n```\r\n\r\n## 事务控制\r\n\r\n在`resources/spring`下创建applicationContext-transaction.xml，在applicationContext-transaction.xml中使用spring声明式事务控制方法。\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\r\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\r\n\r\n<!-- 事务管理器\r\n        对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\r\n    -->\r\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n        <!-- 数据源\r\n        dataSource在applicationContext-dao.xml中配置了\r\n         -->\r\n        <property name=\"dataSource\" ref=\"dataSource\"/>\r\n    </bean>\r\n\r\n    <!-- 通知 -->\r\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\r\n        <tx:attributes>\r\n            <!-- 传播行为 -->\r\n            <tx:method name=\"save*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"insert*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"update*\" propagation=\"REQUIRED\"/>\r\n            <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\r\n            <tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\r\n            <tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\r\n        </tx:attributes>\r\n    </tx:advice>\r\n    <!-- aop -->\r\n    <aop:config>\r\n        <aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.iot.learnssm.firstssm.service.impl.*.*(..))\"/>\r\n    </aop:config>\r\n</beans>\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('87', 'springmvc整合mybatis之controller', '<p>本文介绍如何配置springmvc配置文件和web.xml，以及如何编写controller,jsp</p>\r\n<h2 id=\"h2-springmvc-xml\"><a name=\"springmvc.xml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc.xml</h2><p>在<code>resources/[spring](http://lib.csdn.net/base/javaee &quot;Java EE知识库&quot;)</code>文件下下创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。</p>\r\n<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\r\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;\r\n\r\n   &lt;!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    --&gt;\r\n    &lt;!-- 可以扫描controller、service、...\r\n    这里让扫描controller，指定controller的包\r\n     --&gt;\r\n    &lt;context:component-scan base-package=&quot;com.iot.learnssm.firstssm.controller&quot;&gt;&lt;/context:component-scan&gt;\r\n\r\n    &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     --&gt;\r\n    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;\r\n\r\n    &lt;!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    --&gt;\r\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r\n        &lt;!-- 配置jsp路径的前缀 --&gt;\r\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;\r\n        &lt;!-- 配置jsp路径的后缀 --&gt;\r\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\r\n    &lt;/bean&gt;\r\n\r\n&lt;/beans&gt;\r\n</code></pre><h2 id=\"h2--web-xml\"><a name=\"配置web.xml\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置web.xml</h2><p>参考入门程序，web.xml</p>\r\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;\r\n&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;\r\n         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;\r\n         id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;\r\n    &lt;display-name&gt;firstssm&lt;/display-name&gt;\r\n\r\n    &lt;!-- 加载spring容器 --&gt;\r\n    &lt;context-param&gt;\r\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\r\n        &lt;param-value&gt;WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt;\r\n        &lt;!--  &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;--&gt;\r\n      &lt;/context-param&gt;\r\n    &lt;listener&gt;\r\n      &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\r\n    &lt;/listener&gt;\r\n\r\n&lt;!-- springmvc 前端控制器  --&gt;\r\n    &lt;servlet&gt;\r\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\r\n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\r\n        &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)\r\n          若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)\r\n        --&gt;\r\n        &lt;init-param&gt;\r\n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\r\n            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;\r\n        &lt;/init-param&gt;\r\n    &lt;/servlet&gt;\r\n\r\n    &lt;servlet-mapping&gt;\r\n        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\r\n        &lt;!--\r\n        第一种:*.action,访问以.action三结尾，由DispatcherServlet进行解析\r\n        第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，\r\n                使用此种方式和实现RESTful风格的url\r\n        第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，\r\n                不能根据jsp页面找到handler，会报错\r\n        --&gt;\r\n        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;\r\n    &lt;/servlet-mapping&gt;\r\n\r\n    &lt;welcome-file-list&gt;\r\n        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\r\n        &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;\r\n        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\r\n        &lt;welcome-file&gt;default.html&lt;/welcome-file&gt;\r\n        &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;\r\n        &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;\r\n    &lt;/welcome-file-list&gt;\r\n&lt;/web-app&gt;\r\n</code></pre><p>这个文件有两个作用：</p>\r\n<ul>\r\n<li>配置前端控制器(<code>DispatcherServlet</code>)</li><li><p>加载spring容器：添加spring容器监听器，加载spring容器，使用通配符加载<code>spring/</code>下的配置文件</p>\r\n<ul>\r\n<li>applicationContext-dao.xml</li><li>applicationContext-service.xml</li><li>applicationContext-transaction.xml</li></ul>\r\n</li></ul>\r\n<h2 id=\"h2--controller-handler-\"><a name=\"编写Controller(就是Handler)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>编写Controller(就是Handler)</h2><pre><code>package com.iot.learnssm.firstssm.controller;\r\n\r\nimport com.iot.learnssm.firstssm.po.Items;\r\nimport com.iot.learnssm.firstssm.po.ItemsCustom;\r\nimport com.iot.learnssm.firstssm.service.ItemsService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by brian on 2016/3/2.\r\n */\r\n\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\npublic class ItemsController {\r\n\r\n    @Autowired\r\n    private ItemsService itemsService;\r\n\r\n    //商品查询列表\r\n    @RequestMapping(&quot;/queryItems&quot;)\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表\r\n        List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(&quot;itemsList&quot;,itemsList);\r\n\r\n        //指定视图\r\n        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n        //modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);\r\n        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\n        modelAndView.setViewName(&quot;items/itemsList&quot;);\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n}\r\n</code></pre><h2 id=\"h2--jsp\"><a name=\"编写jsp\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>编写jsp</h2><p>服务器路径为<code>WEB-INF/jsp/items/itemsList.jsp</code></p>\r\n<pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;\r\n    pageEncoding=&quot;UTF-8&quot;%&gt;\r\n&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;\r\n&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;  prefix=&quot;fmt&quot;%&gt;\r\n&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\r\n&lt;title&gt;查询商品列表&lt;/title&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt; \r\n&lt;form action=&quot;${pageContext.request.contextPath }/item/queryItem.action&quot; method=&quot;post&quot;&gt;\r\n查询条件：\r\n&lt;table width=&quot;100%&quot; border=1&gt;\r\n&lt;tr&gt;\r\n&lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;查询&quot;/&gt;&lt;/td&gt;\r\n&lt;/tr&gt;\r\n&lt;/table&gt;\r\n商品列表：\r\n&lt;table width=&quot;100%&quot; border=1&gt;\r\n&lt;tr&gt;\r\n    &lt;td&gt;商品名称&lt;/td&gt;\r\n    &lt;td&gt;商品价格&lt;/td&gt;\r\n    &lt;td&gt;生产日期&lt;/td&gt;\r\n    &lt;td&gt;商品描述&lt;/td&gt;\r\n    &lt;td&gt;操作&lt;/td&gt;\r\n&lt;/tr&gt;\r\n&lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot;&gt;\r\n&lt;tr&gt;\r\n    &lt;td&gt;${item.name }&lt;/td&gt;\r\n    &lt;td&gt;${item.price }&lt;/td&gt;\r\n    &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;\r\n    &lt;td&gt;${item.detail }&lt;/td&gt;\r\n\r\n    &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/item/editItem.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;\r\n\r\n&lt;/tr&gt;\r\n&lt;/c:forEach&gt;\r\n\r\n&lt;/table&gt;\r\n&lt;/form&gt;\r\n&lt;/body&gt;\r\n\r\n&lt;/html&gt;\r\n</code></pre>', '113', '\r\n\r\n本文介绍如何配置springmvc配置文件和web.xml，以及如何编写controller,jsp\r\n\r\n## springmvc.xml\r\n\r\n在`resources/[spring](http://lib.csdn.net/base/javaee \"Java EE知识库\")`文件下下创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。\r\n\r\n```\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n    http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\r\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\r\n\r\n   <!-- 对于注解的Handler 可以单个配置\r\n    实际开发中加你使用组件扫描\r\n    -->\r\n    <!-- 可以扫描controller、service、...\r\n    这里让扫描controller，指定controller的包\r\n     -->\r\n    <context:component-scan base-package=\"com.iot.learnssm.firstssm.controller\"></context:component-scan>\r\n\r\n    <!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置\r\n     mvc:annotation-driven默认加载很多的参数绑定方法，\r\n     比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\r\n     实际开发时使用mvc:annotation-driven\r\n     -->\r\n    <mvc:annotation-driven></mvc:annotation-driven>\r\n\r\n    <!-- 视图解析器\r\n    解析jsp,默认使用jstl,classpath下要有jstl的包\r\n    -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n        <!-- 配置jsp路径的前缀 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <!-- 配置jsp路径的后缀 -->\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n    </bean>\r\n\r\n</beans>\r\n```\r\n\r\n## 配置web.xml\r\n\r\n参考入门程序，web.xml\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\r\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\r\n         id=\"WebApp_ID\" version=\"3.0\">\r\n    <display-name>firstssm</display-name>\r\n\r\n    <!-- 加载spring容器 -->\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>WEB-INF/classes/spring/applicationContext-*.xml</param-value>\r\n        <!--  <param-value>classpath:spring/applicationContext-*.xml</param-value>-->\r\n      </context-param>\r\n    <listener>\r\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n\r\n<!-- springmvc 前端控制器  -->\r\n    <servlet>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等)\r\n          若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml)\r\n        -->\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <param-value>classpath:spring/springmvc.xml</param-value>\r\n        </init-param>\r\n    </servlet>\r\n\r\n    <servlet-mapping>\r\n        <servlet-name>springmvc</servlet-name>\r\n        <!--\r\n        第一种:*.action,访问以.action三结尾，由DispatcherServlet进行解析\r\n        第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析，\r\n                使用此种方式和实现RESTful风格的url\r\n        第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址，\r\n                不能根据jsp页面找到handler，会报错\r\n        -->\r\n        <url-pattern>*.action</url-pattern>\r\n    </servlet-mapping>\r\n\r\n    <welcome-file-list>\r\n        <welcome-file>index.html</welcome-file>\r\n        <welcome-file>index.htm</welcome-file>\r\n        <welcome-file>index.jsp</welcome-file>\r\n        <welcome-file>default.html</welcome-file>\r\n        <welcome-file>default.htm</welcome-file>\r\n        <welcome-file>default.jsp</welcome-file>\r\n    </welcome-file-list>\r\n</web-app>\r\n```\r\n\r\n这个文件有两个作用：\r\n\r\n*   配置前端控制器(`DispatcherServlet`)\r\n*   加载spring容器：添加spring容器监听器，加载spring容器，使用通配符加载`spring/`下的配置文件\r\n\r\n    *   applicationContext-dao.xml\r\n    *   applicationContext-service.xml\r\n    *   applicationContext-transaction.xml\r\n\r\n## 编写Controller(就是Handler)\r\n\r\n```\r\npackage com.iot.learnssm.firstssm.controller;\r\n\r\nimport com.iot.learnssm.firstssm.po.Items;\r\nimport com.iot.learnssm.firstssm.po.ItemsCustom;\r\nimport com.iot.learnssm.firstssm.service.ItemsService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Created by brian on 2016/3/2.\r\n */\r\n\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\npublic class ItemsController {\r\n\r\n    @Autowired\r\n    private ItemsService itemsService;\r\n\r\n    //商品查询列表\r\n    @RequestMapping(\"/queryItems\")\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表\r\n        List<ItemsCustom> itemsList = itemsService.findItemsList(null);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(\"itemsList\",itemsList);\r\n\r\n        //指定视图\r\n        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n        //modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\n        modelAndView.setViewName(\"items/itemsList\");\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n}\r\n```\r\n\r\n## 编写jsp\r\n\r\n服务器路径为`WEB-INF/jsp/items/itemsList.jsp`\r\n\r\n```\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n    pageEncoding=\"UTF-8\"%>\r\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %>\r\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\"  prefix=\"fmt\"%>\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\r\n<html>\r\n<head>\r\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n<title>查询商品列表</title>\r\n</head>\r\n<body> \r\n<form action=\"${pageContext.request.contextPath }/item/queryItem.action\" method=\"post\">\r\n查询条件：\r\n<table width=\"100%\" border=1>\r\n<tr>\r\n<td><input type=\"submit\" value=\"查询\"/></td>\r\n</tr>\r\n</table>\r\n商品列表：\r\n<table width=\"100%\" border=1>\r\n<tr>\r\n    <td>商品名称</td>\r\n    <td>商品价格</td>\r\n    <td>生产日期</td>\r\n    <td>商品描述</td>\r\n    <td>操作</td>\r\n</tr>\r\n<c:forEach items=\"${itemsList }\" var=\"item\">\r\n<tr>\r\n    <td>${item.name }</td>\r\n    <td>${item.price }</td>\r\n    <td><fmt:formatDate value=\"${item.createtime}\" pattern=\"yyyy-MM-dd HH:mm:ss\"/></td>\r\n    <td>${item.detail }</td>\r\n\r\n    <td><a href=\"${pageContext.request.contextPath }/item/editItem.action?id=${item.id}\">修改</a></td>\r\n\r\n</tr>\r\n</c:forEach>\r\n\r\n</table>\r\n</form>\r\n</body>\r\n\r\n</html>\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('88', 'springmvc注解开发之商品修改功能', '<p>本文以商品修改为例，记录springmvc的注解开发，包括mapper,service,controller,<a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>,controller方法的返回值等</p>\r\n<h2 id=\"h2-u9700u6C42\"><a name=\"需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>需求</h2><p>操作流程：</p>\r\n<ul>\r\n<li>1.进入商品查询列表页面</li><li>2.点击修改，进入商品修改页面，页面中显示了要修改的商品。要修改的商品从数据库查询，根据商品id(主键)查询商品信息</li><li>3.在商品修改页面，修改商品信息，修改后，点击提交</li></ul>\r\n<h2 id=\"h2--mapper\"><a name=\"开发mapper\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开发mapper</h2><p>mapper：</p>\r\n<ul>\r\n<li>根据id查询商品信息</li><li>根据id更新Items表的数据</li></ul>\r\n<p>不用开发了，使用逆向工程生成的代码。</p>\r\n<h2 id=\"h2--service\"><a name=\"开发service\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开发service</h2><p>在<code>com.iot.learnssm.firstssm.service.ItemsService</code>中添加两个接口</p>\r\n<pre><code>  //根据id查询商品信息\r\n    /**\r\n     *\r\n     * &lt;p&gt;Title: findItemsById&lt;/p&gt;\r\n     * &lt;p&gt;Description: &lt;/p&gt;\r\n     * @param id 查询商品的id\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n     ItemsCustom findItemsById(Integer id) throws Exception;\r\n\r\n    //修改商品信息\r\n    /**\r\n     *\r\n     * &lt;p&gt;Title: updateItems&lt;/p&gt;\r\n     * &lt;p&gt;Description: &lt;/p&gt;\r\n     * @param id 修改商品的id\r\n     * @param itemsCustom 修改的商品信息\r\n     * @throws Exception\r\n     */\r\n     void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception;\r\n</code></pre><p>在<code>com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl</code>中实现接口，增加<code>itemsMapper</code>属性</p>\r\n<pre><code>@Autowired\r\nprivate ItemsMapper itemsMapper;\r\n\r\npublic ItemsCustom findItemsById(Integer id) throws Exception {\r\n    Items items = itemsMapper.selectByPrimaryKey(id);\r\n    //中间对商品信息进行业务处理\r\n    //....\r\n    //返回ItemsCustom\r\n    ItemsCustom itemsCustom = new ItemsCustom();\r\n    //将items的属性值拷贝到itemsCustom\r\n    BeanUtils.copyProperties(items, itemsCustom);\r\n\r\n    return itemsCustom;\r\n}\r\n\r\npublic void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception {\r\n    //添加业务校验，通常在service接口对关键参数进行校验\r\n    //校验 id是否为空，如果为空抛出异常\r\n\r\n    //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段\r\n    //updateByPrimaryKeyWithBLOBs要求必须转入id\r\n    itemsCustom.setId(id);\r\n    itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);\r\n}\r\n</code></pre><h2 id=\"h2--controller\"><a name=\"开发controller\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开发controller</h2><p>方法：</p>\r\n<ul>\r\n<li>商品信息修改页面显示</li><li>商品信息修改提交</li></ul>\r\n<pre><code>//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\n//@RequestMapping(&quot;/items&quot;)\r\npublic class ItemsController {\r\n\r\n    @Autowired\r\n    private ItemsService itemsService;\r\n\r\n    //商品查询列表\r\n    @RequestMapping(&quot;/queryItems&quot;)\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表\r\n        List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(&quot;itemsList&quot;,itemsList);\r\n\r\n        //指定视图\r\n        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n        //modelAndView.setViewName(&quot;/WEB-INF/jsp/items/itemsList.jsp&quot;);\r\n        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\n        modelAndView.setViewName(&quot;items/itemsList&quot;);\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n    //商品信息修改页面显示\r\n    @RequestMapping(&quot;/editItems&quot;)\r\n    //限制http请求方法，可以post和get\r\n    //@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST, RequestMethod.GET})\r\n    public ModelAndView editItems()throws Exception {\r\n\r\n        //调用service根据商品id查询商品信息\r\n        ItemsCustom itemsCustom = itemsService.findItemsById(1);\r\n\r\n        // 返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n\r\n        //将商品信息放到model\r\n        modelAndView.addObject(&quot;itemsCustom&quot;, itemsCustom);\r\n\r\n        //商品修改页面\r\n        modelAndView.setViewName(&quot;items/editItems&quot;);\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n    //商品信息修改提交\r\n    @RequestMapping(&quot;/editItemsSubmit&quot;)\r\n    public ModelAndView editItemsSubmit(HttpServletRequest request, Integer id, ItemsCustom itemsCustom)throws Exception {\r\n\r\n        //调用service更新商品信息，页面需要将商品信息传到此方法\r\n        itemsService.updateItems(id, itemsCustom);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //返回一个成功页面\r\n        modelAndView.setViewName(&quot;success&quot;);\r\n        return modelAndView;\r\n    }\r\n\r\n}\r\n</code></pre><h2 id=\"h2--code-requestmapping-code-\"><a name=\"<code>@RequestMapping</code>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code></h2><ul>\r\n<li>url映射</li></ul>\r\n<p>定义controller方法对应的url，进行处理器映射使用。</p>\r\n<ul>\r\n<li>窄化请求映射</li></ul>\r\n<pre><code>//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\n@RequestMapping(&quot;/items&quot;)\r\npublic class ItemsController {\r\n</code></pre><ul>\r\n<li>限制http请求方法</li></ul>\r\n<p>出于安全性考虑，对http的链接进行方法限制。</p>\r\n<pre><code>//商品信息修改页面显示\r\n    //@RequestMapping(&quot;/editItems&quot;)\r\n    //限制http请求方法，可以post和get\r\n    @RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST, RequestMethod.GET})\r\n    public ModelAndView editItems()throws Exception {\r\n</code></pre><p>如果限制请求为post方法，进行get请求，即将上面代码的注解改为<code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>(value=&quot;/editItems&quot;,method={RequestMethod.POST})</code></p>\r\n<p>报错，状态码405：</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E9%99%90%E5%88%B6http%E8%AF%B7%E6%B1%82-GET%E6%8B%92%E7%BB%9D.png\" alt=\"GET拒绝\"></p>\r\n<h2 id=\"h2-controller-\"><a name=\"controller方法的返回值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>controller方法的返回值</h2><ul>\r\n<li>返回<code>ModelAndView</code></li></ul>\r\n<p>需要方法结束时，定义ModelAndView，将model和view分别进行设置。</p>\r\n<ul>\r\n<li>返回string</li></ul>\r\n<p>如果controller方法返回string</p>\r\n<p>1.表示返回逻辑视图名。</p>\r\n<p>真正视图(jsp路径)=前缀+逻辑视图名+后缀</p>\r\n<pre><code>@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST,RequestMethod.GET})\r\n//@RequestParam里边指定request传入参数名称和形参进行绑定。\r\n//通过required属性指定参数是否必须要传入\r\n//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。\r\n//public String editItems(Model model, @RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {\r\npublic String editItems(Model model)throws Exception {\r\n\r\n    //调用service根据商品id查询商品信息\r\n    ItemsCustom itemsCustom = itemsService.findItemsById(1);\r\n\r\n    //通过形参中的model将model数据传到页面\r\n    //相当于modelAndView.addObject方法\r\n    model.addAttribute(&quot;itemsCustom&quot;, itemsCustom);\r\n\r\n    return &quot;items/editItems&quot;;\r\n}\r\n</code></pre><p>2.redirect重定向</p>\r\n<p>商品修改提交后，重定向到商品查询列表。</p>\r\n<p>redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享）</p>\r\n<pre><code>//重定向到商品查询列表\r\n//return &quot;redirect:queryItems.action&quot;;\r\n</code></pre><p>3.forward页面转发</p>\r\n<p>通过forward进行页面转发，浏览器地址栏url不变，request可以共享。</p>\r\n<pre><code>//页面转发\r\nreturn &quot;forward:queryItems.action&quot;;\r\n</code></pre><ul>\r\n<li>返回void</li></ul>\r\n<p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p>\r\n<p>1.使用request转向页面，如下：</p>\r\n<p><code>request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response);</code></p>\r\n<p>2.也可以通过response页面重定向：</p>\r\n<p><code>response.sendRedirect(&quot;url&quot;)</code></p>\r\n<p>3.也可以通过response指定响应结果，例如响应json数据如下：</p>\r\n<pre><code>response.setCharacterEncoding(&quot;utf-8&quot;);\r\nresponse.setContentType(&quot;application/json;charset=utf-8&quot;);\r\nresponse.getWriter().write(&quot;json串&quot;);\r\n</code></pre>', '114', '\r\n\r\n本文以商品修改为例，记录springmvc的注解开发，包括mapper,service,controller,@RequestMapping,controller方法的返回值等\r\n\r\n## 需求\r\n\r\n操作流程：\r\n\r\n*   1.进入商品查询列表页面\r\n*   2.点击修改，进入商品修改页面，页面中显示了要修改的商品。要修改的商品从数据库查询，根据商品id(主键)查询商品信息\r\n*   3.在商品修改页面，修改商品信息，修改后，点击提交\r\n\r\n## 开发mapper\r\n\r\nmapper：\r\n\r\n*   根据id查询商品信息\r\n*   根据id更新Items表的数据\r\n\r\n不用开发了，使用逆向工程生成的代码。\r\n\r\n## 开发service\r\n\r\n在`com.iot.learnssm.firstssm.service.ItemsService`中添加两个接口\r\n\r\n```\r\n  //根据id查询商品信息\r\n    /**\r\n     *\r\n     * <p>Title: findItemsById</p>\r\n     * <p>Description: </p>\r\n     * @param id 查询商品的id\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n     ItemsCustom findItemsById(Integer id) throws Exception;\r\n\r\n    //修改商品信息\r\n    /**\r\n     *\r\n     * <p>Title: updateItems</p>\r\n     * <p>Description: </p>\r\n     * @param id 修改商品的id\r\n     * @param itemsCustom 修改的商品信息\r\n     * @throws Exception\r\n     */\r\n     void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception;\r\n\r\n```\r\n\r\n在`com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl`中实现接口，增加`itemsMapper`属性\r\n\r\n```\r\n@Autowired\r\nprivate ItemsMapper itemsMapper;\r\n\r\npublic ItemsCustom findItemsById(Integer id) throws Exception {\r\n    Items items = itemsMapper.selectByPrimaryKey(id);\r\n    //中间对商品信息进行业务处理\r\n    //....\r\n    //返回ItemsCustom\r\n    ItemsCustom itemsCustom = new ItemsCustom();\r\n    //将items的属性值拷贝到itemsCustom\r\n    BeanUtils.copyProperties(items, itemsCustom);\r\n\r\n    return itemsCustom;\r\n}\r\n\r\npublic void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception {\r\n    //添加业务校验，通常在service接口对关键参数进行校验\r\n    //校验 id是否为空，如果为空抛出异常\r\n\r\n    //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段\r\n    //updateByPrimaryKeyWithBLOBs要求必须转入id\r\n    itemsCustom.setId(id);\r\n    itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);\r\n}\r\n```\r\n\r\n## 开发controller\r\n\r\n方法：\r\n\r\n*   商品信息修改页面显示\r\n*   商品信息修改提交\r\n\r\n```\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\n//@RequestMapping(\"/items\")\r\npublic class ItemsController {\r\n\r\n    @Autowired\r\n    private ItemsService itemsService;\r\n\r\n    //商品查询列表\r\n    @RequestMapping(\"/queryItems\")\r\n    //实现 对queryItems方法和url进行映射，一个方法对应一个url\r\n    //一般建议将url和方法写成一样\r\n    public ModelAndView queryItems() throws Exception{\r\n        //调用service查找数据库，查询商品列表\r\n        List<ItemsCustom> itemsList = itemsService.findItemsList(null);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据\r\n        modelAndView.addObject(\"itemsList\",itemsList);\r\n\r\n        //指定视图\r\n        //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList\r\n        //modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\r\n        //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀\r\n        modelAndView.setViewName(\"items/itemsList\");\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n    //商品信息修改页面显示\r\n    @RequestMapping(\"/editItems\")\r\n    //限制http请求方法，可以post和get\r\n    //@RequestMapping(value=\"/editItems\",method={RequestMethod.POST, RequestMethod.GET})\r\n    public ModelAndView editItems()throws Exception {\r\n\r\n        //调用service根据商品id查询商品信息\r\n        ItemsCustom itemsCustom = itemsService.findItemsById(1);\r\n\r\n        // 返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n\r\n        //将商品信息放到model\r\n        modelAndView.addObject(\"itemsCustom\", itemsCustom);\r\n\r\n        //商品修改页面\r\n        modelAndView.setViewName(\"items/editItems\");\r\n\r\n        return modelAndView;\r\n    }\r\n\r\n    //商品信息修改提交\r\n    @RequestMapping(\"/editItemsSubmit\")\r\n    public ModelAndView editItemsSubmit(HttpServletRequest request, Integer id, ItemsCustom itemsCustom)throws Exception {\r\n\r\n        //调用service更新商品信息，页面需要将商品信息传到此方法\r\n        itemsService.updateItems(id, itemsCustom);\r\n\r\n        //返回ModelAndView\r\n        ModelAndView modelAndView = new ModelAndView();\r\n        //返回一个成功页面\r\n        modelAndView.setViewName(\"success\");\r\n        return modelAndView;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n## `@RequestMapping`\r\n\r\n*   url映射\r\n\r\n定义controller方法对应的url，进行处理器映射使用。\r\n\r\n*   窄化请求映射\r\n\r\n```\r\n//使用@Controller来标识它是一个控制器\r\n@Controller\r\n//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径\r\n//比如：商品列表：/items/queryItems.action\r\n@RequestMapping(\"/items\")\r\npublic class ItemsController {\r\n```\r\n\r\n*   限制http请求方法\r\n\r\n出于安全性考虑，对http的链接进行方法限制。\r\n\r\n```\r\n//商品信息修改页面显示\r\n    //@RequestMapping(\"/editItems\")\r\n    //限制http请求方法，可以post和get\r\n    @RequestMapping(value=\"/editItems\",method={RequestMethod.POST, RequestMethod.GET})\r\n    public ModelAndView editItems()throws Exception {\r\n```\r\n\r\n如果限制请求为post方法，进行get请求，即将上面代码的注解改为`@RequestMapping(value=\"/editItems\",method={RequestMethod.POST})`\r\n\r\n报错，状态码405：\r\n\r\n![GET拒绝](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E9%99%90%E5%88%B6http%E8%AF%B7%E6%B1%82-GET%E6%8B%92%E7%BB%9D.png)\r\n\r\n## controller方法的返回值\r\n\r\n*   返回`ModelAndView`\r\n\r\n需要方法结束时，定义ModelAndView，将model和view分别进行设置。\r\n\r\n*   返回string\r\n\r\n如果controller方法返回string\r\n\r\n1.表示返回逻辑视图名。\r\n\r\n真正视图(jsp路径)=前缀+逻辑视图名+后缀\r\n\r\n```\r\n@RequestMapping(value=\"/editItems\",method={RequestMethod.POST,RequestMethod.GET})\r\n//@RequestParam里边指定request传入参数名称和形参进行绑定。\r\n//通过required属性指定参数是否必须要传入\r\n//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。\r\n//public String editItems(Model model, @RequestParam(value=\"id\",required=true) Integer items_id)throws Exception {\r\npublic String editItems(Model model)throws Exception {\r\n\r\n    //调用service根据商品id查询商品信息\r\n    ItemsCustom itemsCustom = itemsService.findItemsById(1);\r\n\r\n    //通过形参中的model将model数据传到页面\r\n    //相当于modelAndView.addObject方法\r\n    model.addAttribute(\"itemsCustom\", itemsCustom);\r\n\r\n    return \"items/editItems\";\r\n}\r\n```\r\n\r\n2.redirect重定向\r\n\r\n商品修改提交后，重定向到商品查询列表。\r\n\r\nredirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享）\r\n\r\n```\r\n//重定向到商品查询列表\r\n//return \"redirect:queryItems.action\";\r\n```\r\n\r\n3.forward页面转发\r\n\r\n通过forward进行页面转发，浏览器地址栏url不变，request可以共享。\r\n\r\n```\r\n//页面转发\r\nreturn \"forward:queryItems.action\";\r\n```\r\n\r\n*   返回void\r\n\r\n在controller方法形参上可以定义request和response，使用request或response指定响应结果：\r\n\r\n1.使用request转向页面，如下：\r\n\r\n`request.getRequestDispatcher(\"页面路径\").forward(request, response);`\r\n\r\n2.也可以通过response页面重定向：\r\n\r\n`response.sendRedirect(\"url\")`\r\n\r\n3.也可以通过response指定响应结果，例如响应json数据如下：\r\n\r\n```\r\nresponse.setCharacterEncoding(\"utf-8\");\r\nresponse.setContentType(\"application/json;charset=utf-8\");\r\nresponse.getWriter().write(\"json串\");\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('89', 'springmvc注解开发之简单参数绑定', '<p>本文主要介绍注解开发的简单参数绑定，包括简单类型、简单pojo以及自定义绑定实现类型转换</p>\r\n<h2 id=\"h2-spring-\"><a name=\"spring参数绑定过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>spring参数绑定过程</h2><p>从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。</p>\r\n<p>springmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变更接收！！！！</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B.png\" alt=\"参数绑定过程\"></p>\r\n<h2 id=\"h2-u9ED8u8BA4u652Fu6301u7684u7C7Bu578B\"><a name=\"默认支持的类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>默认支持的类型</h2><p>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。</p>\r\n<ul>\r\n<li><code>HttpServletRequest</code>：通过request对象获取请求信息</li><li><code>HttpServletResponse</code>：通过response处理响应信息</li><li><code>HttpSession</code>：通过session对象得到session中存放的对象</li><li><code>Model/ModelMap</code>：model是一个接口，modelMap是一个接口实现。作用：将model数据填充到request域。</li></ul>\r\n<h2 id=\"h2-u7B80u5355u7C7Bu578B\"><a name=\"简单类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>简单类型</h2><p>通过<code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code>对简单类型的参数进行绑定。如果不使用<code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code>，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。</p>\r\n<p>如果使用<code><a href=\"https://github.com/RequestParam\" title=\"&#64;RequestParam\" class=\"at-link\">@RequestParam</a></code>，不用限制request传入参数名称和controller方法的形参名称一致。</p>\r\n<p>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，报下边错误：</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%8C%87%E5%AE%9A%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E6%9C%AA%E4%BC%A0%E5%85%A5%E6%8A%A5%E9%94%99.png\" alt=\"指定传入参数未传入报错\"></p>\r\n<pre><code>@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST,RequestMethod.GET})\r\n//@RequestParam里边指定request传入参数名称和形参进行绑定。\r\n//通过required属性指定参数是否必须要传入\r\n//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。\r\npublic String editItems(Model model,@RequestParam(value=&quot;id&quot;,required=true) Integer items_id)throws Exception {\r\n</code></pre><h2 id=\"h2-pojo-\"><a name=\"pojo绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>pojo绑定</h2><p>页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。</p>\r\n<p>注意:这里只是要求name和形参的<strong>属性名</strong>一致，而不是要求和形参的<strong>名称</strong>一致，这点不要混淆了，框架会进入形参内部自动匹配pojo类的属性名。(我没看源码，但应该是用反射实现的)</p>\r\n<p>页面定义：</p>\r\n<pre><code>&lt;table width=&quot;100%&quot; border=1&gt;\r\n&lt;tr&gt;\r\n    &lt;td&gt;商品名称&lt;/td&gt;\r\n    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;${itemsCustom.name }&quot;/&gt;&lt;/td&gt;\r\n&lt;/tr&gt;\r\n&lt;tr&gt;\r\n    &lt;td&gt;商品价格&lt;/td&gt;\r\n    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;${itemsCustom.price }&quot;/&gt;&lt;/td&gt;\r\n&lt;/tr&gt;\r\n</code></pre><p>controller的pojo形参的定义：</p>\r\n<pre><code>public class Items {\r\n    private Integer id;\r\n\r\n    private String name;\r\n\r\n    private Float price;\r\n\r\n    private String pic;\r\n\r\n    private Date createtime;\r\n\r\n    private String detail;\r\n</code></pre><h2 id=\"h2-u81EAu5B9Au4E49u53C2u6570u7ED1u5B9Au5B9Eu73B0u65E5u671Fu7C7Bu578Bu7ED1u5B9A\"><a name=\"自定义参数绑定实现日期类型绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>自定义参数绑定实现日期类型绑定</h2><p>对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。</p>\r\n<p>将请求日期数据串传成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。本文示例中，自定义参数绑定将日期串转成<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>.util.Date类型。</p>\r\n<p>需要向处理器适配器中注入自定义的参数绑定组件。</p>\r\n<ul>\r\n<li>自定义日期类型绑定</li></ul>\r\n<pre><code>public class CustomDateConverter implements Converter&lt;String,Date&gt;{\r\n    public Date convert(String s) {\r\n        //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss)\r\n\r\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\r\n\r\n        try {\r\n            //转成直接返回\r\n            return simpleDateFormat.parse(s);\r\n        } catch (ParseException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        }\r\n        //如果参数绑定失败返回null\r\n        return null;\r\n\r\n    }\r\n}\r\n</code></pre><ul>\r\n<li>配置方式</li></ul>\r\n<pre><code>&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt;\r\n</code></pre><pre><code>&lt;!-- 自定义参数绑定 --&gt;\r\n    &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;\r\n        &lt;!-- 转换器 --&gt;\r\n        &lt;property name=&quot;converters&quot;&gt;\r\n            &lt;list&gt;\r\n                &lt;!-- 日期类型转换 --&gt;\r\n                &lt;bean class=&quot;com.iot.learnssm.firstssm.controller.converter.CustomDateConverter&quot;/&gt;\r\n           &lt;/list&gt;\r\n        &lt;/property&gt;\r\n    &lt;/bean&gt;\r\n</code></pre><h2 id=\"h2-springmvc-struts2-\"><a name=\"springmvc和struts2的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc和struts2的区别</h2><ul>\r\n<li>1.springmvc基于方法开发的，struts2基于类开发的。</li></ul>\r\n<p>springmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method。方法执行结束，形参数据销毁。springmvc的controller开发类似service开发。</p>\r\n<ul>\r\n<li><p>2.springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。</p>\r\n</li><li><p>3.经过实际<a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\">测试</a>，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl。</p>\r\n</li></ul>\r\n', '115', '\r\n本文主要介绍注解开发的简单参数绑定，包括简单类型、简单pojo以及自定义绑定实现类型转换\r\n\r\n## spring参数绑定过程\r\n\r\n从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。\r\n\r\nspringmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变更接收！！！！\r\n\r\n![参数绑定过程](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B.png)\r\n\r\n## 默认支持的类型\r\n\r\n直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。\r\n\r\n*   `HttpServletRequest`：通过request对象获取请求信息\r\n*   `HttpServletResponse`：通过response处理响应信息\r\n*   `HttpSession`：通过session对象得到session中存放的对象\r\n*   `Model/ModelMap`：model是一个接口，modelMap是一个接口实现。作用：将model数据填充到request域。\r\n\r\n## 简单类型\r\n\r\n通过`@RequestParam`对简单类型的参数进行绑定。如果不使用`@RequestParam`，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。\r\n\r\n如果使用`@RequestParam`，不用限制request传入参数名称和controller方法的形参名称一致。\r\n\r\n通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，报下边错误：\r\n\r\n![指定传入参数未传入报错](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_%E6%8C%87%E5%AE%9A%E4%BC%A0%E5%85%A5%E5%8F%82%E6%95%B0%E6%9C%AA%E4%BC%A0%E5%85%A5%E6%8A%A5%E9%94%99.png)\r\n\r\n```\r\n@RequestMapping(value=\"/editItems\",method={RequestMethod.POST,RequestMethod.GET})\r\n//@RequestParam里边指定request传入参数名称和形参进行绑定。\r\n//通过required属性指定参数是否必须要传入\r\n//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。\r\npublic String editItems(Model model,@RequestParam(value=\"id\",required=true) Integer items_id)throws Exception {\r\n\r\n```\r\n\r\n## pojo绑定\r\n\r\n页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。\r\n\r\n注意:这里只是要求name和形参的**属性名**一致，而不是要求和形参的**名称**一致，这点不要混淆了，框架会进入形参内部自动匹配pojo类的属性名。(我没看源码，但应该是用反射实现的)\r\n\r\n页面定义：\r\n\r\n```\r\n<table width=\"100%\" border=1>\r\n<tr>\r\n    <td>商品名称</td>\r\n    <td><input type=\"text\" name=\"name\" value=\"${itemsCustom.name }\"/></td>\r\n</tr>\r\n<tr>\r\n    <td>商品价格</td>\r\n    <td><input type=\"text\" name=\"price\" value=\"${itemsCustom.price }\"/></td>\r\n</tr>\r\n```\r\n\r\ncontroller的pojo形参的定义：\r\n\r\n```\r\npublic class Items {\r\n    private Integer id;\r\n\r\n    private String name;\r\n\r\n    private Float price;\r\n\r\n    private String pic;\r\n\r\n    private Date createtime;\r\n\r\n    private String detail;\r\n```\r\n\r\n## 自定义参数绑定实现日期类型绑定\r\n\r\n对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。\r\n\r\n将请求日期数据串传成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。本文示例中，自定义参数绑定将日期串转成[Java](http://lib.csdn.net/base/javase \"Java SE知识库\").util.Date类型。\r\n\r\n需要向处理器适配器中注入自定义的参数绑定组件。\r\n\r\n*   自定义日期类型绑定\r\n\r\n```\r\npublic class CustomDateConverter implements Converter<String,Date>{\r\n    public Date convert(String s) {\r\n        //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss)\r\n\r\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n        try {\r\n            //转成直接返回\r\n            return simpleDateFormat.parse(s);\r\n        } catch (ParseException e) {\r\n            // TODO Auto-generated catch block\r\n            e.printStackTrace();\r\n        }\r\n        //如果参数绑定失败返回null\r\n        return null;\r\n\r\n    }\r\n}\r\n```\r\n\r\n*   配置方式\r\n\r\n```\r\n<mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\r\n```\r\n\r\n```\r\n<!-- 自定义参数绑定 -->\r\n    <bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\r\n        <!-- 转换器 -->\r\n        <property name=\"converters\">\r\n            <list>\r\n                <!-- 日期类型转换 -->\r\n                <bean class=\"com.iot.learnssm.firstssm.controller.converter.CustomDateConverter\"/>\r\n           </list>\r\n        </property>\r\n    </bean>\r\n```\r\n\r\n## springmvc和struts2的区别\r\n\r\n*   1.springmvc基于方法开发的，struts2基于类开发的。\r\n\r\nspringmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method。方法执行结束，形参数据销毁。springmvc的controller开发类似service开发。\r\n\r\n*   2.springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。\r\n\r\n*   3.经过实际[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl。\r\n');
INSERT INTO `article_info_true` VALUES ('90', 'springmvc注解开发之包装类型参数绑定', '<p>本文主要介绍注解开发的介绍包装类型的参数绑定</p>\r\n<h2 id=\"h2-u9700u6C42\"><a name=\"需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>需求</h2><p>商品查询controller方法中实现商品查询条件传入。</p>\r\n<h2 id=\"h2-u5B9Eu73B0u65B9u6CD5\"><a name=\"实现方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实现方法</h2><ul>\r\n<li>第一种方法：在形参中添加<code>HttpServletRequest request</code>参数，通过request接收查询条件参数。</li><li>第二种方法：在形参中让包装类型的pojo接收查询条件参数。</li></ul>\r\n<p>分析：</p>\r\n<p>页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。</p>\r\n<p>如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。</p>\r\n<h2 id=\"h2--controller-\"><a name=\"页面参数和controller方法形参定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>页面参数和controller方法形参定义</h2><ul>\r\n<li>页面参数：</li></ul>\r\n<p>商品名称：<code>&lt;input name=&quot;itemsCustom.name&quot; /&gt;</code></p>\r\n<p><strong>注意：itemsCustom和包装pojo中的属性名一致即可。</strong></p>\r\n<ul>\r\n<li>controller方法形参：</li></ul>\r\n<p><code>public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception</code></p>\r\n<ul>\r\n<li>包装类ItemsQueryVo中部分属性：</li></ul>\r\n<pre><code>public class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n</code></pre><p>可见，<code>ItemsQueryVo</code>中属性<code>itemsCustom</code>和页面参数中一致</p>\r\n', '116', '\r\n本文主要介绍注解开发的介绍包装类型的参数绑定\r\n\r\n## 需求\r\n\r\n商品查询controller方法中实现商品查询条件传入。\r\n\r\n## 实现方法\r\n\r\n*   第一种方法：在形参中添加`HttpServletRequest request`参数，通过request接收查询条件参数。\r\n*   第二种方法：在形参中让包装类型的pojo接收查询条件参数。\r\n\r\n分析：\r\n\r\n页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。\r\n\r\n如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。\r\n\r\n## 页面参数和controller方法形参定义\r\n\r\n*   页面参数：\r\n\r\n商品名称：`<input name=\"itemsCustom.name\" />`\r\n\r\n**注意：itemsCustom和包装pojo中的属性名一致即可。**\r\n\r\n*   controller方法形参：\r\n\r\n`public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception`\r\n\r\n*   包装类ItemsQueryVo中部分属性：\r\n\r\n```\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n```\r\n\r\n可见，`ItemsQueryVo`中属性`itemsCustom`和页面参数中一致\r\n');
INSERT INTO `article_info_true` VALUES ('91', 'springmvc注解开发之包装类型参数绑定', '<p>本文主要介绍注解开发的介绍包装类型的参数绑定</p>\r\n<h2 id=\"h2-u9700u6C42\"><a name=\"需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>需求</h2><p>商品查询controller方法中实现商品查询条件传入。</p>\r\n<h2 id=\"h2-u5B9Eu73B0u65B9u6CD5\"><a name=\"实现方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>实现方法</h2><ul>\r\n<li>第一种方法：在形参中添加<code>HttpServletRequest request</code>参数，通过request接收查询条件参数。</li><li>第二种方法：在形参中让包装类型的pojo接收查询条件参数。</li></ul>\r\n<p>分析：</p>\r\n<p>页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。</p>\r\n<p>如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。</p>\r\n<h2 id=\"h2--controller-\"><a name=\"页面参数和controller方法形参定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>页面参数和controller方法形参定义</h2><ul>\r\n<li>页面参数：</li></ul>\r\n<p>商品名称：<code>&lt;input name=&quot;itemsCustom.name&quot; /&gt;</code></p>\r\n<p><strong>注意：itemsCustom和包装pojo中的属性名一致即可。</strong></p>\r\n<ul>\r\n<li>controller方法形参：</li></ul>\r\n<p><code>public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception</code></p>\r\n<ul>\r\n<li>包装类ItemsQueryVo中部分属性：</li></ul>\r\n<pre><code>public class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n</code></pre><p>可见，<code>ItemsQueryVo</code>中属性<code>itemsCustom</code>和页面参数中一致</p>\r\n', '116', '\r\n本文主要介绍注解开发的介绍包装类型的参数绑定\r\n\r\n## 需求\r\n\r\n商品查询controller方法中实现商品查询条件传入。\r\n\r\n## 实现方法\r\n\r\n*   第一种方法：在形参中添加`HttpServletRequest request`参数，通过request接收查询条件参数。\r\n*   第二种方法：在形参中让包装类型的pojo接收查询条件参数。\r\n\r\n分析：\r\n\r\n页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。\r\n\r\n如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。\r\n\r\n## 页面参数和controller方法形参定义\r\n\r\n*   页面参数：\r\n\r\n商品名称：`<input name=\"itemsCustom.name\" />`\r\n\r\n**注意：itemsCustom和包装pojo中的属性名一致即可。**\r\n\r\n*   controller方法形参：\r\n\r\n`public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception`\r\n\r\n*   包装类ItemsQueryVo中部分属性：\r\n\r\n```\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n```\r\n\r\n可见，`ItemsQueryVo`中属性`itemsCustom`和页面参数中一致\r\n');
INSERT INTO `article_info_true` VALUES ('92', 'New node', '<p>本文主要介绍注解开发的集合类型参数绑定，包括数组绑定，list绑定以及map绑定</p>\r\n<h2 id=\"h2-u6570u7EC4u7ED1u5B9A\"><a name=\"数组绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数组绑定</h2><h3 id=\"h3-u9700u6C42\"><a name=\"需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>需求</h3><p>商品批量删除，用户在页面选择多个商品，批量删除。</p>\r\n<h3 id=\"h3-u8868u73B0u5C42u5B9Eu73B0\"><a name=\"表现层实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>表现层实现</h3><p>关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。</p>\r\n<ul>\r\n<li>controller方法定义：</li></ul>\r\n<pre><code>// 批量删除 商品信息\r\n@RequestMapping(&quot;/deleteItems&quot;)\r\npublic String deleteItems(Integer[] items_id) throws Exception\r\n</code></pre><ul>\r\n<li>页面定义：</li></ul>\r\n<pre><code>&lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot;&gt;\r\n&lt;tr&gt;\r\n    &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;items_id&quot; value=&quot;${item.id}&quot;/&gt;&lt;/td&gt;\r\n    &lt;td&gt;${item.name }&lt;/td&gt;\r\n    &lt;td&gt;${item.price }&lt;/td&gt;\r\n    &lt;td&gt;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&lt;/td&gt;\r\n    &lt;td&gt;${item.detail }&lt;/td&gt;\r\n\r\n    &lt;td&gt;&lt;a href=&quot;${pageContext.request.contextPath }/items/editItems.action?id=${item.id}&quot;&gt;修改&lt;/a&gt;&lt;/td&gt;\r\n\r\n&lt;/tr&gt;\r\n&lt;/c:forEach&gt;\r\n</code></pre><h2 id=\"h2-list-\"><a name=\"list绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>list绑定</h2><h3 id=\"h3-u9700u6C42\"><a name=\"需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>需求</h3><p>通常在需要批量提交数据时，将提交的数据绑定到<code>list&lt;pojo&gt;</code>中，比如：成绩录入（录入多门课成绩，批量提交），</p>\r\n<p>本例子需求：批量商品修改，在页面输入多个商品信息，将多个商品信息提交到controller方法中。</p>\r\n<h3 id=\"h3-u8868u73B0u5C42u5B9Eu73B0\"><a name=\"表现层实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>表现层实现</h3><ul>\r\n<li><p>controller方法定义：</p>\r\n<ul>\r\n<li>1、进入批量商品修改页面(页面样式参考商品列表实现)</li><li>2、批量修改商品提交</li></ul>\r\n</li></ul>\r\n<p>使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义<code>list&lt;pojo&gt;</code>属性</p>\r\n<pre><code>public class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n\r\n    //批量商品信息\r\n    private List&lt;ItemsCustom&gt; itemsList;\r\n</code></pre><pre><code>// 批量修改商品提交\r\n// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。\r\n@RequestMapping(&quot;/editItemsAllSubmit&quot;)\r\npublic String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception {\r\n\r\n    return &quot;success&quot;;\r\n}\r\n</code></pre><ul>\r\n<li>页面定义：</li></ul>\r\n<pre><code>&lt;c:forEach items=&quot;${itemsList }&quot; var=&quot;item&quot; varStatus=&quot;status&quot;&gt;\r\n    &lt;tr&gt;\r\n\r\n        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].name&quot; value=&quot;${item.name }&quot;/&gt;&lt;/td&gt;\r\n        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].price&quot; value=&quot;${item.price }&quot;/&gt;&lt;/td&gt;\r\n        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].createtime&quot; value=&quot;&lt;fmt:formatDate value=&quot;${item.createtime}&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;&quot;/&gt;&lt;/td&gt;\r\n        &lt;td&gt;&lt;input name=&quot;itemsList[${status.index }].detail&quot; value=&quot;${item.detail }&quot;/&gt;&lt;/td&gt;\r\n\r\n    &lt;/tr&gt;\r\n&lt;/c:forEach&gt;\r\n</code></pre><p>name的格式：</p>\r\n<p><strong><code>对应包装pojo中的list类型属性名</code>[<code>下标(从0开始)</code>].<code>包装pojo中List类型的属性中pojo的属性名</code></strong></p>\r\n<p>例子：</p>\r\n<p><code>&quot;name=&quot;itemsList[${status.index }].price&quot;</code></p>\r\n<p><em>可以和包装类型的参数绑定归纳对比一下，其实就是在包装类的pojo基础上多了个下标。只不过包装类参数绑定时，要和包装pojo中的pojo类性的属性名一致，而list参数绑定时，要和包装pojo中的list类型的属性名一致。</em></p>\r\n<h2 id=\"h2-map-\"><a name=\"map绑定\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>map绑定</h2><p>也通过在包装pojo中定义map类型属性。</p>\r\n<p>在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。</p>\r\n<ul>\r\n<li>包装类中定义Map对象如下：</li></ul>\r\n<pre><code>Public class QueryVo {\r\nprivate Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;();\r\n  //get/set方法..\r\n}\r\n</code></pre><ul>\r\n<li>页面定义如下：</li></ul>\r\n<pre><code>&lt;tr&gt;\r\n&lt;td&gt;学生信息：&lt;/td&gt;\r\n&lt;td&gt;\r\n姓名：&lt;inputtype=&quot;text&quot;name=&quot;itemInfo[&#39;name&#39;]&quot;/&gt;\r\n年龄：&lt;inputtype=&quot;text&quot;name=&quot;itemInfo[&#39;price&#39;]&quot;/&gt;\r\n.. .. ..\r\n&lt;/td&gt;\r\n&lt;/tr&gt;\r\n</code></pre><ul>\r\n<li>Contrller方法定义如下：</li></ul>\r\n<pre><code>public String useraddsubmit(Model model,QueryVo queryVo)throws Exception{\r\nSystem.out.println(queryVo.getStudentinfo());\r\n}\r\n</code></pre>', '117', '\r\n\r\n本文主要介绍注解开发的集合类型参数绑定，包括数组绑定，list绑定以及map绑定\r\n\r\n## 数组绑定\r\n\r\n### 需求\r\n\r\n商品批量删除，用户在页面选择多个商品，批量删除。\r\n\r\n### 表现层实现\r\n\r\n关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。\r\n\r\n*   controller方法定义：\r\n\r\n```\r\n// 批量删除 商品信息\r\n@RequestMapping(\"/deleteItems\")\r\npublic String deleteItems(Integer[] items_id) throws Exception\r\n```\r\n\r\n*   页面定义：\r\n\r\n```\r\n<c:forEach items=\"${itemsList }\" var=\"item\">\r\n<tr>\r\n    <td><input type=\"checkbox\" name=\"items_id\" value=\"${item.id}\"/></td>\r\n    <td>${item.name }</td>\r\n    <td>${item.price }</td>\r\n    <td><fmt:formatDate value=\"${item.createtime}\" pattern=\"yyyy-MM-dd HH:mm:ss\"/></td>\r\n    <td>${item.detail }</td>\r\n\r\n    <td><a href=\"${pageContext.request.contextPath }/items/editItems.action?id=${item.id}\">修改</a></td>\r\n\r\n</tr>\r\n</c:forEach>\r\n```\r\n\r\n## list绑定\r\n\r\n### 需求\r\n\r\n通常在需要批量提交数据时，将提交的数据绑定到`list<pojo>`中，比如：成绩录入（录入多门课成绩，批量提交），\r\n\r\n本例子需求：批量商品修改，在页面输入多个商品信息，将多个商品信息提交到controller方法中。\r\n\r\n### 表现层实现\r\n\r\n*   controller方法定义：\r\n\r\n    *   1、进入批量商品修改页面(页面样式参考商品列表实现)\r\n    *   2、批量修改商品提交\r\n\r\n使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义`list<pojo>`属性\r\n\r\n```\r\npublic class ItemsQueryVo {\r\n\r\n    //商品信息\r\n    private Items items;\r\n\r\n    //为了系统 可扩展性，对原始生成的po进行扩展\r\n    private ItemsCustom itemsCustom;\r\n\r\n    //批量商品信息\r\n    private List<ItemsCustom> itemsList;\r\n```\r\n\r\n```\r\n// 批量修改商品提交\r\n// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。\r\n@RequestMapping(\"/editItemsAllSubmit\")\r\npublic String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception {\r\n\r\n    return \"success\";\r\n}\r\n```\r\n\r\n*   页面定义：\r\n\r\n```\r\n<c:forEach items=\"${itemsList }\" var=\"item\" varStatus=\"status\">\r\n    <tr>\r\n\r\n        <td><input name=\"itemsList[${status.index }].name\" value=\"${item.name }\"/></td>\r\n        <td><input name=\"itemsList[${status.index }].price\" value=\"${item.price }\"/></td>\r\n        <td><input name=\"itemsList[${status.index }].createtime\" value=\"<fmt:formatDate value=\"${item.createtime}\" pattern=\"yyyy-MM-dd HH:mm:ss\"/>\"/></td>\r\n        <td><input name=\"itemsList[${status.index }].detail\" value=\"${item.detail }\"/></td>\r\n\r\n    </tr>\r\n</c:forEach>\r\n```\r\n\r\nname的格式：\r\n\r\n**`对应包装pojo中的list类型属性名`[`下标(从0开始)`].`包装pojo中List类型的属性中pojo的属性名`**\r\n\r\n例子：\r\n\r\n`\"name=\"itemsList[${status.index }].price\"`\r\n\r\n_可以和包装类型的参数绑定归纳对比一下，其实就是在包装类的pojo基础上多了个下标。只不过包装类参数绑定时，要和包装pojo中的pojo类性的属性名一致，而list参数绑定时，要和包装pojo中的list类型的属性名一致。_\r\n\r\n## map绑定\r\n\r\n也通过在包装pojo中定义map类型属性。\r\n\r\n在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。\r\n\r\n*   包装类中定义Map对象如下：\r\n\r\n```\r\nPublic class QueryVo {\r\nprivate Map<String, Object> itemInfo = new HashMap<String, Object>();\r\n  //get/set方法..\r\n}\r\n```\r\n\r\n*   页面定义如下：\r\n\r\n```\r\n<tr>\r\n<td>学生信息：</td>\r\n<td>\r\n姓名：<inputtype=\"text\"name=\"itemInfo[\'name\']\"/>\r\n年龄：<inputtype=\"text\"name=\"itemInfo[\'price\']\"/>\r\n.. .. ..\r\n</td>\r\n</tr>\r\n```\r\n\r\n*   Contrller方法定义如下：\r\n\r\n```\r\npublic String useraddsubmit(Model model,QueryVo queryVo)throws Exception{\r\nSystem.out.println(queryVo.getStudentinfo());\r\n}\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('93', 'spring', '<p><img src=\"http://ok9ci9ckr.bkt.clouddn.com/Garden_adventure_of_the_little_puppy_photos_pictures_puppy_MIL56015.jpg\" alt=\"\"></p>\r\n', '78', '![](http://ok9ci9ckr.bkt.clouddn.com/Garden_adventure_of_the_little_puppy_photos_pictures_puppy_MIL56015.jpg)');
INSERT INTO `article_info_true` VALUES ('94', '搭建Java开发环境(一)', '<p><span style=\"font-size:18px\">? ? ? ?在上一篇的博文中，所编辑的<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>源文件和编译的字节码文件是保存在E:\\Java\\develop\\jdk1.8.0_25\\bin目录下，</span></p>\r\n<p><span style=\"font-size:18px\">如果编辑的Java源文件和字节码文件没有用了或者想要删掉，我们很容易删除bin目录下的其它运行程序文件。还有</span></p>\r\n<p><span style=\"font-size:18px\">如果想要创建很多个Java源文件或者我们开发Java程序，那么bin目录中会存在很多的Java源文件和字节码文件，因</span></p>\r\n<p><span style=\"font-size:18px\">此我们不会将源文件写在bin目录中，需要我们在另外的文件夹下编辑源文件。</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 我们将编辑好的Java源文件保存在E:\\Java\\JavaSE\\Code目录下，我们来使用DOS编译和运行，那么会出现下面</span></p>\r\n<p><span style=\"font-size:18px\">的错误：</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119102826436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 那么我们在当前的文件夹下面怎么做到像在E:\\Java\\develop\\jdk1.8.0_25\\bin目录下那样，使用javac编译Java源</span></p>\r\n<p><span style=\"font-size:18px\">文</span><span style=\"font-size:18px\">件和使用java运</span><span style=\"font-size:18px\">行字节码文件呢？</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?我们都知道在DOS中可以使用notepad命令打开记事本，我们来看看，在任何盘符或任意的目录中，它是否可以</span></p>\r\n<p><span style=\"font-size:18px\">打开记事本：</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119102922498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 经过上面的<a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\">测试</a>我们可以在计算机中任何的目录下打开记事本，我们想要的编译的Java源文件也需要这样，在任</span></p>\r\n<p><span style=\"font-size:18px\">何的目录下或指定的目录下都可以编译Java源文件和运行Java程序。我们可以模仿打开记事本的方式使用javac命</span></p>\r\n<p><span style=\"font-size:18px\">令。这就需要</span><span style=\"font-size:18px\">进行环境变量的配置。</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?<span style=\"color:#ff0000\">首先我们来看path环境变量。</span></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?(1)为什么要配置path环境变量呢？我们来看看<span style=\"font-size:18px\">path环境变量的作用。</span></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?<span style=\"color:#ff0000\">程序的执行需要使用外部指令javac，但是javac指令仅仅能在JDK安装目录下的bin目录下时候，因此程序只能写</span></span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\">入bin目录。程序开发过程中，不能将源代码写入JDK的安装目录，因此需要将源程序保存到任意位置的指定目录(建</span></p>\r\n<p><span style=\"color:#ff0000\"><span style=\"font-size:18px\">议</span><span style=\"font-size:18px\">使用英文目录)，所以需要使javac指令在任意目录下可以运行。也就是说.exe结尾的程序就可以在任意的盘符中打</span></span></p>\r\n<p><span style=\"font-size:18px\"><span style=\"color:#ff0000\">开。</span>下面就来看看配置的方式。</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?(2)path环境变量配置方式1</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?<span style=\"color:#ff0000\">通过配置path环境变量，将javac指令所在目录也就是JDK安装目录下的bin目录配置到path变量下，即可使javac</span></span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\">指令在任意目录下运行。将JDK安装目录下的bin目录添加到最左边并添加分号。</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?配置步骤：</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?a)找到JDK安装目录下的bin目录，我的是：E:\\Java\\develop\\jdk1.8.0_25\\bin</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119103713158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?b)右键点击桌面计算机——选择属性——选择高级系统设置</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119103752096?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?c)在打开的系统属性对话框中选择高级，再找到环境变量</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119103820083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?d)在环境变量的对话框中找到系统变量中的Path环境变量，点击编辑。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119103826018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?e)将E:\\Java\\develop\\jdk1.8.0_25\\bin;粘贴到Path环境变量的最前边(建议在最前边)，点击确定。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119103833705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ?f)重新启动DOS，再次使用javac编译Java源文件和java运行字节码文件。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119103943242?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 额外的说一个话题：使用DOS打开QQ</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 我们配置的Path环境变量作用在前面说过，它可以启动.exe的运行程序，那么我们就来配置一下：</span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 首先还是找到QQ.exe运行程序所在的目录：D:\\Program Files\\Tencent\\QQ\\Bin;</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119105503607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 重新找到path环境变量，在末尾粘贴上。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119105509790?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">? ? ? ? 重新启动DOS，我们使用QQ外部命令打开QQ运行程序</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119105516430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n', '118', '<span style=\"font-size:18px\">? ? ? ?在上一篇的博文中，所编辑的[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")源文件和编译的字节码文件是保存在E:\\Java\\develop\\jdk1.8.0_25\\bin目录下，</span>\r\n\r\n<span style=\"font-size:18px\">如果编辑的Java源文件和字节码文件没有用了或者想要删掉，我们很容易删除bin目录下的其它运行程序文件。还有</span>\r\n\r\n<span style=\"font-size:18px\">如果想要创建很多个Java源文件或者我们开发Java程序，那么bin目录中会存在很多的Java源文件和字节码文件，因</span>\r\n\r\n<span style=\"font-size:18px\">此我们不会将源文件写在bin目录中，需要我们在另外的文件夹下编辑源文件。</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 我们将编辑好的Java源文件保存在E:\\Java\\JavaSE\\Code目录下，我们来使用DOS编译和运行，那么会出现下面</span>\r\n\r\n<span style=\"font-size:18px\">的错误：</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119102826436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 那么我们在当前的文件夹下面怎么做到像在E:\\Java\\develop\\jdk1.8.0_25\\bin目录下那样，使用javac编译Java源</span>\r\n\r\n<span style=\"font-size:18px\">文</span><span style=\"font-size:18px\">件和使用java运</span><span style=\"font-size:18px\">行字节码文件呢？</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?我们都知道在DOS中可以使用notepad命令打开记事本，我们来看看，在任何盘符或任意的目录中，它是否可以</span>\r\n\r\n<span style=\"font-size:18px\">打开记事本：</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119102922498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 经过上面的[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")我们可以在计算机中任何的目录下打开记事本，我们想要的编译的Java源文件也需要这样，在任</span>\r\n\r\n<span style=\"font-size:18px\">何的目录下或指定的目录下都可以编译Java源文件和运行Java程序。我们可以模仿打开记事本的方式使用javac命</span>\r\n\r\n<span style=\"font-size:18px\">令。这就需要</span><span style=\"font-size:18px\">进行环境变量的配置。</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?<span style=\"color:#ff0000\">首先我们来看path环境变量。</span></span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?(1)为什么要配置path环境变量呢？我们来看看<span style=\"font-size:18px\">path环境变量的作用。</span></span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?<span style=\"color:#ff0000\">程序的执行需要使用外部指令javac，但是javac指令仅仅能在JDK安装目录下的bin目录下时候，因此程序只能写</span></span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\">入bin目录。程序开发过程中，不能将源代码写入JDK的安装目录，因此需要将源程序保存到任意位置的指定目录(建</span>\r\n\r\n<span style=\"color:#ff0000\"><span style=\"font-size:18px\">议</span><span style=\"font-size:18px\">使用英文目录)，所以需要使javac指令在任意目录下可以运行。也就是说.exe结尾的程序就可以在任意的盘符中打</span></span>\r\n\r\n<span style=\"font-size:18px\"><span style=\"color:#ff0000\">开。</span>下面就来看看配置的方式。</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?(2)path环境变量配置方式1</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?<span style=\"color:#ff0000\">通过配置path环境变量，将javac指令所在目录也就是JDK安装目录下的bin目录配置到path变量下，即可使javac</span></span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\">指令在任意目录下运行。将JDK安装目录下的bin目录添加到最左边并添加分号。</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?配置步骤：</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?a)找到JDK安装目录下的bin目录，我的是：E:\\Java\\develop\\jdk1.8.0_25\\bin</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119103713158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?b)右键点击桌面计算机——选择属性——选择高级系统设置</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119103752096?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?c)在打开的系统属性对话框中选择高级，再找到环境变量</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119103820083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?d)在环境变量的对话框中找到系统变量中的Path环境变量，点击编辑。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119103826018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?e)将E:\\Java\\develop\\jdk1.8.0_25\\bin;粘贴到Path环境变量的最前边(建议在最前边)，点击确定。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119103833705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ?f)重新启动DOS，再次使用javac编译Java源文件和java运行字节码文件。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119103943242?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 额外的说一个话题：使用DOS打开QQ</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 我们配置的Path环境变量作用在前面说过，它可以启动.exe的运行程序，那么我们就来配置一下：</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 首先还是找到QQ.exe运行程序所在的目录：D:\\Program Files\\Tencent\\QQ\\Bin;</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119105503607?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 重新找到path环境变量，在末尾粘贴上。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119105509790?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">? ? ? ? 重新启动DOS，我们使用QQ外部命令打开QQ运行程序</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119105516430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('95', '搭建Java开发环境(二)', '<p>在上一篇的博文中说到我们配置了Path变量的一种方式，再来说说第二种配置方式，这种配置方式是必须掌握的。</span></p>\r\n<h1 id=\"h1-path-2-span-span-\"><a name=\"path环境变量配置方式2</span></span>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>path环境变量配置方式2</span></span></h1><p><span style=\"font-size:18px\">我们为什么要将第二种配置形式呢？那第一种的配置方式有什么缺点吗？假设我的计算机上安装了两个JDK，一</span></p>\r\n<p><span style=\"font-size:18px\">个是1.7，一个1.8，我刚才配置的是1.8的，那么我需要配置1.7，需要重新配置Path</span><span style=\"font-size:18px\">环境变量，有可能在修改Path环</span></p>\r\n<p><span style=\"font-size:18px\">境变量的同时误删其它的东西，所以不建议使用第一种。</span></p>\r\n<h2 id=\"h2-path-span-span-\"><a name=\"path环境变量的参照形配置方式的步骤：</span></span>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>path环境变量的参照形配置方式的步骤：</span></span></h2><p><span style=\"font-size:18px\">a)重新打开系统环境变量Path，将第一种配置的路径删除。</span></p>\r\n<p><span style=\"font-size:18px\">b)创建新的环境变量名称：JAVA_HOME；为JAVA_HOME添加变量值：JDK安装目录，我的也就</span></p>\r\n<p><span style=\"font-size:18px\">是：</span><span style=\"font-size:18px\">E:[Java](<a href=\"http://lib.csdn.net/base/javase\">http://lib.csdn.net/base/javase</a> “Java SE知识库”)\\develop\\jdk1.8.0_25</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119142239625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">c)将path环境变量中JDK目录修改为：%JAVA_HOME%\\bin;(%路径名称%相当于引用路径名称)</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119142245875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">d)重新启动DOS，再次使用javac编译Java源文件和java运行字节码文件。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119142252015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">这种方式我们在使用其它的JDK时，可以只修改JAVA_HOME变量，不修改Path变量，这样不会误删其他的东西</span></p>\r\n<p><span style=\"font-size:18px\">造成一些其它程序无法运行。</span></p>\r\n<p><span style=\"font-size:18px\">我们再来看一个在Java程序运行的过程中出现的问题，下面的运行结果就是很好的示例，这就需要用到了另一个</span></p>\r\n<p><span style=\"font-size:18px\">系统变量classpath的配置。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119143336467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h1 id=\"h1-classpath-\"><a name=\"classpath环境变量的配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>classpath环境变量的配置</h1><p>我们为什么要配置classpath环境变量？</span>classpath环境变量的作用是什么？</span></p>\r\n<p><span style=\"font-size:18px\">我们在将来的Java程序开发中，只需要字节码文件，假设我们在其它的目</span><span style=\"font-size:18px\">录下运行字节码文件，结果是和上面的</span></p>\r\n<p><span style=\"font-size:18px\">一样的，是无法运行。因此上面配置的path</span><span style=\"font-size:18px\">环境变量只能在一起使用，如果要</span><span style=\"font-size:18px\">实现字节码文件在任意的目录下运行，</span></p>\r\n<p><span style=\"font-size:18px\">就需要配置classpath环境</span><span style=\"font-size:18px\">变量。<span style=\"color:#ff0000\">因此它的作用是：使classpath目录中的.class</span></span><span style=\"font-size:18px\"><span style=\"color:#ff0000\">文件可以在任意目录运行。</span></span></p>\r\n<h2 id=\"h2-classpath-\"><a name=\"classpath环境变量配置方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>classpath环境变量配置方式</h2><p><span style=\"font-size:18px\">a)创建新的变量名称：classpath</span></p>\r\n<p><span style=\"font-size:18px\">b)变量值：设定为指定的含有class文件的目录，多个目录间使用分号(;)分割。我指定的目录是：E:\\Java\\JavaSE\\Code;</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119143746489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">c)重新启动DOS，使用java运行字节码文件。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119143827360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">d)我们在桌面重新编辑一个Java源文件，要求输出：你好，世界，保存的名称还是HelloWorld.java，继续编译和</span></p>\r\n<p><span style=\"font-size:18px\">运行。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119143934673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">e)上面遇到的问题是我们配置的classpath环境变量只是包含了E:\\Java\\JavaSE\\Code这个目录下的字节码文件,</span></p>\r\n<p><span style=\"font-size:18px\">因此解决的方法是：<span style=\"color:#ff0000\">通常将配置的目录最前面添加.;配置，即便当前目录，使.class文件搜索时首先搜索当前目录，然</span></span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\">后根据目录配置的顺序依次查找，找到后即运行，因此classpath目录中的配置存在先后顺序。</span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\"><img src=\"http://img.blog.csdn.net/20160119144013727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">f)重新启动DOS，再次运行桌面上的字节码文件。</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119144028642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<p><span style=\"font-size:18px\">我们在网上找到的配置classpath的值可能各不相同，不过其中包含最多的就是下面的三个Java类库文件：rt.jar是</span></p>\r\n<p><span style=\"font-size:18px\">JAVA基础类库，dt.jar是关于运行环境的类库，tools.jar是工具类库。我们来看</span><span style=\"font-size:18px\">看这些类库。</span></p>\r\n<p><span style=\"font-size:18px\">1)rt.jar默认就根classloader的加载路径里面放在claspath是多此一举不信你可以去classpath里面的rt.jar然后用?</span></p>\r\n<p><span style=\"font-size:18px\">java -verbose XXXX 的方式运行一个简单的类 就知道JVM的系统根Loader的</span><span style=\"font-size:18px\">路径里面不光rt.jar， jre\\lib下面的大部分</span></p>\r\n<p><span style=\"font-size:18px\">jar都在这个路径里。</span></p>\r\n<p><span style=\"font-size:18px\">2)tools.jar是系统用来编译一个类的时候用到的 也就是javac的时候用到javac XXX.java。实际上就是运行java -</span></p>\r\n<p><span style=\"font-size:18px\">calsspath=%JAVA_HOME%\\lib\\tools.jar xx.xxx.Main XXX.javajavac就是对</span><span style=\"font-size:18px\">上面命令的封装 所以tools.jar 也不用加到</span></p>\r\n<p><span style=\"font-size:18px\">classpath里面。</span></p>\r\n<p><span style=\"font-size:18px\">3)dt.jar是关于运行环境的类库,主要是swing的包你要用到swing时最好加上。</span></p>\r\n<p><span style=\"font-size:18px\">因此，最后配置的classpath环境变量的值是：.;E:\\Java\\JavaSE\\Code;%JAVA_HOME%\\lib\\dt.jar;</span></p>\r\n<p><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119144213745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></p>\r\n<h1 id=\"h1-path-classpath-\"><a name=\"path和classpath的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>path和classpath的区别</h1><p><span style=\"font-size:18px; color:#ff0000\">path环境变量里面记录的是可执行性文件，如.exe文件，对可执行文件先在当前路径去找，如果没找到就去path</span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\">环境变量中配置的路径去找</span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\">classpath环境变量里记录的是java类的运行文件所在的目录。</span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\"><span style=\"font-size:18px\">?java -version 检测JDK版本：</span></span></p>\r\n<p><span style=\"font-size:18px; color:#ff0000\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160119144432831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br></span></span></p>\r\n', '119', '在上一篇的博文中说到我们配置了Path变量的一种方式，再来说说第二种配置方式，这种配置方式是必须掌握的。</span>\r\n\r\n# path环境变量配置方式2</span></span>\r\n\r\n<span style=\"font-size:18px\">我们为什么要将第二种配置形式呢？那第一种的配置方式有什么缺点吗？假设我的计算机上安装了两个JDK，一</span>\r\n\r\n<span style=\"font-size:18px\">个是1.7，一个1.8，我刚才配置的是1.8的，那么我需要配置1.7，需要重新配置Path</span><span style=\"font-size:18px\">环境变量，有可能在修改Path环</span>\r\n\r\n<span style=\"font-size:18px\">境变量的同时误删其它的东西，所以不建议使用第一种。</span>\r\n\r\n## path环境变量的参照形配置方式的步骤：</span></span>\r\n\r\n<span style=\"font-size:18px\">a)重新打开系统环境变量Path，将第一种配置的路径删除。</span>\r\n\r\n<span style=\"font-size:18px\">b)创建新的环境变量名称：JAVA_HOME；为JAVA_HOME添加变量值：JDK安装目录，我的也就</span>\r\n\r\n<span style=\"font-size:18px\">是：</span><span style=\"font-size:18px\">E:\\[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")\\develop\\jdk1.8.0_25</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119142239625?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">c)将path环境变量中JDK目录修改为：%JAVA_HOME%\\bin;(%路径名称%相当于引用路径名称)</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119142245875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">d)重新启动DOS，再次使用javac编译Java源文件和java运行字节码文件。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119142252015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">这种方式我们在使用其它的JDK时，可以只修改JAVA_HOME变量，不修改Path变量，这样不会误删其他的东西</span>\r\n\r\n<span style=\"font-size:18px\">造成一些其它程序无法运行。</span>\r\n\r\n<span style=\"font-size:18px\">我们再来看一个在Java程序运行的过程中出现的问题，下面的运行结果就是很好的示例，这就需要用到了另一个</span>\r\n\r\n<span style=\"font-size:18px\">系统变量classpath的配置。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119143336467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n# classpath环境变量的配置\r\n\r\n我们为什么要配置classpath环境变量？</span>classpath环境变量的作用是什么？</span>\r\n\r\n<span style=\"font-size:18px\">我们在将来的Java程序开发中，只需要字节码文件，假设我们在其它的目</span><span style=\"font-size:18px\">录下运行字节码文件，结果是和上面的</span>\r\n\r\n<span style=\"font-size:18px\">一样的，是无法运行。因此上面配置的path</span><span style=\"font-size:18px\">环境变量只能在一起使用，如果要</span><span style=\"font-size:18px\">实现字节码文件在任意的目录下运行，</span>\r\n\r\n<span style=\"font-size:18px\">就需要配置classpath环境</span><span style=\"font-size:18px\">变量。<span style=\"color:#ff0000\">因此它的作用是：使classpath目录中的.class</span></span><span style=\"font-size:18px\"><span style=\"color:#ff0000\">文件可以在任意目录运行。</span></span>\r\n\r\n## classpath环境变量配置方式\r\n\r\n<span style=\"font-size:18px\">a)创建新的变量名称：classpath</span>\r\n\r\n<span style=\"font-size:18px\">b)变量值：设定为指定的含有class文件的目录，多个目录间使用分号(;)分割。我指定的目录是：E:\\Java\\JavaSE\\Code;</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119143746489?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">c)重新启动DOS，使用java运行字节码文件。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119143827360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">d)我们在桌面重新编辑一个Java源文件，要求输出：你好，世界，保存的名称还是HelloWorld.java，继续编译和</span>\r\n\r\n<span style=\"font-size:18px\">运行。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119143934673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">e)上面遇到的问题是我们配置的classpath环境变量只是包含了E:\\Java\\JavaSE\\Code这个目录下的字节码文件,</span>\r\n\r\n<span style=\"font-size:18px\">因此解决的方法是：<span style=\"color:#ff0000\">通常将配置的目录最前面添加.;配置，即便当前目录，使.class文件搜索时首先搜索当前目录，然</span></span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\">后根据目录配置的顺序依次查找，找到后即运行，因此classpath目录中的配置存在先后顺序。</span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\">![](http://img.blog.csdn.net/20160119144013727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">f)重新启动DOS，再次运行桌面上的字节码文件。</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119144028642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n<span style=\"font-size:18px\">我们在网上找到的配置classpath的值可能各不相同，不过其中包含最多的就是下面的三个Java类库文件：rt.jar是</span>\r\n\r\n<span style=\"font-size:18px\">JAVA基础类库，dt.jar是关于运行环境的类库，tools.jar是工具类库。我们来看</span><span style=\"font-size:18px\">看这些类库。</span>\r\n\r\n<span style=\"font-size:18px\">1)rt.jar默认就根classloader的加载路径里面放在claspath是多此一举不信你可以去classpath里面的rt.jar然后用?</span>\r\n\r\n<span style=\"font-size:18px\">java -verbose XXXX 的方式运行一个简单的类 就知道JVM的系统根Loader的</span><span style=\"font-size:18px\">路径里面不光rt.jar， jre\\lib下面的大部分</span>\r\n\r\n<span style=\"font-size:18px\">jar都在这个路径里。</span>\r\n\r\n<span style=\"font-size:18px\">2)tools.jar是系统用来编译一个类的时候用到的 也就是javac的时候用到javac XXX.java。实际上就是运行java -</span>\r\n\r\n<span style=\"font-size:18px\">calsspath=%JAVA_HOME%\\lib\\tools.jar xx.xxx.Main XXX.javajavac就是对</span><span style=\"font-size:18px\">上面命令的封装 所以tools.jar 也不用加到</span>\r\n\r\n<span style=\"font-size:18px\">classpath里面。</span>\r\n\r\n<span style=\"font-size:18px\">3)dt.jar是关于运行环境的类库,主要是swing的包你要用到swing时最好加上。</span>\r\n\r\n<span style=\"font-size:18px\">因此，最后配置的classpath环境变量的值是：.;E:\\Java\\JavaSE\\Code;%JAVA_HOME%\\lib\\dt.jar;</span>\r\n\r\n<span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119144213745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span>\r\n\r\n# path和classpath的区别\r\n\r\n<span style=\"font-size:18px; color:#ff0000\">path环境变量里面记录的是可执行性文件，如.exe文件，对可执行文件先在当前路径去找，如果没找到就去path</span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\">环境变量中配置的路径去找</span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\">classpath环境变量里记录的是java类的运行文件所在的目录。</span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\"><span style=\"font-size:18px\">?java -version 检测JDK版本：</span></span>\r\n\r\n<span style=\"font-size:18px; color:#ff0000\"><span style=\"font-size:18px\">![](http://img.blog.csdn.net/20160119144432831?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n</span></span>\r\n\r\n');
INSERT INTO `article_info_true` VALUES ('96', 'New node', '<p><h1><a name=\"t0\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff0000\">数值运算符和函数</span></span></h1></p>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;常见的数值函数下面几个：</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605163714646?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t1\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(1)数值运算符</span></span></h2><br><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;MySQL数据库常见的数值运算符有：+、-、<em>、、、%等等。这里我们就不再一一列举，只是来看两个例子：<br><br></span><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 3+4;</span></span></p><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 3%4;</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605163900647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t2\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(2)进一取整和舍一取整</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT CEIL(3.01);</span></span></p><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT FLOOR(3.99);</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://img.blog.csdn.net/20160605163904001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p><br><h2><a name=\"t3\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(3)整数除法</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 3/4;</span></span></p><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 3 DIV 4;</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164122145?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t4\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(4)取余数(取模)</span></span></h2><br><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; <span style=\"color:#ff6600\">&nbsp;SELECT 5 % 3;<br><br></span></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 5 MOD 3;</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164242399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t5\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; <span style=\"color:#33cc00\">&nbsp;(5)幂运算</span></span></h2><br><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 5.3 MOD 3;<br><br></span></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT POWER(3,3);</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164338211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t6\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(6)四舍五入</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT ROUND(3.652,2);</span></span></p><br><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT ROUND(3.652,1);<br><br></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT ROUND(3.652,0);</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164447024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t7\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(7)数字截取</span></span></h2><br><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT TRUNCATE(125.89,1);<br><br></span></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT TRUNCATE(125.89,0);</span></p><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT TRUNCATE(125.89,-1);</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164451368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h1><a name=\"t8\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff0000\">比较运算符和函数</span></span></h1><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;常见的比较运算符和函数：</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164652588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t9\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(1)[不]在范围之内</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 15 BETWEEN 1 AND 22;</span></span></p><br><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 35 BETWEEN 1 AND 22;<br><br></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 35 NOT BETWEEN 1 AND 22;</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164739994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t10\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(2)[不]在列出范围之内</span></span></h2><br><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 10 IN(5,10,15,20);<br><br></span></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 13 IN(5,10,15,20);</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164953715?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t11\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; <span style=\"color:#33cc00\">&nbsp;(3)[不]为空</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT NULL IS NULL;</span></span></p><br><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT ‘’ IS NULL;<br><br></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 0 IS NULL;</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165023559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t12\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(4)<span style=\"font-size:18px\">[不]为空在查询语句中</span></span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT </em> FROM test WHERE first_name IS NULL;</span></p><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT * FROM test WHERE first_name IS NOT NULL;</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165027606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h1><a name=\"t13\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff0000\">日期时间函数</span></span></h1><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;常用的日期时间函数：</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165351810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t14\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(1)当前日期和时间以及当前日期和当前时间</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT NOW();</span></span></p><br><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT CURDATE();<br><br></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT CURTIME();</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165358920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t15\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(2)日期变化</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT DATE_ADD(‘2016-5-1’,INTERVAL 23 DAY);</span></span></p><br><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATE_ADD(‘2016-5-1’,INTERVAL -23 DAY);<br><br></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATE_ADD(‘2016-5-1’,INTERVAL 3 WEEK);</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165409248?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p><br><h2><a name=\"t16\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(3)日期差值和日期格式化</span></span></h2><br><p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT DATEDIFF(‘2016-5-1’,’2016-5-23’);</span></span></p><br><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATEDIFF(‘2016-5-15’,’2016-5-3’);<br><br></span><br><p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATE_FORMAT(‘2016-5-2’,’%m/%d/%Y’);</span></p><br><p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165416066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br><br></span></p>\r\n\r\n', '120', '\r\n\r\n<h1><a name=\"t0\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff0000\">数值运算符和函数</span></span></h1>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;常见的数值函数下面几个：</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605163714646?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t1\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(1)数值运算符</span></span></h2>\r\n<span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;MySQL数据库常见的数值运算符有：+、-、*、、、%等等。这里我们就不再一一列举，只是来看两个例子：<br>\r\n</span>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 3+4;</span></span></p>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 3%4;</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605163900647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t2\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(2)进一取整和舍一取整</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT CEIL(3.01);</span></span></p>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT FLOOR(3.99);</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://img.blog.csdn.net/20160605163904001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\r\n<h2><a name=\"t3\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(3)整数除法</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 3/4;</span></span></p>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 3 DIV 4;</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164122145?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t4\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(4)取余数(取模)</span></span></h2>\r\n<span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; <span style=\"color:#ff6600\">&nbsp;SELECT 5 % 3;<br>\r\n</span></span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 5 MOD 3;</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164242399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t5\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; <span style=\"color:#33cc00\">&nbsp;(5)幂运算</span></span></h2>\r\n<span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 5.3 MOD 3;<br>\r\n</span></span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT POWER(3,3);</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164338211?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t6\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(6)四舍五入</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT ROUND(3.652,2);</span></span></p>\r\n<span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT ROUND(3.652,1);<br>\r\n</span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT ROUND(3.652,0);</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164447024?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t7\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(7)数字截取</span></span></h2>\r\n<span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT TRUNCATE(125.89,1);<br>\r\n</span></span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT TRUNCATE(125.89,0);</span></p>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT TRUNCATE(125.89,-1);</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164451368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h1><a name=\"t8\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff0000\">比较运算符和函数</span></span></h1>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;常见的比较运算符和函数：</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164652588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t9\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(1)[不]在范围之内</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 15 BETWEEN 1 AND 22;</span></span></p>\r\n<span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 35 BETWEEN 1 AND 22;<br>\r\n</span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 35 NOT BETWEEN 1 AND 22;</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164739994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t10\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(2)[不]在列出范围之内</span></span></h2>\r\n<span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT 10 IN(5,10,15,20);<br>\r\n</span></span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 13 IN(5,10,15,20);</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605164953715?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t11\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; <span style=\"color:#33cc00\">&nbsp;(3)[不]为空</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT NULL IS NULL;</span></span></p>\r\n<span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT \'\' IS NULL;<br>\r\n</span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT 0 IS NULL;</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165023559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t12\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(4)<span style=\"font-size:18px\">[不]为空在查询语句中</span></span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT * FROM test WHERE first_name IS NULL;</span></p>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT * FROM test WHERE first_name IS NOT NULL;</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165027606?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h1><a name=\"t13\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff0000\">日期时间函数</span></span></h1>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;常用的日期时间函数：</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165351810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t14\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(1)当前日期和时间以及当前日期和当前时间</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT NOW();</span></span></p>\r\n<span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT CURDATE();<br>\r\n</span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT CURTIME();</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165358920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t15\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(2)日期变化</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT DATE_ADD(\'2016-5-1\',INTERVAL 23 DAY);</span></span></p>\r\n<span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATE_ADD(\'2016-5-1\',INTERVAL -23 DAY);<br>\r\n</span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATE_ADD(\'2016-5-1\',INTERVAL 3 WEEK);</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165409248?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n<h2><a name=\"t16\"></a><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#33cc00\">(3)日期差值和日期格式化</span></span></h2>\r\n<p><span style=\"font-size:18px\">&nbsp; &nbsp; &nbsp; &nbsp;<span style=\"color:#ff6600\">SELECT DATEDIFF(\'2016-5-1\',\'2016-5-23\');</span></span></p>\r\n<span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATEDIFF(\'2016-5-15\',\'2016-5-3\');<br>\r\n</span>\r\n<p><span style=\"font-size:18px; color:#ff6600\">&nbsp; &nbsp; &nbsp; &nbsp;SELECT DATE_FORMAT(\'2016-5-2\',\'%m/%d/%Y\');</span></p>\r\n<p style=\"text-align:center\"><span style=\"font-size:18px\"><img src=\"http://img.blog.csdn.net/20160605165416066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\r\n</span></p>\r\n   \r\n');
INSERT INTO `article_info_true` VALUES ('97', '初识java编程', '<p><img src=\"http://ww3.sinaimg.cn/mw690/006pQ25sgw1f26n66379ij30f0092wh2.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-1-java-\"><a name=\"1. 马上开始 － 编写你的第1个Java程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 马上开始 － 编写你的第1个Java程序</h3><p>检查在开发环境中是否安装了 Java Development Kit (JDK)。</p>\r\n<p>让我们来编写第1个Java程序，在控制台上输出“Hello，world！”，</p>\r\n<pre><code>Hello，World！?\r\n</code></pre><h4 id=\"h4--1-\"><a name=\"步骤1：编写代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>步骤1：编写代码</h4><p>选择一个文本编辑器，Windows：TextPad、NotePad++；Mac OS X：jEdit、gedit；Ubuntu：gedit。</p>\r\n<p>在编辑器内输入以下代码，输入完毕后保存为“Hello.Java”文件，扩展名“.java”，文件名需要与类名一致区分大小写。</p>\r\n<pre><code>public class Hello \r\n{  \r\npublic static void main(String[] args)\r\n{        \r\nSystem.out.println(&quot;Hello，World！&quot;);    \r\n}\r\n}\r\n</code></pre><h4 id=\"h4--2-\"><a name=\"步骤2：编译源码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>步骤2：编译源码</h4><p>运行命令“javac”编译源文件”Hello.java”，编译成功后会生成二进制文件“hello.class”。在终端中运行下面命令：</p>\r\n<p>// 进入Hello.java所在目录<br><code>javac Hello.java</code></p>\r\n<p>?在IDEs（例如Eclispe、NetBeans）中不需要显示编译文件，因为他们支持即时编译。</p>\r\n<h4 id=\"h4--3-\"><a name=\"步骤3：运行程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>步骤3：运行程序</h4><p>运行”java”命令，</p>\r\n<p><code>java Hello</code></p>\r\n<pre><code>Hello，World！\r\n</code></pre><p>需要注意的是“java Hello”并没有包含“.class”扩展名。</p>\r\n<p>在IDEs中，源文件右键 ＝》运行… ＝》Java Application会起到同样的作用。</p>\r\n<h4 id=\"h4--\"><a name=\"编程的简要说明?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>编程的简要说明?</h4><p><code>/* ...... */</code></p>\r\n<p><code>// ... 一直到行末尾</code></p>\r\n<p>这都是注释的方式，注释会被编译器忽略不会被执行，但是注释方便读者更好的阅读和理解程序，有两种注释的方式：</p>\r\n<ol>\r\n<li>多行注释：以/*开头，以*/结尾，可以跨越多行。</li><li>单行注释：以//开头，直到行尾。</li></ol>\r\n<p><code>public class Hello { ...... }</code></p>\r\n<p>这个单元就是类的声明方式，类用关键字“class”进行定义，{ ….. }里面是类的主题内容，关键字”public”稍后会说明。</p>\r\n<p>在Java中，源文件名需要和类名保持一致，同时以“.java”为文件扩展名。</p>\r\n<p><code>public static void main（String[] args) { ...... }</code></p>\r\n<p>这个单元是main()方法的定义，{ …… }方法的主体中包含了编程语句。</p>\r\n<p><code>System.out.println(&quot;Hello, world！&quot;);</code></p>\r\n<p><span style=\"font-family: monospace;\">字符串是由双引号和引号之间的文本组成，上面语句运行后，会在控制台输出Hello, world！，不包括两端的引号。</span></p>\r\n<h3 id=\"h3-2-java-\"><a name=\"2. Java术语和语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. Java术语和语法</h3><p><strong>语句:</strong>表示着一段程序的执行以；为结尾。</p>\r\n<p><strong>块:</strong>一个块是由一组大括号和里面的语句组成，通常被视为一个单独的单元。我们的程序有两个块组成，一个块包含着Hello类的主体，另一个块包含着main()方法的主体，不需要在结束括号添加分号。</p>\r\n<p><strong>注释：</strong>多行注释以/*卡头，以*/结尾，单行注释以//开头直到行尾，注释会被变编译器忽略不会被执行，但是注释提供了解释、使用的文档说明，所以请自由的使用注释。</p>\r\n<p><strong>空白：</strong>空格，制表符和换行符统称为空白。一个空格标记分割，其余的空白会被忽略，但是他们会帮助你和你的读者更好的理解你的程序，所以请自由的使用空格。</p>\r\n<p><strong>区分大小写：</strong>Java是大小写敏感的，ROSE、Rose、rose是不同的变量，还有文件名也是区分大小写的。</p>\r\n<h3 id=\"h3--3-java-\"><a name=\"?3. Java程序模板\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>?3. Java程序模板</h3><p>编程中你可以使用下面的模板，在你的程序中选择一个有意义的”Classname”，在main方法体中写入编程语句，不用担心其他的项和关键字，我会在适当的时候加以解释。</p>\r\n<pre><code>public class Classname {    // 选择一个有意义的类名\r\n    public static void main(String[] args){\r\n    // 这里是你的编程语句\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-4-system-out-println-system-out-print-\"><a name=\"4. 使用System.out.println()和System.out.print()输出\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 使用System.out.println()和System.out.print()输出</h3><p>你可以使用?System.out.println()和System.out.print()将文本输出到控制台上：</p>\r\n<ul>\r\n<li>System.out.println(aString) 输出字符串，折行，光标位于折行开头的位置。</li><li>System.out.print(aString)输出字符串，光标位于输出文本的后面。</li></ul>\r\n<p>运行下面的代码，并解释生成的输出：</p>\r\n<pre><code>public class PrintTest \r\n{    \r\npublic static void main(String[] args) \r\n{       \r\nSystem.out.println(&quot;Hello, world!&quot;);         \r\nSystem.out.println();                        \r\nSystem.out.print(&quot;Hello, world!&quot;);          \r\nSystem.out.println(&quot;Hello,&quot;);        \r\nSystem.out.print(&quot; &quot;);                    \r\nSystem.out.print(&quot;world!&quot;);       \r\nSystem.out.println(&quot;Hello, world!&quot;);    \r\n}\r\n}\r\nHello, world!\r\n\r\nHello, world!Hello,\r\n world!Hello, world!\r\n</code></pre><h3 id=\"h3-5-\"><a name=\"5. 编写一个加法的程序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 编写一个加法的程序</h3><pre><code>public classFiveNumberSum {\r\n    public static void main(String[] args) {\r\n        int number1 = 11;  // 声明5个int变量来存储5个数值\r\n        int number2 = 22;\r\n        int number3 = 33;\r\n        int number4 = 44;\r\n        int number5 = 55;\r\n        int sum;           // 声明1个sum变量来存储相加之和\r\n        sum = number1 + number2 + number3 + number4 + number5;\r\n\r\n        System.out.print(&quot;The sum is &quot;);\r\n        System.out.println(sum);          // 输出相加之和\r\n    }\r\n}\r\nThe sum is 165\r\n</code></pre><p><code>int number1 = 11;\r\nint number2 = 22;\r\nint number3 = 33;\r\nint number4 = 44;\r\nint number5 = 55;</code></p>\r\n<p>声明了5个int型变量number1、number2、number3、number4和number5，将11、22、33、44和55利用操作符”=”赋给变量，你可以在一条语句中声明多个变量，用逗号分割，例如：</p>\r\n<p>int number1 = 11, number2 = 22, number3 = 33, number4 = 44, number5 = 55;</p>\r\n<p><code>int sum;</code></p>\r\n<p>声明一个没有初始化的int型变量。</p>\r\n<p><code>sum = number1 + number2 + number3 + number4 + number5;</code></p>\r\n<p>sum存储number1到number5相加之和，操作符”+”表示加法，和数学上的一样。</p>\r\n<p><code>System.out.print(&quot;The sum is &quot;);\r\nSystem.out.println(sum);</code><br>打印输出变量sum值，sum不加双引号，否则会直接输出”sum”。</p>\r\n<h3 id=\"h3-u7EC3u4E60\"><a name=\"练习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习</h3><ol>\r\n<li>用操作符”*”修改上面的程序，并计算相乘的结果.</li></ol>\r\n<h3 id=\"h3-6-\"><a name=\"6. 程序是什么?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. 程序是什么?</h3><p>程序是顺序执行的指令序列，参考下面的流程图。</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Construct_Sequential.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u4F8Bu5B50\"><a name=\"例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>例子</h3><p>根据圆的半径计算周长和面积并输出。</p>\r\n<pre><code>public class CircleComputation {\r\n   public static void main(String[] args) {\r\n      // 声明变量\r\n      double radius, area, circumference;\r\n      final double PI = 3.14159265;\r\n\r\n      // 初始化圆半径\r\n      radius = 1.2;\r\n\r\n      // 计算面和周长\r\n      area = radius * radius * PI;\r\n      circumference = 2.0 * radius * PI;\r\n\r\n      // 打印输出结果\r\n      System.out.print(&quot;The radius is &quot;);\r\n      System.out.println(radius);\r\n      System.out.print(&quot;The area is &quot;);\r\n      System.out.println(area);\r\n      System.out.print(&quot;The circumference is &quot;);\r\n      System.out.println(circumference);\r\n   }\r\n}\r\nThe radius is 1.2The area is 4.523893416The circumference is 7.5398223600000005\r\n</code></pre><p><code>double radius, area, circumference;</code><br>声明了3个double变量radius、area和circumference，double变量存储实数。</p>\r\n<p><code>final double PI = 3.14159265;</code><br>声明一个double型变量PI并设置了初值，PI被声明为final，意味着它的值不能被改变。</p>\r\n<p><code>radius = 1.2;</code><br>将1.2赋值给radius。</p>\r\n<p><code>area = radius * radius * PI;</code><br><code>circumference = 2.0 * radius * PI;</code><br>根据圆的半径计算面积和周长。</p>\r\n<p><code>System.out.print(&quot;The radius is &quot;);</code><br><code>System.out.println(radius);</code><br><code>System.out.print(&quot;The area is &quot;);</code><br><code>System.out.println(area);</code><br><code>System.out.print(&quot;The circumference is &quot;);</code><br><code>System.out.println(circumference);</code><br>打印计算结果。值得注意的是main（）方法体中顺序执行的语句。</p>\r\n<h3 id=\"h3-u7EC3u4E60\"><a name=\"练习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习</h3><ol>\r\n<li>参考上面的例子，编写程序：根据长度和宽度打印输出矩形的周长和面积。</li></ol>\r\n<h3 id=\"h3-7-\"><a name=\"7. 什么是变量\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7. 什么是变量</h3><p>计算机操纵数据，变量存储数据，之所以叫变量因为它的值可以被改变。</p>\r\n<p>变量就是一块内存的地址，存储特定类型的值，换句话说，一个变量有一个名称，数据类型和存储该类型的值。</p>\r\n<ul>\r\n<li>变量有名称，例如半径，面积，年龄，高度，变量的名称是唯一的，我们可以获取（radius*radius*3.1416）和设置（radius＝1.2）变量存储的值。<ul>\r\n<li>int：整数例如123和－456。</li><li>double：浮点数或者实数，例如：3.1416、－55.66、7.8e9和－1.2e3.4， 有一个可选的小数点和小数部分，也可以用科学计数法表示。</li><li>String：文本例如”Hello”，”Good Moring!”。文本字符串包含在双引号里面。</li></ul>\r\n</li><li>变量存储特定类型的值。值得注意的是，大多数编程语言中变量都关联着类型以及该类型的值。int变量可以存储整数例如123，但不能存储实数例如12.34，也不能存储文本例如”你好”。早期的编程语言引入类型的概念来简化数据的理解。</li></ul>\r\n<p>下图说明了3种数据类型：int，double和String，int变量存储整数，double存储实数，字符串存储文本内容。</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_Variable.png\" alt=\"\"></p>\r\n<p>变量使用前需要被声明，你可以使用下面的声明方式：</p>\r\n<pre><code>varType varName;                                                  // 声明变量的类型\r\nvarType varName1, varName2,...;                                   // 声明多个同一类型的变量\r\nvarType varName = initialValue;                                   // 声明变量的类型并赋值\r\nvarType varName1 = initialValue1, varName2 = initialValue2,... ;  // 声明多个变量并分别赋值\r\n</code></pre><p>请注意：</p>\r\n<ul>\r\n<li>声明语句以分号（;）为结尾。</li><li>声明多个变量，变量间以逗号（,）分隔。</li><li>操作符＝，用来给变量赋值。</li></ul>\r\n<p>举例：</p>\r\n<pre><code>int sum;               // 声明1个int型变量sum。\r\nint number1, number2;  // 声明2个int型变量number1，number2以分号相隔。\r\ndouble average;        // 声明1个double型变量average。 \r\nint height = 20;       // 声明1个int型变量并初始化。\r\n</code></pre><p>变量声明后，你可以利用操作符”=”给变量赋值或重新赋值，例如：</p>\r\n<pre><code>int number;                  // 声明1个int型变量number。\r\nnumber = 99;                 // 给变量&quot;number&quot;分配了一个整数99。\r\nnumber = 88;                 // 给变量&quot;number&quot;重新分配了一个整数88。\r\nnumber = number + 1;         // 计算&quot;number + 1&quot;, 将结果赋值给&quot;number&quot;。\r\nint sum = 0;                 // 声明1个&quot;int&quot;变量&quot;sum&quot;并设置初值0。\r\nsum = sum + number;          // 计算&quot;sum + number&quot;，将结果复制给&quot;sum&quot;。\r\nint num1 = 5, num2 = 6;      // 一条语句中声明了两个变量并设置初值, 用逗号分隔。\r\ndouble radius = 1.5;         // 声明1个&quot;double&quot;变量&quot;radius&quot;并设置初值1.5。\r\nint number;                  // 错误: 变量&quot;number&quot;已经声明。\r\nsum = 55.66;                 // 错误: &quot;sum&quot;是&quot;int&quot;型变量不能存储实数。\r\nsum = &quot;Hello&quot;;               // 错误: &quot;sum&quot;是&quot;int&quot;型变量不能存储字符串。\r\n</code></pre><p>?请注意：</p>\r\n<ul>\r\n<li>每个变量只能声明一次。（没有两套房子对应着一个地址吧。）</li><li>你可以在程序内的任意位置声明。</li><li>一旦声明了某个类型的变量，它只能存储该类型的值，例如一个int型变量职能存储整数例如123，不能存储浮点类型例如－2.17或者文本“Hello”。</li><li>变量声明后类型不能改变。</li></ul>\r\n<p>在上面的列子中我已经展示了两种类型：int类型存储整数，double类型存储浮点数，编程时混合使用int和double时，需要特别的小心稍后我会解释。</p>\r\n<p><strong>x=x+1</strong></p>\r\n<p>对于赋值操作符（＝）在编程和数学中我们要区别对待，数学中”x=x+1”等式是不成立的，但在编程中意为着x＋1后的值重新赋值给x。</p>\r\n<p><strong>x+y=1</strong></p>\r\n<p>数学中是有效，编程中无效。在编程中等式右侧是计算值；等式的左侧是变量，也就是说优先计算等式右侧，之后赋值给等式左侧。有一些编程语言使用 :=为赋值操作符，避免与等号混淆。</p>\r\n<h3 id=\"h3-8-\"><a name=\"8. 基本的算数运算\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8. 基本的算数运算</h3><p>基本的算数运算符是：</p>\r\n<p>| 运算符 | 含义 | 例子 |<br>| <code>+</code> | 加法 | <code>x + y</code> |<br>| <code>-</code> | 减法 | <code>x - y</code> |<br>| <code>*</code> | 乘法 | <code>x * y</code> |<br>| <code>/</code> | 除法 | <code>x / y</code> |<br>| <code>%</code> | 取模（求余） | <code>x % y</code> |<br>| <code>++</code> | 递增（一元） | <code>++x</code>or<code>x++</code> |<br>| <code>--</code> | 递减（一元） | <code>--x</code>or<code>x--</code> |</p>\r\n<p>加法、减法、乘法、除法和取模是两个操作数二元运算，而自增和自减是一个操作数一元运算。</p>\r\n<h4 id=\"h4-u4F8Bu5B50\"><a name=\"例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>例子</h4><p>下面的程序说明了这些运算：</p>\r\n<pre><code>\r\n/**\r\n * 算数运算符测试\r\n */\r\n public classArithmeticTest {\r\n    public static void main(String[] args) {\r\n        int number1 = 98;                                   // 声明了一个int型变量number1设置初值98\r\n        int number2 = 5;                                    // 声明了一个int型变量number2设置初值5\r\n        int sum, difference, product, quotient, remainder;  // 声明5个变量来存储计算结果\r\n\r\n        // 执行算数运算\r\n        sum = number1 + number2;\r\n        difference = number1 - number2;\r\n        product = number1 * number2;\r\n        quotient = number1 / number2;\r\n        remainder = number1 % number2;\r\n\r\n        // 打印输出结果\r\n        System.out.print(number1);\r\n        System.out.print(&quot;和&quot;);\r\n        System.out.print(number2);\r\n        System.out.print(&quot;的相加, 相减, 相乘, 相除和取模的结果分别为&quot;);\r\n        System.out.print(sum);\r\n        System.out.print(&quot;, &quot;);\r\n        System.out.print(difference);\r\n        System.out.print(&quot;, &quot;);\r\n        System.out.print(product);\r\n        System.out.print(&quot;, &quot;);\r\n        System.out.print(quotient);\r\n        System.out.print(&quot;, 和&quot;);\r\n        System.out.println(remainder);\r\n\r\n        ++number1;  // number1自增1, 相当于&quot;number1=number1 + 1&quot;\r\n        --number2;  // number2自减2, 相当于&quot;number2=number2 - 1&quot;\r\n        System.out.println(&quot;number1递增后的结果为&quot; + number1);\r\n        System.out.println(&quot;number2递增后的结果为&quot; + number2);\r\n\r\n        quotient = number1 / number2;\r\n        System.out.println(number1 + &quot; 和&quot; + number2 + &quot;新的商为&quot; + quotient);\r\n    }\r\n}\r\n98和5的相加, 相减, 相乘, 相除和取模的结果分别为103, 93, 490, 19, 和3\r\nnumber1递增后的结果为99\r\nnumber2递增后的结果为4\r\n99和4新的商为24\r\n</code></pre><h4 id=\"h4-u7A0Bu5E8Fu5256u6790\"><a name=\"程序剖析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>程序剖析</h4><p><span class=\"line-heading-code-new\"><code>int number1 = 98;</code><br><code>int number2 = 5;</code><br><code>int sum, difference, product, quotient, remainder;</code><br></span>为了程序的需要声明了全都是int型的变量number1、number2、 sum、difference、product、quotient和remainder。</p>\r\n<p><span class=\"line-heading-code-new\"><code>sum = number1 + number2;</code><br><code>difference = number1 - number2;</code><br><code>product = number1 * number2;</code><br><code>quotient = number1 / number2;</code><br><code>remainder = number1 % number2;</code><br></span><span style=\"font-family: Verdana, Arial, Helvetica, sans-serif;\">开始执行</span>number1<span style=\"font-family: Verdana, Arial, Helvetica, sans-serif;\">和</span>number2的运算，注意下整数相除后产生的截断整数，例如98/5 → 19,?99/4 → 24<span style=\"font-family: Verdana, Arial, Helvetica, sans-serif;\">和</span>1/2 → 0。</p>\r\n<p><code>System.out.print(number1); // 输出变量值</code></p>\r\n<p><code>System.out.print(&quot;和&quot;);</code><br><code>System.out.print(number2);</code><br><code>System.out.print(&quot;的相加, 相减, 相乘, 相除和取模的结果分别为&quot;);</code><br><code>......</code><br>打印运算结果并适当的加以描述，输出普通文本需要加双引号，变量不需要。</p>\r\n<pre><code>System.out.println(&quot;sum&quot;);   // 输出&quot;sum&quot;\r\nSystem.out.println(sum);     // 输出变量sum存储的值例如98\r\n</code></pre><p><code>++number1;</code><br><code>--number2;</code></p>\r\n<p>举例说明了自增和自减操作， “++”和”—“只有一个操作数（一元运符）而不像”+”、”-“、”*”、”/“和”%”有两个操作数（二元运算符），++放在操作数之前称作预增，放在操作数之后称作后增，预增和后增的最终结果都是使操作数自增1，但是两者有所区别，我会在后面说明。</p>\r\n<p><code>System.out.println(&quot;number1递增后的结果为&quot; + number1);</code><br><code>System.out.println(&quot;number2递增后的结果为&quot; + number2);</code></p>\r\n<p>打印自增/自减后的结果。这里我们将文本字符串和变量通过”+”操作符联合输出，在这种情况下”+”不执行加法操作，而是字符串连接符。</p>\r\n<h4 id=\"h4-u7EC3u4E60\"><a name=\"练习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习</h4><ol>\r\n<li>使用”+”操作符使用一条println()语句打印所有的输出结果。</li><li>增加一个新int型变量number3，设置初始值为77，计算和打印三个数之和。</li><li>编程中我们使用＊来表示乘法，试着计算并打印输出结果：1的31倍加上2的17倍加上3的87倍的和。</li></ol>\r\n<h3 id=\"h3-9-1000-\"><a name=\"9. 累加1000个数 使用循环\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>9. 累加1000个数 使用循环</h3><p>假设你想计算从1～1000累加和，按照上面的例子你要在程序中写1000行代码！不过有个更简单的方式就是使用循环，要知道计算机最擅长的就是重复性的计算。</p>\r\n<h4 id=\"h4-u4F8Bu5B50\"><a name=\"例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>例子</h4><p>来试试下面的程序：使用循环来计算从1累加到1000的和</p>\r\n<pre><code>\r\n/*\r\n * 使用循环计算从最小值到最大值的累加和\r\n */\r\n public class RunningNumberSum {\r\n     public static void main(String[] args) {\r\n         int lowerbound = 1;               // 存储最小值\r\n         int upperbound = 1000;            // 存储最大值\r\n         int sum = 0;                      // 声明sum变量来存储中间的累加和\r\n         int number = lowerbound;\r\n\r\n         while (number &lt;= upperbound) {\r\n             sum = sum + number;           // 将number累加到sum中\r\n             ++number;                     // 开始累加下个数\r\n             }\r\n\r\n         // 打印输出结果\r\n         System.out.println(&quot;从&quot; + lowerbound + &quot;到&quot; + upperbound + &quot;的累加之和为&quot; + sum);\r\n     }\r\n }\r\n从1到1000的累加之和为500500\r\n</code></pre><h4 id=\"h4-u7A0Bu5E8Fu5256u6790\"><a name=\"程序剖析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>程序剖析</h4><p><code>int lowerbound = 1;</code><br><code>int upperbound = 1000;</code><br>定义两个变量分别存储最小值和最大值。</p>\r\n<p><code>int sum = 0;</code><br>定义一个变量来存储累加之和。</p>\r\n<p><code>int number = lowerbound;</code><br><code>while (number &lt;= upperbound) {</code><br><code>???sum = sum + number;</code><br><code>???++number;</code><br><code>}</code></p>\r\n<p>?这个我们称之为循环，一个while循环的语法如下：</p>\r\n<pre><code>initialization-statement;\r\nwhile (test) {\r\n   loop-body;\r\n}\r\nnext-statement;\r\n</code></pre><p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/Construct_WhileLoop.png\" alt=\"\">?</p>\r\n<p>从上面的流程图我们可以看出，首先执行初始化语句，校验test，如果为真执行方法体，每执行一次方法体后都会重新校验test，为真继续执行，直到test为假的时候退出循环。</p>\r\n<p>程序循环的总次数：upperbound-lowerbound+1，循环结束后打印输出结果。</p>\r\n<pre><code>System.out.println(&quot;从&quot; + lowerbound + &quot;到&quot; + upperbound + &quot;的累加之和为&quot; + sum);\r\n</code></pre><h4 id=\"h4-u7EC3u4E60\"><a name=\"练习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习</h4><ol>\r\n<li>修改上面的程序计算从9到888累加和。</li><li>修改上面的程序计算从1到1000的奇数累加和。</li><li>修改上面的程序计算从1到1000每个数都被7除的累加和。</li><li>修改上面的程序计算从1到100每个数平方的累加和。</li><li>修改上面的程序计算从1到10的乘积。</li></ol>\r\n<h3 id=\"h3-10-\"><a name=\"10. 条件（判断）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>10. 条件（判断）</h3><p>如果你想计算从1到1000的奇数之和，有很多种方法，你可以声明两个变量：sumOdd和sumEven，使用条件语句判断奇数和偶数，之后累加到相应的变量，程序如下：</p>\r\n<pre><code>\r\n/*\r\n * 分别计算从最小值到最大值的奇数和偶数和\r\n */\r\n public class OddEvenSum {\r\n     public static void main(String[] args) {\r\n         int lowerbound = 1, upperbound = 1000;   // 最小值, 最大值\r\n         int sumOdd  = 0;                         // 奇数累加和, 初始化为0\r\n         int sumEven = 0;                         // 偶数累加和, 初始化为0\r\n         int number = lowerbound;\r\n\r\n         while (number &lt;= upperbound) {\r\n             if (number % 2 == 0) {               // 偶数\r\n                 sumEven += number;               // 等价于sumEven = sumEven + number\r\n             } else {                             // 奇数\r\n                 sumOdd += number;                // 等价于sumOdd = sumOdd + number\r\n             }\r\n             ++number;                            // 下个数值\r\n\r\n             // 打印输出结果\r\n             System.out.println(&quot;奇数和从&quot; + lowerbound + &quot;到&quot; + upperbound + &quot;为&quot; + sumOdd);\r\n             System.out.println(&quot;偶数和从&quot; + lowerbound + &quot;到&quot; + upperbound + &quot;为&quot; + sumEven);\r\n             System.out.println(&quot;两者之差为&quot; + (sumOdd - sumEven));\r\n         }\r\n     }\r\n}\r\n奇数和从1到1000为250000\r\n偶数和从1到1000为250500\r\n两者之差为-500\r\n</code></pre><h4 id=\"h4-u7A0Bu5E8Fu5256u6790\"><a name=\"程序剖析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>程序剖析</h4><p><code>int lowerbound = 1, upperbound = 1000;</code><br>声明用于循环的最小值和最大值。</p>\r\n<p><code>int sumOdd = 0;</code><br><code>int sumEven = 0;</code><br>声明两个变量分别来存储累加奇数和累加偶数。</p>\r\n<p><code>if (number % 2 == 0) {</code><br><code>???sumEven = sumEven + number;</code><br><code>} else {</code><br><code>???sumOdd = sumOdd + number;</code><br><code>}</code></p>\r\n<p>这是一个条件语句。可以使用这一种条件语句：if-then活if-then-else。</p>\r\n<pre><code>// if-then\r\nif ( test ) {\r\n   true-body;\r\n}\r\n// if-then-else\r\nif ( test ) {\r\n   true-body;\r\n} else {\r\n   false-body;\r\n}\r\n</code></pre><p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Construct_IfElse.png\" alt=\"\"><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Construct_IfThen.png\" alt=\"\"></p>\r\n<p>if-then条件语句，test为真执行true-body。if-then-else语句，test为真执行true-body，test为假执行false-body。在我们的程序中，我们使用求余操作符（%）取2的余数来校验奇偶。</p>\r\n<h4 id=\"h4-u6BD4u8F83u8FD0u7B97u7B26\"><a name=\"比较运算符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>比较运算符</h4><p>有6比较运算符：</p>\r\n<div class=\"table-responsive\"><br><br>| 操作符 | 含义 | 举例 |<br>| <code>==</code> | 等于 | <code>x == y</code> |<br>| <code>!=</code> | 不等于 | <code>x != y</code> |<br>| <code>&gt;</code> | 大于 | <code>x &gt; y</code> |<br>| <code>&gt;=</code> | 大于等于 | <code>x &gt;= y</code> |<br>| <code>&lt;</code> | 小于 | <code>x &lt; y</code> |<br>| <code>&lt;=</code> | 小于等于 | <code>x &lt;= y</code> |<br><br></div>\r\n\r\n<p>值得注意的是双等号（==）是用来比较相等；一个等号（=）是赋值操作。</p>\r\n<h4 id=\"h4-u5E76u5217u6761u4EF6\"><a name=\"并列条件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>并列条件</h4><p>验某个数值是否在1～100之间：1&lt;=x&lt;=100，这里面有条件(x&gt;=1) 与 (x&lt;=100)，编程中你需要用( x &gt;= 1 ) &amp;&amp; ( x &lt;= 100 ) 来表示， “&amp;&amp;”操作符表示”与”操作，同样校验某个数值是否可以被2或3整除，你可以使用 ( x % 2 ==0 ) || ( x % 3 == 0 ) ，”||”操作符表示”或”操作。</p>\r\n<p>有三个逻辑运算符</p>\r\n<div class=\"table-responsive\"><br><br>| 操作符 | 含义 | 举例 |<br>| <code>&amp;&amp;</code> | 逻辑与 | <code>(x &gt;= 1) &amp;&amp; (x &lt;= 100)</code> |<br>| <code>||</code> | 逻辑或 | <code>(x &lt; 1) || (x &gt; 100)</code> |<br>| <code>!</code> | 逻辑非 | <code>!(x == 8)</code> |<br><br></div>\r\n\r\n<p>举例：</p>\r\n<pre><code>(x &gt;= 0) &amp;&amp; (x &lt;= 100)     // 验证x是否大于等于0小于等于100，错误的用法：0 &lt;= x &lt;= 100\r\n(x &lt; 0) || (x &gt; 100)       // 验证x是否小于0或者大于100\r\n!((x &gt;= 0) &amp;&amp; (x &lt;= 100))  // 条件非\r\n// 验证闰年：闰年要被4整除但不能被100整除，或者直接被400整除\r\n((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)\r\n</code></pre><h4 id=\"h4-u7EC3u4E60\"><a name=\"练习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习</h4><ol>\r\n<li>编程校验1～1000之间被13或者15或者17整除，但是不能被30整除的数都有哪些。</li><li>编程计算从公元1年到公元2010年所有的闰年。</li></ol>\r\n<h3 id=\"h3-11-\"><a name=\"11. 浮点类型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>11. 浮点类型</h3><p>回想一下，在Java中变量有名称、类型和存储该类型的值。我们之前已经使用过int类型，int型变量只能存储整型，例如123和-456；它不能存储一个实数，例如12.34。编程中，真正的实数例如3.1416和-55.66称之为浮点数，它们属于类型double，你可以使用浮点数（例如1.23，－4.5）或者科学计数法（例如1.2e3，－4E5.6）其中e或E表示10的指数。</p>\r\n<h4 id=\"h4-u4F8Bu5B50\"><a name=\"例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>例子</h4><pre><code>\r\n/*\r\n * 摄氏温度和华氏温度之间的转换\r\n */\r\n public class h {\r\n     public static void main(String[] args) {\r\n         double celsius, fahrenheit;\r\n         celsius = 37.5;\r\n\r\n         fahrenheit = celsius * 9.0 / 5.0 + 32.0;\r\n         System.out.println(celsius + &quot; degree C is &quot; + fahrenheit + &quot; degree F.&quot;);\r\n\r\n         fahrenheit = 100.0;\r\n         celsius =  (fahrenheit - 32.0) * 5.0 / 9.0;\r\n         System.out.println(fahrenheit + &quot; degree F is &quot; + celsius + &quot; degree C.&quot;);\r\n         }\r\n     }\r\n37.5 degree C is 99.5 degree F.\r\n100.0 degree F is 37.77777777777778 degree C.\r\n</code></pre><h3 id=\"h3-12-int-double-\"><a name=\"12. 混合使用int、double和类型转换\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>12. 混合使用int、double和类型转换</h3><p>虽然你可以使用double存储整数（例如：double count=5.0），但是强烈建议你使用int来存储，因为int比double更高效（运行时间、存储等）。</p>\r\n<p>你的程序有时会同时使用int和double，例如用int来存储1～1000累加之和，用double来存储平均值，混合使用类型的场景你要格外的小心。</p>\r\n<p>值得注意的是：</p>\r\n<ul>\r\n<li>对于算数运算(‘+’,’-‘,’*’,’/‘)，两个int会产生一个int；同样的两个double会产生一个double，例如1/2 → 0，1.0/2.0 → 0.5。</li><li>一个int和一个double会产生一个double，例如1.0/2 → 0.5，1/2.0 → 0.5。</li></ul>\r\n<p>你可以将int赋值给double变量，int类型会自动转换为double类型：3 → 3.0，举例：</p>\r\n<pre><code>int i = 3;\r\ndouble d;\r\nd = i;              // 3 → 3.0, d = 3.0\r\nd = 88;             // 88 → 88.0, d = 88.0\r\ndouble nought = 0;  // 0 → 0.0; int 0和double 0.0有些细微的差别\r\n</code></pre><p>但是不能直接将double赋值给int变量，因为小数部分可能会丢失，编译器也会发出错误的警告，举例：</p>\r\n<pre><code>double d = 5.5;\r\nint i;\r\ni = d;     // 错误: 丢失精度\r\ni = 6.6;   // 错误: 丢失精度\r\n</code></pre><h4 id=\"h4-u7C7Bu578Bu8F6Cu6362u64CDu4F5Cu7B26\"><a name=\"类型转换操作符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>类型转换操作符</h4><p>将一个double赋值给int变量，你需要显示的调用类型转换操作符来截断小数，如下：</p>\r\n<pre><code>(new-type)expression;\r\n</code></pre><p>举例：</p>\r\n<pre><code>double d = 5.5;\r\nint i;\r\ni = (int) d;        // 强制的将double转换为int，d变量值不受影响\r\ni = (int) 3.1416;   // i = 3\r\n</code></pre><p>值得注意的是强制类型转换是以(int)或(double)的形式，适用于一个操作数的运算符（一元运算符）。</p>\r\n<p>类型转换是一个操作，就像自增、自减，强制转换一个特定类型的数值。(int)3.1416返回3，(double）5返回5.0。</p>\r\n<h4 id=\"h4-u4F8Bu5B50\"><a name=\"例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>例子</h4><p>运行下面的代码并解释输出的原因</p>\r\n<pre><code>\r\n/*\r\n *  计算从最小值到最大值的累加之和, 同时计算平均值\r\n */\r\n public class TypeCastingTest {\r\n     public static void main(String[] args) {\r\n         int lowerbound = 1, upperbound = 1000;\r\n         int sum = 0;      // sum为&quot;int&quot;\r\n         double average;   // average为&quot;double&quot;\r\n         // 计算和(使用&quot;int&quot;)\r\n         int number = lowerbound;\r\n\r\n         while (number &lt;= upperbound) {\r\n             sum = sum + number;\r\n             ++number;\r\n             }\r\n\r\n         System.out.println(&quot;The sum from &quot; + lowerbound + &quot; to &quot; + upperbound + &quot; is &quot; + sum);\r\n\r\n         // 计算平均值(使用&quot;double&quot;)\r\n         average = sum / (upperbound - lowerbound + 1);\r\n         System.out.println(&quot;平均值1为&quot; + average);\r\n\r\n         average = (double)sum / (upperbound - lowerbound + 1);\r\n         System.out.println(&quot;平均值2为&quot; + average);\r\n\r\n         average = sum / 1000;\r\n         System.out.println(&quot;平均值3为&quot; + average);\r\n\r\n         average = sum / 1000.0;\r\n         System.out.println(&quot;平均值4为&quot; + average);\r\n\r\n         average = (double)(sum / 1000);\r\n         System.out.println(&quot;平均值5为&quot; + average);\r\n     }\r\n }\r\n从1到1000累加和为500500\r\n平均值1为500.0\r\n平均值2为500.5\r\n平均值3为500.0\r\n平均值4为500.5\r\n平均值5为500.0\r\n</code></pre><p>平均值1不正确，因为int/int生成int(500)，最后被转换成double(500.0)。</p>\r\n<p>对于平均值2，sum首先被转换成double，随后，double/int产生一个double。</p>\r\n<p>对于平局值5，int/int产生int(500)，之后被强制转换成double。</p>\r\n<h3 id=\"h3-u7EC3u4E60\"><a name=\"练习\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>练习</h3><ol>\r\n<li>创建一个类HarmonicSeriesSum来计算谐波系列1 + 1/2 + 1/3 + 1/4 + …. + 1/n的总和，其中n＝1000，sum为double类型，特别注意1/2输出0，1.0/2输出0.5。试着改变的n的值1000，5000，10000，50000，100000重新计算。</li><li>修改上面类为GeometricSeriesSum来计算几何级数1 + 1/2 + 1/4 + 1/8 + ….的总和，其中n=1000。</li></ol>\r\n<h3 id=\"h3-13-\"><a name=\"13. 总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>13. 总结</h3><p>本文介绍的编程基础知识非常Java适合初学者。</p>\r\n<p>要学习编程，你需要了解编程语言的语法和功能。</p>\r\n<p>你要不断的练习、练习和实践来处理你遇到的各种问题。</p>\r\n', '60', '![](http://ww3.sinaimg.cn/mw690/006pQ25sgw1f26n66379ij30f0092wh2.jpg)\r\n\r\n### 1\\. 马上开始 － 编写你的第1个Java程序\r\n\r\n检查在开发环境中是否安装了 Java Development Kit (JDK)。\r\n\r\n让我们来编写第1个Java程序，在控制台上输出“Hello，world！”，\r\n\r\n```\r\nHello，World！?\r\n```\r\n\r\n#### 步骤1：编写代码\r\n\r\n选择一个文本编辑器，Windows：TextPad、NotePad++；Mac OS X：jEdit、gedit；Ubuntu：gedit。\r\n\r\n在编辑器内输入以下代码，输入完毕后保存为“Hello.Java\"文件，扩展名“.java\"，文件名需要与类名一致区分大小写。\r\n\r\n```\r\npublic class Hello \r\n{  \r\npublic static void main(String[] args)\r\n{        \r\nSystem.out.println(\"Hello，World！\");    \r\n}\r\n}\r\n```\r\n\r\n#### 步骤2：编译源码\r\n\r\n运行命令“javac”编译源文件\"Hello.java\"，编译成功后会生成二进制文件“hello.class”。在终端中运行下面命令：\r\n\r\n// 进入Hello.java所在目录\r\n`javac Hello.java`\r\n\r\n?在IDEs（例如Eclispe、NetBeans）中不需要显示编译文件，因为他们支持即时编译。\r\n\r\n#### 步骤3：运行程序\r\n\r\n运行\"java\"命令，\r\n\r\n`java Hello`\r\n\r\n```\r\nHello，World！\r\n```\r\n\r\n需要注意的是“java Hello”并没有包含“.class\"扩展名。\r\n\r\n在IDEs中，源文件右键 ＝》运行... ＝》Java Application会起到同样的作用。\r\n\r\n#### 编程的简要说明?\r\n\r\n`/* ...... */`\r\n\r\n`// ... 一直到行末尾`\r\n\r\n这都是注释的方式，注释会被编译器忽略不会被执行，但是注释方便读者更好的阅读和理解程序，有两种注释的方式：\r\n\r\n1.  多行注释：以/\\*开头，以\\*/结尾，可以跨越多行。\r\n2.  单行注释：以//开头，直到行尾。\r\n\r\n`public class Hello { ...... }`\r\n\r\n这个单元就是类的声明方式，类用关键字“class”进行定义，{ ..... }里面是类的主题内容，关键字\"public”稍后会说明。\r\n\r\n在Java中，源文件名需要和类名保持一致，同时以“.java\"为文件扩展名。\r\n\r\n`public static void main（String[] args) { ...... }`\r\n\r\n这个单元是main()方法的定义，{ ...... }方法的主体中包含了编程语句。\r\n\r\n`System.out.println(\"Hello, world！\");`\r\n\r\n<span style=\"font-family: monospace;\">字符串是由双引号和引号之间的文本组成，上面语句运行后，会在控制台输出Hello, world！，不包括两端的引号。</span>\r\n\r\n### 2\\. Java术语和语法\r\n\r\n**语句:**表示着一段程序的执行以；为结尾。\r\n\r\n**块:**一个块是由一组大括号和里面的语句组成，通常被视为一个单独的单元。我们的程序有两个块组成，一个块包含着Hello类的主体，另一个块包含着main()方法的主体，不需要在结束括号添加分号。\r\n\r\n**注释：**多行注释以/\\*卡头，以\\*/结尾，单行注释以//开头直到行尾，注释会被变编译器忽略不会被执行，但是注释提供了解释、使用的文档说明，所以请自由的使用注释。\r\n\r\n**空白：**空格，制表符和换行符统称为空白。一个空格标记分割，其余的空白会被忽略，但是他们会帮助你和你的读者更好的理解你的程序，所以请自由的使用空格。\r\n\r\n**区分大小写：**Java是大小写敏感的，ROSE、Rose、rose是不同的变量，还有文件名也是区分大小写的。\r\n\r\n### ?3\\. Java程序模板\r\n\r\n编程中你可以使用下面的模板，在你的程序中选择一个有意义的\"Classname\"，在main方法体中写入编程语句，不用担心其他的项和关键字，我会在适当的时候加以解释。\r\n\r\n```\r\npublic class Classname {    // 选择一个有意义的类名\r\n    public static void main(String[] args){\r\n    // 这里是你的编程语句\r\n    }\r\n}\r\n```\r\n\r\n### 4\\. 使用System.out.println()和System.out.print()输出\r\n\r\n你可以使用?System.out.println()和System.out.print()将文本输出到控制台上：\r\n\r\n*   System.out.println(aString) 输出字符串，折行，光标位于折行开头的位置。\r\n*   System.out.print(aString)输出字符串，光标位于输出文本的后面。\r\n\r\n运行下面的代码，并解释生成的输出：\r\n\r\n```\r\npublic class PrintTest \r\n{    \r\npublic static void main(String[] args) \r\n{       \r\nSystem.out.println(\"Hello, world!\");         \r\nSystem.out.println();                        \r\nSystem.out.print(\"Hello, world!\");          \r\nSystem.out.println(\"Hello,\");        \r\nSystem.out.print(\" \");                    \r\nSystem.out.print(\"world!\");       \r\nSystem.out.println(\"Hello, world!\");    \r\n}\r\n}\r\nHello, world!\r\n\r\nHello, world!Hello,\r\n world!Hello, world!\r\n```\r\n\r\n\r\n### 5\\. 编写一个加法的程序\r\n\r\n```\r\npublic classFiveNumberSum {\r\n    public static void main(String[] args) {\r\n        int number1 = 11;  // 声明5个int变量来存储5个数值\r\n        int number2 = 22;\r\n        int number3 = 33;\r\n        int number4 = 44;\r\n        int number5 = 55;\r\n        int sum;           // 声明1个sum变量来存储相加之和\r\n        sum = number1 + number2 + number3 + number4 + number5;\r\n\r\n        System.out.print(\"The sum is \");\r\n        System.out.println(sum);          // 输出相加之和\r\n    }\r\n}\r\nThe sum is 165\r\n\r\n```\r\n\r\n`\r\nint number1 = 11;\r\nint number2 = 22;\r\nint number3 = 33;\r\nint number4 = 44;\r\nint number5 = 55;\r\n`\r\n\r\n声明了5个int型变量number1、number2、number3、number4和number5，将11、22、33、44和55利用操作符\"=\"赋给变量，你可以在一条语句中声明多个变量，用逗号分割，例如：\r\n\r\nint number1 = 11, number2 = 22, number3 = 33, number4 = 44, number5 = 55;\r\n\r\n`int sum;`\r\n\r\n声明一个没有初始化的int型变量。\r\n\r\n`sum = number1 + number2 + number3 + number4 + number5;`\r\n\r\nsum存储number1到number5相加之和，操作符\"+\"表示加法，和数学上的一样。\r\n\r\n`\r\nSystem.out.print(\"The sum is \");\r\nSystem.out.println(sum);\r\n`\r\n打印输出变量sum值，sum不加双引号，否则会直接输出\"sum\"。\r\n\r\n### 练习\r\n\r\n1.  用操作符\"*\"修改上面的程序，并计算相乘的结果.\r\n\r\n### 6\\. 程序是什么?\r\n\r\n程序是顺序执行的指令序列，参考下面的流程图。\r\n\r\n![](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Construct_Sequential.png)\r\n\r\n### 例子\r\n\r\n根据圆的半径计算周长和面积并输出。\r\n\r\n```\r\npublic class CircleComputation {\r\n   public static void main(String[] args) {\r\n      // 声明变量\r\n      double radius, area, circumference;\r\n      final double PI = 3.14159265;\r\n\r\n      // 初始化圆半径\r\n      radius = 1.2;\r\n\r\n      // 计算面和周长\r\n      area = radius * radius * PI;\r\n      circumference = 2.0 * radius * PI;\r\n\r\n      // 打印输出结果\r\n      System.out.print(\"The radius is \");\r\n      System.out.println(radius);\r\n      System.out.print(\"The area is \");\r\n      System.out.println(area);\r\n      System.out.print(\"The circumference is \");\r\n      System.out.println(circumference);\r\n   }\r\n}\r\nThe radius is 1.2The area is 4.523893416The circumference is 7.5398223600000005\r\n```\r\n\r\n`double radius, area, circumference;`\r\n声明了3个double变量radius、area和circumference，double变量存储实数。\r\n\r\n`final double PI = 3.14159265;`\r\n声明一个double型变量PI并设置了初值，PI被声明为final，意味着它的值不能被改变。\r\n\r\n`radius = 1.2;`\r\n将1.2赋值给radius。\r\n\r\n`area = radius * radius * PI;`\r\n`circumference = 2.0 * radius * PI;`\r\n根据圆的半径计算面积和周长。\r\n\r\n`System.out.print(\"The radius is \");`\r\n`System.out.println(radius);`\r\n`System.out.print(\"The area is \");`\r\n`System.out.println(area);`\r\n`System.out.print(\"The circumference is \");`\r\n`System.out.println(circumference);`\r\n打印计算结果。值得注意的是main（）方法体中顺序执行的语句。\r\n\r\n### 练习\r\n\r\n1.  参考上面的例子，编写程序：根据长度和宽度打印输出矩形的周长和面积。\r\n\r\n\r\n### 7\\. 什么是变量\r\n\r\n计算机操纵数据，变量存储数据，之所以叫变量因为它的值可以被改变。\r\n\r\n变量就是一块内存的地址，存储特定类型的值，换句话说，一个变量有一个名称，数据类型和存储该类型的值。\r\n\r\n*   变量有名称，例如半径，面积，年龄，高度，变量的名称是唯一的，我们可以获取（radius\\*radius\\*3.1416）和设置（radius＝1.2）变量存储的值。\r\n    *   int：整数例如123和－456。\r\n    *   double：浮点数或者实数，例如：3.1416、－55.66、7.8e9和－1.2e3.4， 有一个可选的小数点和小数部分，也可以用科学计数法表示。\r\n    *   String：文本例如\"Hello\"，\"Good Moring!\"。文本字符串包含在双引号里面。\r\n*   变量存储特定类型的值。值得注意的是，大多数编程语言中变量都关联着类型以及该类型的值。int变量可以存储整数例如123，但不能存储实数例如12.34，也不能存储文本例如\"你好\"。早期的编程语言引入类型的概念来简化数据的理解。\r\n\r\n下图说明了3种数据类型：int，double和String，int变量存储整数，double存储实数，字符串存储文本内容。\r\n\r\n![](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/JavaBasics_Variable.png)\r\n\r\n变量使用前需要被声明，你可以使用下面的声明方式：\r\n\r\n```\r\nvarType varName;                                                  // 声明变量的类型\r\nvarType varName1, varName2,...;                                   // 声明多个同一类型的变量\r\nvarType varName = initialValue;                                   // 声明变量的类型并赋值\r\nvarType varName1 = initialValue1, varName2 = initialValue2,... ;  // 声明多个变量并分别赋值\r\n```\r\n\r\n请注意：\r\n\r\n*   声明语句以分号（;）为结尾。\r\n*   声明多个变量，变量间以逗号（,）分隔。\r\n*   操作符＝，用来给变量赋值。\r\n\r\n举例：\r\n\r\n```\r\nint sum;               // 声明1个int型变量sum。\r\nint number1, number2;  // 声明2个int型变量number1，number2以分号相隔。\r\ndouble average;        // 声明1个double型变量average。 \r\nint height = 20;       // 声明1个int型变量并初始化。\r\n```\r\n\r\n变量声明后，你可以利用操作符\"=\"给变量赋值或重新赋值，例如：\r\n\r\n```\r\nint number;                  // 声明1个int型变量number。\r\nnumber = 99;                 // 给变量\"number\"分配了一个整数99。\r\nnumber = 88;                 // 给变量\"number\"重新分配了一个整数88。\r\nnumber = number + 1;         // 计算\"number + 1\", 将结果赋值给\"number\"。\r\nint sum = 0;                 // 声明1个\"int\"变量\"sum\"并设置初值0。\r\nsum = sum + number;          // 计算\"sum + number\"，将结果复制给\"sum\"。\r\nint num1 = 5, num2 = 6;      // 一条语句中声明了两个变量并设置初值, 用逗号分隔。\r\ndouble radius = 1.5;         // 声明1个\"double\"变量\"radius\"并设置初值1.5。\r\nint number;                  // 错误: 变量\"number\"已经声明。\r\nsum = 55.66;                 // 错误: \"sum\"是\"int\"型变量不能存储实数。\r\nsum = \"Hello\";               // 错误: \"sum\"是\"int\"型变量不能存储字符串。\r\n```\r\n\r\n?请注意：\r\n\r\n*   每个变量只能声明一次。（没有两套房子对应着一个地址吧。）\r\n*   你可以在程序内的任意位置声明。\r\n*   一旦声明了某个类型的变量，它只能存储该类型的值，例如一个int型变量职能存储整数例如123，不能存储浮点类型例如－2.17或者文本“Hello\"。\r\n*   变量声明后类型不能改变。\r\n\r\n在上面的列子中我已经展示了两种类型：int类型存储整数，double类型存储浮点数，编程时混合使用int和double时，需要特别的小心稍后我会解释。\r\n\r\n**x=x+1**\r\n\r\n对于赋值操作符（＝）在编程和数学中我们要区别对待，数学中\"x=x+1\"等式是不成立的，但在编程中意为着x＋1后的值重新赋值给x。\r\n\r\n**x+y=1**\r\n\r\n数学中是有效，编程中无效。在编程中等式右侧是计算值；等式的左侧是变量，也就是说优先计算等式右侧，之后赋值给等式左侧。有一些编程语言使用 :=为赋值操作符，避免与等号混淆。\r\n\r\n### 8\\. 基本的算数运算\r\n\r\n基本的算数运算符是：\r\n\r\n\r\n| 运算符 | 含义 | 例子 |\r\n| `+` | 加法 | `x + y` |\r\n| `-` | 减法 | `x - y` |\r\n| `*` | 乘法 | `x * y` |\r\n| `/` | 除法 | `x / y` |\r\n| `%` | 取模（求余） | `x % y` |\r\n| `++` | 递增（一元） | `++x`or`x++` |\r\n| `--` | 递减（一元） | `--x`or`x--\r\n` |\r\n\r\n\r\n加法、减法、乘法、除法和取模是两个操作数二元运算，而自增和自减是一个操作数一元运算。\r\n\r\n#### 例子\r\n\r\n下面的程序说明了这些运算：\r\n\r\n```\r\n\r\n/**\r\n * 算数运算符测试\r\n */\r\n public classArithmeticTest {\r\n    public static void main(String[] args) {\r\n        int number1 = 98;                                   // 声明了一个int型变量number1设置初值98\r\n        int number2 = 5;                                    // 声明了一个int型变量number2设置初值5\r\n        int sum, difference, product, quotient, remainder;  // 声明5个变量来存储计算结果\r\n\r\n        // 执行算数运算\r\n        sum = number1 + number2;\r\n        difference = number1 - number2;\r\n        product = number1 * number2;\r\n        quotient = number1 / number2;\r\n        remainder = number1 % number2;\r\n\r\n        // 打印输出结果\r\n        System.out.print(number1);\r\n        System.out.print(\"和\");\r\n        System.out.print(number2);\r\n        System.out.print(\"的相加, 相减, 相乘, 相除和取模的结果分别为\");\r\n        System.out.print(sum);\r\n        System.out.print(\", \");\r\n        System.out.print(difference);\r\n        System.out.print(\", \");\r\n        System.out.print(product);\r\n        System.out.print(\", \");\r\n        System.out.print(quotient);\r\n        System.out.print(\", 和\");\r\n        System.out.println(remainder);\r\n\r\n        ++number1;  // number1自增1, 相当于\"number1=number1 + 1\"\r\n        --number2;  // number2自减2, 相当于\"number2=number2 - 1\"\r\n        System.out.println(\"number1递增后的结果为\" + number1);\r\n        System.out.println(\"number2递增后的结果为\" + number2);\r\n\r\n        quotient = number1 / number2;\r\n        System.out.println(number1 + \" 和\" + number2 + \"新的商为\" + quotient);\r\n    }\r\n}\r\n98和5的相加, 相减, 相乘, 相除和取模的结果分别为103, 93, 490, 19, 和3\r\nnumber1递增后的结果为99\r\nnumber2递增后的结果为4\r\n99和4新的商为24\r\n\r\n```\r\n\r\n#### 程序剖析\r\n\r\n<span class=\"line-heading-code-new\">`int number1 = 98;`\r\n`int number2 = 5;`\r\n`int sum, difference, product, quotient, remainder;`\r\n</span>为了程序的需要声明了全都是int型的变量number1、number2、 sum、difference、product、quotient和remainder。\r\n\r\n<span class=\"line-heading-code-new\">`sum = number1 + number2;`\r\n`difference = number1 - number2;`\r\n`product = number1 * number2;`\r\n`quotient = number1 / number2;`\r\n`remainder = number1 % number2;`\r\n</span><span style=\"font-family: Verdana, Arial, Helvetica, sans-serif;\">开始执行</span>number1<span style=\"font-family: Verdana, Arial, Helvetica, sans-serif;\">和</span>number2的运算，注意下整数相除后产生的截断整数，例如98/5 → 19,?99/4 → 24<span style=\"font-family: Verdana, Arial, Helvetica, sans-serif;\">和</span>1/2 → 0。\r\n\r\n`System.out.print(number1); // 输出变量值`\r\n\r\n`System.out.print(\"和\");`\r\n`System.out.print(number2);`\r\n`System.out.print(\"的相加, 相减, 相乘, 相除和取模的结果分别为\");`\r\n`......`\r\n打印运算结果并适当的加以描述，输出普通文本需要加双引号，变量不需要。\r\n\r\n```\r\nSystem.out.println(\"sum\");   // 输出\"sum\"\r\nSystem.out.println(sum);     // 输出变量sum存储的值例如98\r\n```\r\n\r\n`++number1;`\r\n`--number2;`\r\n\r\n举例说明了自增和自减操作， \"++\"和\"--\"只有一个操作数（一元运符）而不像\"+\"、\"-\"、\"*\"、\"/\"和\"%\"有两个操作数（二元运算符），++放在操作数之前称作预增，放在操作数之后称作后增，预增和后增的最终结果都是使操作数自增1，但是两者有所区别，我会在后面说明。\r\n\r\n`System.out.println(\"number1递增后的结果为\" + number1);`\r\n`System.out.println(\"number2递增后的结果为\" + number2);`\r\n\r\n打印自增/自减后的结果。这里我们将文本字符串和变量通过\"+\"操作符联合输出，在这种情况下\"+\"不执行加法操作，而是字符串连接符。\r\n\r\n#### 练习\r\n\r\n1.  使用\"+\"操作符使用一条println()语句打印所有的输出结果。\r\n2.  增加一个新int型变量number3，设置初始值为77，计算和打印三个数之和。\r\n3.  编程中我们使用＊来表示乘法，试着计算并打印输出结果：1的31倍加上2的17倍加上3的87倍的和。\r\n\r\n### 9\\. 累加1000个数 使用循环\r\n\r\n假设你想计算从1～1000累加和，按照上面的例子你要在程序中写1000行代码！不过有个更简单的方式就是使用循环，要知道计算机最擅长的就是重复性的计算。\r\n\r\n#### 例子\r\n\r\n来试试下面的程序：使用循环来计算从1累加到1000的和\r\n\r\n```\r\n\r\n/*\r\n * 使用循环计算从最小值到最大值的累加和\r\n */\r\n public class RunningNumberSum {\r\n     public static void main(String[] args) {\r\n         int lowerbound = 1;               // 存储最小值\r\n         int upperbound = 1000;            // 存储最大值\r\n         int sum = 0;                      // 声明sum变量来存储中间的累加和\r\n         int number = lowerbound;\r\n\r\n         while (number <= upperbound) {\r\n             sum = sum + number;           // 将number累加到sum中\r\n             ++number;                     // 开始累加下个数\r\n             }\r\n\r\n         // 打印输出结果\r\n         System.out.println(\"从\" + lowerbound + \"到\" + upperbound + \"的累加之和为\" + sum);\r\n     }\r\n }\r\n从1到1000的累加之和为500500\r\n\r\n```\r\n\r\n#### 程序剖析\r\n\r\n`int lowerbound = 1;`\r\n`int upperbound = 1000;`\r\n定义两个变量分别存储最小值和最大值。\r\n\r\n`int sum = 0;`\r\n定义一个变量来存储累加之和。\r\n\r\n`int number = lowerbound;`\r\n`while (number <= upperbound) {`\r\n`???sum = sum + number;`\r\n`???++number;`\r\n`}`\r\n\r\n?这个我们称之为循环，一个while循环的语法如下：\r\n\r\n```\r\ninitialization-statement;\r\nwhile (test) {\r\n   loop-body;\r\n}\r\nnext-statement;\r\n```\r\n\r\n![](http://www3.ntu.edu.sg/home/ehchua/programming/cpp/images/Construct_WhileLoop.png)?\r\n\r\n从上面的流程图我们可以看出，首先执行初始化语句，校验test，如果为真执行方法体，每执行一次方法体后都会重新校验test，为真继续执行，直到test为假的时候退出循环。\r\n\r\n程序循环的总次数：upperbound-lowerbound+1，循环结束后打印输出结果。\r\n\r\n```\r\nSystem.out.println(\"从\" + lowerbound + \"到\" + upperbound + \"的累加之和为\" + sum);\r\n```\r\n\r\n#### 练习\r\n\r\n1.  修改上面的程序计算从9到888累加和。\r\n2.  修改上面的程序计算从1到1000的奇数累加和。\r\n3.  修改上面的程序计算从1到1000每个数都被7除的累加和。\r\n4.  修改上面的程序计算从1到100每个数平方的累加和。\r\n5.  修改上面的程序计算从1到10的乘积。\r\n\r\n### 10\\. 条件（判断）\r\n\r\n如果你想计算从1到1000的奇数之和，有很多种方法，你可以声明两个变量：sumOdd和sumEven，使用条件语句判断奇数和偶数，之后累加到相应的变量，程序如下：\r\n\r\n```\r\n\r\n/*\r\n * 分别计算从最小值到最大值的奇数和偶数和\r\n */\r\n public class OddEvenSum {\r\n     public static void main(String[] args) {\r\n         int lowerbound = 1, upperbound = 1000;   // 最小值, 最大值\r\n         int sumOdd  = 0;                         // 奇数累加和, 初始化为0\r\n         int sumEven = 0;                         // 偶数累加和, 初始化为0\r\n         int number = lowerbound;\r\n\r\n         while (number <= upperbound) {\r\n             if (number % 2 == 0) {               // 偶数\r\n                 sumEven += number;               // 等价于sumEven = sumEven + number\r\n             } else {                             // 奇数\r\n                 sumOdd += number;                // 等价于sumOdd = sumOdd + number\r\n             }\r\n             ++number;                            // 下个数值\r\n\r\n             // 打印输出结果\r\n             System.out.println(\"奇数和从\" + lowerbound + \"到\" + upperbound + \"为\" + sumOdd);\r\n             System.out.println(\"偶数和从\" + lowerbound + \"到\" + upperbound + \"为\" + sumEven);\r\n             System.out.println(\"两者之差为\" + (sumOdd - sumEven));\r\n         }\r\n     }\r\n}\r\n奇数和从1到1000为250000\r\n偶数和从1到1000为250500\r\n两者之差为-500\r\n\r\n```\r\n\r\n#### 程序剖析\r\n\r\n`int lowerbound = 1, upperbound = 1000;`\r\n声明用于循环的最小值和最大值。\r\n\r\n`int sumOdd = 0;`\r\n`int sumEven = 0;`\r\n声明两个变量分别来存储累加奇数和累加偶数。\r\n\r\n`if (number % 2 == 0) {`\r\n`???sumEven = sumEven + number;`\r\n`} else {`\r\n`???sumOdd = sumOdd + number;`\r\n`}`\r\n\r\n这是一个条件语句。可以使用这一种条件语句：if-then活if-then-else。\r\n\r\n```\r\n// if-then\r\nif ( test ) {\r\n   true-body;\r\n}\r\n// if-then-else\r\nif ( test ) {\r\n   true-body;\r\n} else {\r\n   false-body;\r\n}\r\n```\r\n\r\n![](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Construct_IfElse.png)![](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Construct_IfThen.png)\r\n\r\nif-then条件语句，test为真执行true-body。if-then-else语句，test为真执行true-body，test为假执行false-body。在我们的程序中，我们使用求余操作符（%）取2的余数来校验奇偶。\r\n\r\n#### 比较运算符\r\n\r\n有6比较运算符：\r\n\r\n<div class=\"table-responsive\">\r\n\r\n| 操作符 | 含义 | 举例 |\r\n| `==` | 等于 | `x == y` |\r\n| `!=` | 不等于 | `x != y` |\r\n| `>` | 大于 | `x > y` |\r\n| `>=` | 大于等于 | `x >= y` |\r\n| `<` | 小于 | `x < y` |\r\n| `<=` | 小于等于 | `x <= y` |\r\n\r\n</div>\r\n\r\n值得注意的是双等号（==）是用来比较相等；一个等号（=）是赋值操作。\r\n\r\n#### 并列条件\r\n\r\n验某个数值是否在1～100之间：1<=x<=100，这里面有条件(x>=1) 与 (x<=100)，编程中你需要用( x >= 1 ) && ( x <= 100 ) 来表示， \"&&\"操作符表示\"与\"操作，同样校验某个数值是否可以被2或3整除，你可以使用 ( x % 2 ==0 ) || ( x % 3 == 0 ) ，\"||\"操作符表示\"或\"操作。\r\n\r\n有三个逻辑运算符\r\n\r\n<div class=\"table-responsive\">\r\n\r\n| 操作符 | 含义 | 举例 |\r\n| `&&` | 逻辑与 | `(x >= 1) && (x <= 100)` |\r\n| `||` | 逻辑或 | `(x < 1) || (x > 100)` |\r\n| `!` | 逻辑非 | `!(x == 8)` |\r\n\r\n</div>\r\n\r\n举例：\r\n\r\n```\r\n(x >= 0) && (x <= 100)     // 验证x是否大于等于0小于等于100，错误的用法：0 <= x <= 100\r\n(x < 0) || (x > 100)       // 验证x是否小于0或者大于100\r\n!((x >= 0) && (x <= 100))  // 条件非\r\n// 验证闰年：闰年要被4整除但不能被100整除，或者直接被400整除\r\n((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)\r\n```\r\n\r\n#### 练习\r\n\r\n1.  编程校验1～1000之间被13或者15或者17整除，但是不能被30整除的数都有哪些。\r\n2.  编程计算从公元1年到公元2010年所有的闰年。\r\n\r\n### 11\\. 浮点类型\r\n\r\n回想一下，在Java中变量有名称、类型和存储该类型的值。我们之前已经使用过int类型，int型变量只能存储整型，例如123和-456；它不能存储一个实数，例如12.34。编程中，真正的实数例如3.1416和-55.66称之为浮点数，它们属于类型double，你可以使用浮点数（例如1.23，－4.5）或者科学计数法（例如1.2e3，－4E5.6）其中e或E表示10的指数。\r\n\r\n#### 例子\r\n\r\n```\r\n\r\n/*\r\n * 摄氏温度和华氏温度之间的转换\r\n */\r\n public class h {\r\n     public static void main(String[] args) {\r\n         double celsius, fahrenheit;\r\n         celsius = 37.5;\r\n\r\n         fahrenheit = celsius * 9.0 / 5.0 + 32.0;\r\n         System.out.println(celsius + \" degree C is \" + fahrenheit + \" degree F.\");\r\n\r\n         fahrenheit = 100.0;\r\n         celsius =  (fahrenheit - 32.0) * 5.0 / 9.0;\r\n         System.out.println(fahrenheit + \" degree F is \" + celsius + \" degree C.\");\r\n         }\r\n     }\r\n37.5 degree C is 99.5 degree F.\r\n100.0 degree F is 37.77777777777778 degree C.\r\n\r\n```\r\n\r\n### 12\\. 混合使用int、double和类型转换\r\n\r\n虽然你可以使用double存储整数（例如：double count=5.0），但是强烈建议你使用int来存储，因为int比double更高效（运行时间、存储等）。\r\n\r\n你的程序有时会同时使用int和double，例如用int来存储1～1000累加之和，用double来存储平均值，混合使用类型的场景你要格外的小心。\r\n\r\n值得注意的是：\r\n\r\n*   对于算数运算(\'+\',\'-\',\'*\',\'/\')，两个int会产生一个int；同样的两个double会产生一个double，例如1/2 → 0，1.0/2.0 → 0.5。\r\n*   一个int和一个double会产生一个double，例如1.0/2 → 0.5，1/2.0 → 0.5。\r\n\r\n你可以将int赋值给double变量，int类型会自动转换为double类型：3 → 3.0，举例：\r\n\r\n```\r\nint i = 3;\r\ndouble d;\r\nd = i;              // 3 → 3.0, d = 3.0\r\nd = 88;             // 88 → 88.0, d = 88.0\r\ndouble nought = 0;  // 0 → 0.0; int 0和double 0.0有些细微的差别\r\n\r\n```\r\n\r\n但是不能直接将double赋值给int变量，因为小数部分可能会丢失，编译器也会发出错误的警告，举例：\r\n\r\n```\r\ndouble d = 5.5;\r\nint i;\r\ni = d;     // 错误: 丢失精度\r\ni = 6.6;   // 错误: 丢失精度\r\n```\r\n\r\n#### 类型转换操作符\r\n\r\n将一个double赋值给int变量，你需要显示的调用类型转换操作符来截断小数，如下：\r\n\r\n```\r\n(new-type)expression;\r\n```\r\n\r\n举例：\r\n\r\n```\r\ndouble d = 5.5;\r\nint i;\r\ni = (int) d;        // 强制的将double转换为int，d变量值不受影响\r\ni = (int) 3.1416;   // i = 3\r\n\r\n```\r\n\r\n值得注意的是强制类型转换是以(int)或(double)的形式，适用于一个操作数的运算符（一元运算符）。\r\n\r\n类型转换是一个操作，就像自增、自减，强制转换一个特定类型的数值。(int)3.1416返回3，(double）5返回5.0。\r\n\r\n#### 例子\r\n\r\n运行下面的代码并解释输出的原因\r\n\r\n```\r\n\r\n/*\r\n *  计算从最小值到最大值的累加之和, 同时计算平均值\r\n */\r\n public class TypeCastingTest {\r\n     public static void main(String[] args) {\r\n         int lowerbound = 1, upperbound = 1000;\r\n         int sum = 0;      // sum为\"int\"\r\n         double average;   // average为\"double\"\r\n         // 计算和(使用\"int\")\r\n         int number = lowerbound;\r\n\r\n         while (number <= upperbound) {\r\n             sum = sum + number;\r\n             ++number;\r\n             }\r\n\r\n         System.out.println(\"The sum from \" + lowerbound + \" to \" + upperbound + \" is \" + sum);\r\n\r\n         // 计算平均值(使用\"double\")\r\n         average = sum / (upperbound - lowerbound + 1);\r\n         System.out.println(\"平均值1为\" + average);\r\n\r\n         average = (double)sum / (upperbound - lowerbound + 1);\r\n         System.out.println(\"平均值2为\" + average);\r\n\r\n         average = sum / 1000;\r\n         System.out.println(\"平均值3为\" + average);\r\n\r\n         average = sum / 1000.0;\r\n         System.out.println(\"平均值4为\" + average);\r\n\r\n         average = (double)(sum / 1000);\r\n         System.out.println(\"平均值5为\" + average);\r\n     }\r\n }\r\n从1到1000累加和为500500\r\n平均值1为500.0\r\n平均值2为500.5\r\n平均值3为500.0\r\n平均值4为500.5\r\n平均值5为500.0\r\n\r\n```\r\n\r\n平均值1不正确，因为int/int生成int(500)，最后被转换成double(500.0)。\r\n\r\n对于平均值2，sum首先被转换成double，随后，double/int产生一个double。\r\n\r\n对于平局值5，int/int产生int(500)，之后被强制转换成double。\r\n\r\n### 练习\r\n\r\n1.  创建一个类HarmonicSeriesSum来计算谐波系列1 + 1/2 + 1/3 + 1/4 + .... + 1/n的总和，其中n＝1000，sum为double类型，特别注意1/2输出0，1.0/2输出0.5。试着改变的n的值1000，5000，10000，50000，100000重新计算。\r\n2.  修改上面类为GeometricSeriesSum来计算几何级数1 + 1/2 + 1/4 + 1/8 + ....的总和，其中n=1000。\r\n\r\n### 13\\. 总结\r\n\r\n本文介绍的编程基础知识非常Java适合初学者。\r\n\r\n要学习编程，你需要了解编程语言的语法和功能。\r\n\r\n你要不断的练习、练习和实践来处理你遇到的各种问题。');
INSERT INTO `article_info_true` VALUES ('98', 'mybatis简介', '<p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p>\r\n<p><img src=\"http://images2015.cnblogs.com/blog/664931/201602/664931-20160225091618443-1699061978.png\" alt=\"\"></p>\r\n<p>一、理解什么是MyBatis？<br>MyBatis 是支持普通 SQL 查询，存储过程和高级映射的优秀持久层框架。 MyBatis 消除了几乎所有的 JDBC 代码和参数的手工设置以及对结果集的检索。 MyBatis 可以使用简单的XML 或注解用于配置和原始映射，将接口和 Java 的 POJO（ Plain Old Java Objects，普通的Java 对象）映射成数据库中的记录.</p>\r\n<p>  1）MyBATIS 目前提供了三种语言实现的版本，包括：Java、.NET以及Ruby。<br>  2）它提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。<br>  3）mybatis与hibernate的对比？</p>\r\n<p>   mybatis提供一种“半自动化”的ORM实现。<br>   这里的“半自动化”，是相对Hibernate等提供了全面的数据库封装机制的“全自动化”ORM实现而言，“全自动”ORM实现了POJO和数据库表之间的映射，以及 SQL 的自动生成和执行。</p>\r\n<pre><code>而mybatis的着力点，则在于POJO与SQL之间的映射关系。\r\n</code></pre>', '80', 'MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。\r\n\r\n![](http://images2015.cnblogs.com/blog/664931/201602/664931-20160225091618443-1699061978.png)\r\n\r\n \r\n\r\n一、理解什么是MyBatis？\r\nMyBatis 是支持普通 SQL 查询，存储过程和高级映射的优秀持久层框架。 MyBatis 消除了几乎所有的 JDBC 代码和参数的手工设置以及对结果集的检索。 MyBatis 可以使用简单的XML 或注解用于配置和原始映射，将接口和 Java 的 POJO（ Plain Old Java Objects，普通的Java 对象）映射成数据库中的记录.\r\n\r\n  1）MyBATIS 目前提供了三种语言实现的版本，包括：Java、.NET以及Ruby。\r\n  2）它提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。\r\n  3）mybatis与hibernate的对比？\r\n\r\n   mybatis提供一种“半自动化”的ORM实现。\r\n   这里的“半自动化”，是相对Hibernate等提供了全面的数据库封装机制的“全自动化”ORM实现而言，“全自动”ORM实现了POJO和数据库表之间的映射，以及 SQL 的自动生成和执行。\r\n\r\n    而mybatis的着力点，则在于POJO与SQL之间的映射关系。');
INSERT INTO `article_info_true` VALUES ('99', '方法', '<p><img src=\"http://ww4.sinaimg.cn/large/006pQ25sgw1f5dfgmy4olj30ic08fq3p.jpg\" alt=\"\"></p>\r\n<h3 id=\"h3-1-\"><a name=\"1. 什么是方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. 什么是方法</h3><p>有时某些部分代码会被使用多次，为了重复使用，通常这些代码封装在子程序中，之后调用，这种做法易于维护和理解，Java中将子程序叫做方法。</p><br><p>方法的好处：</p><br><ol class=\"margin-height\"><br><li>分而治之：程序从简单的、小片段或组件进行构造，使程序变为模块化的独立任务。</li><br><li>避免重复代码：易于复制和拷贝，但是难于维护所有的副本。</li><br><li>软件复用：其它程序可以复用。</li><br></ol><br><h3 id=\"t2\">2. 方法使用</h3><br><p>方法使用涉及到两方面内容：调用者和被调用的方法。</p><br><p>调用过程：</p><br><ol><br><li>调用者调用方法并传递参数。</li><br><li>接收调用者传递的参数。</li><br><li>方法体执行。</li><br><li>返回结果给调用者。</li><br><li>调用者接收返回结果，继续其它的操作。</li><br></ol><br><p>举例：假设我们要多次计算圆面积，为了复用，我们声明了一个方法getArea()。</p><br><p><img class=\"image-center\" src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Method.png\" alt=\"Method.png\"></p><br><pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EgMethodGetArea</span> </span>{<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{<br>        <span class=\"hljs-keyword\">double</span> r = <span class=\"hljs-number\">1.1</span>, area, area2;<br>        <span class=\"hljs-comment\">// 调用getArea方法</span><br>        area = getArea(r);<br>        System.out.println(<span class=\"hljs-string\">“面积:”</span> + area);<br><br>        <span class=\"hljs-comment\">// 再一次调用getArea方法</span><br>        area2 = getArea(<span class=\"hljs-number\">2.2</span>);<br>        System.out.println(<span class=\"hljs-string\">“面积2:”</span> + area2);<br><br>        <span class=\"hljs-comment\">// 第三次调用getArea方法</span><br>        System.out.println(<span class=\"hljs-string\">“面积3:”</span> + getArea(<span class=\"hljs-number\">3.3</span>));<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> radius)</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> radius <em> radius </em> Math.PI;<br>    }<br><br>}<br><br><span class=\"hljs-comment\">// 输出如下</span><br>面积:<span class=\"hljs-number\">3.8013271108436504</span><br>面积<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">15.205308443374602</span><br>面积<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">34.21194399759284</span><br></code></pre><br><p>上面的例子中，我们定义了方法getArea，方法接收double类型参数，经过计算将double结果返回给调用者，main方法中我们调用该方法三次，每一次都传递了不同的参数。</p><br><p>下面是方法定义的语法：</p><br><pre><code class=\"java hljs\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> returnValueType <span class=\"hljs-title\">methodName</span> <span class=\"hljs-params\">( arg<span class=\"hljs-number\">-1</span>-type arg<span class=\"hljs-number\">-1</span>, arg<span class=\"hljs-number\">-2</span>-type arg<span class=\"hljs-number\">-2</span>,… )</span> </span>{<br>   body ;<br>}</code></pre><br><h4>方法命名约定</h4><br><p>方法名使用动词或动词短语，包含一个或多个单词，第一个单词小写其余单词首字母大写，例如getArea()、setRadius()、moveDown()、isPrime()等。</p><br><p>举例:</p><br><pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EgMinMaxMethod</span> </span>{<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{<br>        <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">6</span>, b = <span class=\"hljs-number\">9</span>, max, min;<br><br>        max = max(a, b);<br>        min = min(a, b);<br><br>        System.out.println(max + <span class=\"hljs-string\">“,”</span> + min);<br>        System.out.println(max(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>));<br>        System.out.println(min(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>));<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number1, <span class=\"hljs-keyword\">int</span> number2)</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> (number1 &gt; number2) ? number1 : number2;<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number1, <span class=\"hljs-keyword\">int</span> number2)</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> (number1 &lt; number2) ? number1 : number2;<br>    }<br>}</code></pre><br><h3 id=\"t3\">3. return语句</h3><br><p>方法使用return语句将结果返回给调用者，语法如下：</p><br><pre><code class=\"java hljs\"><span class=\"hljs-keyword\">return</span> aReturnValue;   <span class=\"hljs-comment\">// 返回方法定义的类型</span><br><span class=\"hljs-keyword\">return</span>;                <span class=\"hljs-comment\">// 直接返回，当方法返回类型为void时</span><br></code></pre><br><h3 id=\"t4\">4. void返回类型</h3><br><p class=\"margin-height\">假设某操作不需要返回结果，你可以声明方法的返回类型为void，你可以直接使用”return;”语句，不需要任何的返回值，”return”语句是可选的。</p><br><h3 id=\"t5\">5. 实参和形参</h3><br><p class=\"margin-height\">在上面的例子中，greaArea方法定义的参数(double radius)称作形参，其作用域在方法体内，当方法被调用时，方法只接收用于计算的实际参数，例如area1=getArea(radis1)，radius1是实际参数，真实值为1.1。</p><br><h3 id=\"t6\">6. 基本类型参数的值传递</h3><br><p>方法参数的传递过程中，对于基本类型参数，会传递该参数的副本，方法基于副本进行相关操作，这就是所谓的按值传递。</p><br><p>举例：</p><br><pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PassingParameterTest</span> </span>{<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{<br>        <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">8</span>;<br>        System.out.println(<span class=\"hljs-string\">“方法调用前number: “</span> + number);    <span class=\"hljs-comment\">// 8</span><br><br>        <span class=\"hljs-keyword\">int</span> result = increment(number);<br>        System.out.println(<span class=\"hljs-string\">“方法调用后number: “</span> + number);    <span class=\"hljs-comment\">// 8</span><br><br>        System.out.println(<span class=\"hljs-string\">“返回结果: “</span> + result);            <span class=\"hljs-comment\">// 9</span><br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">increment</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{<br>        System.out.println(<span class=\"hljs-string\">“方法内部操作前number: “</span> + number); <span class=\"hljs-comment\">// 8</span><br><br>        ++number;<br>        System.out.println(<span class=\"hljs-string\">“方法内部操作后number: “</span>);          <span class=\"hljs-comment\">// 9</span><br><br>        <span class=\"hljs-keyword\">return</span> number;<br>    }<br>}</code></pre><br><h3 id=\"t7\">7. 可变参数 (JDK 1.5)</h3><br><p>JDK1.5之前，方法必须声明固定数量的参数，虽然可以将多个参数封装在数组中，但不简洁，还需要一些编程工作。</p><br><p>JDK1.5引入了可变参数，一种新的语法“Type…“，举例：</p><br><pre><code class=\"java hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> PrintWriter <span class=\"hljs-title\">printf</span><span class=\"hljs-params\">(String format, Object… args)</span><br><span class=\"hljs-keyword\">public</span> PrintWriter <span class=\"hljs-title\">printf</span><span class=\"hljs-params\">(Local l, String format, Object… args)</span><br><br><span class=\"hljs-comment\">// 可变参数用于最后一位，3个点(…)表示该参数可以作为一个数组或逗号分割的参数序列，编译器会将其封装在数组中。</span><br><span class=\"hljs-keyword\">public</span> class VarargsTest </span>{<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">(String… strs)</span> </span>{<br>        System.out.print(<span class=\"hljs-string\">“参数为: “</span>);<br><br>        <span class=\"hljs-keyword\">for</span> (String str : strs) {<br>            System.out.print(str + <span class=\"hljs-string\">“, “</span>);<br>        }        System.out.println();<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">(String s1, String s2)</span> </span>{<br>        System.out.println(<span class=\"hljs-string\">“重载的方法参数为: “</span> + s1 + <span class=\"hljs-string\">“, “</span> + s2);<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String… args)</span> </span>{<br>        doSomething(<span class=\"hljs-string\">“Hello”</span>, <span class=\"hljs-string\">“world”</span>, <span class=\"hljs-string\">“again”</span>, <span class=\"hljs-string\">“and”</span>, <span class=\"hljs-string\">“again”</span>);<br>        doSomething(<span class=\"hljs-string\">“Hello”</span>, <span class=\"hljs-string\">“world”</span>);<br><br>        String[] strs = {<span class=\"hljs-string\">“apple”</span>, <span class=\"hljs-string\">“orange”</span>};<br>        doSomething(strs);<br>    }<br>}</code></pre><br><h3 id=\"t8\">8. 方法重载</h3><br><p>某方法有多版本，对于每个版本的方法参数，要么个数不同、要么类型不同或者顺序不同，这就是所谓的方法重载。</p><br><p>举例：</p><br><pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EgMethodOverloading</span> </span>{<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{<br>        System.out.println(average(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>));     <span class=\"hljs-comment\">// 调用版本1</span><br>        System.out.println(average(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>));  <span class=\"hljs-comment\">// 调用版本2</span><br>        System.out.println(average(<span class=\"hljs-number\">8.1</span>, <span class=\"hljs-number\">6.1</span>)); <span class=\"hljs-comment\">// 调用版本3</span><br>        System.out.println(average(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6.1</span>));   <span class=\"hljs-comment\">// 调用版本3,int8会自动转换成double8.0</span><br>        <span class=\"hljs-comment\">// average(1, 2, 3, 4)                 // 编辑错误: 因为没有这个方法</span><br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n1, <span class=\"hljs-keyword\">int</span> n2)</span> </span>{<br>        System.out.print(<span class=\"hljs-string\">“版本1:”</span>);<br>        <span class=\"hljs-keyword\">return</span> (n1 + n2)/<span class=\"hljs-number\">2</span>;<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n1, <span class=\"hljs-keyword\">int</span> n2, <span class=\"hljs-keyword\">int</span> n3)</span> </span>{<br>        System.out.print(<span class=\"hljs-string\">“版本2:”</span>);<br>        <span class=\"hljs-keyword\">return</span> (n1 + n2 + n3)/<span class=\"hljs-number\">3</span>;<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> n1, <span class=\"hljs-keyword\">double</span> n2)</span> </span>{<br>        System.out.print(<span class=\"hljs-string\">“版本3:”</span>);<br>        <span class=\"hljs-keyword\">return</span> (n1 + n2)/<span class=\"hljs-number\">2.0</span>;<br>    }<br>}<br><br><span class=\"hljs-comment\">// 输出如下:</span><br>版本<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">17</span><br>版本<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">27</span><br>版本<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">37.1</span><br>版本<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">37.05</span><br></code></pre><br><h3 id=\"t9\">9. “boolean”方法</h3><br><p>这里我们说一下返回值为boolean类型的方法。</p><br><p>假设我们有一个校验奇数的方法如下：</p><br><pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BooleanMethodTest</span> </span>{<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>) {<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>        } <span class=\"hljs-keyword\">else</span> {<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>        }<br>    }<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{<br>        System.out.println(isOdd(<span class=\"hljs-number\">5</span>));<br>        System.out.println(isOdd(<span class=\"hljs-number\">6</span>));<br>        System.out.println(isOdd(-<span class=\"hljs-number\">5</span>));<br>    }<br>}<br><br><span class=\"hljs-comment\">// 输出如下：</span><br><span class=\"hljs-keyword\">true</span><br><span class=\"hljs-keyword\">false</span><br><span class=\"hljs-keyword\">false</span><br><br><span class=\"hljs-comment\">// 看似正确的代码却得到了错误的结果，因为-5%2得-1而不是1，你可以改写判断条件：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{<br>   <span class=\"hljs-keyword\">if</span> (number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) {<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>   } <span class=\"hljs-keyword\">else</span> {<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>   }<br>}<br><br><span class=\"hljs-comment\">// 上面得到了正确的结果，但代码不规范，对于boolean方法，你可以简单返回比较的值，而不是用条件语句，如下：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isEven</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{<br>   <span class=\"hljs-keyword\">return</span> (number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>);<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{<br>   <span class=\"hljs-keyword\">return</span> !(number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>);<br>}</code></pre><br><h3 id=\"t10\">10. 算数方法</h3><br><pre><code class=\"java hljs\"><span class=\"hljs-comment\">// JDK提供了通用的算数方法封装在Math工具类里，例如：</span><br><span class=\"hljs-keyword\">double</span> Math.pow(<span class=\"hljs-keyword\">double</span> x, <span class=\"hljs-keyword\">double</span> y) <span class=\"hljs-comment\">// x的y次幂</span><br><span class=\"hljs-keyword\">double</span> Math.sqrt(<span class=\"hljs-keyword\">double</span> x)          <span class=\"hljs-comment\">// x的平方根</span><br><span class=\"hljs-keyword\">double</span> Math.random()                <span class=\"hljs-comment\">// 区间[0.0, 1.0)的随机数</span><br><span class=\"hljs-keyword\">double</span> Math.sin()<br><span class=\"hljs-keyword\">double</span> Math.cos()<br><br><span class=\"hljs-comment\">// Math类提供了2个常量：</span><br>Math.PI                             <span class=\"hljs-comment\">// 3.141592653589793</span><br>Math.E                              <span class=\"hljs-comment\">// 2.718281828459045</span><br><br><span class=\"hljs-comment\">// 你可以通过API文档查看Math类其余的方法</span><br><span class=\"hljs-keyword\">int</span> secretNumber = (<span class=\"hljs-keyword\">int</span>)Math.random()<em><span class=\"hljs-number\">100</span>;<br><span class=\"hljs-keyword\">double</span> radius = <span class=\"hljs-number\">5.5</span>;<br><span class=\"hljs-keyword\">double</span> area = radius</em>radius<em>Math.PI;<br>area = Math.pow(radius, <span class=\"hljs-number\">2</span>)</em>Math.PI;<br><br><span class=\"hljs-keyword\">int</span> x1 = <span class=\"hljs-number\">1</span>, y1 = <span class=\"hljs-number\">1</span>, x2 = <span class=\"hljs-number\">2</span>, y2 = <span class=\"hljs-number\">2</span>;<br><span class=\"hljs-keyword\">double</span> distance = Math.sqrt((x2-x1)<em>(x2-x1) + (y2-y1)</em>(y2-y1));<br><span class=\"hljs-keyword\">int</span> dx = x2 - x1;<br><span class=\"hljs-keyword\">int</span> dy = y2 - y1;<br>distance = Math.sqrt(dx<em>dx + dy</em>dy);<br></code></pre><br><h3 id=\"t11\">11. 方法参数隐式转换</h3><br><p>boule类型的方法参数为可以接收任何数值例如int或者float，这是隐式转换，但是为int类型却接收不了double，因为这样做会引起精度的丢失。</p>\r\n', '121', '![](http://ww4.sinaimg.cn/large/006pQ25sgw1f5dfgmy4olj30ic08fq3p.jpg)\r\n### 1. 什么是方法\r\n<p>有时某些部分代码会被使用多次，为了重复使用，通常这些代码封装在子程序中，之后调用，这种做法易于维护和理解，Java中将子程序叫做方法。</p>\r\n<p>方法的好处：</p>\r\n<ol class=\"margin-height\">\r\n<li>分而治之：程序从简单的、小片段或组件进行构造，使程序变为模块化的独立任务。</li>\r\n<li>避免重复代码：易于复制和拷贝，但是难于维护所有的副本。</li>\r\n<li>软件复用：其它程序可以复用。</li>\r\n</ol>\r\n<h3 id=\"t2\">2. 方法使用</h3>\r\n<p>方法使用涉及到两方面内容：调用者和被调用的方法。</p>\r\n<p>调用过程：</p>\r\n<ol>\r\n<li>调用者调用方法并传递参数。</li>\r\n<li>接收调用者传递的参数。</li>\r\n<li>方法体执行。</li>\r\n<li>返回结果给调用者。</li>\r\n<li>调用者接收返回结果，继续其它的操作。</li>\r\n</ol>\r\n<p>举例：假设我们要多次计算圆面积，为了复用，我们声明了一个方法getArea()。</p>\r\n<p><img class=\"image-center\" src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/Method.png\" alt=\"Method.png\"></p>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EgMethodGetArea</span> </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        <span class=\"hljs-keyword\">double</span> r = <span class=\"hljs-number\">1.1</span>, area, area2;\r\n        <span class=\"hljs-comment\">// 调用getArea方法</span>\r\n        area = getArea(r);\r\n        System.out.println(<span class=\"hljs-string\">\"面积:\"</span> + area);\r\n\r\n        <span class=\"hljs-comment\">// 再一次调用getArea方法</span>\r\n        area2 = getArea(<span class=\"hljs-number\">2.2</span>);\r\n        System.out.println(<span class=\"hljs-string\">\"面积2:\"</span> + area2);\r\n\r\n        <span class=\"hljs-comment\">// 第三次调用getArea方法</span>\r\n        System.out.println(<span class=\"hljs-string\">\"面积3:\"</span> + getArea(<span class=\"hljs-number\">3.3</span>));\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getArea</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> radius)</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> radius * radius * Math.PI;\r\n    }\r\n\r\n}\r\n\r\n<span class=\"hljs-comment\">// 输出如下</span>\r\n面积:<span class=\"hljs-number\">3.8013271108436504</span>\r\n面积<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">15.205308443374602</span>\r\n面积<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">34.21194399759284</span>\r\n</code></pre>\r\n<p>上面的例子中，我们定义了方法getArea，方法接收double类型参数，经过计算将double结果返回给调用者，main方法中我们调用该方法三次，每一次都传递了不同的参数。</p>\r\n<p>下面是方法定义的语法：</p>\r\n<pre><code class=\"java hljs\">\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> returnValueType <span class=\"hljs-title\">methodName</span> <span class=\"hljs-params\">( arg<span class=\"hljs-number\">-1</span>-type arg<span class=\"hljs-number\">-1</span>, arg<span class=\"hljs-number\">-2</span>-type arg<span class=\"hljs-number\">-2</span>,... )</span> </span>{\r\n   body ;\r\n}</code></pre>\r\n<h4>方法命名约定</h4>\r\n<p>方法名使用动词或动词短语，包含一个或多个单词，第一个单词小写其余单词首字母大写，例如getArea()、setRadius()、moveDown()、isPrime()等。</p>\r\n<p>举例:</p>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EgMinMaxMethod</span> </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">6</span>, b = <span class=\"hljs-number\">9</span>, max, min;\r\n\r\n        max = max(a, b);\r\n        min = min(a, b);\r\n\r\n        System.out.println(max + <span class=\"hljs-string\">\",\"</span> + min);\r\n        System.out.println(max(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>));\r\n        System.out.println(min(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>));\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number1, <span class=\"hljs-keyword\">int</span> number2)</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> (number1 &gt; number2) ? number1 : number2;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number1, <span class=\"hljs-keyword\">int</span> number2)</span> </span>{\r\n        <span class=\"hljs-keyword\">return</span> (number1 &lt; number2) ? number1 : number2;\r\n    }\r\n}</code></pre>\r\n<h3 id=\"t3\">3. return语句</h3>\r\n<p>方法使用return语句将结果返回给调用者，语法如下：</p>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\">return</span> aReturnValue;   <span class=\"hljs-comment\">// 返回方法定义的类型</span>\r\n<span class=\"hljs-keyword\">return</span>;                <span class=\"hljs-comment\">// 直接返回，当方法返回类型为void时</span>\r\n</code></pre>\r\n<h3 id=\"t4\">4. void返回类型</h3>\r\n<p class=\"margin-height\">假设某操作不需要返回结果，你可以声明方法的返回类型为void，你可以直接使用\"return;\"语句，不需要任何的返回值，\"return\"语句是可选的。</p>\r\n<h3 id=\"t5\">5. 实参和形参</h3>\r\n<p class=\"margin-height\">在上面的例子中，greaArea方法定义的参数(double radius)称作形参，其作用域在方法体内，当方法被调用时，方法只接收用于计算的实际参数，例如area1=getArea(radis1)，radius1是实际参数，真实值为1.1。</p>\r\n<h3 id=\"t6\">6. 基本类型参数的值传递</h3>\r\n<p>方法参数的传递过程中，对于基本类型参数，会传递该参数的副本，方法基于副本进行相关操作，这就是所谓的按值传递。</p>\r\n<p>举例：</p>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PassingParameterTest</span> </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        <span class=\"hljs-keyword\">int</span> number = <span class=\"hljs-number\">8</span>;\r\n        System.out.println(<span class=\"hljs-string\">\"方法调用前number: \"</span> + number);    <span class=\"hljs-comment\">// 8</span>\r\n\r\n        <span class=\"hljs-keyword\">int</span> result = increment(number);\r\n        System.out.println(<span class=\"hljs-string\">\"方法调用后number: \"</span> + number);    <span class=\"hljs-comment\">// 8</span>\r\n\r\n        System.out.println(<span class=\"hljs-string\">\"返回结果: \"</span> + result);            <span class=\"hljs-comment\">// 9</span>\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">increment</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{\r\n        System.out.println(<span class=\"hljs-string\">\"方法内部操作前number: \"</span> + number); <span class=\"hljs-comment\">// 8</span>\r\n\r\n        ++number;\r\n        System.out.println(<span class=\"hljs-string\">\"方法内部操作后number: \"</span>);          <span class=\"hljs-comment\">// 9</span>\r\n\r\n        <span class=\"hljs-keyword\">return</span> number;\r\n    }\r\n}</code></pre>\r\n<h3 id=\"t7\">7. 可变参数 (JDK 1.5)</h3>\r\n<p>JDK1.5之前，方法必须声明固定数量的参数，虽然可以将多个参数封装在数组中，但不简洁，还需要一些编程工作。</p>\r\n<p>JDK1.5引入了可变参数，一种新的语法“Type...“，举例：</p>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> PrintWriter <span class=\"hljs-title\">printf</span><span class=\"hljs-params\">(String format, Object... args)</span>\r\n<span class=\"hljs-keyword\">public</span> PrintWriter <span class=\"hljs-title\">printf</span><span class=\"hljs-params\">(Local l, String format, Object... args)</span>\r\n\r\n<span class=\"hljs-comment\">// 可变参数用于最后一位，3个点(...)表示该参数可以作为一个数组或逗号分割的参数序列，编译器会将其封装在数组中。</span>\r\n<span class=\"hljs-keyword\">public</span> class VarargsTest </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">(String... strs)</span> </span>{\r\n        System.out.print(<span class=\"hljs-string\">\"参数为: \"</span>);\r\n\r\n        <span class=\"hljs-keyword\">for</span> (String str : strs) {\r\n            System.out.print(str + <span class=\"hljs-string\">\", \"</span>);\r\n        }        System.out.println();\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">(String s1, String s2)</span> </span>{\r\n        System.out.println(<span class=\"hljs-string\">\"重载的方法参数为: \"</span> + s1 + <span class=\"hljs-string\">\", \"</span> + s2);\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String... args)</span> </span>{\r\n        doSomething(<span class=\"hljs-string\">\"Hello\"</span>, <span class=\"hljs-string\">\"world\"</span>, <span class=\"hljs-string\">\"again\"</span>, <span class=\"hljs-string\">\"and\"</span>, <span class=\"hljs-string\">\"again\"</span>);\r\n        doSomething(<span class=\"hljs-string\">\"Hello\"</span>, <span class=\"hljs-string\">\"world\"</span>);\r\n\r\n        String[] strs = {<span class=\"hljs-string\">\"apple\"</span>, <span class=\"hljs-string\">\"orange\"</span>};\r\n        doSomething(strs);\r\n    }\r\n}</code></pre>\r\n<h3 id=\"t8\">8. 方法重载</h3>\r\n<p>某方法有多版本，对于每个版本的方法参数，要么个数不同、要么类型不同或者顺序不同，这就是所谓的方法重载。</p>\r\n<p>举例：</p>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">EgMethodOverloading</span> </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        System.out.println(average(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>));     <span class=\"hljs-comment\">// 调用版本1</span>\r\n        System.out.println(average(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>));  <span class=\"hljs-comment\">// 调用版本2</span>\r\n        System.out.println(average(<span class=\"hljs-number\">8.1</span>, <span class=\"hljs-number\">6.1</span>)); <span class=\"hljs-comment\">// 调用版本3</span>\r\n        System.out.println(average(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6.1</span>));   <span class=\"hljs-comment\">// 调用版本3,int8会自动转换成double8.0</span>\r\n        <span class=\"hljs-comment\">// average(1, 2, 3, 4)                 // 编辑错误: 因为没有这个方法</span>\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n1, <span class=\"hljs-keyword\">int</span> n2)</span> </span>{\r\n        System.out.print(<span class=\"hljs-string\">\"版本1:\"</span>);\r\n        <span class=\"hljs-keyword\">return</span> (n1 + n2)/<span class=\"hljs-number\">2</span>;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n1, <span class=\"hljs-keyword\">int</span> n2, <span class=\"hljs-keyword\">int</span> n3)</span> </span>{\r\n        System.out.print(<span class=\"hljs-string\">\"版本2:\"</span>);\r\n        <span class=\"hljs-keyword\">return</span> (n1 + n2 + n3)/<span class=\"hljs-number\">3</span>;\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> n1, <span class=\"hljs-keyword\">double</span> n2)</span> </span>{\r\n        System.out.print(<span class=\"hljs-string\">\"版本3:\"</span>);\r\n        <span class=\"hljs-keyword\">return</span> (n1 + n2)/<span class=\"hljs-number\">2.0</span>;\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// 输出如下:</span>\r\n版本<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">17</span>\r\n版本<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">27</span>\r\n版本<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">37.1</span>\r\n版本<span class=\"hljs-number\">3</span>:<span class=\"hljs-number\">37.05</span>\r\n</code></pre>\r\n<h3 id=\"t9\">9. \"boolean\"方法</h3>\r\n<p>这里我们说一下返回值为boolean类型的方法。</p>\r\n<p>假设我们有一个校验奇数的方法如下：</p>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BooleanMethodTest</span> </span>{\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{\r\n        <span class=\"hljs-keyword\">if</span> (number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>) {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n        }\r\n    }\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\r\n        System.out.println(isOdd(<span class=\"hljs-number\">5</span>));\r\n        System.out.println(isOdd(<span class=\"hljs-number\">6</span>));\r\n        System.out.println(isOdd(-<span class=\"hljs-number\">5</span>));\r\n    }\r\n}\r\n\r\n<span class=\"hljs-comment\">// 输出如下：</span>\r\n<span class=\"hljs-keyword\">true</span>\r\n<span class=\"hljs-keyword\">false</span>\r\n<span class=\"hljs-keyword\">false</span>\r\n\r\n<span class=\"hljs-comment\">// 看似正确的代码却得到了错误的结果，因为-5%2得-1而不是1，你可以改写判断条件：</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{\r\n   <span class=\"hljs-keyword\">if</span> (number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) {\r\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\r\n   } <span class=\"hljs-keyword\">else</span> {\r\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\r\n   }\r\n}\r\n\r\n<span class=\"hljs-comment\">// 上面得到了正确的结果，但代码不规范，对于boolean方法，你可以简单返回比较的值，而不是用条件语句，如下：</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isEven</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{\r\n   <span class=\"hljs-keyword\">return</span> (number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>);\r\n}\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> number)</span> </span>{\r\n   <span class=\"hljs-keyword\">return</span> !(number % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>);\r\n}</code></pre>\r\n<h3 id=\"t10\">10. 算数方法</h3>\r\n<pre><code class=\"java hljs\"><span class=\"hljs-comment\">// JDK提供了通用的算数方法封装在Math工具类里，例如：</span>\r\n<span class=\"hljs-keyword\">double</span> Math.pow(<span class=\"hljs-keyword\">double</span> x, <span class=\"hljs-keyword\">double</span> y) <span class=\"hljs-comment\">// x的y次幂</span>\r\n<span class=\"hljs-keyword\">double</span> Math.sqrt(<span class=\"hljs-keyword\">double</span> x)          <span class=\"hljs-comment\">// x的平方根</span>\r\n<span class=\"hljs-keyword\">double</span> Math.random()                <span class=\"hljs-comment\">// 区间[0.0, 1.0)的随机数</span>\r\n<span class=\"hljs-keyword\">double</span> Math.sin()\r\n<span class=\"hljs-keyword\">double</span> Math.cos()\r\n\r\n<span class=\"hljs-comment\">// Math类提供了2个常量：</span>\r\nMath.PI                             <span class=\"hljs-comment\">// 3.141592653589793</span>\r\nMath.E                              <span class=\"hljs-comment\">// 2.718281828459045</span>\r\n\r\n<span class=\"hljs-comment\">// 你可以通过API文档查看Math类其余的方法</span>\r\n<span class=\"hljs-keyword\">int</span> secretNumber = (<span class=\"hljs-keyword\">int</span>)Math.random()*<span class=\"hljs-number\">100</span>;\r\n<span class=\"hljs-keyword\">double</span> radius = <span class=\"hljs-number\">5.5</span>;\r\n<span class=\"hljs-keyword\">double</span> area = radius*radius*Math.PI;\r\narea = Math.pow(radius, <span class=\"hljs-number\">2</span>)*Math.PI;\r\n\r\n<span class=\"hljs-keyword\">int</span> x1 = <span class=\"hljs-number\">1</span>, y1 = <span class=\"hljs-number\">1</span>, x2 = <span class=\"hljs-number\">2</span>, y2 = <span class=\"hljs-number\">2</span>;\r\n<span class=\"hljs-keyword\">double</span> distance = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\r\n<span class=\"hljs-keyword\">int</span> dx = x2 - x1;\r\n<span class=\"hljs-keyword\">int</span> dy = y2 - y1;\r\ndistance = Math.sqrt(dx*dx + dy*dy);\r\n</code></pre>\r\n<h3 id=\"t11\">11. 方法参数隐式转换</h3>\r\n<p>boule类型的方法参数为可以接收任何数值例如int或者float，这是隐式转换，但是为int类型却接收不了double，因为这样做会引起精度的丢失。</p>\r\n                    ');
INSERT INTO `article_info_true` VALUES ('100', '面向对象', '<h2 id=\"h2-u4E3Au4F55u8981u9762u5411u5BF9u8C61\"><a name=\"为何要面向对象\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>为何要面向对象</h2><p>假设您想要自己组装电脑,你去电脑店,挑选一个主板,处理器,内存,一个硬盘,一个机箱,电源,把它们放在一起。你打开电源,电脑运行。你不用担心CPU是1核还是4核;主板是什么架构;硬盘是机械还是固态,RAM在日本或韩国,等等。你只是把硬件组件在一起,希望这台机器运行。当然,你必须确保你有正确的接口,即,你选择一个IDE硬盘,而不是一个SCSI硬盘,如果你的主板只支持IDE;你必须选择正确的RAM速度等级,等等。不过,不难从硬件组件组装一台机器。</p>\r\n<p>同样,一辆车从零部件组装,如底盘、门、发动机、车轮、制动和传动，是可重用的组件,例如,可以在许多汽车(相同的规范)上使用一个品牌的轮子。</p>\r\n<p>硬件,如电脑,汽车,从零件组装,可重用的硬件组件。</p>\r\n<p>软件怎么样?你能通过选择一个程序,一个例程“装配”一个软件应用程序,并期望运行程序?答案显然是否定的!<br>与硬件不同,很难“组装”应用程序软件组件。自70年前计算机的出现,我们写了大量的程序和例程。然而,对于每一个新的应用程序,我们必须重新发明轮子,从头编写的程序!<br>为什么要另发明轮子呢?为什么要重写代码?你能写出比专家所写的代码更好的代码吗?</p>\r\n<p>传统面向过程语言<br><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/OOP_CFunction.png\" alt=\"\"><br>传统面向过程编程语言(如C、Fortran、Cobol和pascal)创建可重用的软件组件中遭受一些明显的缺点:</p>\r\n<p>面向过程项目是由函数构建的。函数难以重用。因为函数可能会引用全局变量和其他函数。换句话说,作为一个独立的可重用单元，函数并不是很好的。<br>程序语言不适合解决现实生活问题的高层抽象。例如,C程序使用如if - else For循环,数组,方法,指针,低级别的抽象,很难解决真正的问题,如客户关系管理(CRM)系统或电脑足球比赛游戏。</p>\r\n<p>传统程序语言的独立的数据结构(变量)和算法(功能)。</p>\r\n<p>在1970年代早期,美国国防部(DoD)委托一个工作组来调查为什么其IT预算总是失去控制。研究结果是:</p>\r\n<ul>\r\n<li>80%的预算用到了软件,硬件(剩下的20%)。</li><li>超过80%的软件预算去维护，新的软件开发(只剩下的20%)。</li><li>硬件组件可以应用到各种产品,其完整性通常并不影响其他产品。(硬件可以共享和重用!硬件故障隔离!)</li><li>软件往往不能共享,而不是可复用的软件程序。软件故障可能会影响其他程序运行。</li><li>项目组提出软件像硬件对象。随后,国防部取代450计算机语言,然后用于构建国防部系统,出现了一个名为Ada的面向对象的语言。</li></ul>\r\n<p>面向对象的编程语言<br><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/OOP_Objects.png\" alt=\"\"><br>面向对象编程(OOP)语言旨在克服这些问题。</p>\r\n<p>OOP的基本单位是一个类,这个类在一个“箱子”中封装了静态属性和动态操作,并指定使用这些箱子的公共接口。由于类被很好的进行了封装,更容易重用这些类。换句话说,OOP在一个类中组合软件实体内部的数据结构和算法。</p>\r\n<p>为解决现实生活中的问题，OOP语言允许更高级别的抽象。传统程序语言(如C、Pascal)迫使你思考的计算机的结构(如内存比特和字节数组,决定,循环),而不是考虑你想解决的问题。OOP语言(如Java、c++和c#)让你在问题空间中,并使用软件对象来表示和抽象实体问题的空间。</p>\r\n<p><img src=\"http://www3.ntu.edu.sg/home/ehchua/programming/java/images/OOP_SoccerGame.png\" alt=\"\"><br>作为一个例子,假设您希望编写一个电脑足球游戏（一个复杂的应用程序）。使用面向过程语言来建模这个游戏是非常困难的。但使用OOP语言,你可以很容易地建模程序相应出现在足球比赛中的“真实的东西”。</p>\r\n<p>球员:属性包括名称、数量、位置,等,操作包括跑,跳,把球踢等。<br>球:<br>足球场:<br>字段:<br>观众:<br>天气:<br>计分板：<br>最重要的是,这些类(如 Ball和 Audience)在另一个应用程序可以重用,如。篮球、电脑游戏,很少或根本没有修改。</p>\r\n<p>OOP的好处<br>面向过程语言关注过程,以函数为基本单位。首先需要找出所有的功能,然后思考如何来表示数据。<br>面向对象语言关注组件,用户感知,以对象为基本单位。你算出所有的对象通过将所有的数据和操作，描述用户与数据的交互。<br>面向对象技术有很多好处:<br>在软件设计中你可以聚焦于问题空间,而不是机器的比特和字节。你处理的是高级概念和抽象。<br>在软件维护:面向对象软件更容易理解,因此更容易测试,调试和维护。<br>可重用软件:你不需重复制造轮子和重写相同功能。最快和最安全的方式开发新应用程序，重用现有代码——充分测试和验证。</p>\r\n', '61', '## 为何要面向对象\r\n\r\n假设您想要自己组装电脑,你去电脑店,挑选一个主板,处理器,内存,一个硬盘,一个机箱,电源,把它们放在一起。你打开电源,电脑运行。你不用担心CPU是1核还是4核;主板是什么架构;硬盘是机械还是固态,RAM在日本或韩国,等等。你只是把硬件组件在一起,希望这台机器运行。当然,你必须确保你有正确的接口,即,你选择一个IDE硬盘,而不是一个SCSI硬盘,如果你的主板只支持IDE;你必须选择正确的RAM速度等级,等等。不过,不难从硬件组件组装一台机器。\r\n\r\n同样,一辆车从零部件组装,如底盘、门、发动机、车轮、制动和传动，是可重用的组件,例如,可以在许多汽车(相同的规范)上使用一个品牌的轮子。\r\n\r\n硬件,如电脑,汽车,从零件组装,可重用的硬件组件。\r\n\r\n软件怎么样?你能通过选择一个程序,一个例程“装配”一个软件应用程序,并期望运行程序?答案显然是否定的!\r\n与硬件不同,很难“组装”应用程序软件组件。自70年前计算机的出现,我们写了大量的程序和例程。然而,对于每一个新的应用程序,我们必须重新发明轮子,从头编写的程序!\r\n为什么要另发明轮子呢?为什么要重写代码?你能写出比专家所写的代码更好的代码吗?\r\n\r\n传统面向过程语言\r\n![](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/OOP_CFunction.png)\r\n传统面向过程编程语言(如C、Fortran、Cobol和pascal)创建可重用的软件组件中遭受一些明显的缺点:\r\n\r\n面向过程项目是由函数构建的。函数难以重用。因为函数可能会引用全局变量和其他函数。换句话说,作为一个独立的可重用单元，函数并不是很好的。\r\n程序语言不适合解决现实生活问题的高层抽象。例如,C程序使用如if - else For循环,数组,方法,指针,低级别的抽象,很难解决真正的问题,如客户关系管理(CRM)系统或电脑足球比赛游戏。\r\n\r\n传统程序语言的独立的数据结构(变量)和算法(功能)。\r\n\r\n在1970年代早期,美国国防部(DoD)委托一个工作组来调查为什么其IT预算总是失去控制。研究结果是:\r\n\r\n* 80%的预算用到了软件,硬件(剩下的20%)。\r\n* 超过80%的软件预算去维护，新的软件开发(只剩下的20%)。\r\n* 硬件组件可以应用到各种产品,其完整性通常并不影响其他产品。(硬件可以共享和重用!硬件故障隔离!)\r\n* 软件往往不能共享,而不是可复用的软件程序。软件故障可能会影响其他程序运行。\r\n* 项目组提出软件像硬件对象。随后,国防部取代450计算机语言,然后用于构建国防部系统,出现了一个名为Ada的面向对象的语言。\r\n\r\n面向对象的编程语言\r\n![](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/OOP_Objects.png)\r\n面向对象编程(OOP)语言旨在克服这些问题。\r\n\r\nOOP的基本单位是一个类,这个类在一个“箱子”中封装了静态属性和动态操作,并指定使用这些箱子的公共接口。由于类被很好的进行了封装,更容易重用这些类。换句话说,OOP在一个类中组合软件实体内部的数据结构和算法。\r\n\r\n为解决现实生活中的问题，OOP语言允许更高级别的抽象。传统程序语言(如C、Pascal)迫使你思考的计算机的结构(如内存比特和字节数组,决定,循环),而不是考虑你想解决的问题。OOP语言(如Java、c++和c#)让你在问题空间中,并使用软件对象来表示和抽象实体问题的空间。\r\n\r\n![](http://www3.ntu.edu.sg/home/ehchua/programming/java/images/OOP_SoccerGame.png)\r\n作为一个例子,假设您希望编写一个电脑足球游戏（一个复杂的应用程序）。使用面向过程语言来建模这个游戏是非常困难的。但使用OOP语言,你可以很容易地建模程序相应出现在足球比赛中的“真实的东西”。\r\n\r\n球员:属性包括名称、数量、位置,等,操作包括跑,跳,把球踢等。\r\n球:\r\n足球场:\r\n字段:\r\n观众:\r\n天气:\r\n计分板：\r\n最重要的是,这些类(如 Ball和 Audience)在另一个应用程序可以重用,如。篮球、电脑游戏,很少或根本没有修改。\r\n\r\nOOP的好处\r\n面向过程语言关注过程,以函数为基本单位。首先需要找出所有的功能,然后思考如何来表示数据。\r\n面向对象语言关注组件,用户感知,以对象为基本单位。你算出所有的对象通过将所有的数据和操作，描述用户与数据的交互。\r\n面向对象技术有很多好处:\r\n在软件设计中你可以聚焦于问题空间,而不是机器的比特和字节。你处理的是高级概念和抽象。\r\n在软件维护:面向对象软件更容易理解,因此更容易测试,调试和维护。\r\n可重用软件:你不需重复制造轮子和重写相同功能。最快和最安全的方式开发新应用程序，重用现有代码——充分测试和验证。');
INSERT INTO `article_info_true` VALUES ('101', 'springmvc数据回显', '<h1 id=\"h1-u6570u636Eu56DEu663E\"><a name=\"数据回显\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据回显</h1><p>本文介绍springmvc中数据回显的几种实现方法</p>\r\n<p>数据回显：提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。</p>\r\n<h2 id=\"h2-pojo-\"><a name=\"pojo数据回显方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>pojo数据回显方法</h2><p>1.springmvc默认对pojo数据进行回显。</p>\r\n<p><strong>pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）</strong></p>\r\n<p>使用<code><a href=\"https://github.com/ModelAttribute\" title=\"&#64;ModelAttribute\" class=\"at-link\">@ModelAttribute</a></code>指定pojo回显到页面在request中的key</p>\r\n<p>2.<code><a href=\"https://github.com/ModelAttribute\" title=\"&#64;ModelAttribute\" class=\"at-link\">@ModelAttribute</a></code>还可以将方法的返回值传到页面</p>\r\n<p>在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。</p>\r\n<pre><code> // 商品分类\r\n//itemtypes表示最终将方法返回值放在request中的key\r\n@ModelAttribute(&quot;itemtypes&quot;)\r\npublic Map&lt;String, String&gt; getItemTypes() {\r\n\r\n    Map&lt;String, String&gt; itemTypes = new HashMap&lt;String, String&gt;();\r\n    itemTypes.put(&quot;101&quot;, &quot;数码&quot;);\r\n    itemTypes.put(&quot;102&quot;, &quot;母婴&quot;);\r\n\r\n    return itemTypes;\r\n}\r\n</code></pre><p>页面上可以得到itemTypes数据。</p>\r\n<pre><code>&lt;td&gt;\r\n    商品名称：&lt;input name=&quot;itemsCustom.name&quot; /&gt;\r\n    商品类型：\r\n    &lt;select name=&quot;itemtype&quot;&gt;\r\n        &lt;c:forEach items=&quot;${itemtypes}&quot; var=&quot;itemtype&quot;&gt;\r\n            &lt;option value=&quot;${itemtype.key }&quot;&gt;${itemtype.value }&lt;/option&gt;\r\n        &lt;/c:forEach&gt;\r\n    &lt;/select&gt;\r\n&lt;/td&gt;\r\n</code></pre><p>3.使用最简单方法使用model，可以不用<code><a href=\"https://github.com/ModelAttribute\" title=\"&#64;ModelAttribute\" class=\"at-link\">@ModelAttribute</a></code></p>\r\n<pre><code>//可以直接使用model将提交pojo回显到页面\r\n//model.addAttribute(&quot;items&quot;, itemsCustom);\r\n</code></pre><h2 id=\"h2-u7B80u5355u7C7Bu578Bu6570u636Eu56DEu663E\"><a name=\"简单类型数据回显\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>简单类型数据回显</h2><p>使用最简单方法使用model</p>\r\n<p><code>model.addAttribute(&quot;id&quot;, id);</code></p>\r\n', '122', '# 数据回显\r\n\r\n本文介绍springmvc中数据回显的几种实现方法\r\n\r\n数据回显：提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。\r\n\r\n## pojo数据回显方法\r\n\r\n1.springmvc默认对pojo数据进行回显。\r\n\r\n**pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写）**\r\n\r\n使用`@ModelAttribute`指定pojo回显到页面在request中的key\r\n\r\n2.`@ModelAttribute`还可以将方法的返回值传到页面\r\n\r\n在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。\r\n\r\n```\r\n // 商品分类\r\n//itemtypes表示最终将方法返回值放在request中的key\r\n@ModelAttribute(\"itemtypes\")\r\npublic Map<String, String> getItemTypes() {\r\n\r\n    Map<String, String> itemTypes = new HashMap<String, String>();\r\n    itemTypes.put(\"101\", \"数码\");\r\n    itemTypes.put(\"102\", \"母婴\");\r\n\r\n    return itemTypes;\r\n}\r\n```\r\n\r\n页面上可以得到itemTypes数据。\r\n\r\n```\r\n<td>\r\n    商品名称：<input name=\"itemsCustom.name\" />\r\n    商品类型：\r\n    <select name=\"itemtype\">\r\n        <c:forEach items=\"${itemtypes}\" var=\"itemtype\">\r\n            <option value=\"${itemtype.key }\">${itemtype.value }</option>\r\n        </c:forEach>\r\n    </select>\r\n</td>\r\n```\r\n\r\n3.使用最简单方法使用model，可以不用`@ModelAttribute`\r\n\r\n```\r\n//可以直接使用model将提交pojo回显到页面\r\n//model.addAttribute(\"items\", itemsCustom);\r\n```\r\n\r\n## 简单类型数据回显\r\n\r\n使用最简单方法使用model\r\n\r\n`model.addAttribute(\"id\", id);`\r\n');
INSERT INTO `article_info_true` VALUES ('102', 'springmvc图片上传', '<h1 id=\"h1-u4E0Au4F20u56FEu7247\"><a name=\"上传图片\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>上传图片</h1><p>本文展示如何在springmvc中上传图片</p>\r\n<h2 id=\"h2-springmvc-\"><a name=\"springmvc中对多部件类型解析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc中对多部件类型解析</h2><p>在修改商品页面，添加上传商品图片功能。</p>\r\n<p>在页面form中提交<code>enctype=&quot;multipart/form-data&quot;</code>的数据时，需要springmvc对multipart类型的数据进行解析。</p>\r\n<p>在springmvc.xml中配置multipart类型解析器。</p>\r\n<pre><code>&lt;!-- 文件上传 --&gt;\r\n&lt;bean id=&quot;multipartResolver&quot;\r\n      class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;\r\n    &lt;!-- 设置上传文件的最大尺寸为5MB --&gt;\r\n    &lt;property name=&quot;maxUploadSize&quot;&gt;\r\n        &lt;value&gt;5242880&lt;/value&gt;\r\n    &lt;/property&gt;\r\n&lt;/bean&gt;\r\n</code></pre><h2 id=\"h2--jar\"><a name=\"加入上传图片的jar\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>加入上传图片的jar</h2><p>添加依赖</p>\r\n<pre><code>&lt;!-- 文件上传 --&gt;\r\n&lt;dependency&gt;\r\n    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;\r\n    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;\r\n    &lt;version&gt;1.3.1&lt;/version&gt;\r\n&lt;/dependency&gt;\r\n</code></pre><p>依赖树</p>\r\n<pre><code>[INFO] \\- commons-fileupload:commons-fileupload:jar:1.3.1:compile\r\n[INFO]    \\- commons-io:commons-io:jar:2.2:compile\r\n</code></pre><p>可以看到，其实还间接依赖了<code>commons-io.jar</code></p>\r\n<h2 id=\"h2-u4E0Au4F20u56FEu7247u4EE3u7801\"><a name=\"上传图片代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>上传图片代码</h2><ul>\r\n<li>页面</li></ul>\r\n<pre><code>&lt;tr&gt;\r\n    &lt;td&gt;商品图片&lt;/td&gt;\r\n    &lt;td&gt;\r\n        &lt;c:if test=&quot;${items.pic !=null}&quot;&gt;\r\n            &lt;img src=&quot;/pic/${items.pic}&quot; width=100 height=100/&gt;\r\n            &lt;br/&gt;\r\n        &lt;/c:if&gt;\r\n        &lt;input type=&quot;file&quot;  name=&quot;items_pic&quot;/&gt;\r\n    &lt;/td&gt;\r\n&lt;/tr&gt;\r\n</code></pre><ul>\r\n<li>controller方法</li></ul>\r\n<p>修改：商品修改controller方法：</p>\r\n<pre><code>@RequestMapping(&quot;/editItemsSubmit&quot;)\r\n    public String editItemsSubmit(\r\n            Model model,\r\n            HttpServletRequest request,\r\n            Integer id,\r\n            @ModelAttribute(&quot;items&quot;)\r\n            @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,\r\n            BindingResult bindingResult,\r\n            MultipartFile items_pic\r\n    )throws Exception {\r\n</code></pre><pre><code> //原始名称\r\nString originalFilename = items_pic.getOriginalFilename();\r\n//上传图片\r\nif(items_pic!=null &amp;&amp; originalFilename!=null &amp;&amp; originalFilename.length()&gt;0){\r\n\r\n    //存储图片的物理路径\r\n    String pic_path = &quot;D:\\\\tmp\\\\&quot;;\r\n\r\n    //新的图片名称\r\n    String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));\r\n    //新图片\r\n    File newFile = new File(pic_path+newFileName);\r\n\r\n    //将内存中的数据写入磁盘\r\n    items_pic.transferTo(newFile);\r\n\r\n    //将新图片名称写到itemsCustom中\r\n    itemsCustom.setPic(newFileName);\r\n\r\n}\r\n</code></pre>', '123', '# 上传图片\r\n\r\n本文展示如何在springmvc中上传图片\r\n\r\n## springmvc中对多部件类型解析\r\n\r\n在修改商品页面，添加上传商品图片功能。\r\n\r\n在页面form中提交`enctype=\"multipart/form-data\"`的数据时，需要springmvc对multipart类型的数据进行解析。\r\n\r\n在springmvc.xml中配置multipart类型解析器。\r\n\r\n```\r\n<!-- 文件上传 -->\r\n<bean id=\"multipartResolver\"\r\n      class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\r\n    <!-- 设置上传文件的最大尺寸为5MB -->\r\n    <property name=\"maxUploadSize\">\r\n        <value>5242880</value>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n## 加入上传图片的jar\r\n\r\n添加依赖\r\n\r\n```\r\n<!-- 文件上传 -->\r\n<dependency>\r\n    <groupId>commons-fileupload</groupId>\r\n    <artifactId>commons-fileupload</artifactId>\r\n    <version>1.3.1</version>\r\n</dependency>\r\n```\r\n\r\n依赖树\r\n\r\n```\r\n[INFO] \\- commons-fileupload:commons-fileupload:jar:1.3.1:compile\r\n[INFO]    \\- commons-io:commons-io:jar:2.2:compile\r\n```\r\n\r\n可以看到，其实还间接依赖了`commons-io.jar`\r\n\r\n## 上传图片代码\r\n\r\n*   页面\r\n\r\n```\r\n<tr>\r\n    <td>商品图片</td>\r\n    <td>\r\n        <c:if test=\"${items.pic !=null}\">\r\n            <img src=\"/pic/${items.pic}\" width=100 height=100/>\r\n            <br/>\r\n        </c:if>\r\n        <input type=\"file\"  name=\"items_pic\"/>\r\n    </td>\r\n</tr>\r\n```\r\n\r\n*   controller方法\r\n\r\n修改：商品修改controller方法：\r\n\r\n```\r\n@RequestMapping(\"/editItemsSubmit\")\r\n    public String editItemsSubmit(\r\n            Model model,\r\n            HttpServletRequest request,\r\n            Integer id,\r\n            @ModelAttribute(\"items\")\r\n            @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom,\r\n            BindingResult bindingResult,\r\n            MultipartFile items_pic\r\n    )throws Exception {\r\n```\r\n\r\n```\r\n //原始名称\r\nString originalFilename = items_pic.getOriginalFilename();\r\n//上传图片\r\nif(items_pic!=null && originalFilename!=null && originalFilename.length()>0){\r\n\r\n    //存储图片的物理路径\r\n    String pic_path = \"D:\\\\tmp\\\\\";\r\n\r\n    //新的图片名称\r\n    String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(\".\"));\r\n    //新图片\r\n    File newFile = new File(pic_path+newFileName);\r\n\r\n    //将内存中的数据写入磁盘\r\n    items_pic.transferTo(newFile);\r\n\r\n    //将新图片名称写到itemsCustom中\r\n    itemsCustom.setPic(newFileName);\r\n\r\n}\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('103', 'springmvc json数据交互', '<h1 id=\"h1-json-\"><a name=\"json数据交互\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>json数据交互</h1><p>本文主要介绍如何在springmvc中进行json数据的交互，先是环境准备和配置，然后分别展示了“输入json串，输出是json串”和“输入key/value，输出是json串”两种情况下的交互</p>\r\n<h2 id=\"h2-springmvc-json-\"><a name=\"springmvc进行json交互\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>springmvc进行json交互</h2><p>json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。</p>\r\n<p>比如：webservice接口，传输json数据.</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json%E4%BA%A4%E4%BA%92.png\" alt=\"json交互\"></p>\r\n<ul>\r\n<li>请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。</li><li>请求key/value、输出json。此方法比较常用。</li></ul>\r\n<h2 id=\"h2-u73AFu5883u51C6u5907\"><a name=\"环境准备\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>环境准备</h2><h3 id=\"h3--json-\"><a name=\"添加json转换的依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>添加json转换的依赖</h3><pre><code>\r\n&lt;!-- json 转换--&gt;\r\n&lt;dependency&gt;\r\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\r\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\r\n    &lt;version&gt;2.7.2&lt;/version&gt;\r\n&lt;/dependency&gt;\r\n\r\n&lt;dependency&gt;\r\n    &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;\r\n    &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;\r\n    &lt;version&gt;1.9.13&lt;/version&gt;\r\n&lt;/dependency&gt;\r\n</code></pre><p>查看依赖树</p>\r\n<pre><code>[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.7.2:compile\r\n[INFO] |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile\r\n[INFO] |  \\- com.fasterxml.jackson.core:jackson-core:jar:2.7.2:compile\r\n[INFO] \\- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile\r\n[INFO]    \\- org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile\r\n</code></pre><h3 id=\"h3--json-\"><a name=\"配置json转换器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置json转换器</h3><p>在注解适配器中加入<code>messageConverters</code></p>\r\n<pre><code>\r\n&lt;!--注解适配器 --&gt;\r\n&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;\r\n    &lt;property name=&quot;messageConverters&quot;&gt;\r\n    &lt;list&gt;\r\n    &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot;&gt;&lt;/bean&gt;\r\n    &lt;/list&gt;\r\n    &lt;/property&gt;\r\n&lt;/bean&gt;\r\n</code></pre><p><strong>注意：如果使用<code>&lt;mvc:annotation-driven /&gt;</code>则不用定义上边的内容。</strong></p>\r\n<h2 id=\"h2-json-\"><a name=\"json交互测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>json交互测试</h2><p>显示两个按钮分别<a href=\"http://lib.csdn.net/base/softwaretest\" title=\"软件测试知识库\">测试</a></p>\r\n<ul>\r\n<li>jsp页面</li></ul>\r\n<pre><code>&lt;%--\r\n  Created by IntelliJ IDEA.\r\n  User: brian\r\n  Date: 2016/3/7\r\n  Time: 20:49\r\n  To change this template use File | Settings | File Templates.\r\n--%&gt;\r\n&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\r\n    &lt;title&gt;json交互测试&lt;/title&gt;\r\n    &lt;script type=&quot;text/javascript&quot; src=&quot;${pageContext.request.contextPath }/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt;\r\n    &lt;script type=&quot;text/javascript&quot;&gt;\r\n        //请求json，输出是json\r\n        function requestJson(){     省略    }\r\n        //请求key/value，输出是json\r\n        function responseJson(){    省略    }\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;input type=&quot;button&quot; onclick=&quot;requestJson()&quot; value=&quot;请求json，输出是json&quot;/&gt;\r\n&lt;input type=&quot;button&quot; onclick=&quot;responseJson()&quot; value=&quot;请求key/value，输出是json&quot;/&gt;\r\n&lt;/body&gt;\r\n</code></pre><ul>\r\n<li>controller</li></ul>\r\n<pre><code>@Controller\r\npublic class JsonTest {\r\n    省略\r\n}\r\n</code></pre><ul>\r\n<li>测试结果</li></ul>\r\n<h3 id=\"h3--json-json-\"><a name=\"输入json串，输出是json串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>输入json串，输出是json串</h3><p>使用<a href=\"http://lib.csdn.net/base/jquery\" title=\"jQuery知识库\">jQuery</a>的ajax提交json串，对输出的json结果进行解析。</p>\r\n<ul>\r\n<li>jsp页面</li></ul>\r\n<pre><code>//请求json，输出是json\r\nfunction requestJson(){\r\n\r\n    $.ajax({\r\n        type:&#39;post&#39;,\r\n        url:&#39;${pageContext.request.contextPath }/requestJson.action&#39;,\r\n        contentType:&#39;application/json;charset=utf-8&#39;,\r\n        //数据格式是json串，商品信息\r\n        data:&#39;{&quot;name&quot;:&quot;手机&quot;,&quot;price&quot;:999}&#39;,\r\n        success:function(data){//返回json结果\r\n            alert(data);\r\n        }\r\n\r\n    });\r\n\r\n}\r\n</code></pre><ul>\r\n<li>controller</li></ul>\r\n<pre><code> //请求json串(商品信息)，输出json(商品信息)\r\n//@RequestBody将请求的商品信息的json串转成itemsCustom对象\r\n//@ResponseBody将itemsCustom转成json输出\r\n@RequestMapping(&quot;/requestJson&quot;)\r\npublic @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom){\r\n\r\n    //@ResponseBody将itemsCustom转成json输出\r\n    return itemsCustom;\r\n}\r\n</code></pre><ul>\r\n<li>测试结果</li></ul>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-json-1.png\" alt=\"请求json，返回json\"></p>\r\n<p>可以看到，request和response的HTTP头的Content-Type都是<code>application/json;charset=utf-8</code></p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-json-2.png\" alt=\"请求json，返回json,response的body\"></p>\r\n<h3 id=\"h3--key-value-json-\"><a name=\"输入key/value，输出是json串\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>输入key/value，输出是json串</h3><p>使用jquery的ajax提交key/value串，对输出的json结果进行解析</p>\r\n<ul>\r\n<li>jsp页面</li></ul>\r\n<pre><code>//请求key/value，输出是json\r\nfunction responseJson(){\r\n\r\n    $.ajax({\r\n        type:&#39;post&#39;,\r\n        url:&#39;${pageContext.request.contextPath }/responseJson.action&#39;,\r\n        //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型\r\n        //contentType:&#39;application/json;charset=utf-8&#39;,\r\n        //数据格式是json串，商品信息\r\n        data:&#39;name=手机&amp;price=999&#39;,\r\n        success:function(data){//返回json结果\r\n            alert(data.name);\r\n        }\r\n\r\n    });\r\n\r\n}\r\n</code></pre><ul>\r\n<li>controller</li></ul>\r\n<pre><code> //请求key/value，输出json\r\n@RequestMapping(&quot;/responseJson&quot;)\r\npublic @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom){\r\n\r\n    //@ResponseBody将itemsCustom转成json输出\r\n    return itemsCustom;\r\n}\r\n</code></pre><ul>\r\n<li>测试结果</li></ul>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-keyvalue-1.png\" alt=\"请求key/value,返回json\"></p>\r\n<p>可以看到，key/value键值对的默认Content-Type是<code>application/x-www-form-urlencoded</code>,同时，我们收到了响应“手机”</p>\r\n', '124', '# json数据交互\r\n\r\n本文主要介绍如何在springmvc中进行json数据的交互，先是环境准备和配置，然后分别展示了“输入json串，输出是json串”和“输入key/value，输出是json串”两种情况下的交互\r\n\r\n## springmvc进行json交互\r\n\r\njson数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。\r\n\r\n比如：webservice接口，传输json数据.\r\n\r\n![json交互](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json%E4%BA%A4%E4%BA%92.png)\r\n\r\n*   请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。\r\n*   请求key/value、输出json。此方法比较常用。\r\n\r\n## 环境准备\r\n\r\n### 添加json转换的依赖\r\n\r\n\r\n```\r\n\r\n<!-- json 转换-->\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.core</groupId>\r\n    <artifactId>jackson-databind</artifactId>\r\n    <version>2.7.2</version>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>org.codehaus.jackson</groupId>\r\n    <artifactId>jackson-mapper-asl</artifactId>\r\n    <version>1.9.13</version>\r\n</dependency>\r\n```\r\n\r\n查看依赖树\r\n\r\n```\r\n[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.7.2:compile\r\n[INFO] |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile\r\n[INFO] |  \\- com.fasterxml.jackson.core:jackson-core:jar:2.7.2:compile\r\n[INFO] \\- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile\r\n[INFO]    \\- org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile\r\n```\r\n\r\n### 配置json转换器\r\n\r\n在注解适配器中加入`messageConverters`\r\n\r\n```\r\n\r\n<!--注解适配器 -->\r\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\r\n    <property name=\"messageConverters\">\r\n    <list>\r\n    <bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"></bean>\r\n    </list>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n**注意：如果使用`<mvc:annotation-driven />`则不用定义上边的内容。**\r\n\r\n## json交互测试\r\n\r\n显示两个按钮分别[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")\r\n\r\n*   jsp页面\r\n\r\n```\r\n<%--\r\n  Created by IntelliJ IDEA.\r\n  User: brian\r\n  Date: 2016/3/7\r\n  Time: 20:49\r\n  To change this template use File | Settings | File Templates.\r\n--%>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n    <title>json交互测试</title>\r\n    <script type=\"text/javascript\" src=\"${pageContext.request.contextPath }/js/jquery-1.4.4.min.js\"></script>\r\n    <script type=\"text/javascript\">\r\n        //请求json，输出是json\r\n        function requestJson(){     省略    }\r\n        //请求key/value，输出是json\r\n        function responseJson(){    省略    }\r\n    </script>\r\n</head>\r\n<body>\r\n<input type=\"button\" onclick=\"requestJson()\" value=\"请求json，输出是json\"/>\r\n<input type=\"button\" onclick=\"responseJson()\" value=\"请求key/value，输出是json\"/>\r\n</body>\r\n\r\n```\r\n\r\n*   controller\r\n\r\n```\r\n@Controller\r\npublic class JsonTest {\r\n    省略\r\n}\r\n```\r\n\r\n*   测试结果\r\n\r\n### 输入json串，输出是json串\r\n\r\n使用[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")的ajax提交json串，对输出的json结果进行解析。\r\n\r\n*   jsp页面\r\n\r\n```\r\n//请求json，输出是json\r\nfunction requestJson(){\r\n\r\n    $.ajax({\r\n        type:\'post\',\r\n        url:\'${pageContext.request.contextPath }/requestJson.action\',\r\n        contentType:\'application/json;charset=utf-8\',\r\n        //数据格式是json串，商品信息\r\n        data:\'{\"name\":\"手机\",\"price\":999}\',\r\n        success:function(data){//返回json结果\r\n            alert(data);\r\n        }\r\n\r\n    });\r\n\r\n}\r\n```\r\n\r\n*   controller\r\n\r\n```\r\n //请求json串(商品信息)，输出json(商品信息)\r\n//@RequestBody将请求的商品信息的json串转成itemsCustom对象\r\n//@ResponseBody将itemsCustom转成json输出\r\n@RequestMapping(\"/requestJson\")\r\npublic @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom){\r\n\r\n    //@ResponseBody将itemsCustom转成json输出\r\n    return itemsCustom;\r\n}\r\n```\r\n\r\n*   测试结果\r\n\r\n![请求json，返回json](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-json-1.png)\r\n\r\n可以看到，request和response的HTTP头的Content-Type都是`application/json;charset=utf-8`\r\n\r\n![请求json，返回json,response的body](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-json-2.png)\r\n\r\n### 输入key/value，输出是json串\r\n\r\n使用jquery的ajax提交key/value串，对输出的json结果进行解析\r\n\r\n*   jsp页面\r\n\r\n```\r\n//请求key/value，输出是json\r\nfunction responseJson(){\r\n\r\n    $.ajax({\r\n        type:\'post\',\r\n        url:\'${pageContext.request.contextPath }/responseJson.action\',\r\n        //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型\r\n        //contentType:\'application/json;charset=utf-8\',\r\n        //数据格式是json串，商品信息\r\n        data:\'name=手机&price=999\',\r\n        success:function(data){//返回json结果\r\n            alert(data.name);\r\n        }\r\n\r\n    });\r\n\r\n}\r\n```\r\n\r\n*   controller\r\n\r\n```\r\n //请求key/value，输出json\r\n@RequestMapping(\"/responseJson\")\r\npublic @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom){\r\n\r\n    //@ResponseBody将itemsCustom转成json输出\r\n    return itemsCustom;\r\n}\r\n```\r\n\r\n*   测试结果\r\n\r\n![请求key/value,返回json](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_json-request-keyvalue-1.png)\r\n\r\n可以看到，key/value键值对的默认Content-Type是`application/x-www-form-urlencoded`,同时，我们收到了响应“手机”\r\n');
INSERT INTO `article_info_true` VALUES ('104', 'springmvc restful支持', '<h1 id=\"h1-restful-\"><a name=\"RESTful支持\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>RESTful支持</h1><p>本文介绍RESTful的概念，并通过一个小例子展示如何编写RESTful风格的controller和配置前端控制器，最后展示静态资源的解析</p>\r\n<h2 id=\"h2--gt-\"><a name=\"&gt;概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>&gt;概念</h2><p>首先附上两篇博客链接</p>\r\n<blockquote>\r\n<ul>\r\n<li><a href=\"http://zqpythonic.qiniucdn.com/data/20110912210739/index.html\">理解RESTful架构 - 阮一峰的网络日志</a></li><li><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\">RESTful API 设计指南- 阮一峰的网络日志</a></li></ul>\r\n</blockquote>\r\n<p>RESTful<a href=\"http://lib.csdn.net/base/architecture\" title=\"大型网站架构知识库\">架构</a>，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>\r\n<p>RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。</p>\r\n<p>1.对url进行规范，写RESTful格式的url</p>\r\n<ul>\r\n<li>非REST的url：<code>http://...../queryItems.action?id=001&amp;type=T01</code></li><li>REST的url风格：<code>http://..../items/001</code></li></ul>\r\n<p>特点：url简洁，将参数通过url传到服务端</p>\r\n<p>2.http的方法规范</p>\r\n<p>不管是删除、添加、更新，等等。使用url是一致的，如果进行删除，需要设置http的方法为delete，其他同理。</p>\r\n<p>后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。</p>\r\n<p>3.对http的contentType规范</p>\r\n<p>请求时指定contentType，要json数据，设置成json格式的type。</p>\r\n<h2 id=\"h2-rest-\"><a name=\"REST的例子\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>REST的例子</h2><p>查询商品信息，返回json数据。</p>\r\n<h3 id=\"h3-controller\"><a name=\"controller\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>controller</h3><p>定义方法，进行url映射使用REST风格的url，将查询商品信息的id传入controller .</p>\r\n<p>输出json使用<code><a href=\"https://github.com/ResponseBody\" title=\"&#64;ResponseBody\" class=\"at-link\">@ResponseBody</a></code>将<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>对象输出json。</p>\r\n<pre><code>//查询商品信息，输出json\r\n//itemsView/{id}里边的{id}表示占位符，通过@PathVariable获取占位符中的参数，\r\n//@PathVariable中名称要和占位符一致，形参名无需和其一致\r\n//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称\r\n@RequestMapping(&quot;/itemsView/{id}&quot;)\r\npublic @ResponseBody ItemsCustom itemsView(@PathVariable(&quot;id&quot;) Integer items_id)throws Exception{\r\n\r\n    //调用service查询商品信息\r\n    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);\r\n\r\n    return itemsCustom;\r\n\r\n}\r\n</code></pre><p><code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a>(value=&quot;/ itemsView/{id}&quot;)</code>：<code>{×××}</code>占位符，请求的URL可以是<code>/viewItems/1</code>或<code>/viewItems/2</code>，通过在方法中使用<code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code>获取{×××}中的×××变量。<code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code>用于将请求URL中的模板变量映射到功能处理方法的参数上。</p>\r\n<p>如果<code><a href=\"https://github.com/RequestMapping\" title=\"&#64;RequestMapping\" class=\"at-link\">@RequestMapping</a></code>中表示为<code>/itemsView/{id}</code>，id和形参名称一致，<code><a href=\"https://github.com/PathVariable\" title=\"&#64;PathVariable\" class=\"at-link\">@PathVariable</a></code>不用指定名称。</p>\r\n<h3 id=\"h3-rest-\"><a name=\"REST方法的前端控制器配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>REST方法的前端控制器配置</h3><pre><code>&lt;!-- springmvc前端控制器，rest配置 --&gt;\r\n&lt;servlet&gt;\r\n    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;\r\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\r\n    &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt;\r\n    &lt;init-param&gt;\r\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\r\n        &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;\r\n    &lt;/init-param&gt;\r\n&lt;/servlet&gt;\r\n\r\n&lt;servlet-mapping&gt;\r\n    &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt;\r\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\r\n&lt;/servlet-mapping&gt;\r\n</code></pre><p>访问结果如图：</p>\r\n<p><img src=\"http://7xph6d.com1.z0.glb.clouddn.com/springmvc_RESTful%E6%A0%BC%E5%BC%8F%E8%AE%BF%E9%97%AE.png\" alt=\"RESTful格式访问\"></p>\r\n<h2 id=\"h2-u5BF9u9759u6001u8D44u6E90u7684u89E3u6790\"><a name=\"对静态资源的解析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>对静态资源的解析</h2><p>配置前端控制器的url-parttern中指定<code>/</code>，对静态资源的解析会出现问题，报404错误。</p>\r\n<p>在springmvc.xml中添加静态资源解析方法。</p>\r\n<pre><code>&lt;!-- 静态资源解析\r\n    包括 ：js、css、img、..\r\n     --&gt;\r\n&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;\r\n</code></pre><p>这时访问<code>http://localhost:8080/ssm1/js/[jQuery](http://lib.csdn.net/base/jquery &quot;jQuery知识库&quot;)-1.4.4.min.js</code>，可以在浏览器中看到js的内容</p>\r\n', '125', '# RESTful支持\r\n\r\n本文介绍RESTful的概念，并通过一个小例子展示如何编写RESTful风格的controller和配置前端控制器，最后展示静态资源的解析\r\n\r\n## >概念\r\n\r\n首先附上两篇博客链接\r\n\r\n> *   [理解RESTful架构 - 阮一峰的网络日志](http://zqpythonic.qiniucdn.com/data/20110912210739/index.html)\r\n> *   [RESTful API 设计指南- 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)\r\n\r\nRESTful[架构](http://lib.csdn.net/base/architecture \"大型网站架构知识库\")，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。\r\n\r\nRESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。\r\n\r\n1.对url进行规范，写RESTful格式的url\r\n\r\n*   非REST的url：`http://...../queryItems.action?id=001&type=T01`\r\n*   REST的url风格：`http://..../items/001`\r\n\r\n特点：url简洁，将参数通过url传到服务端\r\n\r\n2.http的方法规范\r\n\r\n不管是删除、添加、更新，等等。使用url是一致的，如果进行删除，需要设置http的方法为delete，其他同理。\r\n\r\n后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。\r\n\r\n3.对http的contentType规范\r\n\r\n请求时指定contentType，要json数据，设置成json格式的type。\r\n\r\n## REST的例子\r\n\r\n查询商品信息，返回json数据。\r\n\r\n### controller\r\n\r\n定义方法，进行url映射使用REST风格的url，将查询商品信息的id传入controller .\r\n\r\n输出json使用`@ResponseBody`将[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")对象输出json。\r\n\r\n```\r\n//查询商品信息，输出json\r\n//itemsView/{id}里边的{id}表示占位符，通过@PathVariable获取占位符中的参数，\r\n//@PathVariable中名称要和占位符一致，形参名无需和其一致\r\n//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称\r\n@RequestMapping(\"/itemsView/{id}\")\r\npublic @ResponseBody ItemsCustom itemsView(@PathVariable(\"id\") Integer items_id)throws Exception{\r\n\r\n    //调用service查询商品信息\r\n    ItemsCustom itemsCustom = itemsService.findItemsById(items_id);\r\n\r\n    return itemsCustom;\r\n\r\n}\r\n```\r\n\r\n`@RequestMapping(value=\"/ itemsView/{id}\")`：`{×××}`占位符，请求的URL可以是`/viewItems/1`或`/viewItems/2`，通过在方法中使用`@PathVariable`获取{×××}中的×××变量。`@PathVariable`用于将请求URL中的模板变量映射到功能处理方法的参数上。\r\n\r\n如果`@RequestMapping`中表示为`/itemsView/{id}`，id和形参名称一致，`@PathVariable`不用指定名称。\r\n\r\n### REST方法的前端控制器配置\r\n\r\n```\r\n<!-- springmvc前端控制器，rest配置 -->\r\n<servlet>\r\n    <servlet-name>springmvc_rest</servlet-name>\r\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n    <!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） -->\r\n    <init-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>classpath:spring/springmvc.xml</param-value>\r\n    </init-param>\r\n</servlet>\r\n\r\n<servlet-mapping>\r\n    <servlet-name>springmvc_rest</servlet-name>\r\n    <url-pattern>/</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n访问结果如图：\r\n\r\n![RESTful格式访问](http://7xph6d.com1.z0.glb.clouddn.com/springmvc_RESTful%E6%A0%BC%E5%BC%8F%E8%AE%BF%E9%97%AE.png)\r\n\r\n## 对静态资源的解析\r\n\r\n配置前端控制器的url-parttern中指定`/`，对静态资源的解析会出现问题，报404错误。\r\n\r\n在springmvc.xml中添加静态资源解析方法。\r\n\r\n```\r\n<!-- 静态资源解析\r\n    包括 ：js、css、img、..\r\n     -->\r\n<mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\r\n```\r\n\r\n这时访问`http://localhost:8080/ssm1/js/[jQuery](http://lib.csdn.net/base/jquery \"jQuery知识库\")-1.4.4.min.js`，可以在浏览器中看到js的内容\r\n');
INSERT INTO `article_info_true` VALUES ('105', 'springmvc拦截器', '<h1 id=\"h1-u62E6u622Au5668\"><a name=\"拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>拦截器</h1><p>本文主要介绍springmvc中的拦截器，包括拦截器定义和的配置，最后通过一个登录认证的例子展示了拦截器的应用</p>\r\n<h2 id=\"h2-u62E6u622Au5B9Au4E49\"><a name=\"拦截定义\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>拦截定义</h2><p>定义拦截器，实现<code>HandlerInterceptor</code>接口。接口中提供三个方法。</p>\r\n<pre><code>public class HandlerInterceptor1 implements HandlerInterceptor{\r\n    //进入 Handler方法之前执行\r\n    //用于身份认证、身份授权\r\n    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n\r\n        //return false表示拦截，不向下执行\r\n        //return true表示放行\r\n        return false;\r\n    }\r\n\r\n    //进入Handler方法之后，返回modelAndView之前执行\r\n    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r\n\r\n    }\r\n\r\n    //执行Handler完成执行此方法\r\n    //应用场景：统一异常处理，统一日志处理\r\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r\n\r\n    }\r\n}\r\n</code></pre><p>可以从名称和参数看出各个接口的顺序和作用:</p>\r\n<ul>\r\n<li><p><code>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception</code></p>\r\n<ul>\r\n<li>参数最少，只有三个</li><li>进入 Handler方法之前执行</li><li>用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行</li></ul>\r\n</li><li><p><code>public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception</code></p>\r\n<ul>\r\n<li>多了一个modelAndView参数</li><li>进入Handler方法之后，返回modelAndView之前执行</li><li>应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图</li></ul>\r\n</li><li><p><code>public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception</code></p>\r\n<ul>\r\n<li>多了一个Exception的类型的参数</li><li>执行Handler完成执行此方法</li><li>应用场景：统一异常处理，统一日志处理</li></ul>\r\n</li></ul>\r\n<h2 id=\"h2-u62E6u622Au5668u914Du7F6E\"><a name=\"拦截器配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>拦截器配置</h2><h3 id=\"h3--handlermapping-\"><a name=\"针对HandlerMapping配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>针对HandlerMapping配置</h3><p>springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器。</p>\r\n<pre><code>&lt;bean\r\n    class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;\r\n    &lt;property name=&quot;interceptors&quot;&gt;\r\n        &lt;list&gt;\r\n            &lt;ref bean=&quot;handlerInterceptor1&quot;/&gt;\r\n            &lt;ref bean=&quot;handlerInterceptor2&quot;/&gt;\r\n        &lt;/list&gt;\r\n    &lt;/property&gt;\r\n&lt;/bean&gt;\r\n    &lt;bean id=&quot;handlerInterceptor1&quot; class=&quot;springmvc.intercapter.HandlerInterceptor1&quot;/&gt;\r\n    &lt;bean id=&quot;handlerInterceptor2&quot; class=&quot;springmvc.intercapter.HandlerInterceptor2&quot;/&gt;\r\n</code></pre><p>一般不推荐使用。</p>\r\n<h3 id=\"h3-u7C7Bu4F3Cu5168u5C40u7684u62E6u622Au5668\"><a name=\"类似全局的拦截器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>类似全局的拦截器</h3><p>springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。</p>\r\n<pre><code> &lt;!--拦截器 --&gt;\r\n&lt;mvc:interceptors&gt;\r\n    &lt;!--多个拦截器,顺序执行 --&gt;\r\n    &lt;mvc:interceptor&gt;\r\n        &lt;!-- /**表示所有url包括子url路径 --&gt;\r\n        &lt;mvc:mapping path=&quot;/**&quot;/&gt;\r\n        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor1&quot;&gt;&lt;/bean&gt;\r\n    &lt;/mvc:interceptor&gt;\r\n    &lt;mvc:interceptor&gt;\r\n        &lt;mvc:mapping path=&quot;/**&quot;/&gt;\r\n        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.HandlerInterceptor2&quot;&gt;&lt;/bean&gt;\r\n    &lt;/mvc:interceptor&gt;\r\n&lt;/mvc:interceptors&gt;\r\n</code></pre><h2 id=\"h2-u62E6u622Au6D4Bu8BD5\"><a name=\"拦截测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>拦截测试</h2><p>测试多个拦截器各个方法执行时机</p>\r\n<p>访问<code>/items/queryItems.action</code></p>\r\n<ul>\r\n<li>1.两个拦截器都放行</li></ul>\r\n<pre><code>DEBUG [http-apr-8080-exec-1] - DispatcherServlet with name &#39;springmvc&#39; processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-1] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-1] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-1] - Returning cached instance of singleton bean &#39;itemsController&#39;\r\nDEBUG [http-apr-8080-exec-1] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nHandlerInterceptor2...preHandle\r\nDEBUG [http-apr-8080-exec-1] - Fetching JDBC Connection from DataSource\r\nDEBUG [http-apr-8080-exec-1] - Registering transaction synchronization for JDBC Connection\r\nDEBUG [http-apr-8080-exec-1] - Returning JDBC Connection to DataSource\r\nHandlerInterceptor2...postHandle\r\nHandlerInterceptor1...postHandle\r\nDEBUG [http-apr-8080-exec-1] - Rendering view [org.springframework.web.servlet.view.JstlView: name &#39;items/itemsList&#39;; URL [/WEB-INF/jsp/items/itemsList.jsp]] in DispatcherServlet with name &#39;springmvc&#39;\r\nDEBUG [http-apr-8080-exec-1] - Added model object &#39;itemtypes&#39; of type [java.util.HashMap] to request in view with name &#39;items/itemsList&#39;\r\nDEBUG [http-apr-8080-exec-1] - Added model object &#39;itemsQueryVo&#39; of type [com.iot.learnssm.firstssm.po.ItemsQueryVo] to request in view with name &#39;items/itemsList&#39;\r\nDEBUG [http-apr-8080-exec-1] - Added model object &#39;org.springframework.validation.BindingResult.itemsQueryVo&#39; of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name &#39;items/itemsList&#39;\r\nDEBUG [http-apr-8080-exec-1] - Added model object &#39;itemsList&#39; of type [java.util.ArrayList] to request in view with name &#39;items/itemsList&#39;\r\nDEBUG [http-apr-8080-exec-1] - Forwarding to resource [/WEB-INF/jsp/items/itemsList.jsp] in InternalResourceView &#39;items/itemsList&#39;\r\nHandlerInterceptor2...afterCompletion\r\nHandlerInterceptor1...afterCompletion\r\nDEBUG [http-apr-8080-exec-1] - Successfully completed request\r\n</code></pre><p>总结：preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行。</p>\r\n<p>2.拦截器1放行，拦截器2不放行</p>\r\n<pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &#39;springmvc&#39; processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &#39;itemsController&#39;\r\nDEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nHandlerInterceptor2...preHandle\r\nHandlerInterceptor1...afterCompletion\r\nDEBUG [http-apr-8080-exec-8] - Successfully completed request\r\n</code></pre><p>总结：</p>\r\n<ul>\r\n<li>拦截器1放行，拦截器2 preHandle才会执行。</li><li>拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。</li><li>只要有一个拦截器不放行，postHandle不会执行。</li></ul>\r\n<p>3.两个拦截器都不放</p>\r\n<pre><code>DEBUG [http-apr-8080-exec-9] - DispatcherServlet with name &#39;springmvc&#39; processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-9] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-9] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-9] - Returning cached instance of singleton bean &#39;itemsController&#39;\r\nDEBUG [http-apr-8080-exec-9] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nDEBUG [http-apr-8080-exec-9] - Successfully completed request\r\n</code></pre><p>总结：</p>\r\n<ul>\r\n<li>拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。</li><li>拦截器1 preHandle不放行，拦截器2不执行。</li></ul>\r\n<p>4.拦截器1不放行，拦截器2放行</p>\r\n<pre><code>DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &#39;springmvc&#39; processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &#39;itemsController&#39;\r\nDEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nDEBUG [http-apr-8080-exec-8] - Successfully completed request\r\n</code></pre><p>和两个拦截器都不行的结果一致，因为拦截器1先执行，没放行</p>\r\n<ul>\r\n<li>小结</li></ul>\r\n<p>根据测试结果，对拦截器应用。</p>\r\n<p>比如：统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。</p>\r\n<p>比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）</p>\r\n<h2 id=\"h2--\"><a name=\"拦截器应用(实现登陆认证)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>拦截器应用(实现登陆认证)</h2><h3 id=\"h3-u9700u6C42\"><a name=\"需求\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>需求</h3><ul>\r\n<li>1.用户请求url</li><li><p>2.拦截器进行拦截校验</p>\r\n<ul>\r\n<li>如果请求的url是公开地址（无需登陆即可访问的url），让放行</li><li>如果用户session 不存在跳转到登陆页面</li><li>如果用户session存在放行，继续操作。</li></ul>\r\n</li></ul>\r\n<h3 id=\"h3--controller-\"><a name=\"登陆controller方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>登陆controller方法</h3><pre><code>@Controller\r\npublic class LoginController {\r\n    // 登陆\r\n    @RequestMapping(&quot;/login&quot;)\r\n    public String login(HttpSession session, String username, String password)\r\n            throws Exception {\r\n\r\n        // 调用service进行用户身份验证\r\n        // ...\r\n\r\n        // 在session中保存用户身份信息\r\n        session.setAttribute(&quot;username&quot;, username);\r\n        // 重定向到商品列表页面\r\n        return &quot;redirect:/items/queryItems.action&quot;;\r\n    }\r\n\r\n    // 退出\r\n    @RequestMapping(&quot;/logout&quot;)\r\n    public String logout(HttpSession session) throws Exception {\r\n\r\n        // 清除session\r\n        session.invalidate();\r\n\r\n        // 重定向到商品列表页面\r\n        return &quot;redirect:/items/queryItems.action&quot;;\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-u767Bu9646u8BA4u8BC1u62E6u622Au5B9Eu73B0\"><a name=\"登陆认证拦截实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>登陆认证拦截实现</h3><ul>\r\n<li>代码实现</li></ul>\r\n<pre><code>/**\r\n * Created by brian on 2016/3/8.\r\n * 登陆认证拦截器\r\n */\r\n\r\npublic class LoginInterceptor implements HandlerInterceptor {\r\n\r\n    //进入 Handler方法之前执行\r\n    //用于身份认证、身份授权\r\n    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n    public boolean preHandle(HttpServletRequest request,\r\n                             HttpServletResponse response, Object handler) throws Exception {\r\n\r\n        //获取请求的url\r\n        String url = request.getRequestURI();\r\n        //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中）\r\n        //这里公开地址是登陆提交的地址\r\n        if(url.indexOf(&quot;login.action&quot;)&gt;=0){\r\n            //如果进行登陆提交，放行\r\n            return true;\r\n        }\r\n\r\n        //判断session\r\n        HttpSession session  = request.getSession();\r\n        //从session中取出用户身份信息\r\n        String username = (String) session.getAttribute(&quot;username&quot;);\r\n\r\n        if(username != null){\r\n            //身份存在，放行\r\n            return true;\r\n        }\r\n\r\n        //执行这里表示用户身份需要认证，跳转登陆页面\r\n        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);\r\n\r\n        //return false表示拦截，不向下执行\r\n        //return true表示放行\r\n        return false;\r\n    }\r\n\r\n    //进入Handler方法之后，返回modelAndView之前执行\r\n    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n    public void postHandle(HttpServletRequest request,\r\n                           HttpServletResponse response, Object handler,\r\n                           ModelAndView modelAndView) throws Exception {\r\n\r\n        System.out.println(&quot;LoginInterceptor...postHandle&quot;);\r\n\r\n    }\r\n\r\n    //执行Handler完成执行此方法\r\n    //应用场景：统一异常处理，统一日志处理\r\n    public void afterCompletion(HttpServletRequest request,\r\n                                HttpServletResponse response, Object handler, Exception ex)\r\n            throws Exception {\r\n\r\n        System.out.println(&quot;LoginInterceptor...afterCompletion&quot;);\r\n    }\r\n\r\n}\r\n</code></pre><ul>\r\n<li>拦截器配置</li></ul>\r\n<pre><code>&lt;!--拦截器 --&gt;\r\n&lt;mvc:interceptors&gt;\r\n    &lt;!--多个拦截器,顺序执行 --&gt;\r\n    &lt;!-- 登陆认证拦截器 --&gt;\r\n    &lt;mvc:interceptor&gt;\r\n        &lt;mvc:mapping path=&quot;/**&quot;/&gt;\r\n        &lt;bean class=&quot;com.iot.learnssm.firstssm.interceptor.LoginInterceptor&quot;&gt;&lt;/bean&gt;\r\n    &lt;/mvc:interceptor&gt;\r\n\r\n    ...省略\r\n</code></pre>', '126', '# 拦截器\r\n\r\n\r\n本文主要介绍springmvc中的拦截器，包括拦截器定义和的配置，最后通过一个登录认证的例子展示了拦截器的应用\r\n\r\n## 拦截定义\r\n\r\n定义拦截器，实现`HandlerInterceptor`接口。接口中提供三个方法。\r\n\r\n```\r\npublic class HandlerInterceptor1 implements HandlerInterceptor{\r\n    //进入 Handler方法之前执行\r\n    //用于身份认证、身份授权\r\n    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n\r\n        //return false表示拦截，不向下执行\r\n        //return true表示放行\r\n        return false;\r\n    }\r\n\r\n    //进入Handler方法之后，返回modelAndView之前执行\r\n    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r\n\r\n    }\r\n\r\n    //执行Handler完成执行此方法\r\n    //应用场景：统一异常处理，统一日志处理\r\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r\n\r\n    }\r\n}\r\n```\r\n\r\n可以从名称和参数看出各个接口的顺序和作用:\r\n\r\n*   `public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception`\r\n\r\n    *   参数最少，只有三个\r\n    *   进入 Handler方法之前执行\r\n    *   用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n*   `public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception`\r\n\r\n    *   多了一个modelAndView参数\r\n    *   进入Handler方法之后，返回modelAndView之前执行\r\n    *   应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n*   `public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception`\r\n\r\n    *   多了一个Exception的类型的参数\r\n    *   执行Handler完成执行此方法\r\n    *   应用场景：统一异常处理，统一日志处理\r\n\r\n## 拦截器配置\r\n\r\n### 针对HandlerMapping配置\r\n\r\nspringmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器。\r\n\r\n```\r\n<bean\r\n    class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\">\r\n    <property name=\"interceptors\">\r\n        <list>\r\n            <ref bean=\"handlerInterceptor1\"/>\r\n            <ref bean=\"handlerInterceptor2\"/>\r\n        </list>\r\n    </property>\r\n</bean>\r\n    <bean id=\"handlerInterceptor1\" class=\"springmvc.intercapter.HandlerInterceptor1\"/>\r\n    <bean id=\"handlerInterceptor2\" class=\"springmvc.intercapter.HandlerInterceptor2\"/>\r\n```\r\n\r\n一般不推荐使用。\r\n\r\n### 类似全局的拦截器\r\n\r\nspringmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。\r\n\r\n```\r\n <!--拦截器 -->\r\n<mvc:interceptors>\r\n    <!--多个拦截器,顺序执行 -->\r\n    <mvc:interceptor>\r\n        <!-- /**表示所有url包括子url路径 -->\r\n        <mvc:mapping path=\"/**\"/>\r\n        <bean class=\"com.iot.learnssm.firstssm.interceptor.HandlerInterceptor1\"></bean>\r\n    </mvc:interceptor>\r\n    <mvc:interceptor>\r\n        <mvc:mapping path=\"/**\"/>\r\n        <bean class=\"com.iot.learnssm.firstssm.interceptor.HandlerInterceptor2\"></bean>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n## 拦截测试\r\n\r\n测试多个拦截器各个方法执行时机\r\n\r\n访问`/items/queryItems.action`\r\n\r\n*   1.两个拦截器都放行\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-1] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-1] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-1] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-1] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-1] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nHandlerInterceptor2...preHandle\r\nDEBUG [http-apr-8080-exec-1] - Fetching JDBC Connection from DataSource\r\nDEBUG [http-apr-8080-exec-1] - Registering transaction synchronization for JDBC Connection\r\nDEBUG [http-apr-8080-exec-1] - Returning JDBC Connection to DataSource\r\nHandlerInterceptor2...postHandle\r\nHandlerInterceptor1...postHandle\r\nDEBUG [http-apr-8080-exec-1] - Rendering view [org.springframework.web.servlet.view.JstlView: name \'items/itemsList\'; URL [/WEB-INF/jsp/items/itemsList.jsp]] in DispatcherServlet with name \'springmvc\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'itemtypes\' of type [java.util.HashMap] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'itemsQueryVo\' of type [com.iot.learnssm.firstssm.po.ItemsQueryVo] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'org.springframework.validation.BindingResult.itemsQueryVo\' of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Added model object \'itemsList\' of type [java.util.ArrayList] to request in view with name \'items/itemsList\'\r\nDEBUG [http-apr-8080-exec-1] - Forwarding to resource [/WEB-INF/jsp/items/itemsList.jsp] in InternalResourceView \'items/itemsList\'\r\nHandlerInterceptor2...afterCompletion\r\nHandlerInterceptor1...afterCompletion\r\nDEBUG [http-apr-8080-exec-1] - Successfully completed request\r\n\r\n```\r\n\r\n总结：preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行。\r\n\r\n2.拦截器1放行，拦截器2不放行\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-8] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nHandlerInterceptor2...preHandle\r\nHandlerInterceptor1...afterCompletion\r\nDEBUG [http-apr-8080-exec-8] - Successfully completed request\r\n```\r\n\r\n总结：\r\n\r\n*   拦截器1放行，拦截器2 preHandle才会执行。\r\n*   拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。\r\n*   只要有一个拦截器不放行，postHandle不会执行。\r\n\r\n3.两个拦截器都不放\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-9] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-9] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-9] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-9] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-9] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nDEBUG [http-apr-8080-exec-9] - Successfully completed request\r\n```\r\n\r\n总结：\r\n\r\n*   拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。\r\n*   拦截器1 preHandle不放行，拦截器2不执行。\r\n\r\n4.拦截器1不放行，拦截器2放行\r\n\r\n```\r\nDEBUG [http-apr-8080-exec-8] - DispatcherServlet with name \'springmvc\' processing GET request for [/ssm1/items/queryItems.action]\r\nDEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.action\r\nDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]\r\nDEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean \'itemsController\'\r\nDEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1\r\nHandlerInterceptor1...preHandle\r\nDEBUG [http-apr-8080-exec-8] - Successfully completed request\r\n```\r\n\r\n和两个拦截器都不行的结果一致，因为拦截器1先执行，没放行\r\n\r\n*   小结\r\n\r\n根据测试结果，对拦截器应用。\r\n\r\n比如：统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。\r\n\r\n比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）\r\n\r\n## 拦截器应用(实现登陆认证)\r\n\r\n### 需求\r\n\r\n*   1.用户请求url\r\n*   2.拦截器进行拦截校验\r\n\r\n    *   如果请求的url是公开地址（无需登陆即可访问的url），让放行\r\n    *   如果用户session 不存在跳转到登陆页面\r\n    *   如果用户session存在放行，继续操作。\r\n\r\n### 登陆controller方法\r\n\r\n```\r\n@Controller\r\npublic class LoginController {\r\n    // 登陆\r\n    @RequestMapping(\"/login\")\r\n    public String login(HttpSession session, String username, String password)\r\n            throws Exception {\r\n\r\n        // 调用service进行用户身份验证\r\n        // ...\r\n\r\n        // 在session中保存用户身份信息\r\n        session.setAttribute(\"username\", username);\r\n        // 重定向到商品列表页面\r\n        return \"redirect:/items/queryItems.action\";\r\n    }\r\n\r\n    // 退出\r\n    @RequestMapping(\"/logout\")\r\n    public String logout(HttpSession session) throws Exception {\r\n\r\n        // 清除session\r\n        session.invalidate();\r\n\r\n        // 重定向到商品列表页面\r\n        return \"redirect:/items/queryItems.action\";\r\n    }\r\n}\r\n```\r\n\r\n### 登陆认证拦截实现\r\n\r\n*   代码实现\r\n\r\n```\r\n/**\r\n * Created by brian on 2016/3/8.\r\n * 登陆认证拦截器\r\n */\r\n\r\npublic class LoginInterceptor implements HandlerInterceptor {\r\n\r\n    //进入 Handler方法之前执行\r\n    //用于身份认证、身份授权\r\n    //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行\r\n    public boolean preHandle(HttpServletRequest request,\r\n                             HttpServletResponse response, Object handler) throws Exception {\r\n\r\n        //获取请求的url\r\n        String url = request.getRequestURI();\r\n        //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中）\r\n        //这里公开地址是登陆提交的地址\r\n        if(url.indexOf(\"login.action\")>=0){\r\n            //如果进行登陆提交，放行\r\n            return true;\r\n        }\r\n\r\n        //判断session\r\n        HttpSession session  = request.getSession();\r\n        //从session中取出用户身份信息\r\n        String username = (String) session.getAttribute(\"username\");\r\n\r\n        if(username != null){\r\n            //身份存在，放行\r\n            return true;\r\n        }\r\n\r\n        //执行这里表示用户身份需要认证，跳转登陆页面\r\n        request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request, response);\r\n\r\n        //return false表示拦截，不向下执行\r\n        //return true表示放行\r\n        return false;\r\n    }\r\n\r\n    //进入Handler方法之后，返回modelAndView之前执行\r\n    //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图\r\n    public void postHandle(HttpServletRequest request,\r\n                           HttpServletResponse response, Object handler,\r\n                           ModelAndView modelAndView) throws Exception {\r\n\r\n        System.out.println(\"LoginInterceptor...postHandle\");\r\n\r\n    }\r\n\r\n    //执行Handler完成执行此方法\r\n    //应用场景：统一异常处理，统一日志处理\r\n    public void afterCompletion(HttpServletRequest request,\r\n                                HttpServletResponse response, Object handler, Exception ex)\r\n            throws Exception {\r\n\r\n        System.out.println(\"LoginInterceptor...afterCompletion\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n*   拦截器配置\r\n\r\n```\r\n<!--拦截器 -->\r\n<mvc:interceptors>\r\n    <!--多个拦截器,顺序执行 -->\r\n    <!-- 登陆认证拦截器 -->\r\n    <mvc:interceptor>\r\n        <mvc:mapping path=\"/**\"/>\r\n        <bean class=\"com.iot.learnssm.firstssm.interceptor.LoginInterceptor\"></bean>\r\n    </mvc:interceptor>\r\n\r\n    ...省略\r\n```\r\n');
INSERT INTO `article_info_true` VALUES ('106', '框架基础', '<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">在学习框架设计之前，先来了解一下框架基础——<a href=\"http://lib.csdn.net/base/javase\" title=\"Java SE知识库\">Java</a>反射机制。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">一、什么是反射机制</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">反射机制是在程序运行状态时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">用所描述行为的状态和相关的语义。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">反射是Java语言中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">组件之间进行源代码链接。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">要让Java程序能够运行，就得让Java类被Java虚拟机加载。Java类如果不被Java虚拟机加载就不能正常运行。正</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">常情况下，我们运行的所有的程序在编译期时候就已经把那个类被加载了。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">Java的反射机制是在编译时并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用的是</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">在编译期并不知道的类。这样的编译特点就是Java反射。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在Java中，只要给定类的名字， 那么就可以通</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">过反射机制来获得类的所有信息。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><br></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">二、反射机制能做什么</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">反射机制主要提供了以下功能：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">1.在运行时判断任意一个对象所属的类；</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">2.在运行时构造任意一个类的对象；</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">3.在运行时判断任意一个类所具有的成员变量和方法；</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">4.在运行时调用任意一个对象的方法；</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">5.生成动态代理；</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">6.进行反编译：.class(字节码文件)—&gt;.java(源代码文件)；</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><br></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">三、Java反射的作用</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">假如有两个程序员，一个程序员在写程序的时需要使用第二个程序员所写的类，但第二个程序员并没完成他所写</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">的类。那么第一个程序员的代码是不能通过编译的。此时，利用Java反射的机制，就可以让第一个程序员在没有得到</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">第二个程序员所写的类的时候，来完成自身代码的编译。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。如Eclipse</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">中，一按点，编译工具就会自动的把该对象能够使用的所有的方法和属性全部都列出来，供用户进行选择。这就是利</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">用了Java反射的原理，是对我们创建对象的探知、自审。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">四、反射机制的优点与缺点<br></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">静态编译：在编译时确定类型，绑定对象，即通过。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">类之间的藕合性。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在JavaEE的开发中。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">它</span><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发</span></p>\r\n<p><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软</span></p>\r\n<p><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能 的更新，而采用反射机制的</span></p>\r\n<p><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它 满足我</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">们的要求。这类操作总是慢于只直接执行相同的操作。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">在下面我们会举一个比较简单的小例子。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><br></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">五、一个简单的例子</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">首先我们先来编写一个静态加载类的示例：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">Office.java源文件：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<div class=\"dp-highlighter bg_java\"><br><br><div class=\"bar\"><br><br><div class=\"tools\"><strong>[java]</strong> <a href=\"#\" title=\"view plain\">view plain</a> <span data-mod=\"popu_168\"><a href=\"#\" title=\"copy\">copy</a><br><br><div style=\"position: absolute; left: 770px; top: 2429px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_1\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_1\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=1&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\"><a href=\"#\" title=\"print\">print</a></span><a href=\"#\" title=\"?\">?</a><span class=\"tracking-ad\" data-mod=\"popu_167\"><a href=\"https://code.csdn.net/snippets/2015390\" title=\"在CODE上查看代码片\"><img src=\"https://code.csdn.net/assets/CODE_ico.png\" alt=\"在CODE上查看代码片\"></a></span><span class=\"tracking-ad\" data-mod=\"popu_170\"><a href=\"https://code.csdn.net/snippets/2015390/fork\" title=\"派生到我的代码片\"><img src=\"https://code.csdn.net/assets/ico_fork.svg\" alt=\"派生到我的代码片\"></a></span></div>\r\n\r\n<p></div></p>\r\n<ol>\r\n<li><span><span class=\"keyword\">class</span><span>Office{</span></span></li><li><span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">static</span><span></span><span class=\"keyword\">void</span><span>main(String[]args){</span></span></li><li><span></span></li><li><span><span class=\"comment\">//使用new创建对象是静态加载类，在编译时刻就需要加载所有可能使用到的类</span><span></span></span></li><li><span><span class=\"comment\">//通过加载加载类可以解决该问题</span><span></span></span></li><li><span><span class=\"keyword\">if</span><span>(</span><span class=\"string\">“Word”</span><span>.equals(args[</span><span class=\"number\">0</span><span>])){</span></span></li><li><span>Wordw=<span class=\"keyword\">new</span><span>Word();</span></span></li><li><span>w.start();</span></li><li><span>}</span></li><li><span><span class=\"keyword\">if</span><span>(</span><span class=\"string\">“Excel”</span><span>.equals(args[</span><span class=\"number\">0</span><span>])){</span></span></li><li><span>Excele=<span class=\"keyword\">new</span><span>Excel();</span></span></li><li><span>e.start();</span></li><li><span>}</span></li><li><span>}</span></li><li><span>}</span></li></ol>\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\"><a href=\"javascript:;\"><img src=\"http://static.blog.csdn.net/images/save_snippets.png\" alt=\"\"></a></div>\r\n\r\n<p></div></p>\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_1_6957448\" name=\"code\" class=\"java\" style=\"display: none;\">class Office{\r\n    public static void main(String[] args){\r\n\r\n        //使用new创建对象是静态加载类，在编译时刻就需要加载所有可能使用到的类\r\n        //通过加载加载类可以解决该问题\r\n        if(\"Word\".equals(args[0])){\r\n            Word w = new Word();\r\n            w.start();\r\n        }\r\n        if(\"Excel\".equals(args[0])){\r\n            Excel e = new Excel();\r\n            e.start();\r\n        }\r\n    } \r\n} </pre>\r\n\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">使用javac进行编译：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><img src=\"http://img.blog.csdn.net/20161129145500501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>编译出错的原因我们大家都知道，就是找不到Word类和Excel类。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">假设我们写好了Word类，Word.java源文件：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<div class=\"dp-highlighter bg_java\"><br><br><div class=\"bar\"><br><br><div class=\"tools\"><strong>[java]</strong> <a href=\"#\" title=\"view plain\">view plain</a> <span data-mod=\"popu_168\"><a href=\"#\" title=\"copy\">copy</a><br><br><div style=\"position: absolute; left: 770px; top: 3289px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_2\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_2\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=2&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\"><a href=\"#\" title=\"print\">print</a></span><a href=\"#\" title=\"?\">?</a><span class=\"tracking-ad\" data-mod=\"popu_167\"><a href=\"https://code.csdn.net/snippets/2015390\" title=\"在CODE上查看代码片\"><img src=\"https://code.csdn.net/assets/CODE_ico.png\" alt=\"在CODE上查看代码片\"></a></span><span class=\"tracking-ad\" data-mod=\"popu_170\"><a href=\"https://code.csdn.net/snippets/2015390/fork\" title=\"派生到我的代码片\"><img src=\"https://code.csdn.net/assets/ico_fork.svg\" alt=\"派生到我的代码片\"></a></span></div>\r\n\r\n<p></div></p>\r\n<ol>\r\n<li><span><span class=\"keyword\">class</span><span>Word{</span></span></li><li><span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start(){</span></span></li><li><span>System.out.println(<span class=\"string\">“word…starts…”</span><span>);</span></span></li><li><span>}</span></li><li><span>}</span></li></ol>\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\"><a href=\"javascript:;\"><img src=\"http://static.blog.csdn.net/images/save_snippets.png\" alt=\"\"></a></div>\r\n\r\n<p></div></p>\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_2_9542150\" name=\"code\" class=\"java\" style=\"display: none;\">class Word{\r\n    public void start(){\r\n        System.out.println(\"word...starts...\");\r\n    }\r\n}    </pre>\r\n\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">使用javac编译：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><img src=\"http://img.blog.csdn.net/20161129145645705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>再次编译此程序还是不通过，因为找不到Excel类，那么我们需要的就是Word功能，不需要Excel功能，那么主要</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">的程序还是无法编译运行，我们所需要的功能还是无法使用，这就是静态加载的不足之处。如果主程序中有多个功</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">能，只要其中一个没有实现或者是错</span><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">误的，那么这个主程序就无法编译运行。那么这就需要使用动态加载来进行类的</span></p>\r\n<p><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">加载了。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">下面就来通过反射来实现动态加载：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">OfficeBetter.java源文件：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<div class=\"dp-highlighter bg_java\"><br><br><div class=\"bar\"><br><br><div class=\"tools\"><strong>[java]</strong> <a href=\"#\" title=\"view plain\">view plain</a> <span data-mod=\"popu_168\"><a href=\"#\" title=\"copy\">copy</a><br><br><div style=\"position: absolute; left: 770px; top: 4023px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_3\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_3\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=3&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\"><a href=\"#\" title=\"print\">print</a></span><a href=\"#\" title=\"?\">?</a><span class=\"tracking-ad\" data-mod=\"popu_167\"><a href=\"https://code.csdn.net/snippets/2015390\" title=\"在CODE上查看代码片\"><img src=\"https://code.csdn.net/assets/CODE_ico.png\" alt=\"在CODE上查看代码片\"></a></span><span class=\"tracking-ad\" data-mod=\"popu_170\"><a href=\"https://code.csdn.net/snippets/2015390/fork\" title=\"派生到我的代码片\"><img src=\"https://code.csdn.net/assets/ico_fork.svg\" alt=\"派生到我的代码片\"></a></span></div>\r\n\r\n<p></div></p>\r\n<ol>\r\n<li><span><span class=\"keyword\">class</span><span>OfficeBetter{</span></span></li><li><span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">static</span><span></span><span class=\"keyword\">void</span><span>main(String[]args){</span></span></li><li><span><span class=\"keyword\">try</span><span>{</span></span></li><li><span><span class=\"comment\">//动态加载类，在运行时刻加载</span><span></span></span></li><li><span>Classclazz=Class.forName(args[<span class=\"number\">0</span><span>]);</span></span></li><li><span><span class=\"comment\">//通过类类型创建该类的对象</span><span></span></span></li><li><span>OfficeAbleoa=(OfficeAble)clazz.newInstance();</span></li><li><span>oa.start();</span></li><li><span>}<span class=\"keyword\">catch</span><span>(Exceptione){</span></span></li><li><span>e.printStackTrace();</span></li><li><span>}</span></li><li><span>}</span></li><li><span>}</span></li></ol>\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\"><a href=\"javascript:;\"><img src=\"http://static.blog.csdn.net/images/save_snippets.png\" alt=\"\"></a></div>\r\n\r\n<p></div></p>\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_3_6478270\" name=\"code\" class=\"java\" style=\"display: none;\">class OfficeBetter{\r\n    public static void main(String[] args){\r\n        try{    \r\n            //动态加载类，在运行时刻加载\r\n            Class clazz = Class.forName(args[0]);\r\n            //通过类类型创建该类的对象\r\n            OfficeAble oa = (OfficeAble)clazz.newInstance();\r\n            oa.start();\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }\r\n    } \r\n}    </pre>\r\n\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">在其中我们需要定义一个接口，那么我们的功能类需要实现这个接口规范，这个规范就是OfficeAble接口。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">OfficeAble.java源文件：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<div class=\"dp-highlighter bg_java\"><br><br><div class=\"bar\"><br><br><div class=\"tools\"><strong>[java]</strong> <a href=\"#\" title=\"view plain\">view plain</a> <span data-mod=\"popu_168\"><a href=\"#\" title=\"copy\">copy</a><br><br><div style=\"position: absolute; left: 770px; top: 4393px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_4\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_4\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=4&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\"><a href=\"#\" title=\"print\">print</a></span><a href=\"#\" title=\"?\">?</a><span class=\"tracking-ad\" data-mod=\"popu_167\"><a href=\"https://code.csdn.net/snippets/2015390\" title=\"在CODE上查看代码片\"><img src=\"https://code.csdn.net/assets/CODE_ico.png\" alt=\"在CODE上查看代码片\"></a></span><span class=\"tracking-ad\" data-mod=\"popu_170\"><a href=\"https://code.csdn.net/snippets/2015390/fork\" title=\"派生到我的代码片\"><img src=\"https://code.csdn.net/assets/ico_fork.svg\" alt=\"派生到我的代码片\"></a></span></div>\r\n\r\n<p></div></p>\r\n<ol>\r\n<li><span><span class=\"keyword\">interface</span><span>OfficeAble{</span></span></li><li><span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start();</span></span></li><li><span>}</span></li></ol>\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\"><a href=\"javascript:;\"><img src=\"http://static.blog.csdn.net/images/save_snippets.png\" alt=\"\"></a></div>\r\n\r\n<p></div></p>\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_4_3381371\" name=\"code\" class=\"java\" style=\"display: none;\">interface OfficeAble{\r\n    public void start();\r\n}    </pre>\r\n\r\n<p>我们来进行编译：</p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><img src=\"http://img.blog.csdn.net/20161129145927612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">我们对它们进行编译，那么编译就会顺利通过。纵然是我们没有实现一个功能类，我们的主程序依然会通过。下</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">面的我们实现的功能类只要实现这个接口规范，然后编译功能类，我们不编译主类就可以运行。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">我们将先前的Word功能类进行改写，也就是实现OfficeAble接口规范：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<div class=\"dp-highlighter bg_java\"><br><br><div class=\"bar\"><br><br><div class=\"tools\"><strong>[java]</strong> <a href=\"#\" title=\"view plain\">view plain</a> <span data-mod=\"popu_168\"><a href=\"#\" title=\"copy\">copy</a><br><br><div style=\"position: absolute; left: 770px; top: 4966px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_5\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_5\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=5&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\"><a href=\"#\" title=\"print\">print</a></span><a href=\"#\" title=\"?\">?</a><span class=\"tracking-ad\" data-mod=\"popu_167\"><a href=\"https://code.csdn.net/snippets/2015390\" title=\"在CODE上查看代码片\"><img src=\"https://code.csdn.net/assets/CODE_ico.png\" alt=\"在CODE上查看代码片\"></a></span><span class=\"tracking-ad\" data-mod=\"popu_170\"><a href=\"https://code.csdn.net/snippets/2015390/fork\" title=\"派生到我的代码片\"><img src=\"https://code.csdn.net/assets/ico_fork.svg\" alt=\"派生到我的代码片\"></a></span></div>\r\n\r\n<p></div></p>\r\n<ol>\r\n<li><span><span class=\"keyword\">class</span><span>Word</span><span class=\"keyword\">implements</span><span>OfficeAble{</span></span></li><li><span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start(){</span></span></li><li><span>System.out.println(<span class=\"string\">“word…starts…”</span><span>);</span></span></li><li><span>}</span></li><li><span>}</span></li></ol>\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\"><a href=\"javascript:;\"><img src=\"http://static.blog.csdn.net/images/save_snippets.png\" alt=\"\"></a></div>\r\n\r\n<p></div></p>\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_5_9761083\" name=\"code\" class=\"java\" style=\"display: none;\">class Word implements OfficeAble{\r\n    public void start(){\r\n        System.out.println(\"word...starts...\");\r\n    }\r\n}    </pre>\r\n\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">编译运行：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><img src=\"http://img.blog.csdn.net/20161129150105504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">那么我们再扩展新的功能类Excel.java</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<div class=\"dp-highlighter bg_java\"><br><br><div class=\"bar\"><br><br><div class=\"tools\"><strong>[java]</strong> <a href=\"#\" title=\"view plain\">view plain</a> <span data-mod=\"popu_168\"><a href=\"#\" title=\"copy\">copy</a><br><br><div style=\"position: absolute; left: 770px; top: 5470px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_6\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_6\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=6&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\"><a href=\"#\" title=\"print\">print</a></span><a href=\"#\" title=\"?\">?</a><span class=\"tracking-ad\" data-mod=\"popu_167\"><a href=\"https://code.csdn.net/snippets/2015390\" title=\"在CODE上查看代码片\"><img src=\"https://code.csdn.net/assets/CODE_ico.png\" alt=\"在CODE上查看代码片\"></a></span><span class=\"tracking-ad\" data-mod=\"popu_170\"><a href=\"https://code.csdn.net/snippets/2015390/fork\" title=\"派生到我的代码片\"><img src=\"https://code.csdn.net/assets/ico_fork.svg\" alt=\"派生到我的代码片\"></a></span></div>\r\n\r\n<p></div></p>\r\n<ol>\r\n<li><span><span class=\"keyword\">class</span><span>Excel</span><span class=\"keyword\">implements</span><span>OfficeAble{</span></span></li><li><span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start(){</span></span></li><li><span>System.out.println(<span class=\"string\">“excel…starts…”</span><span>);</span></span></li><li><span>}</span></li><li><span>}</span></li></ol>\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\"><a href=\"javascript:;\"><img src=\"http://static.blog.csdn.net/images/save_snippets.png\" alt=\"\"></a></div>\r\n\r\n<p></div></p>\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_6_3632542\" name=\"code\" class=\"java\" style=\"display: none;\">class Excel implements OfficeAble{\r\n    public void start(){\r\n        System.out.println(\"excel...starts...\");\r\n    }\r\n}    </pre>\r\n\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">编译运行：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><img src=\"http://img.blog.csdn.net/20161129150206212?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">总结：</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">通常情况下，Java程序能够运行，必须要让Java类被虚拟机加载，如果不被Java虚拟机加载，程序不能运行。运</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。通过反射机制可以让程序在编</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">译期间并不需要加载某个类，而是在程序运行的时候才加载。<br>利用反射机制可以很灵活的对运行时已经加载到Java虚拟机当中的类信息进行检测。当然这种检测在对运行的性</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">能上会有些减弱，所以什么时候使用反射，就要靠业务的需求、大小，以及经验的积累来决定。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\">反射提高程序的灵活性和扩展性，低耦合。常用于系统<a href=\"http://lib.csdn.net/base/architecture\" title=\"大型网站架构知识库\">架构</a>和框架搭建。</span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><br></span></p>\r\n<p><span style=\"font-family:Microsoft YaHei; font-size:18px\"><br></span></p>\r\n', '127', '<span style=\"font-family:Microsoft YaHei; font-size:18px\">在学习框架设计之前，先来了解一下框架基础——[Java](http://lib.csdn.net/base/javase \"Java SE知识库\")反射机制。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">一、什么是反射机制</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">反射机制是在程序运行状态时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">用所描述行为的状态和相关的语义。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">反射是Java语言中一种强大的工具，能够使我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">组件之间进行源代码链接。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">要让Java程序能够运行，就得让Java类被Java虚拟机加载。Java类如果不被Java虚拟机加载就不能正常运行。正</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">常情况下，我们运行的所有的程序在编译期时候就已经把那个类被加载了。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">Java的反射机制是在编译时并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用的是</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">在编译期并不知道的类。这样的编译特点就是Java反射。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在Java中，只要给定类的名字， 那么就可以通</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">过反射机制来获得类的所有信息。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">二、反射机制能做什么</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">反射机制主要提供了以下功能：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">1.在运行时判断任意一个对象所属的类；</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">2.在运行时构造任意一个类的对象；</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">3.在运行时判断任意一个类所具有的成员变量和方法；</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">4.在运行时调用任意一个对象的方法；</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">5.生成动态代理；</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">6.进行反编译：.class(字节码文件)-->.java(源代码文件)；</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">三、Java反射的作用</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">假如有两个程序员，一个程序员在写程序的时需要使用第二个程序员所写的类，但第二个程序员并没完成他所写</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">的类。那么第一个程序员的代码是不能通过编译的。此时，利用Java反射的机制，就可以让第一个程序员在没有得到</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">第二个程序员所写的类的时候，来完成自身代码的编译。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。如Eclipse</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">中，一按点，编译工具就会自动的把该对象能够使用的所有的方法和属性全部都列出来，供用户进行选择。这就是利</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">用了Java反射的原理，是对我们创建对象的探知、自审。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">四、反射机制的优点与缺点\r\n</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">静态编译：在编译时确定类型，绑定对象，即通过。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">类之间的藕合性。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在JavaEE的开发中。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">它</span><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发</span>\r\n\r\n<span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软</span>\r\n\r\n<span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能 的更新，而采用反射机制的</span>\r\n\r\n<span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它 满足我</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">们的要求。这类操作总是慢于只直接执行相同的操作。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">在下面我们会举一个比较简单的小例子。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">五、一个简单的例子</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">首先我们先来编写一个静态加载类的示例：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">Office.java源文件：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<div class=\"dp-highlighter bg_java\">\r\n\r\n<div class=\"bar\">\r\n\r\n<div class=\"tools\">**[java]** [view plain](# \"view plain\") <span data-mod=\"popu_168\">[copy](# \"copy\")\r\n\r\n<div style=\"position: absolute; left: 770px; top: 2429px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_1\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_1\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=1&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\">[print](# \"print\")</span>[?](# \"?\")<span class=\"tracking-ad\" data-mod=\"popu_167\">[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/2015390 \"在CODE上查看代码片\")</span><span class=\"tracking-ad\" data-mod=\"popu_170\">[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/2015390/fork \"派生到我的代码片\")</span></div>\r\n\r\n</div>\r\n\r\n1.  <span><span class=\"keyword\">class</span><span>Office{</span></span>\r\n2.  <span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">static</span><span></span><span class=\"keyword\">void</span><span>main(String[]args){</span></span>\r\n3.  <span></span>\r\n4.  <span><span class=\"comment\">//使用new创建对象是静态加载类，在编译时刻就需要加载所有可能使用到的类</span><span></span></span>\r\n5.  <span><span class=\"comment\">//通过加载加载类可以解决该问题</span><span></span></span>\r\n6.  <span><span class=\"keyword\">if</span><span>(</span><span class=\"string\">\"Word\"</span><span>.equals(args[</span><span class=\"number\">0</span><span>])){</span></span>\r\n7.  <span>Wordw=<span class=\"keyword\">new</span><span>Word();</span></span>\r\n8.  <span>w.start();</span>\r\n9.  <span>}</span>\r\n10.  <span><span class=\"keyword\">if</span><span>(</span><span class=\"string\">\"Excel\"</span><span>.equals(args[</span><span class=\"number\">0</span><span>])){</span></span>\r\n11.  <span>Excele=<span class=\"keyword\">new</span><span>Excel();</span></span>\r\n12.  <span>e.start();</span>\r\n13.  <span>}</span>\r\n14.  <span>}</span>\r\n15.  <span>}</span>\r\n\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\">[![](http://static.blog.csdn.net/images/save_snippets.png)](javascript:;)</div>\r\n\r\n</div>\r\n\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_1_6957448\" name=\"code\" class=\"java\" style=\"display: none;\">class Office{\r\n	public static void main(String[] args){\r\n\r\n		//使用new创建对象是静态加载类，在编译时刻就需要加载所有可能使用到的类\r\n		//通过加载加载类可以解决该问题\r\n	    if(\"Word\".equals(args[0])){\r\n			Word w = new Word();\r\n			w.start();\r\n	    }\r\n	    if(\"Excel\".equals(args[0])){\r\n			Excel e = new Excel();\r\n		    e.start();\r\n	    }\r\n    } \r\n} </pre>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">使用javac进行编译：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">![](http://img.blog.csdn.net/20161129145500501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n编译出错的原因我们大家都知道，就是找不到Word类和Excel类。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">假设我们写好了Word类，Word.java源文件：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<div class=\"dp-highlighter bg_java\">\r\n\r\n<div class=\"bar\">\r\n\r\n<div class=\"tools\">**[java]** [view plain](# \"view plain\") <span data-mod=\"popu_168\">[copy](# \"copy\")\r\n\r\n<div style=\"position: absolute; left: 770px; top: 3289px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_2\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_2\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=2&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\">[print](# \"print\")</span>[?](# \"?\")<span class=\"tracking-ad\" data-mod=\"popu_167\">[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/2015390 \"在CODE上查看代码片\")</span><span class=\"tracking-ad\" data-mod=\"popu_170\">[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/2015390/fork \"派生到我的代码片\")</span></div>\r\n\r\n</div>\r\n\r\n1.  <span><span class=\"keyword\">class</span><span>Word{</span></span>\r\n2.  <span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start(){</span></span>\r\n3.  <span>System.out.println(<span class=\"string\">\"word...starts...\"</span><span>);</span></span>\r\n4.  <span>}</span>\r\n5.  <span>}</span>\r\n\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\">[![](http://static.blog.csdn.net/images/save_snippets.png)](javascript:;)</div>\r\n\r\n</div>\r\n\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_2_9542150\" name=\"code\" class=\"java\" style=\"display: none;\">class Word{\r\n	public void start(){\r\n	    System.out.println(\"word...starts...\");\r\n	}\r\n}	</pre>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">使用javac编译：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">![](http://img.blog.csdn.net/20161129145645705?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\r\n再次编译此程序还是不通过，因为找不到Excel类，那么我们需要的就是Word功能，不需要Excel功能，那么主要</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">的程序还是无法编译运行，我们所需要的功能还是无法使用，这就是静态加载的不足之处。如果主程序中有多个功</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">能，只要其中一个没有实现或者是错</span><span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">误的，那么这个主程序就无法编译运行。那么这就需要使用动态加载来进行类的</span>\r\n\r\n<span style=\"font-family:\'Microsoft YaHei\'; font-size:18px\">加载了。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">下面就来通过反射来实现动态加载：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">OfficeBetter.java源文件：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<div class=\"dp-highlighter bg_java\">\r\n\r\n<div class=\"bar\">\r\n\r\n<div class=\"tools\">**[java]** [view plain](# \"view plain\") <span data-mod=\"popu_168\">[copy](# \"copy\")\r\n\r\n<div style=\"position: absolute; left: 770px; top: 4023px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_3\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_3\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=3&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\">[print](# \"print\")</span>[?](# \"?\")<span class=\"tracking-ad\" data-mod=\"popu_167\">[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/2015390 \"在CODE上查看代码片\")</span><span class=\"tracking-ad\" data-mod=\"popu_170\">[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/2015390/fork \"派生到我的代码片\")</span></div>\r\n\r\n</div>\r\n\r\n1.  <span><span class=\"keyword\">class</span><span>OfficeBetter{</span></span>\r\n2.  <span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">static</span><span></span><span class=\"keyword\">void</span><span>main(String[]args){</span></span>\r\n3.  <span><span class=\"keyword\">try</span><span>{</span></span>\r\n4.  <span><span class=\"comment\">//动态加载类，在运行时刻加载</span><span></span></span>\r\n5.  <span>Classclazz=Class.forName(args[<span class=\"number\">0</span><span>]);</span></span>\r\n6.  <span><span class=\"comment\">//通过类类型创建该类的对象</span><span></span></span>\r\n7.  <span>OfficeAbleoa=(OfficeAble)clazz.newInstance();</span>\r\n8.  <span>oa.start();</span>\r\n9.  <span>}<span class=\"keyword\">catch</span><span>(Exceptione){</span></span>\r\n10.  <span>e.printStackTrace();</span>\r\n11.  <span>}</span>\r\n12.  <span>}</span>\r\n13.  <span>}</span>\r\n\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\">[![](http://static.blog.csdn.net/images/save_snippets.png)](javascript:;)</div>\r\n\r\n</div>\r\n\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_3_6478270\" name=\"code\" class=\"java\" style=\"display: none;\">class OfficeBetter{\r\n	public static void main(String[] args){\r\n	    try{    \r\n			//动态加载类，在运行时刻加载\r\n			Class clazz = Class.forName(args[0]);\r\n			//通过类类型创建该类的对象\r\n			OfficeAble oa = (OfficeAble)clazz.newInstance();\r\n			oa.start();\r\n		}catch(Exception e){\r\n			e.printStackTrace();\r\n		}\r\n	} \r\n}    </pre>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">在其中我们需要定义一个接口，那么我们的功能类需要实现这个接口规范，这个规范就是OfficeAble接口。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">OfficeAble.java源文件：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<div class=\"dp-highlighter bg_java\">\r\n\r\n<div class=\"bar\">\r\n\r\n<div class=\"tools\">**[java]** [view plain](# \"view plain\") <span data-mod=\"popu_168\">[copy](# \"copy\")\r\n\r\n<div style=\"position: absolute; left: 770px; top: 4393px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_4\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_4\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=4&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\">[print](# \"print\")</span>[?](# \"?\")<span class=\"tracking-ad\" data-mod=\"popu_167\">[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/2015390 \"在CODE上查看代码片\")</span><span class=\"tracking-ad\" data-mod=\"popu_170\">[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/2015390/fork \"派生到我的代码片\")</span></div>\r\n\r\n</div>\r\n\r\n1.  <span><span class=\"keyword\">interface</span><span>OfficeAble{</span></span>\r\n2.  <span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start();</span></span>\r\n3.  <span>}</span>\r\n\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\">[![](http://static.blog.csdn.net/images/save_snippets.png)](javascript:;)</div>\r\n\r\n</div>\r\n\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_4_3381371\" name=\"code\" class=\"java\" style=\"display: none;\">interface OfficeAble{\r\n	public void start();\r\n}	</pre>\r\n\r\n我们来进行编译：\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">![](http://img.blog.csdn.net/20161129145927612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">我们对它们进行编译，那么编译就会顺利通过。纵然是我们没有实现一个功能类，我们的主程序依然会通过。下</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">面的我们实现的功能类只要实现这个接口规范，然后编译功能类，我们不编译主类就可以运行。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">我们将先前的Word功能类进行改写，也就是实现OfficeAble接口规范：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<div class=\"dp-highlighter bg_java\">\r\n\r\n<div class=\"bar\">\r\n\r\n<div class=\"tools\">**[java]** [view plain](# \"view plain\") <span data-mod=\"popu_168\">[copy](# \"copy\")\r\n\r\n<div style=\"position: absolute; left: 770px; top: 4966px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_5\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_5\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=5&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\">[print](# \"print\")</span>[?](# \"?\")<span class=\"tracking-ad\" data-mod=\"popu_167\">[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/2015390 \"在CODE上查看代码片\")</span><span class=\"tracking-ad\" data-mod=\"popu_170\">[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/2015390/fork \"派生到我的代码片\")</span></div>\r\n\r\n</div>\r\n\r\n1.  <span><span class=\"keyword\">class</span><span>Word</span><span class=\"keyword\">implements</span><span>OfficeAble{</span></span>\r\n2.  <span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start(){</span></span>\r\n3.  <span>System.out.println(<span class=\"string\">\"word...starts...\"</span><span>);</span></span>\r\n4.  <span>}</span>\r\n5.  <span>}</span>\r\n\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\">[![](http://static.blog.csdn.net/images/save_snippets.png)](javascript:;)</div>\r\n\r\n</div>\r\n\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_5_9761083\" name=\"code\" class=\"java\" style=\"display: none;\">class Word implements OfficeAble{\r\n	public void start(){\r\n	    System.out.println(\"word...starts...\");\r\n	}\r\n}	</pre>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">编译运行：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">![](http://img.blog.csdn.net/20161129150105504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">那么我们再扩展新的功能类Excel.java</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<div class=\"dp-highlighter bg_java\">\r\n\r\n<div class=\"bar\">\r\n\r\n<div class=\"tools\">**[java]** [view plain](# \"view plain\") <span data-mod=\"popu_168\">[copy](# \"copy\")\r\n\r\n<div style=\"position: absolute; left: 770px; top: 5470px; width: 24px; height: 13px; z-index: 99;\"><embed id=\"ZeroClipboardMovie_6\" src=\"http://static.blog.csdn.net/scripts/ZeroClipboard/ZeroClipboard.swf\" loop=\"false\" menu=\"false\" quality=\"best\" bgcolor=\"#ffffff\" name=\"ZeroClipboardMovie_6\" allowscriptaccess=\"always\" allowfullscreen=\"false\" type=\"application/x-shockwave-flash\" pluginspage=\"http://www.macromedia.com/go/getflashplayer\" flashvars=\"id=6&amp;width=24&amp;height=13\" wmode=\"transparent\" width=\"24\" height=\"13\" align=\"middle\"></div></span><span data-mod=\"popu_169\">[print](# \"print\")</span>[?](# \"?\")<span class=\"tracking-ad\" data-mod=\"popu_167\">[![在CODE上查看代码片](https://code.csdn.net/assets/CODE_ico.png)](https://code.csdn.net/snippets/2015390 \"在CODE上查看代码片\")</span><span class=\"tracking-ad\" data-mod=\"popu_170\">[![派生到我的代码片](https://code.csdn.net/assets/ico_fork.svg)](https://code.csdn.net/snippets/2015390/fork \"派生到我的代码片\")</span></div>\r\n\r\n</div>\r\n\r\n1.  <span><span class=\"keyword\">class</span><span>Excel</span><span class=\"keyword\">implements</span><span>OfficeAble{</span></span>\r\n2.  <span><span class=\"keyword\">public</span><span></span><span class=\"keyword\">void</span><span>start(){</span></span>\r\n3.  <span>System.out.println(<span class=\"string\">\"excel...starts...\"</span><span>);</span></span>\r\n4.  <span>}</span>\r\n5.  <span>}</span>\r\n\r\n<div class=\"save_code tracking-ad\" data-mod=\"popu_249\">[![](http://static.blog.csdn.net/images/save_snippets.png)](javascript:;)</div>\r\n\r\n</div>\r\n\r\n<pre code_snippet_id=\"2015390\" snippet_file_name=\"blog_20161129_6_3632542\" name=\"code\" class=\"java\" style=\"display: none;\">class Excel implements OfficeAble{\r\n	public void start(){\r\n	    System.out.println(\"excel...starts...\");\r\n	}\r\n}	</pre>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">编译运行：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">![](http://img.blog.csdn.net/20161129150206212?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\"></span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">总结：</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">通常情况下，Java程序能够运行，必须要让Java类被虚拟机加载，如果不被Java虚拟机加载，程序不能运行。运</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。通过反射机制可以让程序在编</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">译期间并不需要加载某个类，而是在程序运行的时候才加载。\r\n利用反射机制可以很灵活的对运行时已经加载到Java虚拟机当中的类信息进行检测。当然这种检测在对运行的性</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">能上会有些减弱，所以什么时候使用反射，就要靠业务的需求、大小，以及经验的积累来决定。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">反射提高程序的灵活性和扩展性，低耦合。常用于系统[架构](http://lib.csdn.net/base/architecture \"大型网站架构知识库\")和框架搭建。</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">\r\n</span>\r\n\r\n<span style=\"font-family:Microsoft YaHei; font-size:18px\">\r\n</span>');

-- ----------------------------
-- Table structure for class_info
-- ----------------------------
DROP TABLE IF EXISTS `class_info`;
CREATE TABLE `class_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `class_name` varchar(30) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of class_info
-- ----------------------------
INSERT INTO `class_info` VALUES ('1', 'java19班');
INSERT INTO `class_info` VALUES ('2', 'java20班');

-- ----------------------------
-- Table structure for student_info
-- ----------------------------
DROP TABLE IF EXISTS `student_info`;
CREATE TABLE `student_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `student_name` varchar(64) NOT NULL DEFAULT '',
  `student_pass` varchar(64) NOT NULL DEFAULT '',
  `class_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `class_id` (`class_id`),
  CONSTRAINT `student_info_ibfk_1` FOREIGN KEY (`class_id`) REFERENCES `class_info` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of student_info
-- ----------------------------
INSERT INTO `student_info` VALUES ('1', 'admin', 'songbo982514', '1');

-- ----------------------------
-- Table structure for tag_info
-- ----------------------------
DROP TABLE IF EXISTS `tag_info`;
CREATE TABLE `tag_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(30) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tag_info
-- ----------------------------
INSERT INTO `tag_info` VALUES ('10', 'java基础');
INSERT INTO `tag_info` VALUES ('11', 'java高级');
INSERT INTO `tag_info` VALUES ('12', 'javascript');
INSERT INTO `tag_info` VALUES ('14', 'html/css');
INSERT INTO `tag_info` VALUES ('15', '数据库');
INSERT INTO `tag_info` VALUES ('16', 'jquery');
INSERT INTO `tag_info` VALUES ('17', 'servlet/jsp');
INSERT INTO `tag_info` VALUES ('18', 'spring');
INSERT INTO `tag_info` VALUES ('19', 'springmvc');
INSERT INTO `tag_info` VALUES ('20', 'mybatis');


